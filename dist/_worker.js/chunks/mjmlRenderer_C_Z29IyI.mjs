globalThis.process ??= {}; globalThis.process.env ??= {};
import require$$0$4 from 'fs';
import require$$0$3 from 'path';
import { as as commonjsGlobal, n as getAugmentedNamespace, o as getDefaultExportFromCjs } from './astro/server_BcA0Y13i.mjs';
import { a as requireLib$A, b as requireLib$B, c as requireLib$C, r as requireLib$D, d as requireLib$E } from './index_OO8prrg6.mjs';
import require$$0$1 from 'os';
import require$$0$2 from 'http';
import require$$1$2 from 'https';
import require$$1$1 from 'url';

var lib$z = {exports: {}};

var interopRequireDefault = {exports: {}};

var hasRequiredInteropRequireDefault;

function requireInteropRequireDefault () {
	if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
	hasRequiredInteropRequireDefault = 1;
	(function (module) {
		function _interopRequireDefault(e) {
		  return e && e.__esModule ? e : {
		    "default": e
		  };
		}
		module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (interopRequireDefault));
	return interopRequireDefault.exports;
}

var interopRequireWildcard = {exports: {}};

var _typeof = {exports: {}};

var hasRequired_typeof;

function require_typeof () {
	if (hasRequired_typeof) return _typeof.exports;
	hasRequired_typeof = 1;
	(function (module) {
		function _typeof(o) {
		  "@babel/helpers - typeof";

		  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
		    return typeof o;
		  } : function (o) {
		    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
		}
		module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (_typeof));
	return _typeof.exports;
}

var hasRequiredInteropRequireWildcard;

function requireInteropRequireWildcard () {
	if (hasRequiredInteropRequireWildcard) return interopRequireWildcard.exports;
	hasRequiredInteropRequireWildcard = 1;
	(function (module) {
		var _typeof = require_typeof()["default"];
		function _interopRequireWildcard(e, t) {
		  if ("function" == typeof WeakMap) var r = new WeakMap(),
		    n = new WeakMap();
		  return (module.exports = _interopRequireWildcard = function _interopRequireWildcard(e, t) {
		    if (!t && e && e.__esModule) return e;
		    var o,
		      i,
		      f = {
		        __proto__: null,
		        "default": e
		      };
		    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
		    if (o = t ? n : r) {
		      if (o.has(e)) return o.get(e);
		      o.set(e, f);
		    }
		    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
		    return f;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports)(e, t);
		}
		module.exports = _interopRequireWildcard, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (interopRequireWildcard));
	return interopRequireWildcard.exports;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var lib$y = {};

var createClass = {exports: {}};

var toPropertyKey = {exports: {}};

var toPrimitive = {exports: {}};

var hasRequiredToPrimitive;

function requireToPrimitive () {
	if (hasRequiredToPrimitive) return toPrimitive.exports;
	hasRequiredToPrimitive = 1;
	(function (module) {
		var _typeof = require_typeof()["default"];
		function toPrimitive(t, r) {
		  if ("object" != _typeof(t) || !t) return t;
		  var e = t[Symbol.toPrimitive];
		  if (void 0 !== e) {
		    var i = e.call(t, r || "default");
		    if ("object" != _typeof(i)) return i;
		    throw new TypeError("@@toPrimitive must return a primitive value.");
		  }
		  return ("string" === r ? String : Number)(t);
		}
		module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toPrimitive));
	return toPrimitive.exports;
}

var hasRequiredToPropertyKey;

function requireToPropertyKey () {
	if (hasRequiredToPropertyKey) return toPropertyKey.exports;
	hasRequiredToPropertyKey = 1;
	(function (module) {
		var _typeof = require_typeof()["default"];
		var toPrimitive = requireToPrimitive();
		function toPropertyKey(t) {
		  var i = toPrimitive(t, "string");
		  return "symbol" == _typeof(i) ? i : i + "";
		}
		module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toPropertyKey));
	return toPropertyKey.exports;
}

var hasRequiredCreateClass;

function requireCreateClass () {
	if (hasRequiredCreateClass) return createClass.exports;
	hasRequiredCreateClass = 1;
	(function (module) {
		var toPropertyKey = requireToPropertyKey();
		function _defineProperties(e, r) {
		  for (var t = 0; t < r.length; t++) {
		    var o = r[t];
		    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
		  }
		}
		function _createClass(e, r, t) {
		  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
		    writable: false
		  }), e;
		}
		module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (createClass));
	return createClass.exports;
}

var classCallCheck = {exports: {}};

var hasRequiredClassCallCheck;

function requireClassCallCheck () {
	if (hasRequiredClassCallCheck) return classCallCheck.exports;
	hasRequiredClassCallCheck = 1;
	(function (module) {
		function _classCallCheck(a, n) {
		  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
		}
		module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (classCallCheck));
	return classCallCheck.exports;
}

var callSuper = {exports: {}};

var getPrototypeOf = {exports: {}};

var hasRequiredGetPrototypeOf;

function requireGetPrototypeOf () {
	if (hasRequiredGetPrototypeOf) return getPrototypeOf.exports;
	hasRequiredGetPrototypeOf = 1;
	(function (module) {
		function _getPrototypeOf(t) {
		  return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
		    return t.__proto__ || Object.getPrototypeOf(t);
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
		}
		module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (getPrototypeOf));
	return getPrototypeOf.exports;
}

var isNativeReflectConstruct = {exports: {}};

var hasRequiredIsNativeReflectConstruct;

function requireIsNativeReflectConstruct () {
	if (hasRequiredIsNativeReflectConstruct) return isNativeReflectConstruct.exports;
	hasRequiredIsNativeReflectConstruct = 1;
	(function (module) {
		function _isNativeReflectConstruct() {
		  try {
		    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
		  } catch (t) {}
		  return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
		    return !!t;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
		}
		module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (isNativeReflectConstruct));
	return isNativeReflectConstruct.exports;
}

var possibleConstructorReturn = {exports: {}};

var assertThisInitialized = {exports: {}};

var hasRequiredAssertThisInitialized;

function requireAssertThisInitialized () {
	if (hasRequiredAssertThisInitialized) return assertThisInitialized.exports;
	hasRequiredAssertThisInitialized = 1;
	(function (module) {
		function _assertThisInitialized(e) {
		  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		  return e;
		}
		module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (assertThisInitialized));
	return assertThisInitialized.exports;
}

var hasRequiredPossibleConstructorReturn;

function requirePossibleConstructorReturn () {
	if (hasRequiredPossibleConstructorReturn) return possibleConstructorReturn.exports;
	hasRequiredPossibleConstructorReturn = 1;
	(function (module) {
		var _typeof = require_typeof()["default"];
		var assertThisInitialized = requireAssertThisInitialized();
		function _possibleConstructorReturn(t, e) {
		  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
		  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
		  return assertThisInitialized(t);
		}
		module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (possibleConstructorReturn));
	return possibleConstructorReturn.exports;
}

var hasRequiredCallSuper;

function requireCallSuper () {
	if (hasRequiredCallSuper) return callSuper.exports;
	hasRequiredCallSuper = 1;
	(function (module) {
		var getPrototypeOf = requireGetPrototypeOf();
		var isNativeReflectConstruct = requireIsNativeReflectConstruct();
		var possibleConstructorReturn = requirePossibleConstructorReturn();
		function _callSuper(t, o, e) {
		  return o = getPrototypeOf(o), possibleConstructorReturn(t, isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf(t).constructor) : o.apply(t, e));
		}
		module.exports = _callSuper, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (callSuper));
	return callSuper.exports;
}

var inherits = {exports: {}};

var setPrototypeOf = {exports: {}};

var hasRequiredSetPrototypeOf;

function requireSetPrototypeOf () {
	if (hasRequiredSetPrototypeOf) return setPrototypeOf.exports;
	hasRequiredSetPrototypeOf = 1;
	(function (module) {
		function _setPrototypeOf(t, e) {
		  return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
		    return t.__proto__ = e, t;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
		}
		module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (setPrototypeOf));
	return setPrototypeOf.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	(function (module) {
		var setPrototypeOf = requireSetPrototypeOf();
		function _inherits(t, e) {
		  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
		  t.prototype = Object.create(e && e.prototype, {
		    constructor: {
		      value: t,
		      writable: true,
		      configurable: true
		    }
		  }), Object.defineProperty(t, "prototype", {
		    writable: false
		  }), e && setPrototypeOf(t, e);
		}
		module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (inherits));
	return inherits.exports;
}

var wrapNativeSuper = {exports: {}};

var isNativeFunction = {exports: {}};

var hasRequiredIsNativeFunction;

function requireIsNativeFunction () {
	if (hasRequiredIsNativeFunction) return isNativeFunction.exports;
	hasRequiredIsNativeFunction = 1;
	(function (module) {
		function _isNativeFunction(t) {
		  try {
		    return -1 !== Function.toString.call(t).indexOf("[native code]");
		  } catch (n) {
		    return "function" == typeof t;
		  }
		}
		module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (isNativeFunction));
	return isNativeFunction.exports;
}

var construct = {exports: {}};

var hasRequiredConstruct;

function requireConstruct () {
	if (hasRequiredConstruct) return construct.exports;
	hasRequiredConstruct = 1;
	(function (module) {
		var isNativeReflectConstruct = requireIsNativeReflectConstruct();
		var setPrototypeOf = requireSetPrototypeOf();
		function _construct(t, e, r) {
		  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
		  var o = [null];
		  o.push.apply(o, e);
		  var p = new (t.bind.apply(t, o))();
		  return r && setPrototypeOf(p, r.prototype), p;
		}
		module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (construct));
	return construct.exports;
}

var hasRequiredWrapNativeSuper;

function requireWrapNativeSuper () {
	if (hasRequiredWrapNativeSuper) return wrapNativeSuper.exports;
	hasRequiredWrapNativeSuper = 1;
	(function (module) {
		var getPrototypeOf = requireGetPrototypeOf();
		var setPrototypeOf = requireSetPrototypeOf();
		var isNativeFunction = requireIsNativeFunction();
		var construct = requireConstruct();
		function _wrapNativeSuper(t) {
		  var r = "function" == typeof Map ? new Map() : void 0;
		  return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
		    if (null === t || !isNativeFunction(t)) return t;
		    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
		    if (void 0 !== r) {
		      if (r.has(t)) return r.get(t);
		      r.set(t, Wrapper);
		    }
		    function Wrapper() {
		      return construct(t, arguments, getPrototypeOf(this).constructor);
		    }
		    return Wrapper.prototype = Object.create(t.prototype, {
		      constructor: {
		        value: Wrapper,
		        enumerable: false,
		        writable: true,
		        configurable: true
		      }
		    }), setPrototypeOf(Wrapper, t);
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
		}
		module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (wrapNativeSuper));
	return wrapNativeSuper.exports;
}

/** Used for built-in method references. */

var _isPrototype;
var hasRequired_isPrototype;

function require_isPrototype () {
	if (hasRequired_isPrototype) return _isPrototype;
	hasRequired_isPrototype = 1;
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	_isPrototype = isPrototype;
	return _isPrototype;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

var _overArg;
var hasRequired_overArg;

function require_overArg () {
	if (hasRequired_overArg) return _overArg;
	hasRequired_overArg = 1;
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	_overArg = overArg;
	return _overArg;
}

var _nativeKeys;
var hasRequired_nativeKeys;

function require_nativeKeys () {
	if (hasRequired_nativeKeys) return _nativeKeys;
	hasRequired_nativeKeys = 1;
	var overArg = require_overArg();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	_nativeKeys = nativeKeys;
	return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;

function require_baseKeys () {
	if (hasRequired_baseKeys) return _baseKeys;
	hasRequired_baseKeys = 1;
	var isPrototype = require_isPrototype(),
	    nativeKeys = require_nativeKeys();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeys = baseKeys;
	return _baseKeys;
}

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction_1;
	hasRequiredIsFunction = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _DataView;
var hasRequired_DataView;

function require_DataView () {
	if (hasRequired_DataView) return _DataView;
	hasRequired_DataView = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	_DataView = DataView;
	return _DataView;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _Promise;
var hasRequired_Promise;

function require_Promise () {
	if (hasRequired_Promise) return _Promise;
	hasRequired_Promise = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	_Promise = Promise;
	return _Promise;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	_Set = Set;
	return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;

function require_WeakMap () {
	if (hasRequired_WeakMap) return _WeakMap;
	hasRequired_WeakMap = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	_WeakMap = WeakMap;
	return _WeakMap;
}

var _getTag;
var hasRequired_getTag;

function require_getTag () {
	if (hasRequired_getTag) return _getTag;
	hasRequired_getTag = 1;
	var DataView = require_DataView(),
	    Map = require_Map(),
	    Promise = require_Promise(),
	    Set = require_Set(),
	    WeakMap = require_WeakMap(),
	    baseGetTag = require_baseGetTag(),
	    toSource = require_toSource();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	_getTag = getTag;
	return _getTag;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;

function require_baseIsArguments () {
	if (hasRequired_baseIsArguments) return _baseIsArguments;
	hasRequired_baseIsArguments = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	_baseIsArguments = baseIsArguments;
	return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments_1;
	hasRequiredIsArguments = 1;
	var baseIsArguments = require_baseIsArguments(),
	    isObjectLike = requireIsObjectLike();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	isArguments_1 = isArguments;
	return isArguments_1;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

/** Used as references for various `Number` constants. */

var isLength_1;
var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength_1;
	hasRequiredIsLength = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	isLength_1 = isLength;
	return isLength_1;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike_1;
	hasRequiredIsArrayLike = 1;
	var isFunction = requireIsFunction(),
	    isLength = requireIsLength();

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	isArrayLike_1 = isArrayLike;
	return isArrayLike_1;
}

var isBuffer = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

var stubFalse_1;
var hasRequiredStubFalse;

function requireStubFalse () {
	if (hasRequiredStubFalse) return stubFalse_1;
	hasRequiredStubFalse = 1;
	function stubFalse() {
	  return false;
	}

	stubFalse_1 = stubFalse;
	return stubFalse_1;
}

isBuffer.exports;

var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer.exports;
	hasRequiredIsBuffer = 1;
	(function (module, exports$1) {
		var root = require_root(),
		    stubFalse = requireStubFalse();

		/** Detect free variable `exports`. */
		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer, isBuffer.exports));
	return isBuffer.exports;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;

function require_baseIsTypedArray () {
	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
	hasRequired_baseIsTypedArray = 1;
	var baseGetTag = require_baseGetTag(),
	    isLength = requireIsLength(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	_baseIsTypedArray = baseIsTypedArray;
	return _baseIsTypedArray;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

var _baseUnary;
var hasRequired_baseUnary;

function require_baseUnary () {
	if (hasRequired_baseUnary) return _baseUnary;
	hasRequired_baseUnary = 1;
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	_baseUnary = baseUnary;
	return _baseUnary;
}

var _nodeUtil = {exports: {}};

_nodeUtil.exports;

var hasRequired_nodeUtil;

function require_nodeUtil () {
	if (hasRequired_nodeUtil) return _nodeUtil.exports;
	hasRequired_nodeUtil = 1;
	(function (module, exports$1) {
		var freeGlobal = require_freeGlobal();

		/** Detect free variable `exports`. */
		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));
	return _nodeUtil.exports;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray_1;
	hasRequiredIsTypedArray = 1;
	var baseIsTypedArray = require_baseIsTypedArray(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	isTypedArray_1 = isTypedArray;
	return isTypedArray_1;
}

var isEmpty_1;
var hasRequiredIsEmpty;

function requireIsEmpty () {
	if (hasRequiredIsEmpty) return isEmpty_1;
	hasRequiredIsEmpty = 1;
	var baseKeys = require_baseKeys(),
	    getTag = require_getTag(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isArrayLike = requireIsArrayLike(),
	    isBuffer = requireIsBuffer(),
	    isPrototype = require_isPrototype(),
	    isTypedArray = requireIsTypedArray();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	isEmpty_1 = isEmpty;
	return isEmpty_1;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

var _arrayEach;
var hasRequired_arrayEach;

function require_arrayEach () {
	if (hasRequired_arrayEach) return _arrayEach;
	hasRequired_arrayEach = 1;
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	_arrayEach = arrayEach;
	return _arrayEach;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

var _createBaseFor;
var hasRequired_createBaseFor;

function require_createBaseFor () {
	if (hasRequired_createBaseFor) return _createBaseFor;
	hasRequired_createBaseFor = 1;
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	_createBaseFor = createBaseFor;
	return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;

function require_baseFor () {
	if (hasRequired_baseFor) return _baseFor;
	hasRequired_baseFor = 1;
	var createBaseFor = require_createBaseFor();

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	_baseFor = baseFor;
	return _baseFor;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

var _baseTimes;
var hasRequired_baseTimes;

function require_baseTimes () {
	if (hasRequired_baseTimes) return _baseTimes;
	hasRequired_baseTimes = 1;
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	_baseTimes = baseTimes;
	return _baseTimes;
}

/** Used as references for various `Number` constants. */

var _isIndex;
var hasRequired_isIndex;

function require_isIndex () {
	if (hasRequired_isIndex) return _isIndex;
	hasRequired_isIndex = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	_isIndex = isIndex;
	return _isIndex;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;

function require_arrayLikeKeys () {
	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
	hasRequired_arrayLikeKeys = 1;
	var baseTimes = require_baseTimes(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isIndex = require_isIndex(),
	    isTypedArray = requireIsTypedArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_arrayLikeKeys = arrayLikeKeys;
	return _arrayLikeKeys;
}

var keys_1;
var hasRequiredKeys;

function requireKeys () {
	if (hasRequiredKeys) return keys_1;
	hasRequiredKeys = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeys = require_baseKeys(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	keys_1 = keys;
	return keys_1;
}

var _baseForOwn;
var hasRequired_baseForOwn;

function require_baseForOwn () {
	if (hasRequired_baseForOwn) return _baseForOwn;
	hasRequired_baseForOwn = 1;
	var baseFor = require_baseFor(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	_baseForOwn = baseForOwn;
	return _baseForOwn;
}

var _createBaseEach;
var hasRequired_createBaseEach;

function require_createBaseEach () {
	if (hasRequired_createBaseEach) return _createBaseEach;
	hasRequired_createBaseEach = 1;
	var isArrayLike = requireIsArrayLike();

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	_createBaseEach = createBaseEach;
	return _createBaseEach;
}

var _baseEach;
var hasRequired_baseEach;

function require_baseEach () {
	if (hasRequired_baseEach) return _baseEach;
	hasRequired_baseEach = 1;
	var baseForOwn = require_baseForOwn(),
	    createBaseEach = require_createBaseEach();

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	_baseEach = baseEach;
	return _baseEach;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

var identity_1;
var hasRequiredIdentity$1;

function requireIdentity$1 () {
	if (hasRequiredIdentity$1) return identity_1;
	hasRequiredIdentity$1 = 1;
	function identity(value) {
	  return value;
	}

	identity_1 = identity;
	return identity_1;
}

var _castFunction;
var hasRequired_castFunction;

function require_castFunction () {
	if (hasRequired_castFunction) return _castFunction;
	hasRequired_castFunction = 1;
	var identity = requireIdentity$1();

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	_castFunction = castFunction;
	return _castFunction;
}

var forEach_1;
var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach_1;
	hasRequiredForEach = 1;
	var arrayEach = require_arrayEach(),
	    baseEach = require_baseEach(),
	    castFunction = require_castFunction(),
	    isArray = requireIsArray();

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, castFunction(iteratee));
	}

	forEach_1 = forEach;
	return forEach_1;
}

var each;
var hasRequiredEach;

function requireEach () {
	if (hasRequiredEach) return each;
	hasRequiredEach = 1;
	each = requireForEach();
	return each;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */

var _arrayReduce;
var hasRequired_arrayReduce;

function require_arrayReduce () {
	if (hasRequired_arrayReduce) return _arrayReduce;
	hasRequired_arrayReduce = 1;
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	_arrayReduce = arrayReduce;
	return _arrayReduce;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _stackClear;
var hasRequired_stackClear;

function require_stackClear () {
	if (hasRequired_stackClear) return _stackClear;
	hasRequired_stackClear = 1;
	var ListCache = require_ListCache();

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	_stackClear = stackClear;
	return _stackClear;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _stackDelete;
var hasRequired_stackDelete;

function require_stackDelete () {
	if (hasRequired_stackDelete) return _stackDelete;
	hasRequired_stackDelete = 1;
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	_stackDelete = stackDelete;
	return _stackDelete;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

var _stackGet;
var hasRequired_stackGet;

function require_stackGet () {
	if (hasRequired_stackGet) return _stackGet;
	hasRequired_stackGet = 1;
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	_stackGet = stackGet;
	return _stackGet;
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _stackHas;
var hasRequired_stackHas;

function require_stackHas () {
	if (hasRequired_stackHas) return _stackHas;
	hasRequired_stackHas = 1;
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	_stackHas = stackHas;
	return _stackHas;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var _stackSet;
var hasRequired_stackSet;

function require_stackSet () {
	if (hasRequired_stackSet) return _stackSet;
	hasRequired_stackSet = 1;
	var ListCache = require_ListCache(),
	    Map = require_Map(),
	    MapCache = require_MapCache();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	_stackSet = stackSet;
	return _stackSet;
}

var _Stack;
var hasRequired_Stack;

function require_Stack () {
	if (hasRequired_Stack) return _Stack;
	hasRequired_Stack = 1;
	var ListCache = require_ListCache(),
	    stackClear = require_stackClear(),
	    stackDelete = require_stackDelete(),
	    stackGet = require_stackGet(),
	    stackHas = require_stackHas(),
	    stackSet = require_stackSet();

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	_Stack = Stack;
	return _Stack;
}

/** Used to stand-in for `undefined` hash values. */

var _setCacheAdd;
var hasRequired_setCacheAdd;

function require_setCacheAdd () {
	if (hasRequired_setCacheAdd) return _setCacheAdd;
	hasRequired_setCacheAdd = 1;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	_setCacheAdd = setCacheAdd;
	return _setCacheAdd;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

var _setCacheHas;
var hasRequired_setCacheHas;

function require_setCacheHas () {
	if (hasRequired_setCacheHas) return _setCacheHas;
	hasRequired_setCacheHas = 1;
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	_setCacheHas = setCacheHas;
	return _setCacheHas;
}

var _SetCache;
var hasRequired_SetCache;

function require_SetCache () {
	if (hasRequired_SetCache) return _SetCache;
	hasRequired_SetCache = 1;
	var MapCache = require_MapCache(),
	    setCacheAdd = require_setCacheAdd(),
	    setCacheHas = require_setCacheHas();

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	_SetCache = SetCache;
	return _SetCache;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

var _arraySome;
var hasRequired_arraySome;

function require_arraySome () {
	if (hasRequired_arraySome) return _arraySome;
	hasRequired_arraySome = 1;
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	_arraySome = arraySome;
	return _arraySome;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _cacheHas;
var hasRequired_cacheHas;

function require_cacheHas () {
	if (hasRequired_cacheHas) return _cacheHas;
	hasRequired_cacheHas = 1;
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	_cacheHas = cacheHas;
	return _cacheHas;
}

var _equalArrays;
var hasRequired_equalArrays;

function require_equalArrays () {
	if (hasRequired_equalArrays) return _equalArrays;
	hasRequired_equalArrays = 1;
	var SetCache = require_SetCache(),
	    arraySome = require_arraySome(),
	    cacheHas = require_cacheHas();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	_equalArrays = equalArrays;
	return _equalArrays;
}

var _Uint8Array;
var hasRequired_Uint8Array;

function require_Uint8Array () {
	if (hasRequired_Uint8Array) return _Uint8Array;
	hasRequired_Uint8Array = 1;
	var root = require_root();

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	_Uint8Array = Uint8Array;
	return _Uint8Array;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

var _mapToArray;
var hasRequired_mapToArray;

function require_mapToArray () {
	if (hasRequired_mapToArray) return _mapToArray;
	hasRequired_mapToArray = 1;
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	_mapToArray = mapToArray;
	return _mapToArray;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

var _setToArray;
var hasRequired_setToArray;

function require_setToArray () {
	if (hasRequired_setToArray) return _setToArray;
	hasRequired_setToArray = 1;
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	_setToArray = setToArray;
	return _setToArray;
}

var _equalByTag;
var hasRequired_equalByTag;

function require_equalByTag () {
	if (hasRequired_equalByTag) return _equalByTag;
	hasRequired_equalByTag = 1;
	var Symbol = require_Symbol(),
	    Uint8Array = require_Uint8Array(),
	    eq = requireEq(),
	    equalArrays = require_equalArrays(),
	    mapToArray = require_mapToArray(),
	    setToArray = require_setToArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	_equalByTag = equalByTag;
	return _equalByTag;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

var _arrayPush;
var hasRequired_arrayPush;

function require_arrayPush () {
	if (hasRequired_arrayPush) return _arrayPush;
	hasRequired_arrayPush = 1;
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	_arrayPush = arrayPush;
	return _arrayPush;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;

function require_baseGetAllKeys () {
	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
	hasRequired_baseGetAllKeys = 1;
	var arrayPush = require_arrayPush(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	_baseGetAllKeys = baseGetAllKeys;
	return _baseGetAllKeys;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

var _arrayFilter;
var hasRequired_arrayFilter;

function require_arrayFilter () {
	if (hasRequired_arrayFilter) return _arrayFilter;
	hasRequired_arrayFilter = 1;
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	_arrayFilter = arrayFilter;
	return _arrayFilter;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

var stubArray_1;
var hasRequiredStubArray;

function requireStubArray () {
	if (hasRequiredStubArray) return stubArray_1;
	hasRequiredStubArray = 1;
	function stubArray() {
	  return [];
	}

	stubArray_1 = stubArray;
	return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;

function require_getSymbols () {
	if (hasRequired_getSymbols) return _getSymbols;
	hasRequired_getSymbols = 1;
	var arrayFilter = require_arrayFilter(),
	    stubArray = requireStubArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	_getSymbols = getSymbols;
	return _getSymbols;
}

var _getAllKeys;
var hasRequired_getAllKeys;

function require_getAllKeys () {
	if (hasRequired_getAllKeys) return _getAllKeys;
	hasRequired_getAllKeys = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbols = require_getSymbols(),
	    keys = requireKeys();

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	_getAllKeys = getAllKeys;
	return _getAllKeys;
}

var _equalObjects;
var hasRequired_equalObjects;

function require_equalObjects () {
	if (hasRequired_equalObjects) return _equalObjects;
	hasRequired_equalObjects = 1;
	var getAllKeys = require_getAllKeys();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	_equalObjects = equalObjects;
	return _equalObjects;
}

var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;

function require_baseIsEqualDeep () {
	if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
	hasRequired_baseIsEqualDeep = 1;
	var Stack = require_Stack(),
	    equalArrays = require_equalArrays(),
	    equalByTag = require_equalByTag(),
	    equalObjects = require_equalObjects(),
	    getTag = require_getTag(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isTypedArray = requireIsTypedArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	_baseIsEqualDeep = baseIsEqualDeep;
	return _baseIsEqualDeep;
}

var _baseIsEqual;
var hasRequired_baseIsEqual;

function require_baseIsEqual () {
	if (hasRequired_baseIsEqual) return _baseIsEqual;
	hasRequired_baseIsEqual = 1;
	var baseIsEqualDeep = require_baseIsEqualDeep(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	_baseIsEqual = baseIsEqual;
	return _baseIsEqual;
}

var _baseIsMatch;
var hasRequired_baseIsMatch;

function require_baseIsMatch () {
	if (hasRequired_baseIsMatch) return _baseIsMatch;
	hasRequired_baseIsMatch = 1;
	var Stack = require_Stack(),
	    baseIsEqual = require_baseIsEqual();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	_baseIsMatch = baseIsMatch;
	return _baseIsMatch;
}

var _isStrictComparable;
var hasRequired_isStrictComparable;

function require_isStrictComparable () {
	if (hasRequired_isStrictComparable) return _isStrictComparable;
	hasRequired_isStrictComparable = 1;
	var isObject = requireIsObject();

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	_isStrictComparable = isStrictComparable;
	return _isStrictComparable;
}

var _getMatchData;
var hasRequired_getMatchData;

function require_getMatchData () {
	if (hasRequired_getMatchData) return _getMatchData;
	hasRequired_getMatchData = 1;
	var isStrictComparable = require_isStrictComparable(),
	    keys = requireKeys();

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	_getMatchData = getMatchData;
	return _getMatchData;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;

function require_matchesStrictComparable () {
	if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
	hasRequired_matchesStrictComparable = 1;
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	_matchesStrictComparable = matchesStrictComparable;
	return _matchesStrictComparable;
}

var _baseMatches;
var hasRequired_baseMatches;

function require_baseMatches () {
	if (hasRequired_baseMatches) return _baseMatches;
	hasRequired_baseMatches = 1;
	var baseIsMatch = require_baseIsMatch(),
	    getMatchData = require_getMatchData(),
	    matchesStrictComparable = require_matchesStrictComparable();

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	_baseMatches = baseMatches;
	return _baseMatches;
}

var isSymbol_1;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol_1;
	hasRequiredIsSymbol = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	isSymbol_1 = isSymbol;
	return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;

function require_isKey () {
	if (hasRequired_isKey) return _isKey;
	hasRequired_isKey = 1;
	var isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	_isKey = isKey;
	return _isKey;
}

var memoize_1;
var hasRequiredMemoize;

function requireMemoize () {
	if (hasRequiredMemoize) return memoize_1;
	hasRequiredMemoize = 1;
	var MapCache = require_MapCache();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	memoize_1 = memoize;
	return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;

function require_memoizeCapped () {
	if (hasRequired_memoizeCapped) return _memoizeCapped;
	hasRequired_memoizeCapped = 1;
	var memoize = requireMemoize();

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	_memoizeCapped = memoizeCapped;
	return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;

function require_stringToPath () {
	if (hasRequired_stringToPath) return _stringToPath;
	hasRequired_stringToPath = 1;
	var memoizeCapped = require_memoizeCapped();

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	_stringToPath = stringToPath;
	return _stringToPath;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

var _arrayMap;
var hasRequired_arrayMap;

function require_arrayMap () {
	if (hasRequired_arrayMap) return _arrayMap;
	hasRequired_arrayMap = 1;
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	_arrayMap = arrayMap;
	return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;

function require_baseToString () {
	if (hasRequired_baseToString) return _baseToString;
	hasRequired_baseToString = 1;
	var Symbol = require_Symbol(),
	    arrayMap = require_arrayMap(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_baseToString = baseToString;
	return _baseToString;
}

var toString_1;
var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString_1;
	hasRequiredToString = 1;
	var baseToString = require_baseToString();

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	toString_1 = toString;
	return toString_1;
}

var _castPath;
var hasRequired_castPath;

function require_castPath () {
	if (hasRequired_castPath) return _castPath;
	hasRequired_castPath = 1;
	var isArray = requireIsArray(),
	    isKey = require_isKey(),
	    stringToPath = require_stringToPath(),
	    toString = requireToString();

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	_castPath = castPath;
	return _castPath;
}

var _toKey;
var hasRequired_toKey;

function require_toKey () {
	if (hasRequired_toKey) return _toKey;
	hasRequired_toKey = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_toKey = toKey;
	return _toKey;
}

var _baseGet;
var hasRequired_baseGet;

function require_baseGet () {
	if (hasRequired_baseGet) return _baseGet;
	hasRequired_baseGet = 1;
	var castPath = require_castPath(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	_baseGet = baseGet;
	return _baseGet;
}

var get_1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get_1;
	hasRequiredGet = 1;
	var baseGet = require_baseGet();

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	get_1 = get;
	return get_1;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

var _baseHasIn;
var hasRequired_baseHasIn;

function require_baseHasIn () {
	if (hasRequired_baseHasIn) return _baseHasIn;
	hasRequired_baseHasIn = 1;
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	_baseHasIn = baseHasIn;
	return _baseHasIn;
}

var _hasPath;
var hasRequired_hasPath;

function require_hasPath () {
	if (hasRequired_hasPath) return _hasPath;
	hasRequired_hasPath = 1;
	var castPath = require_castPath(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isIndex = require_isIndex(),
	    isLength = requireIsLength(),
	    toKey = require_toKey();

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	_hasPath = hasPath;
	return _hasPath;
}

var hasIn_1;
var hasRequiredHasIn;

function requireHasIn () {
	if (hasRequiredHasIn) return hasIn_1;
	hasRequiredHasIn = 1;
	var baseHasIn = require_baseHasIn(),
	    hasPath = require_hasPath();

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	hasIn_1 = hasIn;
	return hasIn_1;
}

var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;

function require_baseMatchesProperty () {
	if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
	hasRequired_baseMatchesProperty = 1;
	var baseIsEqual = require_baseIsEqual(),
	    get = requireGet(),
	    hasIn = requireHasIn(),
	    isKey = require_isKey(),
	    isStrictComparable = require_isStrictComparable(),
	    matchesStrictComparable = require_matchesStrictComparable(),
	    toKey = require_toKey();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	_baseMatchesProperty = baseMatchesProperty;
	return _baseMatchesProperty;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

var _baseProperty;
var hasRequired_baseProperty;

function require_baseProperty () {
	if (hasRequired_baseProperty) return _baseProperty;
	hasRequired_baseProperty = 1;
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	_baseProperty = baseProperty;
	return _baseProperty;
}

var _basePropertyDeep;
var hasRequired_basePropertyDeep;

function require_basePropertyDeep () {
	if (hasRequired_basePropertyDeep) return _basePropertyDeep;
	hasRequired_basePropertyDeep = 1;
	var baseGet = require_baseGet();

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	_basePropertyDeep = basePropertyDeep;
	return _basePropertyDeep;
}

var property_1;
var hasRequiredProperty$1;

function requireProperty$1 () {
	if (hasRequiredProperty$1) return property_1;
	hasRequiredProperty$1 = 1;
	var baseProperty = require_baseProperty(),
	    basePropertyDeep = require_basePropertyDeep(),
	    isKey = require_isKey(),
	    toKey = require_toKey();

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	property_1 = property;
	return property_1;
}

var _baseIteratee;
var hasRequired_baseIteratee;

function require_baseIteratee () {
	if (hasRequired_baseIteratee) return _baseIteratee;
	hasRequired_baseIteratee = 1;
	var baseMatches = require_baseMatches(),
	    baseMatchesProperty = require_baseMatchesProperty(),
	    identity = requireIdentity$1(),
	    isArray = requireIsArray(),
	    property = requireProperty$1();

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	_baseIteratee = baseIteratee;
	return _baseIteratee;
}

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */

var _baseReduce;
var hasRequired_baseReduce;

function require_baseReduce () {
	if (hasRequired_baseReduce) return _baseReduce;
	hasRequired_baseReduce = 1;
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initAccum
	      ? (initAccum = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}

	_baseReduce = baseReduce;
	return _baseReduce;
}

var reduce_1;
var hasRequiredReduce;

function requireReduce () {
	if (hasRequiredReduce) return reduce_1;
	hasRequiredReduce = 1;
	var arrayReduce = require_arrayReduce(),
	    baseEach = require_baseEach(),
	    baseIteratee = require_baseIteratee(),
	    baseReduce = require_baseReduce(),
	    isArray = requireIsArray();

	/**
	 * Reduces `collection` to a value which is the accumulated result of running
	 * each element in `collection` thru `iteratee`, where each successive
	 * invocation is supplied the return value of the previous. If `accumulator`
	 * is not given, the first element of `collection` is used as the initial
	 * value. The iteratee is invoked with four arguments:
	 * (accumulator, value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.reduce`, `_.reduceRight`, and `_.transform`.
	 *
	 * The guarded methods are:
	 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	 * and `sortBy`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduceRight
	 * @example
	 *
	 * _.reduce([1, 2], function(sum, n) {
	 *   return sum + n;
	 * }, 0);
	 * // => 3
	 *
	 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 *   return result;
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	 */
	function reduce(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduce : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}

	reduce_1 = reduce;
	return reduce_1;
}

var _defineProperty;
var hasRequired_defineProperty;

function require_defineProperty () {
	if (hasRequired_defineProperty) return _defineProperty;
	hasRequired_defineProperty = 1;
	var getNative = require_getNative();

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	_defineProperty = defineProperty;
	return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;

function require_baseAssignValue () {
	if (hasRequired_baseAssignValue) return _baseAssignValue;
	hasRequired_baseAssignValue = 1;
	var defineProperty = require_defineProperty();

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	_baseAssignValue = baseAssignValue;
	return _baseAssignValue;
}

var _assignValue;
var hasRequired_assignValue;

function require_assignValue () {
	if (hasRequired_assignValue) return _assignValue;
	hasRequired_assignValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignValue = assignValue;
	return _assignValue;
}

var _copyObject;
var hasRequired_copyObject;

function require_copyObject () {
	if (hasRequired_copyObject) return _copyObject;
	hasRequired_copyObject = 1;
	var assignValue = require_assignValue(),
	    baseAssignValue = require_baseAssignValue();

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	_copyObject = copyObject;
	return _copyObject;
}

var _baseAssign;
var hasRequired_baseAssign;

function require_baseAssign () {
	if (hasRequired_baseAssign) return _baseAssign;
	hasRequired_baseAssign = 1;
	var copyObject = require_copyObject(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	_baseAssign = baseAssign;
	return _baseAssign;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

var _nativeKeysIn;
var hasRequired_nativeKeysIn;

function require_nativeKeysIn () {
	if (hasRequired_nativeKeysIn) return _nativeKeysIn;
	hasRequired_nativeKeysIn = 1;
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_nativeKeysIn = nativeKeysIn;
	return _nativeKeysIn;
}

var _baseKeysIn;
var hasRequired_baseKeysIn;

function require_baseKeysIn () {
	if (hasRequired_baseKeysIn) return _baseKeysIn;
	hasRequired_baseKeysIn = 1;
	var isObject = requireIsObject(),
	    isPrototype = require_isPrototype(),
	    nativeKeysIn = require_nativeKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeysIn = baseKeysIn;
	return _baseKeysIn;
}

var keysIn_1;
var hasRequiredKeysIn;

function requireKeysIn () {
	if (hasRequiredKeysIn) return keysIn_1;
	hasRequiredKeysIn = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeysIn = require_baseKeysIn(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	keysIn_1 = keysIn;
	return keysIn_1;
}

var _baseAssignIn;
var hasRequired_baseAssignIn;

function require_baseAssignIn () {
	if (hasRequired_baseAssignIn) return _baseAssignIn;
	hasRequired_baseAssignIn = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	_baseAssignIn = baseAssignIn;
	return _baseAssignIn;
}

var _cloneBuffer = {exports: {}};

_cloneBuffer.exports;

var hasRequired_cloneBuffer;

function require_cloneBuffer () {
	if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
	hasRequired_cloneBuffer = 1;
	(function (module, exports$1) {
		var root = require_root();

		/** Detect free variable `exports`. */
		var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));
	return _cloneBuffer.exports;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

var _copyArray;
var hasRequired_copyArray;

function require_copyArray () {
	if (hasRequired_copyArray) return _copyArray;
	hasRequired_copyArray = 1;
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	_copyArray = copyArray;
	return _copyArray;
}

var _copySymbols;
var hasRequired_copySymbols;

function require_copySymbols () {
	if (hasRequired_copySymbols) return _copySymbols;
	hasRequired_copySymbols = 1;
	var copyObject = require_copyObject(),
	    getSymbols = require_getSymbols();

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	_copySymbols = copySymbols;
	return _copySymbols;
}

var _getPrototype;
var hasRequired_getPrototype;

function require_getPrototype () {
	if (hasRequired_getPrototype) return _getPrototype;
	hasRequired_getPrototype = 1;
	var overArg = require_overArg();

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	_getPrototype = getPrototype;
	return _getPrototype;
}

var _getSymbolsIn;
var hasRequired_getSymbolsIn;

function require_getSymbolsIn () {
	if (hasRequired_getSymbolsIn) return _getSymbolsIn;
	hasRequired_getSymbolsIn = 1;
	var arrayPush = require_arrayPush(),
	    getPrototype = require_getPrototype(),
	    getSymbols = require_getSymbols(),
	    stubArray = requireStubArray();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	_getSymbolsIn = getSymbolsIn;
	return _getSymbolsIn;
}

var _copySymbolsIn;
var hasRequired_copySymbolsIn;

function require_copySymbolsIn () {
	if (hasRequired_copySymbolsIn) return _copySymbolsIn;
	hasRequired_copySymbolsIn = 1;
	var copyObject = require_copyObject(),
	    getSymbolsIn = require_getSymbolsIn();

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	_copySymbolsIn = copySymbolsIn;
	return _copySymbolsIn;
}

var _getAllKeysIn;
var hasRequired_getAllKeysIn;

function require_getAllKeysIn () {
	if (hasRequired_getAllKeysIn) return _getAllKeysIn;
	hasRequired_getAllKeysIn = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbolsIn = require_getSymbolsIn(),
	    keysIn = requireKeysIn();

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}

	_getAllKeysIn = getAllKeysIn;
	return _getAllKeysIn;
}

/** Used for built-in method references. */

var _initCloneArray;
var hasRequired_initCloneArray;

function require_initCloneArray () {
	if (hasRequired_initCloneArray) return _initCloneArray;
	hasRequired_initCloneArray = 1;
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	_initCloneArray = initCloneArray;
	return _initCloneArray;
}

var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;

function require_cloneArrayBuffer () {
	if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
	hasRequired_cloneArrayBuffer = 1;
	var Uint8Array = require_Uint8Array();

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	_cloneArrayBuffer = cloneArrayBuffer;
	return _cloneArrayBuffer;
}

var _cloneDataView;
var hasRequired_cloneDataView;

function require_cloneDataView () {
	if (hasRequired_cloneDataView) return _cloneDataView;
	hasRequired_cloneDataView = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	_cloneDataView = cloneDataView;
	return _cloneDataView;
}

/** Used to match `RegExp` flags from their coerced string values. */

var _cloneRegExp;
var hasRequired_cloneRegExp;

function require_cloneRegExp () {
	if (hasRequired_cloneRegExp) return _cloneRegExp;
	hasRequired_cloneRegExp = 1;
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	_cloneRegExp = cloneRegExp;
	return _cloneRegExp;
}

var _cloneSymbol;
var hasRequired_cloneSymbol;

function require_cloneSymbol () {
	if (hasRequired_cloneSymbol) return _cloneSymbol;
	hasRequired_cloneSymbol = 1;
	var Symbol = require_Symbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	_cloneSymbol = cloneSymbol;
	return _cloneSymbol;
}

var _cloneTypedArray;
var hasRequired_cloneTypedArray;

function require_cloneTypedArray () {
	if (hasRequired_cloneTypedArray) return _cloneTypedArray;
	hasRequired_cloneTypedArray = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	_cloneTypedArray = cloneTypedArray;
	return _cloneTypedArray;
}

var _initCloneByTag;
var hasRequired_initCloneByTag;

function require_initCloneByTag () {
	if (hasRequired_initCloneByTag) return _initCloneByTag;
	hasRequired_initCloneByTag = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer(),
	    cloneDataView = require_cloneDataView(),
	    cloneRegExp = require_cloneRegExp(),
	    cloneSymbol = require_cloneSymbol(),
	    cloneTypedArray = require_cloneTypedArray();

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return new Ctor;

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return new Ctor;

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	_initCloneByTag = initCloneByTag;
	return _initCloneByTag;
}

var _baseCreate;
var hasRequired_baseCreate;

function require_baseCreate () {
	if (hasRequired_baseCreate) return _baseCreate;
	hasRequired_baseCreate = 1;
	var isObject = requireIsObject();

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	_baseCreate = baseCreate;
	return _baseCreate;
}

var _initCloneObject;
var hasRequired_initCloneObject;

function require_initCloneObject () {
	if (hasRequired_initCloneObject) return _initCloneObject;
	hasRequired_initCloneObject = 1;
	var baseCreate = require_baseCreate(),
	    getPrototype = require_getPrototype(),
	    isPrototype = require_isPrototype();

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	_initCloneObject = initCloneObject;
	return _initCloneObject;
}

var _baseIsMap;
var hasRequired_baseIsMap;

function require_baseIsMap () {
	if (hasRequired_baseIsMap) return _baseIsMap;
	hasRequired_baseIsMap = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag(value) == mapTag;
	}

	_baseIsMap = baseIsMap;
	return _baseIsMap;
}

var isMap_1;
var hasRequiredIsMap;

function requireIsMap () {
	if (hasRequiredIsMap) return isMap_1;
	hasRequiredIsMap = 1;
	var baseIsMap = require_baseIsMap(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	isMap_1 = isMap;
	return isMap_1;
}

var _baseIsSet;
var hasRequired_baseIsSet;

function require_baseIsSet () {
	if (hasRequired_baseIsSet) return _baseIsSet;
	hasRequired_baseIsSet = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var setTag = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag(value) == setTag;
	}

	_baseIsSet = baseIsSet;
	return _baseIsSet;
}

var isSet_1;
var hasRequiredIsSet;

function requireIsSet () {
	if (hasRequiredIsSet) return isSet_1;
	hasRequiredIsSet = 1;
	var baseIsSet = require_baseIsSet(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	isSet_1 = isSet;
	return isSet_1;
}

var _baseClone;
var hasRequired_baseClone;

function require_baseClone () {
	if (hasRequired_baseClone) return _baseClone;
	hasRequired_baseClone = 1;
	var Stack = require_Stack(),
	    arrayEach = require_arrayEach(),
	    assignValue = require_assignValue(),
	    baseAssign = require_baseAssign(),
	    baseAssignIn = require_baseAssignIn(),
	    cloneBuffer = require_cloneBuffer(),
	    copyArray = require_copyArray(),
	    copySymbols = require_copySymbols(),
	    copySymbolsIn = require_copySymbolsIn(),
	    getAllKeys = require_getAllKeys(),
	    getAllKeysIn = require_getAllKeysIn(),
	    getTag = require_getTag(),
	    initCloneArray = require_initCloneArray(),
	    initCloneByTag = require_initCloneByTag(),
	    initCloneObject = require_initCloneObject(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isMap = requireIsMap(),
	    isObject = requireIsObject(),
	    isSet = requireIsSet(),
	    keys = requireKeys(),
	    keysIn = requireKeysIn();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	_baseClone = baseClone;
	return _baseClone;
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */

var last_1;
var hasRequiredLast;

function requireLast () {
	if (hasRequiredLast) return last_1;
	hasRequiredLast = 1;
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	last_1 = last;
	return last_1;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */

var _baseSlice;
var hasRequired_baseSlice;

function require_baseSlice () {
	if (hasRequired_baseSlice) return _baseSlice;
	hasRequired_baseSlice = 1;
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	_baseSlice = baseSlice;
	return _baseSlice;
}

var _parent;
var hasRequired_parent;

function require_parent () {
	if (hasRequired_parent) return _parent;
	hasRequired_parent = 1;
	var baseGet = require_baseGet(),
	    baseSlice = require_baseSlice();

	/**
	 * Gets the parent value at `path` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path to get the parent value of.
	 * @returns {*} Returns the parent value.
	 */
	function parent(object, path) {
	  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}

	_parent = parent;
	return _parent;
}

var _baseUnset;
var hasRequired_baseUnset;

function require_baseUnset () {
	if (hasRequired_baseUnset) return _baseUnset;
	hasRequired_baseUnset = 1;
	var castPath = require_castPath(),
	    last = requireLast(),
	    parent = require_parent(),
	    toKey = require_toKey();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.unset`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The property path to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 */
	function baseUnset(object, path) {
	  path = castPath(path, object);

	  // Prevent prototype pollution, see: https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg
	  var index = -1,
	      length = path.length;

	  if (!length) {
	    return true;
	  }

	  var isRootPrimitive = object == null || (typeof object !== 'object' && typeof object !== 'function');

	  while (++index < length) {
	    var key = path[index];

	    // skip non-string keys (e.g., Symbols, numbers)
	    if (typeof key !== 'string') {
	      continue;
	    }

	    // Always block "__proto__" anywhere in the path if it's not expected
	    if (key === '__proto__' && !hasOwnProperty.call(object, '__proto__')) {
	      return false;
	    }

	    // Block "constructor.prototype" chains
	    if (key === 'constructor' &&
	        (index + 1) < length &&
	        typeof path[index + 1] === 'string' &&
	        path[index + 1] === 'prototype') {

	      // Allow ONLY when the path starts at a primitive root, e.g., _.unset(0, 'constructor.prototype.a')
	      if (isRootPrimitive && index === 0) {
	        continue;
	      }

	      return false;
	    }
	  }

	  var obj = parent(object, path);
	  return obj == null || delete obj[toKey(last(path))];
	}

	_baseUnset = baseUnset;
	return _baseUnset;
}

var isPlainObject_1;
var hasRequiredIsPlainObject;

function requireIsPlainObject () {
	if (hasRequiredIsPlainObject) return isPlainObject_1;
	hasRequiredIsPlainObject = 1;
	var baseGetTag = require_baseGetTag(),
	    getPrototype = require_getPrototype(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	isPlainObject_1 = isPlainObject;
	return isPlainObject_1;
}

var _customOmitClone;
var hasRequired_customOmitClone;

function require_customOmitClone () {
	if (hasRequired_customOmitClone) return _customOmitClone;
	hasRequired_customOmitClone = 1;
	var isPlainObject = requireIsPlainObject();

	/**
	 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	 * objects.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {string} key The key of the property to inspect.
	 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	 */
	function customOmitClone(value) {
	  return isPlainObject(value) ? undefined : value;
	}

	_customOmitClone = customOmitClone;
	return _customOmitClone;
}

var _isFlattenable;
var hasRequired_isFlattenable;

function require_isFlattenable () {
	if (hasRequired_isFlattenable) return _isFlattenable;
	hasRequired_isFlattenable = 1;
	var Symbol = require_Symbol(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray();

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	_isFlattenable = isFlattenable;
	return _isFlattenable;
}

var _baseFlatten;
var hasRequired_baseFlatten;

function require_baseFlatten () {
	if (hasRequired_baseFlatten) return _baseFlatten;
	hasRequired_baseFlatten = 1;
	var arrayPush = require_arrayPush(),
	    isFlattenable = require_isFlattenable();

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	_baseFlatten = baseFlatten;
	return _baseFlatten;
}

var flatten_1;
var hasRequiredFlatten;

function requireFlatten () {
	if (hasRequiredFlatten) return flatten_1;
	hasRequiredFlatten = 1;
	var baseFlatten = require_baseFlatten();

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	flatten_1 = flatten;
	return flatten_1;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

var _apply;
var hasRequired_apply;

function require_apply () {
	if (hasRequired_apply) return _apply;
	hasRequired_apply = 1;
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	_apply = apply;
	return _apply;
}

var _overRest;
var hasRequired_overRest;

function require_overRest () {
	if (hasRequired_overRest) return _overRest;
	hasRequired_overRest = 1;
	var apply = require_apply();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	_overRest = overRest;
	return _overRest;
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

var constant_1;
var hasRequiredConstant;

function requireConstant () {
	if (hasRequiredConstant) return constant_1;
	hasRequiredConstant = 1;
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	constant_1 = constant;
	return constant_1;
}

var _baseSetToString;
var hasRequired_baseSetToString;

function require_baseSetToString () {
	if (hasRequired_baseSetToString) return _baseSetToString;
	hasRequired_baseSetToString = 1;
	var constant = requireConstant(),
	    defineProperty = require_defineProperty(),
	    identity = requireIdentity$1();

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	_baseSetToString = baseSetToString;
	return _baseSetToString;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */

var _shortOut;
var hasRequired_shortOut;

function require_shortOut () {
	if (hasRequired_shortOut) return _shortOut;
	hasRequired_shortOut = 1;
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	_shortOut = shortOut;
	return _shortOut;
}

var _setToString;
var hasRequired_setToString;

function require_setToString () {
	if (hasRequired_setToString) return _setToString;
	hasRequired_setToString = 1;
	var baseSetToString = require_baseSetToString(),
	    shortOut = require_shortOut();

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	_setToString = setToString;
	return _setToString;
}

var _flatRest;
var hasRequired_flatRest;

function require_flatRest () {
	if (hasRequired_flatRest) return _flatRest;
	hasRequired_flatRest = 1;
	var flatten = requireFlatten(),
	    overRest = require_overRest(),
	    setToString = require_setToString();

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten), func + '');
	}

	_flatRest = flatRest;
	return _flatRest;
}

var omit_1;
var hasRequiredOmit;

function requireOmit () {
	if (hasRequiredOmit) return omit_1;
	hasRequiredOmit = 1;
	var arrayMap = require_arrayMap(),
	    baseClone = require_baseClone(),
	    baseUnset = require_baseUnset(),
	    castPath = require_castPath(),
	    copyObject = require_copyObject(),
	    customOmitClone = require_customOmitClone(),
	    flatRest = require_flatRest(),
	    getAllKeysIn = require_getAllKeysIn();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * The opposite of `_.pick`; this method creates an object composed of the
	 * own and inherited enumerable property paths of `object` that are not omitted.
	 *
	 * **Note:** This method is considerably slower than `_.pick`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to omit.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omit(object, ['a', 'c']);
	 * // => { 'b': '2' }
	 */
	var omit = flatRest(function(object, paths) {
	  var result = {};
	  if (object == null) {
	    return result;
	  }
	  var isDeep = false;
	  paths = arrayMap(paths, function(path) {
	    path = castPath(path, object);
	    isDeep || (isDeep = path.length > 1);
	    return path;
	  });
	  copyObject(object, getAllKeysIn(object), result);
	  if (isDeep) {
	    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	  }
	  var length = paths.length;
	  while (length--) {
	    baseUnset(result, paths[length]);
	  }
	  return result;
	});

	omit_1 = omit;
	return omit_1;
}

var _baseMap;
var hasRequired_baseMap;

function require_baseMap () {
	if (hasRequired_baseMap) return _baseMap;
	hasRequired_baseMap = 1;
	var baseEach = require_baseEach(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	_baseMap = baseMap;
	return _baseMap;
}

var map_1;
var hasRequiredMap$1;

function requireMap$1 () {
	if (hasRequiredMap$1) return map_1;
	hasRequiredMap$1 = 1;
	var arrayMap = require_arrayMap(),
	    baseIteratee = require_baseIteratee(),
	    baseMap = require_baseMap(),
	    isArray = requireIsArray();

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	map_1 = map;
	return map_1;
}

var _baseFilter;
var hasRequired_baseFilter;

function require_baseFilter () {
	if (hasRequired_baseFilter) return _baseFilter;
	hasRequired_baseFilter = 1;
	var baseEach = require_baseEach();

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	_baseFilter = baseFilter;
	return _baseFilter;
}

var filter_1;
var hasRequiredFilter$1;

function requireFilter$1 () {
	if (hasRequiredFilter$1) return filter_1;
	hasRequiredFilter$1 = 1;
	var arrayFilter = require_arrayFilter(),
	    baseFilter = require_baseFilter(),
	    baseIteratee = require_baseIteratee(),
	    isArray = requireIsArray();

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 *
	 * // Combining several predicates using `_.overEvery` or `_.overSome`.
	 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	 * // => objects for ['fred', 'barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	filter_1 = filter;
	return filter_1;
}

var _createFind;
var hasRequired_createFind;

function require_createFind () {
	if (hasRequired_createFind) return _createFind;
	hasRequired_createFind = 1;
	var baseIteratee = require_baseIteratee(),
	    isArrayLike = requireIsArrayLike(),
	    keys = requireKeys();

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate, 3);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	_createFind = createFind;
	return _createFind;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

var _baseFindIndex;
var hasRequired_baseFindIndex;

function require_baseFindIndex () {
	if (hasRequired_baseFindIndex) return _baseFindIndex;
	hasRequired_baseFindIndex = 1;
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	_baseFindIndex = baseFindIndex;
	return _baseFindIndex;
}

/** Used to match a single whitespace character. */

var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;

function require_trimmedEndIndex () {
	if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
	hasRequired_trimmedEndIndex = 1;
	var reWhitespace = /\s/;

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */
	function trimmedEndIndex(string) {
	  var index = string.length;

	  while (index-- && reWhitespace.test(string.charAt(index))) {}
	  return index;
	}

	_trimmedEndIndex = trimmedEndIndex;
	return _trimmedEndIndex;
}

var _baseTrim;
var hasRequired_baseTrim;

function require_baseTrim () {
	if (hasRequired_baseTrim) return _baseTrim;
	hasRequired_baseTrim = 1;
	var trimmedEndIndex = require_trimmedEndIndex();

	/** Used to match leading whitespace. */
	var reTrimStart = /^\s+/;

	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */
	function baseTrim(string) {
	  return string
	    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	    : string;
	}

	_baseTrim = baseTrim;
	return _baseTrim;
}

var toNumber_1;
var hasRequiredToNumber;

function requireToNumber () {
	if (hasRequiredToNumber) return toNumber_1;
	hasRequiredToNumber = 1;
	var baseTrim = require_baseTrim(),
	    isObject = requireIsObject(),
	    isSymbol = requireIsSymbol();

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = baseTrim(value);
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	toNumber_1 = toNumber;
	return toNumber_1;
}

var toFinite_1;
var hasRequiredToFinite;

function requireToFinite () {
	if (hasRequiredToFinite) return toFinite_1;
	hasRequiredToFinite = 1;
	var toNumber = requireToNumber();

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	toFinite_1 = toFinite;
	return toFinite_1;
}

var toInteger_1;
var hasRequiredToInteger;

function requireToInteger () {
	if (hasRequiredToInteger) return toInteger_1;
	hasRequiredToInteger = 1;
	var toFinite = requireToFinite();

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	toInteger_1 = toInteger;
	return toInteger_1;
}

var findIndex_1;
var hasRequiredFindIndex;

function requireFindIndex () {
	if (hasRequiredFindIndex) return findIndex_1;
	hasRequiredFindIndex = 1;
	var baseFindIndex = require_baseFindIndex(),
	    baseIteratee = require_baseIteratee(),
	    toInteger = requireToInteger();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	findIndex_1 = findIndex;
	return findIndex_1;
}

var find_1;
var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find_1;
	hasRequiredFind = 1;
	var createFind = require_createFind(),
	    findIndex = requireFindIndex();

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	find_1 = find;
	return find_1;
}

var cheerio$1 = {exports: {}};

var lib$x = {};

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	
	return types$1;
}

var load = {};

var options$5 = {};

var hasRequiredOptions$5;

function requireOptions$5 () {
	if (hasRequiredOptions$5) return options$5;
	hasRequiredOptions$5 = 1;
	var __assign = (options$5 && options$5.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(options$5, "__esModule", { value: true });
	options$5.flatten = void 0;
	var defaultOpts = {
	    xml: false,
	    decodeEntities: true,
	};
	/** Cheerio default options. */
	options$5.default = defaultOpts;
	var xmlModeDefault = {
	    _useHtmlParser2: true,
	    xmlMode: true,
	};
	/**
	 * Flatten the options for Cheerio.
	 *
	 * This will set `_useHtmlParser2` to true if `xml` is set to true.
	 *
	 * @param options - The options to flatten.
	 * @returns The flattened options.
	 */
	function flatten(options) {
	    return (options === null || options === void 0 ? void 0 : options.xml)
	        ? typeof options.xml === 'boolean'
	            ? xmlModeDefault
	            : __assign(__assign({}, xmlModeDefault), options.xml)
	        : options !== null && options !== void 0 ? options : undefined;
	}
	options$5.flatten = flatten;
	
	return options$5;
}

var _static = {};

var hasRequired_static;

function require_static () {
	if (hasRequired_static) return _static;
	hasRequired_static = 1;
	var __assign = (_static && _static.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __createBinding = (_static && _static.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (_static && _static.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (_static && _static.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(_static, "__esModule", { value: true });
	_static.merge = _static.contains = _static.root = _static.parseHTML = _static.text = _static.xml = _static.html = void 0;
	var domutils_1 = /*@__PURE__*/ requireLib$A();
	var options_js_1 = __importStar(requireOptions$5());
	/**
	 * Helper function to render a DOM.
	 *
	 * @param that - Cheerio instance to render.
	 * @param dom - The DOM to render. Defaults to `that`'s root.
	 * @param options - Options for rendering.
	 * @returns The rendered document.
	 */
	function render(that, dom, options) {
	    if (!that)
	        return '';
	    return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, undefined, options).toString();
	}
	/**
	 * Checks if a passed object is an options object.
	 *
	 * @param dom - Object to check if it is an options object.
	 * @returns Whether the object is an options object.
	 */
	function isOptions(dom, options) {
	    return (typeof dom === 'object' &&
	        dom != null &&
	        !('length' in dom) &&
	        !('type' in dom));
	}
	function html(dom, options) {
	    /*
	     * Be flexible about parameters, sometimes we call html(),
	     * with options as only parameter
	     * check dom argument for dom element specific properties
	     * assume there is no 'length' or 'type' properties in the options object
	     */
	    var toRender = isOptions(dom) ? ((options = dom), undefined) : dom;
	    /*
	     * Sometimes `$.html()` is used without preloading html,
	     * so fallback non-existing options to the default ones.
	     */
	    var opts = __assign(__assign(__assign({}, options_js_1.default), this === null || this === void 0 ? void 0 : this._options), (0, options_js_1.flatten)(options !== null && options !== void 0 ? options : {}));
	    return render(this, toRender, opts);
	}
	_static.html = html;
	/**
	 * Render the document as XML.
	 *
	 * @param dom - Element to render.
	 * @returns THe rendered document.
	 */
	function xml(dom) {
	    var options = __assign(__assign({}, this._options), { xmlMode: true });
	    return render(this, dom, options);
	}
	_static.xml = xml;
	/**
	 * Render the document as text.
	 *
	 * This returns the `textContent` of the passed elements. The result will
	 * include the contents of `script` and `stype` elements. To avoid this, use
	 * `.prop('innerText')` instead.
	 *
	 * @param elements - Elements to render.
	 * @returns The rendered document.
	 */
	function text(elements) {
	    var elems = elements ? elements : this ? this.root() : [];
	    var ret = '';
	    for (var i = 0; i < elems.length; i++) {
	        ret += (0, domutils_1.textContent)(elems[i]);
	    }
	    return ret;
	}
	_static.text = text;
	function parseHTML(data, context, keepScripts) {
	    if (keepScripts === void 0) { keepScripts = typeof context === 'boolean' ? context : false; }
	    if (!data || typeof data !== 'string') {
	        return null;
	    }
	    if (typeof context === 'boolean') {
	        keepScripts = context;
	    }
	    var parsed = this.load(data, options_js_1.default, false);
	    if (!keepScripts) {
	        parsed('script').remove();
	    }
	    /*
	     * The `children` array is used by Cheerio internally to group elements that
	     * share the same parents. When nodes created through `parseHTML` are
	     * inserted into previously-existing DOM structures, they will be removed
	     * from the `children` array. The results of `parseHTML` should remain
	     * constant across these operations, so a shallow copy should be returned.
	     */
	    return parsed.root()[0].children.slice();
	}
	_static.parseHTML = parseHTML;
	/**
	 * Sometimes you need to work with the top-level root element. To query it, you
	 * can use `$.root()`.
	 *
	 * @example
	 *
	 * ```js
	 * $.root().append('<ul id="vegetables"></ul>').html();
	 * //=> <ul id="fruits">...</ul><ul id="vegetables"></ul>
	 * ```
	 *
	 * @returns Cheerio instance wrapping the root node.
	 * @alias Cheerio.root
	 */
	function root() {
	    return this(this._root);
	}
	_static.root = root;
	/**
	 * Checks to see if the `contained` DOM element is a descendant of the
	 * `container` DOM element.
	 *
	 * @param container - Potential parent node.
	 * @param contained - Potential child node.
	 * @returns Indicates if the nodes contain one another.
	 * @alias Cheerio.contains
	 * @see {@link https://api.jquery.com/jQuery.contains/}
	 */
	function contains(container, contained) {
	    // According to the jQuery API, an element does not "contain" itself
	    if (contained === container) {
	        return false;
	    }
	    /*
	     * Step up the descendants, stopping when the root element is reached
	     * (signaled by `.parent` returning a reference to the same object)
	     */
	    var next = contained;
	    while (next && next !== next.parent) {
	        next = next.parent;
	        if (next === container) {
	            return true;
	        }
	    }
	    return false;
	}
	_static.contains = contains;
	/**
	 * $.merge().
	 *
	 * @param arr1 - First array.
	 * @param arr2 - Second array.
	 * @returns `arr1`, with elements of `arr2` inserted.
	 * @alias Cheerio.merge
	 * @see {@link https://api.jquery.com/jQuery.merge/}
	 */
	function merge(arr1, arr2) {
	    if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
	        return;
	    }
	    var newLength = arr1.length;
	    var len = +arr2.length;
	    for (var i = 0; i < len; i++) {
	        arr1[newLength++] = arr2[i];
	    }
	    arr1.length = newLength;
	    return arr1;
	}
	_static.merge = merge;
	/**
	 * Checks if an object is array-like.
	 *
	 * @param item - Item to check.
	 * @returns Indicates if the item is array-like.
	 */
	function isArrayLike(item) {
	    if (Array.isArray(item)) {
	        return true;
	    }
	    if (typeof item !== 'object' ||
	        !Object.prototype.hasOwnProperty.call(item, 'length') ||
	        typeof item.length !== 'number' ||
	        item.length < 0) {
	        return false;
	    }
	    for (var i = 0; i < item.length; i++) {
	        if (!(i in item)) {
	            return false;
	        }
	    }
	    return true;
	}
	
	return _static;
}

var cheerio = {};

var attributes$1 = {};

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.isHtml = exports$1.cloneDom = exports$1.domEach = exports$1.cssCase = exports$1.camelCase = exports$1.isCheerio = exports$1.isTag = void 0;
		var domhandler_1 = /*@__PURE__*/ requireLib$B();
		/**
		 * Check if the DOM element is a tag.
		 *
		 * `isTag(type)` includes `<script>` and `<style>` tags.
		 *
		 * @private
		 * @category Utils
		 * @param type - The DOM node to check.
		 * @returns Whether the node is a tag.
		 */
		var domhandler_2 = /*@__PURE__*/ requireLib$B();
		Object.defineProperty(exports$1, "isTag", { enumerable: true, get: function () { return domhandler_2.isTag; } });
		/**
		 * Checks if an object is a Cheerio instance.
		 *
		 * @category Utils
		 * @param maybeCheerio - The object to check.
		 * @returns Whether the object is a Cheerio instance.
		 */
		function isCheerio(maybeCheerio) {
		    return maybeCheerio.cheerio != null;
		}
		exports$1.isCheerio = isCheerio;
		/**
		 * Convert a string to camel case notation.
		 *
		 * @private
		 * @category Utils
		 * @param str - The string to be converted.
		 * @returns String in camel case notation.
		 */
		function camelCase(str) {
		    return str.replace(/[_.-](\w|$)/g, function (_, x) { return x.toUpperCase(); });
		}
		exports$1.camelCase = camelCase;
		/**
		 * Convert a string from camel case to "CSS case", where word boundaries are
		 * described by hyphens ("-") and all characters are lower-case.
		 *
		 * @private
		 * @category Utils
		 * @param str - The string to be converted.
		 * @returns String in "CSS case".
		 */
		function cssCase(str) {
		    return str.replace(/[A-Z]/g, '-$&').toLowerCase();
		}
		exports$1.cssCase = cssCase;
		/**
		 * Iterate over each DOM element without creating intermediary Cheerio instances.
		 *
		 * This is indented for use internally to avoid otherwise unnecessary memory
		 * pressure introduced by _make.
		 *
		 * @category Utils
		 * @param array - The array to iterate over.
		 * @param fn - Function to call.
		 * @returns The original instance.
		 */
		function domEach(array, fn) {
		    var len = array.length;
		    for (var i = 0; i < len; i++)
		        fn(array[i], i);
		    return array;
		}
		exports$1.domEach = domEach;
		/**
		 * Create a deep copy of the given DOM structure. Sets the parents of the copies
		 * of the passed nodes to `null`.
		 *
		 * @private
		 * @category Utils
		 * @param dom - The domhandler-compliant DOM structure.
		 * @returns - The cloned DOM.
		 */
		function cloneDom(dom) {
		    var clone = 'length' in dom
		        ? Array.prototype.map.call(dom, function (el) { return (0, domhandler_1.cloneNode)(el, true); })
		        : [(0, domhandler_1.cloneNode)(dom, true)];
		    // Add a root node around the cloned nodes
		    var root = new domhandler_1.Document(clone);
		    clone.forEach(function (node) {
		        node.parent = root;
		    });
		    return clone;
		}
		exports$1.cloneDom = cloneDom;
		var CharacterCodes;
		(function (CharacterCodes) {
		    CharacterCodes[CharacterCodes["LowerA"] = 97] = "LowerA";
		    CharacterCodes[CharacterCodes["LowerZ"] = 122] = "LowerZ";
		    CharacterCodes[CharacterCodes["UpperA"] = 65] = "UpperA";
		    CharacterCodes[CharacterCodes["UpperZ"] = 90] = "UpperZ";
		    CharacterCodes[CharacterCodes["Exclamation"] = 33] = "Exclamation";
		})(CharacterCodes || (CharacterCodes = {}));
		/**
		 * Check if string is HTML.
		 *
		 * Tests for a `<` within a string, immediate followed by a letter and
		 * eventually followed by a `>`.
		 *
		 * @private
		 * @category Utils
		 * @param str - The string to check.
		 * @returns Indicates if `str` is HTML.
		 */
		function isHtml(str) {
		    var tagStart = str.indexOf('<');
		    if (tagStart < 0 || tagStart > str.length - 3)
		        return false;
		    var tagChar = str.charCodeAt(tagStart + 1);
		    return (((tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ) ||
		        (tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ) ||
		        tagChar === CharacterCodes.Exclamation) &&
		        str.includes('>', tagStart + 2));
		}
		exports$1.isHtml = isHtml;
		
	} (utils$2));
	return utils$2;
}

var hasRequiredAttributes$1;

function requireAttributes$1 () {
	if (hasRequiredAttributes$1) return attributes$1;
	hasRequiredAttributes$1 = 1;
	/**
	 * Methods for getting and modifying attributes.
	 *
	 * @module cheerio/attributes
	 */
	Object.defineProperty(attributes$1, "__esModule", { value: true });
	attributes$1.toggleClass = attributes$1.removeClass = attributes$1.addClass = attributes$1.hasClass = attributes$1.removeAttr = attributes$1.val = attributes$1.data = attributes$1.prop = attributes$1.attr = void 0;
	var static_js_1 = require_static();
	var utils_js_1 = requireUtils$2();
	var domutils_1 = /*@__PURE__*/ requireLib$A();
	var hasOwn = Object.prototype.hasOwnProperty;
	var rspace = /\s+/;
	var dataAttrPrefix = 'data-';
	/*
	 * Lookup table for coercing string data-* attributes to their corresponding
	 * JavaScript primitives
	 */
	var primitives = {
	    null: null,
	    true: true,
	    false: false,
	};
	// Attributes that are booleans
	var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
	// Matches strings that look like JSON objects or arrays
	var rbrace = /^{[^]*}$|^\[[^]*]$/;
	function getAttr(elem, name, xmlMode) {
	    var _a;
	    if (!elem || !(0, utils_js_1.isTag)(elem))
	        return undefined;
	    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});
	    // Return the entire attribs object if no attribute specified
	    if (!name) {
	        return elem.attribs;
	    }
	    if (hasOwn.call(elem.attribs, name)) {
	        // Get the (decoded) attribute
	        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
	    }
	    // Mimic the DOM and return text content as value for `option's`
	    if (elem.name === 'option' && name === 'value') {
	        return (0, static_js_1.text)(elem.children);
	    }
	    // Mimic DOM with default value for radios/checkboxes
	    if (elem.name === 'input' &&
	        (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') &&
	        name === 'value') {
	        return 'on';
	    }
	    return undefined;
	}
	/**
	 * Sets the value of an attribute. The attribute will be deleted if the value is `null`.
	 *
	 * @private
	 * @param el - The element to set the attribute on.
	 * @param name - The attribute's name.
	 * @param value - The attribute's value.
	 */
	function setAttr(el, name, value) {
	    if (value === null) {
	        removeAttribute(el, name);
	    }
	    else {
	        el.attribs[name] = "".concat(value);
	    }
	}
	function attr(name, value) {
	    // Set the value (with attr map support)
	    if (typeof name === 'object' || value !== undefined) {
	        if (typeof value === 'function') {
	            if (typeof name !== 'string') {
	                {
	                    throw new Error('Bad combination of arguments.');
	                }
	            }
	            return (0, utils_js_1.domEach)(this, function (el, i) {
	                if ((0, utils_js_1.isTag)(el))
	                    setAttr(el, name, value.call(el, i, el.attribs[name]));
	            });
	        }
	        return (0, utils_js_1.domEach)(this, function (el) {
	            if (!(0, utils_js_1.isTag)(el))
	                return;
	            if (typeof name === 'object') {
	                Object.keys(name).forEach(function (objName) {
	                    var objValue = name[objName];
	                    setAttr(el, objName, objValue);
	                });
	            }
	            else {
	                setAttr(el, name, value);
	            }
	        });
	    }
	    return arguments.length > 1
	        ? this
	        : getAttr(this[0], name, this.options.xmlMode);
	}
	attributes$1.attr = attr;
	/**
	 * Gets a node's prop.
	 *
	 * @private
	 * @category Attributes
	 * @param el - Element to get the prop of.
	 * @param name - Name of the prop.
	 * @returns The prop's value.
	 */
	function getProp(el, name, xmlMode) {
	    return name in el
	        ? // @ts-expect-error TS doesn't like us accessing the value directly here.
	            el[name]
	        : !xmlMode && rboolean.test(name)
	            ? getAttr(el, name, false) !== undefined
	            : getAttr(el, name, xmlMode);
	}
	/**
	 * Sets the value of a prop.
	 *
	 * @private
	 * @param el - The element to set the prop on.
	 * @param name - The prop's name.
	 * @param value - The prop's value.
	 */
	function setProp(el, name, value, xmlMode) {
	    if (name in el) {
	        // @ts-expect-error Overriding value
	        el[name] = value;
	    }
	    else {
	        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : "".concat(value));
	    }
	}
	function prop(name, value) {
	    var _this = this;
	    var _a;
	    if (typeof name === 'string' && value === undefined) {
	        var el = this[0];
	        if (!el || !(0, utils_js_1.isTag)(el))
	            return undefined;
	        switch (name) {
	            case 'style': {
	                var property_1 = this.css();
	                var keys = Object.keys(property_1);
	                keys.forEach(function (p, i) {
	                    property_1[i] = p;
	                });
	                property_1.length = keys.length;
	                return property_1;
	            }
	            case 'tagName':
	            case 'nodeName': {
	                return el.name.toUpperCase();
	            }
	            case 'href':
	            case 'src': {
	                var prop_1 = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];
	                /* eslint-disable node/no-unsupported-features/node-builtins */
	                if (typeof URL !== 'undefined' &&
	                    ((name === 'href' && (el.tagName === 'a' || el.name === 'link')) ||
	                        (name === 'src' &&
	                            (el.tagName === 'img' ||
	                                el.tagName === 'iframe' ||
	                                el.tagName === 'audio' ||
	                                el.tagName === 'video' ||
	                                el.tagName === 'source'))) &&
	                    prop_1 !== undefined &&
	                    this.options.baseURI) {
	                    return new URL(prop_1, this.options.baseURI).href;
	                }
	                /* eslint-enable node/no-unsupported-features/node-builtins */
	                return prop_1;
	            }
	            case 'innerText': {
	                return (0, domutils_1.innerText)(el);
	            }
	            case 'textContent': {
	                return (0, domutils_1.textContent)(el);
	            }
	            case 'outerHTML':
	                return this.clone().wrap('<container />').parent().html();
	            case 'innerHTML':
	                return this.html();
	            default:
	                return getProp(el, name, this.options.xmlMode);
	        }
	    }
	    if (typeof name === 'object' || value !== undefined) {
	        if (typeof value === 'function') {
	            if (typeof name === 'object') {
	                throw new Error('Bad combination of arguments.');
	            }
	            return (0, utils_js_1.domEach)(this, function (el, i) {
	                if ((0, utils_js_1.isTag)(el)) {
	                    setProp(el, name, value.call(el, i, getProp(el, name, _this.options.xmlMode)), _this.options.xmlMode);
	                }
	            });
	        }
	        return (0, utils_js_1.domEach)(this, function (el) {
	            if (!(0, utils_js_1.isTag)(el))
	                return;
	            if (typeof name === 'object') {
	                Object.keys(name).forEach(function (key) {
	                    var val = name[key];
	                    setProp(el, key, val, _this.options.xmlMode);
	                });
	            }
	            else {
	                setProp(el, name, value, _this.options.xmlMode);
	            }
	        });
	    }
	    return undefined;
	}
	attributes$1.prop = prop;
	/**
	 * Sets the value of a data attribute.
	 *
	 * @private
	 * @param el - The element to set the data attribute on.
	 * @param name - The data attribute's name.
	 * @param value - The data attribute's value.
	 */
	function setData(el, name, value) {
	    var _a;
	    var elem = el;
	    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});
	    if (typeof name === 'object')
	        Object.assign(elem.data, name);
	    else if (typeof name === 'string' && value !== undefined) {
	        elem.data[name] = value;
	    }
	}
	/**
	 * Read the specified attribute from the equivalent HTML5 `data-*` attribute,
	 * and (if present) cache the value in the node's internal data store. If no
	 * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.
	 *
	 * @private
	 * @category Attributes
	 * @param el - Element to get the data attribute of.
	 * @param name - Name of the data attribute.
	 * @returns The data attribute's value, or a map with all of the data attributes.
	 */
	function readData(el, name) {
	    var domNames;
	    var jsNames;
	    var value;
	    if (name == null) {
	        domNames = Object.keys(el.attribs).filter(function (attrName) {
	            return attrName.startsWith(dataAttrPrefix);
	        });
	        jsNames = domNames.map(function (domName) {
	            return (0, utils_js_1.camelCase)(domName.slice(dataAttrPrefix.length));
	        });
	    }
	    else {
	        domNames = [dataAttrPrefix + (0, utils_js_1.cssCase)(name)];
	        jsNames = [name];
	    }
	    for (var idx = 0; idx < domNames.length; ++idx) {
	        var domName = domNames[idx];
	        var jsName = jsNames[idx];
	        if (hasOwn.call(el.attribs, domName) &&
	            !hasOwn.call(el.data, jsName)) {
	            value = el.attribs[domName];
	            if (hasOwn.call(primitives, value)) {
	                value = primitives[value];
	            }
	            else if (value === String(Number(value))) {
	                value = Number(value);
	            }
	            else if (rbrace.test(value)) {
	                try {
	                    value = JSON.parse(value);
	                }
	                catch (e) {
	                    /* Ignore */
	                }
	            }
	            el.data[jsName] = value;
	        }
	    }
	    return name == null ? el.data : value;
	}
	function data(name, value) {
	    var _a;
	    var elem = this[0];
	    if (!elem || !(0, utils_js_1.isTag)(elem))
	        return;
	    var dataEl = elem;
	    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});
	    // Return the entire data object if no data specified
	    if (!name) {
	        return readData(dataEl);
	    }
	    // Set the value (with attr map support)
	    if (typeof name === 'object' || value !== undefined) {
	        (0, utils_js_1.domEach)(this, function (el) {
	            if ((0, utils_js_1.isTag)(el)) {
	                if (typeof name === 'object')
	                    setData(el, name);
	                else
	                    setData(el, name, value);
	            }
	        });
	        return this;
	    }
	    if (hasOwn.call(dataEl.data, name)) {
	        return dataEl.data[name];
	    }
	    return readData(dataEl, name);
	}
	attributes$1.data = data;
	function val(value) {
	    var querying = arguments.length === 0;
	    var element = this[0];
	    if (!element || !(0, utils_js_1.isTag)(element))
	        return querying ? undefined : this;
	    switch (element.name) {
	        case 'textarea':
	            return this.text(value);
	        case 'select': {
	            var option = this.find('option:selected');
	            if (!querying) {
	                if (this.attr('multiple') == null && typeof value === 'object') {
	                    return this;
	                }
	                this.find('option').removeAttr('selected');
	                var values = typeof value !== 'object' ? [value] : value;
	                for (var i = 0; i < values.length; i++) {
	                    this.find("option[value=\"".concat(values[i], "\"]")).attr('selected', '');
	                }
	                return this;
	            }
	            return this.attr('multiple')
	                ? option.toArray().map(function (el) { return (0, static_js_1.text)(el.children); })
	                : option.attr('value');
	        }
	        case 'input':
	        case 'option':
	            return querying
	                ? this.attr('value')
	                : this.attr('value', value);
	    }
	    return undefined;
	}
	attributes$1.val = val;
	/**
	 * Remove an attribute.
	 *
	 * @private
	 * @param elem - Node to remove attribute from.
	 * @param name - Name of the attribute to remove.
	 */
	function removeAttribute(elem, name) {
	    if (!elem.attribs || !hasOwn.call(elem.attribs, name))
	        return;
	    delete elem.attribs[name];
	}
	/**
	 * Splits a space-separated list of names to individual names.
	 *
	 * @category Attributes
	 * @param names - Names to split.
	 * @returns - Split names.
	 */
	function splitNames(names) {
	    return names ? names.trim().split(rspace) : [];
	}
	/**
	 * Method for removing attributes by `name`.
	 *
	 * @category Attributes
	 * @example
	 *
	 * ```js
	 * $('.pear').removeAttr('class').html();
	 * //=> <li>Pear</li>
	 *
	 * $('.apple').attr('id', 'favorite');
	 * $('.apple').removeAttr('id class').html();
	 * //=> <li>Apple</li>
	 * ```
	 *
	 * @param name - Name of the attribute.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/removeAttr/}
	 */
	function removeAttr(name) {
	    var attrNames = splitNames(name);
	    var _loop_1 = function (i) {
	        (0, utils_js_1.domEach)(this_1, function (elem) {
	            if ((0, utils_js_1.isTag)(elem))
	                removeAttribute(elem, attrNames[i]);
	        });
	    };
	    var this_1 = this;
	    for (var i = 0; i < attrNames.length; i++) {
	        _loop_1(i);
	    }
	    return this;
	}
	attributes$1.removeAttr = removeAttr;
	/**
	 * Check to see if _any_ of the matched elements have the given `className`.
	 *
	 * @category Attributes
	 * @example
	 *
	 * ```js
	 * $('.pear').hasClass('pear');
	 * //=> true
	 *
	 * $('apple').hasClass('fruit');
	 * //=> false
	 *
	 * $('li').hasClass('pear');
	 * //=> true
	 * ```
	 *
	 * @param className - Name of the class.
	 * @returns Indicates if an element has the given `className`.
	 * @see {@link https://api.jquery.com/hasClass/}
	 */
	function hasClass(className) {
	    return this.toArray().some(function (elem) {
	        var clazz = (0, utils_js_1.isTag)(elem) && elem.attribs['class'];
	        var idx = -1;
	        if (clazz && className.length) {
	            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
	                var end = idx + className.length;
	                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&
	                    (end === clazz.length || rspace.test(clazz[end]))) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    });
	}
	attributes$1.hasClass = hasClass;
	/**
	 * Adds class(es) to all of the matched elements. Also accepts a `function`.
	 *
	 * @category Attributes
	 * @example
	 *
	 * ```js
	 * $('.pear').addClass('fruit').html();
	 * //=> <li class="pear fruit">Pear</li>
	 *
	 * $('.apple').addClass('fruit red').html();
	 * //=> <li class="apple fruit red">Apple</li>
	 * ```
	 *
	 * @param value - Name of new class.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/addClass/}
	 */
	function addClass(value) {
	    // Support functions
	    if (typeof value === 'function') {
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            if ((0, utils_js_1.isTag)(el)) {
	                var className = el.attribs['class'] || '';
	                addClass.call([el], value.call(el, i, className));
	            }
	        });
	    }
	    // Return if no value or not a string or function
	    if (!value || typeof value !== 'string')
	        return this;
	    var classNames = value.split(rspace);
	    var numElements = this.length;
	    for (var i = 0; i < numElements; i++) {
	        var el = this[i];
	        // If selected element isn't a tag, move on
	        if (!(0, utils_js_1.isTag)(el))
	            continue;
	        // If we don't already have classes  always set xmlMode to false here, as it doesn't matter for classes
	        var className = getAttr(el, 'class', false);
	        if (!className) {
	            setAttr(el, 'class', classNames.join(' ').trim());
	        }
	        else {
	            var setClass = " ".concat(className, " ");
	            // Check if class already exists
	            for (var j = 0; j < classNames.length; j++) {
	                var appendClass = "".concat(classNames[j], " ");
	                if (!setClass.includes(" ".concat(appendClass)))
	                    setClass += appendClass;
	            }
	            setAttr(el, 'class', setClass.trim());
	        }
	    }
	    return this;
	}
	attributes$1.addClass = addClass;
	/**
	 * Removes one or more space-separated classes from the selected elements. If no
	 * `className` is defined, all classes will be removed. Also accepts a `function`.
	 *
	 * @category Attributes
	 * @example
	 *
	 * ```js
	 * $('.pear').removeClass('pear').html();
	 * //=> <li class="">Pear</li>
	 *
	 * $('.apple').addClass('red').removeClass().html();
	 * //=> <li class="">Apple</li>
	 * ```
	 *
	 * @param name - Name of the class. If not specified, removes all elements.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/removeClass/}
	 */
	function removeClass(name) {
	    // Handle if value is a function
	    if (typeof name === 'function') {
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            if ((0, utils_js_1.isTag)(el)) {
	                removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));
	            }
	        });
	    }
	    var classes = splitNames(name);
	    var numClasses = classes.length;
	    var removeAll = arguments.length === 0;
	    return (0, utils_js_1.domEach)(this, function (el) {
	        if (!(0, utils_js_1.isTag)(el))
	            return;
	        if (removeAll) {
	            // Short circuit the remove all case as this is the nice one
	            el.attribs['class'] = '';
	        }
	        else {
	            var elClasses = splitNames(el.attribs['class']);
	            var changed = false;
	            for (var j = 0; j < numClasses; j++) {
	                var index = elClasses.indexOf(classes[j]);
	                if (index >= 0) {
	                    elClasses.splice(index, 1);
	                    changed = true;
	                    /*
	                     * We have to do another pass to ensure that there are not duplicate
	                     * classes listed
	                     */
	                    j--;
	                }
	            }
	            if (changed) {
	                el.attribs['class'] = elClasses.join(' ');
	            }
	        }
	    });
	}
	attributes$1.removeClass = removeClass;
	/**
	 * Add or remove class(es) from the matched elements, depending on either the
	 * class's presence or the value of the switch argument. Also accepts a `function`.
	 *
	 * @category Attributes
	 * @example
	 *
	 * ```js
	 * $('.apple.green').toggleClass('fruit green red').html();
	 * //=> <li class="apple fruit red">Apple</li>
	 *
	 * $('.apple.green').toggleClass('fruit green red', true).html();
	 * //=> <li class="apple green fruit red">Apple</li>
	 * ```
	 *
	 * @param value - Name of the class. Can also be a function.
	 * @param stateVal - If specified the state of the class.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/toggleClass/}
	 */
	function toggleClass(value, stateVal) {
	    // Support functions
	    if (typeof value === 'function') {
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            if ((0, utils_js_1.isTag)(el)) {
	                toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);
	            }
	        });
	    }
	    // Return if no value or not a string or function
	    if (!value || typeof value !== 'string')
	        return this;
	    var classNames = value.split(rspace);
	    var numClasses = classNames.length;
	    var state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;
	    var numElements = this.length;
	    for (var i = 0; i < numElements; i++) {
	        var el = this[i];
	        // If selected element isn't a tag, move on
	        if (!(0, utils_js_1.isTag)(el))
	            continue;
	        var elementClasses = splitNames(el.attribs['class']);
	        // Check if class already exists
	        for (var j = 0; j < numClasses; j++) {
	            // Check if the class name is currently defined
	            var index = elementClasses.indexOf(classNames[j]);
	            // Add if stateValue === true or we are toggling and there is no value
	            if (state >= 0 && index < 0) {
	                elementClasses.push(classNames[j]);
	            }
	            else if (state <= 0 && index >= 0) {
	                // Otherwise remove but only if the item exists
	                elementClasses.splice(index, 1);
	            }
	        }
	        el.attribs['class'] = elementClasses.join(' ');
	    }
	    return this;
	}
	attributes$1.toggleClass = toggleClass;
	
	return attributes$1;
}

var traversing = {};

var lib$w = {};

var SelectorType;
(function (SelectorType) {
    SelectorType["Attribute"] = "attribute";
    SelectorType["Pseudo"] = "pseudo";
    SelectorType["PseudoElement"] = "pseudo-element";
    SelectorType["Tag"] = "tag";
    SelectorType["Universal"] = "universal";
    // Traversals
    SelectorType["Adjacent"] = "adjacent";
    SelectorType["Child"] = "child";
    SelectorType["Descendant"] = "descendant";
    SelectorType["Parent"] = "parent";
    SelectorType["Sibling"] = "sibling";
    SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false,
};
var AttributeAction;
(function (AttributeAction) {
    AttributeAction["Any"] = "any";
    AttributeAction["Element"] = "element";
    AttributeAction["End"] = "end";
    AttributeAction["Equals"] = "equals";
    AttributeAction["Exists"] = "exists";
    AttributeAction["Hyphen"] = "hyphen";
    AttributeAction["Not"] = "not";
    AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([
    [126 /* Tilde */, AttributeAction.Element],
    [94 /* Circumflex */, AttributeAction.Start],
    [36 /* Dollar */, AttributeAction.End],
    [42 /* Asterisk */, AttributeAction.Any],
    [33 /* ExclamationMark */, AttributeAction.Not],
    [124 /* Pipe */, AttributeAction.Hyphen],
]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    switch (selector.type) {
        case SelectorType.Adjacent:
        case SelectorType.Child:
        case SelectorType.Descendant:
        case SelectorType.Parent:
        case SelectorType.Sibling:
        case SelectorType.ColumnCombinator:
            return true;
        default:
            return false;
    }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    const high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isQuote(c) {
    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}
function isWhitespace(c) {
    return (c === 32 /* Space */ ||
        c === 9 /* Tab */ ||
        c === 10 /* NewLine */ ||
        c === 12 /* FormFeed */ ||
        c === 13 /* CarriageReturn */);
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$3(selector) {
    const subselects = [];
    const endIndex = parseSelector(subselects, `${selector}`, 0);
    if (endIndex < selector.length) {
        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
    }
    return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
    let tokens = [];
    function getName(offset) {
        const match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
        }
        const [name] = match;
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))) {
            selectorIndex++;
        }
    }
    function readValueWithParenthesis() {
        selectorIndex += 1;
        const start = selectorIndex;
        let counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
            if (selector.charCodeAt(selectorIndex) ===
                40 /* LeftParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter++;
            }
            else if (selector.charCodeAt(selectorIndex) ===
                41 /* RightParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter--;
            }
        }
        if (counter) {
            throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
        let slashCount = 0;
        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    function addTraversal(type) {
        if (tokens.length > 0 &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens[tokens.length - 1].type = type;
            return;
        }
        ensureNotTraversal();
        tokens.push({ type });
    }
    function addSpecialAttribute(name, action) {
        tokens.push({
            type: SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
        });
    }
    /**
     * We have finished parsing the current part of the selector.
     *
     * Remove descendant tokens at the end if they exist,
     * and return the last index, so that parsing can be
     * picked up from here.
     */
    function finalizeSubselector() {
        if (tokens.length &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens.pop();
        }
        if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
        return selectorIndex;
    }
    loop: while (selectorIndex < selector.length) {
        const firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
            case 10 /* NewLine */:
            case 12 /* FormFeed */:
            case 13 /* CarriageReturn */: {
                if (tokens.length === 0 ||
                    tokens[0].type !== SelectorType.Descendant) {
                    ensureNotTraversal();
                    tokens.push({ type: SelectorType.Descendant });
                }
                stripWhitespace(1);
                break;
            }
            // Traversals
            case 62 /* GreaterThan */: {
                addTraversal(SelectorType.Child);
                stripWhitespace(1);
                break;
            }
            case 60 /* LessThan */: {
                addTraversal(SelectorType.Parent);
                stripWhitespace(1);
                break;
            }
            case 126 /* Tilde */: {
                addTraversal(SelectorType.Sibling);
                stripWhitespace(1);
                break;
            }
            case 43 /* Plus */: {
                addTraversal(SelectorType.Adjacent);
                stripWhitespace(1);
                break;
            }
            // Special attribute selectors: .class, #id
            case 46 /* Period */: {
                addSpecialAttribute("class", AttributeAction.Element);
                break;
            }
            case 35 /* Hash */: {
                addSpecialAttribute("id", AttributeAction.Equals);
                break;
            }
            case 91 /* LeftSquareBracket */: {
                stripWhitespace(1);
                // Determine attribute name and namespace
                let name;
                let namespace = null;
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                    // Equivalent to no namespace
                    name = getName(1);
                }
                else if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    name = getName(2);
                }
                else {
                    name = getName(0);
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                        selector.charCodeAt(selectorIndex + 1) !==
                            61 /* Equal */) {
                        namespace = name;
                        name = getName(1);
                    }
                }
                stripWhitespace(0);
                // Determine comparison operation
                let action = AttributeAction.Exists;
                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charCodeAt(selectorIndex + 1) !==
                        61 /* Equal */) {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                    action = AttributeAction.Equals;
                    stripWhitespace(1);
                }
                // Determine value
                let value = "";
                let ignoreCase = null;
                if (action !== "exists") {
                    if (isQuote(selector.charCodeAt(selectorIndex))) {
                        const quote = selector.charCodeAt(selectorIndex);
                        let sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charCodeAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charCodeAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        const valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                selector.charCodeAt(selectorIndex) !==
                                    93 /* RightSquareBracket */) ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === 115 /* LowerS */) {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === 105 /* LowerI */) {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                if (selector.charCodeAt(selectorIndex) !==
                    93 /* RightSquareBracket */) {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                const attributeSelector = {
                    type: SelectorType.Attribute,
                    name,
                    action,
                    value,
                    namespace,
                    ignoreCase,
                };
                tokens.push(attributeSelector);
                break;
            }
            case 58 /* Colon */: {
                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                    tokens.push({
                        type: SelectorType.PseudoElement,
                        name: getName(2).toLowerCase(),
                        data: selector.charCodeAt(selectorIndex) ===
                            40 /* LeftParenthesis */
                            ? readValueWithParenthesis()
                            : null,
                    });
                    continue;
                }
                const name = getName(1).toLowerCase();
                let data = null;
                if (selector.charCodeAt(selectorIndex) ===
                    40 /* LeftParenthesis */) {
                    if (unpackPseudos.has(name)) {
                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                        if (selector.charCodeAt(selectorIndex) !==
                            41 /* RightParenthesis */) {
                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                        }
                        selectorIndex += 1;
                    }
                    else {
                        data = readValueWithParenthesis();
                        if (stripQuotesFromPseudos.has(name)) {
                            const quot = data.charCodeAt(0);
                            if (quot === data.charCodeAt(data.length - 1) &&
                                isQuote(quot)) {
                                data = data.slice(1, -1);
                            }
                        }
                        data = unescapeCSS(data);
                    }
                }
                tokens.push({ type: SelectorType.Pseudo, name, data });
                break;
            }
            case 44 /* Comma */: {
                finalizeSubselector();
                tokens = [];
                stripWhitespace(1);
                break;
            }
            default: {
                if (selector.startsWith("/*", selectorIndex)) {
                    const endIndex = selector.indexOf("*/", selectorIndex + 2);
                    if (endIndex < 0) {
                        throw new Error("Comment was not terminated");
                    }
                    selectorIndex = endIndex + 2;
                    // Remove leading whitespace
                    if (tokens.length === 0) {
                        stripWhitespace(0);
                    }
                    break;
                }
                let namespace = null;
                let name;
                if (firstChar === 42 /* Asterisk */) {
                    selectorIndex += 1;
                    name = "*";
                }
                else if (firstChar === 124 /* Pipe */) {
                    name = "";
                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                        addTraversal(SelectorType.ColumnCombinator);
                        stripWhitespace(2);
                        break;
                    }
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    name = getName(0);
                }
                else {
                    break loop;
                }
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                    namespace = name;
                    if (selector.charCodeAt(selectorIndex + 1) ===
                        42 /* Asterisk */) {
                        name = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name = getName(1);
                    }
                }
                tokens.push(name === "*"
                    ? { type: SelectorType.Universal, namespace }
                    : { type: SelectorType.Tag, name, namespace });
            }
        }
    }
    finalizeSubselector();
    return selectorIndex;
}

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInName = new Set([
    ...pseudoValChars,
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    ".",
].map((c) => c.charCodeAt(0)));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify$1(selector) {
    return selector
        .map((token) => token.map(stringifyToken).join(""))
        .join(", ");
}
function stringifyToken(token, index, arr) {
    switch (token.type) {
        // Simple types
        case SelectorType.Child:
            return index === 0 ? "> " : " > ";
        case SelectorType.Parent:
            return index === 0 ? "< " : " < ";
        case SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
        case SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
        case SelectorType.Descendant:
            return " ";
        case SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
        case SelectorType.Universal:
            // Return an empty string if the selector isn't needed.
            return token.namespace === "*" &&
                index + 1 < arr.length &&
                "name" in arr[index + 1]
                ? ""
                : `${getNamespace(token.namespace)}*`;
        case SelectorType.Tag:
            return getNamespacedName(token);
        case SelectorType.PseudoElement:
            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
        case SelectorType.Pseudo:
            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${typeof token.data === "string"
                    ? escapeName(token.data, charsToEscapeInPseudoValue)
                    : stringify$1(token.data)})`}`;
        case SelectorType.Attribute: {
            if (token.name === "id" &&
                token.action === AttributeAction.Equals &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `#${escapeName(token.value, charsToEscapeInName)}`;
            }
            if (token.name === "class" &&
                token.action === AttributeAction.Element &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `.${escapeName(token.value, charsToEscapeInName)}`;
            }
            const name = getNamespacedName(token);
            if (token.action === AttributeAction.Exists) {
                return `[${name}]`;
            }
            return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
        }
    }
}
function getActionValue(action) {
    switch (action) {
        case AttributeAction.Equals:
            return "";
        case AttributeAction.Element:
            return "~";
        case AttributeAction.Start:
            return "^";
        case AttributeAction.End:
            return "$";
        case AttributeAction.Any:
            return "*";
        case AttributeAction.Not:
            return "!";
        case AttributeAction.Hyphen:
            return "|";
        case AttributeAction.Exists:
            throw new Error("Shouldn't be here");
    }
}
function getNamespacedName(token) {
    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
    return namespace !== null
        ? `${namespace === "*"
            ? "*"
            : escapeName(namespace, charsToEscapeInName)}|`
        : "";
}
function escapeName(str, charsToEscape) {
    let lastIdx = 0;
    let ret = "";
    for (let i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
            ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
            lastIdx = i + 1;
        }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

const es = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  get AttributeAction () { return AttributeAction; },
  IgnoreCaseMode,
  get SelectorType () { return SelectorType; },
  isTraversal,
  parse: parse$3,
  stringify: stringify$1
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(es);

var lib$v = {};

var boolbase;
var hasRequiredBoolbase;

function requireBoolbase () {
	if (hasRequiredBoolbase) return boolbase;
	hasRequiredBoolbase = 1;
	boolbase = {
		trueFunc: function trueFunc(){
			return true;
		},
		falseFunc: function falseFunc(){
			return false;
		}
	};
	return boolbase;
}

var compile$1 = {};

var sort = {};

var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort;
	hasRequiredSort = 1;
	Object.defineProperty(sort, "__esModule", { value: true });
	sort.isTraversal = void 0;
	var css_what_1 = require$$0;
	var procedure = new Map([
	    [css_what_1.SelectorType.Universal, 50],
	    [css_what_1.SelectorType.Tag, 30],
	    [css_what_1.SelectorType.Attribute, 1],
	    [css_what_1.SelectorType.Pseudo, 0],
	]);
	function isTraversal(token) {
	    return !procedure.has(token.type);
	}
	sort.isTraversal = isTraversal;
	var attributes = new Map([
	    [css_what_1.AttributeAction.Exists, 10],
	    [css_what_1.AttributeAction.Equals, 8],
	    [css_what_1.AttributeAction.Not, 7],
	    [css_what_1.AttributeAction.Start, 6],
	    [css_what_1.AttributeAction.End, 6],
	    [css_what_1.AttributeAction.Any, 5],
	]);
	/**
	 * Sort the parts of the passed selector,
	 * as there is potential for optimization
	 * (some types of selectors are faster than others)
	 *
	 * @param arr Selector to sort
	 */
	function sortByProcedure(arr) {
	    var procs = arr.map(getProcedure);
	    for (var i = 1; i < arr.length; i++) {
	        var procNew = procs[i];
	        if (procNew < 0)
	            continue;
	        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
	            var token = arr[j + 1];
	            arr[j + 1] = arr[j];
	            arr[j] = token;
	            procs[j + 1] = procs[j];
	            procs[j] = procNew;
	        }
	    }
	}
	sort.default = sortByProcedure;
	function getProcedure(token) {
	    var _a, _b;
	    var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
	    if (token.type === css_what_1.SelectorType.Attribute) {
	        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
	        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
	            // Prefer ID selectors (eg. #ID)
	            proc = 9;
	        }
	        if (token.ignoreCase) {
	            /*
	             * IgnoreCase adds some overhead, prefer "normal" token
	             * this is a binary operation, to ensure it's still an int
	             */
	            proc >>= 1;
	        }
	    }
	    else if (token.type === css_what_1.SelectorType.Pseudo) {
	        if (!token.data) {
	            proc = 3;
	        }
	        else if (token.name === "has" || token.name === "contains") {
	            proc = 0; // Expensive in any case
	        }
	        else if (Array.isArray(token.data)) {
	            // Eg. :matches, :not
	            proc = Math.min.apply(Math, token.data.map(function (d) { return Math.min.apply(Math, d.map(getProcedure)); }));
	            // If we have traversals, try to avoid executing this selector
	            if (proc < 0) {
	                proc = 0;
	            }
	        }
	        else {
	            proc = 2;
	        }
	    }
	    return proc;
	}
	
	return sort;
}

var general = {};

var attributes = {};

var hasRequiredAttributes;

function requireAttributes () {
	if (hasRequiredAttributes) return attributes;
	hasRequiredAttributes = 1;
	var __importDefault = (attributes && attributes.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(attributes, "__esModule", { value: true });
	attributes.attributeRules = void 0;
	var boolbase_1 = __importDefault(requireBoolbase());
	/**
	 * All reserved characters in a regex, used for escaping.
	 *
	 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
	 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
	 */
	var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
	function escapeRegex(value) {
	    return value.replace(reChars, "\\$&");
	}
	/**
	 * Attributes that are case-insensitive in HTML.
	 *
	 * @private
	 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
	 */
	var caseInsensitiveAttributes = new Set([
	    "accept",
	    "accept-charset",
	    "align",
	    "alink",
	    "axis",
	    "bgcolor",
	    "charset",
	    "checked",
	    "clear",
	    "codetype",
	    "color",
	    "compact",
	    "declare",
	    "defer",
	    "dir",
	    "direction",
	    "disabled",
	    "enctype",
	    "face",
	    "frame",
	    "hreflang",
	    "http-equiv",
	    "lang",
	    "language",
	    "link",
	    "media",
	    "method",
	    "multiple",
	    "nohref",
	    "noresize",
	    "noshade",
	    "nowrap",
	    "readonly",
	    "rel",
	    "rev",
	    "rules",
	    "scope",
	    "scrolling",
	    "selected",
	    "shape",
	    "target",
	    "text",
	    "type",
	    "valign",
	    "valuetype",
	    "vlink",
	]);
	function shouldIgnoreCase(selector, options) {
	    return typeof selector.ignoreCase === "boolean"
	        ? selector.ignoreCase
	        : selector.ignoreCase === "quirks"
	            ? !!options.quirksMode
	            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
	}
	/**
	 * Attribute selectors
	 */
	attributes.attributeRules = {
	    equals: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length === value.length &&
	                    attr.toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) === value && next(elem);
	        };
	    },
	    hyphen: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function hyphenIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    (attr.length === len || attr.charAt(len) === "-") &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function hyphen(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                (attr.length === len || attr.charAt(len) === "-") &&
	                attr.substr(0, len) === value &&
	                next(elem));
	        };
	    },
	    element: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (/\s/.test(value)) {
	            return boolbase_1.default.falseFunc;
	        }
	        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
	        return function element(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                attr.length >= value.length &&
	                regex.test(attr) &&
	                next(elem));
	        };
	    },
	    exists: function (next, _a, _b) {
	        var name = _a.name;
	        var adapter = _b.adapter;
	        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
	    },
	    start: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (len === 0) {
	            return boolbase_1.default.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= len &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
	                next(elem);
	        };
	    },
	    end: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = -value.length;
	        if (len === 0) {
	            return boolbase_1.default.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var _a;
	                return ((_a = adapter
	                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
	                next(elem);
	        };
	    },
	    any: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (value === "") {
	            return boolbase_1.default.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            var regex_1 = new RegExp(escapeRegex(value), "i");
	            return function anyIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= value.length &&
	                    regex_1.test(attr) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
	                next(elem);
	        };
	    },
	    not: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (value === "") {
	            return function (elem) {
	                return !!adapter.getAttributeValue(elem, name) && next(elem);
	            };
	        }
	        else if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return ((attr == null ||
	                    attr.length !== value.length ||
	                    attr.toLowerCase() !== value) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) !== value && next(elem);
	        };
	    },
	};
	
	return attributes;
}

var pseudoSelectors = {};

var filters = {};

var lib$u = {};

var parse$2 = {};

var hasRequiredParse$2;

function requireParse$2 () {
	if (hasRequiredParse$2) return parse$2;
	hasRequiredParse$2 = 1;
	// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
	Object.defineProperty(parse$2, "__esModule", { value: true });
	parse$2.parse = void 0;
	// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
	var whitespace = new Set([9, 10, 12, 13, 32]);
	var ZERO = "0".charCodeAt(0);
	var NINE = "9".charCodeAt(0);
	/**
	 * Parses an expression.
	 *
	 * @throws An `Error` if parsing fails.
	 * @returns An array containing the integer step size and the integer offset of the nth rule.
	 * @example nthCheck.parse("2n+3"); // returns [2, 3]
	 */
	function parse(formula) {
	    formula = formula.trim().toLowerCase();
	    if (formula === "even") {
	        return [2, 0];
	    }
	    else if (formula === "odd") {
	        return [2, 1];
	    }
	    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
	    var idx = 0;
	    var a = 0;
	    var sign = readSign();
	    var number = readNumber();
	    if (idx < formula.length && formula.charAt(idx) === "n") {
	        idx++;
	        a = sign * (number !== null && number !== void 0 ? number : 1);
	        skipWhitespace();
	        if (idx < formula.length) {
	            sign = readSign();
	            skipWhitespace();
	            number = readNumber();
	        }
	        else {
	            sign = number = 0;
	        }
	    }
	    // Throw if there is anything else
	    if (number === null || idx < formula.length) {
	        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
	    }
	    return [a, sign * number];
	    function readSign() {
	        if (formula.charAt(idx) === "-") {
	            idx++;
	            return -1;
	        }
	        if (formula.charAt(idx) === "+") {
	            idx++;
	        }
	        return 1;
	    }
	    function readNumber() {
	        var start = idx;
	        var value = 0;
	        while (idx < formula.length &&
	            formula.charCodeAt(idx) >= ZERO &&
	            formula.charCodeAt(idx) <= NINE) {
	            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
	            idx++;
	        }
	        // Return `null` if we didn't read anything.
	        return idx === start ? null : value;
	    }
	    function skipWhitespace() {
	        while (idx < formula.length &&
	            whitespace.has(formula.charCodeAt(idx))) {
	            idx++;
	        }
	    }
	}
	parse$2.parse = parse;
	
	return parse$2;
}

var compile = {};

var hasRequiredCompile$1;

function requireCompile$1 () {
	if (hasRequiredCompile$1) return compile;
	hasRequiredCompile$1 = 1;
	var __importDefault = (compile && compile.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.generate = compile.compile = void 0;
	var boolbase_1 = __importDefault(requireBoolbase());
	/**
	 * Returns a function that checks if an elements index matches the given rule
	 * highly optimized to return the fastest solution.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A highly optimized function that returns whether an index matches the nth-check.
	 * @example
	 *
	 * ```js
	 * const check = nthCheck.compile([2, 3]);
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 * ```
	 */
	function compile$1(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    /*
	     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
	     * Besides, the specification states that no elements are
	     * matched when `a` and `b` are 0.
	     *
	     * `b < 0` here as we subtracted 1 from `b` above.
	     */
	    if (b < 0 && a <= 0)
	        return boolbase_1.default.falseFunc;
	    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
	    if (a === -1)
	        return function (index) { return index <= b; };
	    if (a === 0)
	        return function (index) { return index === b; };
	    // When `b <= 0` and `a === 1`, they match any element.
	    if (a === 1)
	        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };
	    /*
	     * Otherwise, modulo can be used to check if there is a match.
	     *
	     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
	     */
	    var absA = Math.abs(a);
	    // Get `b mod a`, + a if this is negative.
	    var bMod = ((b % absA) + absA) % absA;
	    return a > 1
	        ? function (index) { return index >= b && index % absA === bMod; }
	        : function (index) { return index <= b && index % absA === bMod; };
	}
	compile.compile = compile$1;
	/**
	 * Returns a function that produces a monotonously increasing sequence of indices.
	 *
	 * If the sequence has an end, the returned function will return `null` after
	 * the last index in the sequence.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A function that produces a sequence of indices.
	 * @example <caption>Always increasing (2n+3)</caption>
	 *
	 * ```js
	 * const gen = nthCheck.generate([2, 3])
	 *
	 * gen() // `1`
	 * gen() // `3`
	 * gen() // `5`
	 * gen() // `8`
	 * gen() // `11`
	 * ```
	 *
	 * @example <caption>With end value (-2n+10)</caption>
	 *
	 * ```js
	 *
	 * const gen = nthCheck.generate([-2, 5]);
	 *
	 * gen() // 0
	 * gen() // 2
	 * gen() // 4
	 * gen() // null
	 * ```
	 */
	function generate(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    var n = 0;
	    // Make sure to always return an increasing sequence
	    if (a < 0) {
	        var aPos_1 = -a;
	        // Get `b mod a`
	        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
	        return function () {
	            var val = minValue_1 + aPos_1 * n++;
	            return val > b ? null : val;
	        };
	    }
	    if (a === 0)
	        return b < 0
	            ? // There are no result  always return `null`
	                function () { return null; }
	            : // Return `b` exactly once
	                function () { return (n++ === 0 ? b : null); };
	    if (b < 0) {
	        b += a * Math.ceil(-b / a);
	    }
	    return function () { return a * n++ + b; };
	}
	compile.generate = generate;
	
	return compile;
}

var hasRequiredLib$z;

function requireLib$z () {
	if (hasRequiredLib$z) return lib$u;
	hasRequiredLib$z = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.sequence = exports$1.generate = exports$1.compile = exports$1.parse = void 0;
		var parse_js_1 = /*@__PURE__*/ requireParse$2();
		Object.defineProperty(exports$1, "parse", { enumerable: true, get: function () { return parse_js_1.parse; } });
		var compile_js_1 = /*@__PURE__*/ requireCompile$1();
		Object.defineProperty(exports$1, "compile", { enumerable: true, get: function () { return compile_js_1.compile; } });
		Object.defineProperty(exports$1, "generate", { enumerable: true, get: function () { return compile_js_1.generate; } });
		/**
		 * Parses and compiles a formula to a highly optimized function.
		 * Combination of {@link parse} and {@link compile}.
		 *
		 * If the formula doesn't match any elements,
		 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
		 * Otherwise, a function accepting an _index_ is returned, which returns
		 * whether or not the passed _index_ matches the formula.
		 *
		 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
		 *
		 * @param formula The formula to compile.
		 * @example
		 * const check = nthCheck("2n+3");
		 *
		 * check(0); // `false`
		 * check(1); // `false`
		 * check(2); // `true`
		 * check(3); // `false`
		 * check(4); // `true`
		 * check(5); // `false`
		 * check(6); // `true`
		 */
		function nthCheck(formula) {
		    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
		}
		exports$1.default = nthCheck;
		/**
		 * Parses and compiles a formula to a generator that produces a sequence of indices.
		 * Combination of {@link parse} and {@link generate}.
		 *
		 * @param formula The formula to compile.
		 * @returns A function that produces a sequence of indices.
		 * @example <caption>Always increasing</caption>
		 *
		 * ```js
		 * const gen = nthCheck.sequence('2n+3')
		 *
		 * gen() // `1`
		 * gen() // `3`
		 * gen() // `5`
		 * gen() // `8`
		 * gen() // `11`
		 * ```
		 *
		 * @example <caption>With end value</caption>
		 *
		 * ```js
		 *
		 * const gen = nthCheck.sequence('-2n+5');
		 *
		 * gen() // 0
		 * gen() // 2
		 * gen() // 4
		 * gen() // null
		 * ```
		 */
		function sequence(formula) {
		    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
		}
		exports$1.sequence = sequence;
		
	} (lib$u));
	return lib$u;
}

var hasRequiredFilters;

function requireFilters () {
	if (hasRequiredFilters) return filters;
	hasRequiredFilters = 1;
	(function (exports$1) {
		var __importDefault = (filters && filters.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.filters = void 0;
		var nth_check_1 = __importDefault(/*@__PURE__*/ requireLib$z());
		var boolbase_1 = __importDefault(requireBoolbase());
		function getChildFunc(next, adapter) {
		    return function (elem) {
		        var parent = adapter.getParent(elem);
		        return parent != null && adapter.isTag(parent) && next(elem);
		    };
		}
		exports$1.filters = {
		    contains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        return function contains(elem) {
		            return next(elem) && adapter.getText(elem).includes(text);
		        };
		    },
		    icontains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        var itext = text.toLowerCase();
		        return function icontains(elem) {
		            return (next(elem) &&
		                adapter.getText(elem).toLowerCase().includes(itext));
		        };
		    },
		    // Location specific methods
		    "nth-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.default.falseFunc)
		            return boolbase_1.default.falseFunc;
		        if (func === boolbase_1.default.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.default.falseFunc)
		            return boolbase_1.default.falseFunc;
		        if (func === boolbase_1.default.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.default.falseFunc)
		            return boolbase_1.default.falseFunc;
		        if (func === boolbase_1.default.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.default.falseFunc)
		            return boolbase_1.default.falseFunc;
		        if (func === boolbase_1.default.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    // TODO determine the actual root element
		    root: function (next, _rule, _a) {
		        var adapter = _a.adapter;
		        return function (elem) {
		            var parent = adapter.getParent(elem);
		            return (parent == null || !adapter.isTag(parent)) && next(elem);
		        };
		    },
		    scope: function (next, rule, options, context) {
		        var equals = options.equals;
		        if (!context || context.length === 0) {
		            // Equivalent to :root
		            return exports$1.filters["root"](next, rule, options);
		        }
		        if (context.length === 1) {
		            // NOTE: can't be unpacked, as :has uses this for side-effects
		            return function (elem) { return equals(context[0], elem) && next(elem); };
		        }
		        return function (elem) { return context.includes(elem) && next(elem); };
		    },
		    hover: dynamicStatePseudo("isHovered"),
		    visited: dynamicStatePseudo("isVisited"),
		    active: dynamicStatePseudo("isActive"),
		};
		/**
		 * Dynamic state pseudos. These depend on optional Adapter methods.
		 *
		 * @param name The name of the adapter method to call.
		 * @returns Pseudo for the `filters` object.
		 */
		function dynamicStatePseudo(name) {
		    return function dynamicPseudo(next, _rule, _a) {
		        var adapter = _a.adapter;
		        var func = adapter[name];
		        if (typeof func !== "function") {
		            return boolbase_1.default.falseFunc;
		        }
		        return function active(elem) {
		            return func(elem) && next(elem);
		        };
		    };
		}
		
	} (filters));
	return filters;
}

var pseudos = {};

var hasRequiredPseudos;

function requirePseudos () {
	if (hasRequiredPseudos) return pseudos;
	hasRequiredPseudos = 1;
	Object.defineProperty(pseudos, "__esModule", { value: true });
	pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
	// While filters are precompiled, pseudos get called when they are needed
	pseudos.pseudos = {
	    empty: function (elem, _a) {
	        var adapter = _a.adapter;
	        return !adapter.getChildren(elem).some(function (elem) {
	            // FIXME: `getText` call is potentially expensive.
	            return adapter.isTag(elem) || adapter.getText(elem) !== "";
	        });
	    },
	    "first-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        if (adapter.prevElementSibling) {
	            return adapter.prevElementSibling(elem) == null;
	        }
	        var firstChild = adapter
	            .getSiblings(elem)
	            .find(function (elem) { return adapter.isTag(elem); });
	        return firstChild != null && equals(elem, firstChild);
	    },
	    "last-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            if (equals(elem, siblings[i]))
	                return true;
	            if (adapter.isTag(siblings[i]))
	                break;
	        }
	        return false;
	    },
	    "first-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = 0; i < siblings.length; i++) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "last-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "only-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var elemName = adapter.getName(elem);
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) {
	            return equals(elem, sibling) ||
	                !adapter.isTag(sibling) ||
	                adapter.getName(sibling) !== elemName;
	        });
	    },
	    "only-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
	    },
	};
	function verifyPseudoArgs(func, name, subselect, argIndex) {
	    if (subselect === null) {
	        if (func.length > argIndex) {
	            throw new Error("Pseudo-class :".concat(name, " requires an argument"));
	        }
	    }
	    else if (func.length === argIndex) {
	        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
	    }
	}
	pseudos.verifyPseudoArgs = verifyPseudoArgs;
	
	return pseudos;
}

var aliases = {};

var hasRequiredAliases;

function requireAliases () {
	if (hasRequiredAliases) return aliases;
	hasRequiredAliases = 1;
	Object.defineProperty(aliases, "__esModule", { value: true });
	aliases.aliases = void 0;
	/**
	 * Aliases are pseudos that are expressed as selectors.
	 */
	aliases.aliases = {
	    // Links
	    "any-link": ":is(a, area, link)[href]",
	    link: ":any-link:not(:visited)",
	    // Forms
	    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
	    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
	    enabled: ":not(:disabled)",
	    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
	    required: ":is(input, select, textarea)[required]",
	    optional: ":is(input, select, textarea):not([required])",
	    // JQuery extensions
	    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
	    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
	    checkbox: "[type=checkbox]",
	    file: "[type=file]",
	    password: "[type=password]",
	    radio: "[type=radio]",
	    reset: "[type=reset]",
	    image: "[type=image]",
	    submit: "[type=submit]",
	    parent: ":not(:empty)",
	    header: ":is(h1, h2, h3, h4, h5, h6)",
	    button: ":is(button, input[type=button])",
	    input: ":is(input, textarea, select, button)",
	    text: "input:is(:not([type!='']), [type=text])",
	};
	
	return aliases;
}

var subselects = {};

var hasRequiredSubselects;

function requireSubselects () {
	if (hasRequiredSubselects) return subselects;
	hasRequiredSubselects = 1;
	(function (exports$1) {
		var __spreadArray = (subselects && subselects.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		var __importDefault = (subselects && subselects.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.subselects = exports$1.getNextSiblings = exports$1.ensureIsTag = exports$1.PLACEHOLDER_ELEMENT = void 0;
		var boolbase_1 = __importDefault(requireBoolbase());
		var sort_js_1 = requireSort();
		/** Used as a placeholder for :has. Will be replaced with the actual element. */
		exports$1.PLACEHOLDER_ELEMENT = {};
		function ensureIsTag(next, adapter) {
		    if (next === boolbase_1.default.falseFunc)
		        return boolbase_1.default.falseFunc;
		    return function (elem) { return adapter.isTag(elem) && next(elem); };
		}
		exports$1.ensureIsTag = ensureIsTag;
		function getNextSiblings(elem, adapter) {
		    var siblings = adapter.getSiblings(elem);
		    if (siblings.length <= 1)
		        return [];
		    var elemIndex = siblings.indexOf(elem);
		    if (elemIndex < 0 || elemIndex === siblings.length - 1)
		        return [];
		    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
		}
		exports$1.getNextSiblings = getNextSiblings;
		function copyOptions(options) {
		    // Not copied: context, rootFunc
		    return {
		        xmlMode: !!options.xmlMode,
		        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
		        lowerCaseTags: !!options.lowerCaseTags,
		        quirksMode: !!options.quirksMode,
		        cacheResults: !!options.cacheResults,
		        pseudos: options.pseudos,
		        adapter: options.adapter,
		        equals: options.equals,
		    };
		}
		var is = function (next, token, options, context, compileToken) {
		    var func = compileToken(token, copyOptions(options), context);
		    return func === boolbase_1.default.trueFunc
		        ? next
		        : func === boolbase_1.default.falseFunc
		            ? boolbase_1.default.falseFunc
		            : function (elem) { return func(elem) && next(elem); };
		};
		/*
		 * :not, :has, :is, :matches and :where have to compile selectors
		 * doing this in src/pseudos.ts would lead to circular dependencies,
		 * so we add them here
		 */
		exports$1.subselects = {
		    is: is,
		    /**
		     * `:matches` and `:where` are aliases for `:is`.
		     */
		    matches: is,
		    where: is,
		    not: function (next, token, options, context, compileToken) {
		        var func = compileToken(token, copyOptions(options), context);
		        return func === boolbase_1.default.falseFunc
		            ? next
		            : func === boolbase_1.default.trueFunc
		                ? boolbase_1.default.falseFunc
		                : function (elem) { return !func(elem) && next(elem); };
		    },
		    has: function (next, subselect, options, _context, compileToken) {
		        var adapter = options.adapter;
		        var opts = copyOptions(options);
		        opts.relativeSelector = true;
		        var context = subselect.some(function (s) { return s.some(sort_js_1.isTraversal); })
		            ? // Used as a placeholder. Will be replaced with the actual element.
		                [exports$1.PLACEHOLDER_ELEMENT]
		            : undefined;
		        var compiled = compileToken(subselect, opts, context);
		        if (compiled === boolbase_1.default.falseFunc)
		            return boolbase_1.default.falseFunc;
		        var hasElement = ensureIsTag(compiled, adapter);
		        // If `compiled` is `trueFunc`, we can skip this.
		        if (context && compiled !== boolbase_1.default.trueFunc) {
		            /*
		             * `shouldTestNextSiblings` will only be true if the query starts with
		             * a traversal (sibling or adjacent). That means we will always have a context.
		             */
		            var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
		            return function (elem) {
		                if (!next(elem))
		                    return false;
		                context[0] = elem;
		                var childs = adapter.getChildren(elem);
		                var nextElements = shouldTestNextSiblings_1
		                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
		                return adapter.existsOne(hasElement, nextElements);
		            };
		        }
		        return function (elem) {
		            return next(elem) &&
		                adapter.existsOne(hasElement, adapter.getChildren(elem));
		        };
		    },
		};
		
	} (subselects));
	return subselects;
}

var hasRequiredPseudoSelectors;

function requirePseudoSelectors () {
	if (hasRequiredPseudoSelectors) return pseudoSelectors;
	hasRequiredPseudoSelectors = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.compilePseudoSelector = exports$1.aliases = exports$1.pseudos = exports$1.filters = void 0;
		var css_what_1 = require$$0;
		var filters_js_1 = requireFilters();
		Object.defineProperty(exports$1, "filters", { enumerable: true, get: function () { return filters_js_1.filters; } });
		var pseudos_js_1 = requirePseudos();
		Object.defineProperty(exports$1, "pseudos", { enumerable: true, get: function () { return pseudos_js_1.pseudos; } });
		var aliases_js_1 = requireAliases();
		Object.defineProperty(exports$1, "aliases", { enumerable: true, get: function () { return aliases_js_1.aliases; } });
		var subselects_js_1 = requireSubselects();
		function compilePseudoSelector(next, selector, options, context, compileToken) {
		    var _a;
		    var name = selector.name, data = selector.data;
		    if (Array.isArray(data)) {
		        if (!(name in subselects_js_1.subselects)) {
		            throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
		        }
		        return subselects_js_1.subselects[name](next, data, options, context, compileToken);
		    }
		    var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
		    var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
		    if (typeof stringPseudo === "string") {
		        if (data != null) {
		            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
		        }
		        // The alias has to be parsed here, to make sure options are respected.
		        var alias = (0, css_what_1.parse)(stringPseudo);
		        return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
		    }
		    if (typeof userPseudo === "function") {
		        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
		        return function (elem) { return userPseudo(elem, data) && next(elem); };
		    }
		    if (name in filters_js_1.filters) {
		        return filters_js_1.filters[name](next, data, options, context);
		    }
		    if (name in pseudos_js_1.pseudos) {
		        var pseudo_1 = pseudos_js_1.pseudos[name];
		        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
		        return function (elem) { return pseudo_1(elem, options, data) && next(elem); };
		    }
		    throw new Error("Unknown pseudo-class :".concat(name));
		}
		exports$1.compilePseudoSelector = compilePseudoSelector;
		
	} (pseudoSelectors));
	return pseudoSelectors;
}

var hasRequiredGeneral;

function requireGeneral () {
	if (hasRequiredGeneral) return general;
	hasRequiredGeneral = 1;
	Object.defineProperty(general, "__esModule", { value: true });
	general.compileGeneralSelector = void 0;
	var attributes_js_1 = requireAttributes();
	var index_js_1 = requirePseudoSelectors();
	var css_what_1 = require$$0;
	function getElementParent(node, adapter) {
	    var parent = adapter.getParent(node);
	    if (parent && adapter.isTag(parent)) {
	        return parent;
	    }
	    return null;
	}
	/*
	 * All available rules
	 */
	function compileGeneralSelector(next, selector, options, context, compileToken) {
	    var adapter = options.adapter, equals = options.equals;
	    switch (selector.type) {
	        case css_what_1.SelectorType.PseudoElement: {
	            throw new Error("Pseudo-elements are not supported by css-select");
	        }
	        case css_what_1.SelectorType.ColumnCombinator: {
	            throw new Error("Column combinators are not yet supported by css-select");
	        }
	        case css_what_1.SelectorType.Attribute: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced attributes are not yet supported by css-select");
	            }
	            if (!options.xmlMode || options.lowerCaseAttributeNames) {
	                selector.name = selector.name.toLowerCase();
	            }
	            return attributes_js_1.attributeRules[selector.action](next, selector, options);
	        }
	        case css_what_1.SelectorType.Pseudo: {
	            return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
	        }
	        // Tags
	        case css_what_1.SelectorType.Tag: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced tag names are not yet supported by css-select");
	            }
	            var name_1 = selector.name;
	            if (!options.xmlMode || options.lowerCaseTags) {
	                name_1 = name_1.toLowerCase();
	            }
	            return function tag(elem) {
	                return adapter.getName(elem) === name_1 && next(elem);
	            };
	        }
	        // Traversal
	        case css_what_1.SelectorType.Descendant: {
	            if (options.cacheResults === false ||
	                typeof WeakSet === "undefined") {
	                return function descendant(elem) {
	                    var current = elem;
	                    while ((current = getElementParent(current, adapter))) {
	                        if (next(current)) {
	                            return true;
	                        }
	                    }
	                    return false;
	                };
	            }
	            // @ts-expect-error `ElementNode` is not extending object
	            var isFalseCache_1 = new WeakSet();
	            return function cachedDescendant(elem) {
	                var current = elem;
	                while ((current = getElementParent(current, adapter))) {
	                    if (!isFalseCache_1.has(current)) {
	                        if (adapter.isTag(current) && next(current)) {
	                            return true;
	                        }
	                        isFalseCache_1.add(current);
	                    }
	                }
	                return false;
	            };
	        }
	        case "_flexibleDescendant": {
	            // Include element itself, only used while querying an array
	            return function flexibleDescendant(elem) {
	                var current = elem;
	                do {
	                    if (next(current))
	                        return true;
	                } while ((current = getElementParent(current, adapter)));
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Parent: {
	            return function parent(elem) {
	                return adapter
	                    .getChildren(elem)
	                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
	            };
	        }
	        case css_what_1.SelectorType.Child: {
	            return function child(elem) {
	                var parent = adapter.getParent(elem);
	                return parent != null && adapter.isTag(parent) && next(parent);
	            };
	        }
	        case css_what_1.SelectorType.Sibling: {
	            return function sibling(elem) {
	                var siblings = adapter.getSiblings(elem);
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Adjacent: {
	            if (adapter.prevElementSibling) {
	                return function adjacent(elem) {
	                    var previous = adapter.prevElementSibling(elem);
	                    return previous != null && next(previous);
	                };
	            }
	            return function adjacent(elem) {
	                var siblings = adapter.getSiblings(elem);
	                var lastElement;
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling)) {
	                        lastElement = currentSibling;
	                    }
	                }
	                return !!lastElement && next(lastElement);
	            };
	        }
	        case css_what_1.SelectorType.Universal: {
	            if (selector.namespace != null && selector.namespace !== "*") {
	                throw new Error("Namespaced universal selectors are not yet supported by css-select");
	            }
	            return next;
	        }
	    }
	}
	general.compileGeneralSelector = compileGeneralSelector;
	
	return general;
}

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile$1;
	hasRequiredCompile = 1;
	var __createBinding = (compile$1 && compile$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (compile$1 && compile$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (compile$1 && compile$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (compile$1 && compile$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile$1, "__esModule", { value: true });
	compile$1.compileToken = compile$1.compileUnsafe = compile$1.compile = void 0;
	var css_what_1 = require$$0;
	var boolbase_1 = __importDefault(requireBoolbase());
	var sort_js_1 = __importStar(requireSort());
	var general_js_1 = requireGeneral();
	var subselects_js_1 = requireSubselects();
	/**
	 * Compiles a selector to an executable function.
	 *
	 * @param selector Selector to compile.
	 * @param options Compilation options.
	 * @param context Optional context for the selector.
	 */
	function compile(selector, options, context) {
	    var next = compileUnsafe(selector, options, context);
	    return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
	}
	compile$1.compile = compile;
	function compileUnsafe(selector, options, context) {
	    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
	    return compileToken(token, options, context);
	}
	compile$1.compileUnsafe = compileUnsafe;
	function includesScopePseudo(t) {
	    return (t.type === css_what_1.SelectorType.Pseudo &&
	        (t.name === "scope" ||
	            (Array.isArray(t.data) &&
	                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
	}
	var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
	var FLEXIBLE_DESCENDANT_TOKEN = {
	    type: "_flexibleDescendant",
	};
	var SCOPE_TOKEN = {
	    type: css_what_1.SelectorType.Pseudo,
	    name: "scope",
	    data: null,
	};
	/*
	 * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
	 * http://www.w3.org/TR/selectors4/#absolutizing
	 */
	function absolutize(token, _a, context) {
	    var adapter = _a.adapter;
	    // TODO Use better check if the context is a document
	    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
	        var parent = adapter.isTag(e) && adapter.getParent(e);
	        return e === subselects_js_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
	    }));
	    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
	        var t = token_1[_i];
	        if (t.length > 0 &&
	            (0, sort_js_1.isTraversal)(t[0]) &&
	            t[0].type !== css_what_1.SelectorType.Descendant) ;
	        else if (hasContext && !t.some(includesScopePseudo)) {
	            t.unshift(DESCENDANT_TOKEN);
	        }
	        else {
	            continue;
	        }
	        t.unshift(SCOPE_TOKEN);
	    }
	}
	function compileToken(token, options, context) {
	    var _a;
	    token.forEach(sort_js_1.default);
	    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
	    var isArrayContext = Array.isArray(context);
	    var finalContext = context && (Array.isArray(context) ? context : [context]);
	    // Check if the selector is relative
	    if (options.relativeSelector !== false) {
	        absolutize(token, options, finalContext);
	    }
	    else if (token.some(function (t) { return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]); })) {
	        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
	    }
	    var shouldTestNextSiblings = false;
	    var query = token
	        .map(function (rules) {
	        if (rules.length >= 2) {
	            var first = rules[0], second = rules[1];
	            if (first.type !== css_what_1.SelectorType.Pseudo ||
	                first.name !== "scope") ;
	            else if (isArrayContext &&
	                second.type === css_what_1.SelectorType.Descendant) {
	                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
	            }
	            else if (second.type === css_what_1.SelectorType.Adjacent ||
	                second.type === css_what_1.SelectorType.Sibling) {
	                shouldTestNextSiblings = true;
	            }
	        }
	        return compileRules(rules, options, finalContext);
	    })
	        .reduce(reduceRules, boolbase_1.default.falseFunc);
	    query.shouldTestNextSiblings = shouldTestNextSiblings;
	    return query;
	}
	compile$1.compileToken = compileToken;
	function compileRules(rules, options, context) {
	    var _a;
	    return rules.reduce(function (previous, rule) {
	        return previous === boolbase_1.default.falseFunc
	            ? boolbase_1.default.falseFunc
	            : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
	    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
	}
	function reduceRules(a, b) {
	    if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
	        return a;
	    }
	    if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
	        return b;
	    }
	    return function combine(elem) {
	        return a(elem) || b(elem);
	    };
	}
	
	return compile$1;
}

var hasRequiredLib$y;

function requireLib$y () {
	if (hasRequiredLib$y) return lib$v;
	hasRequiredLib$y = 1;
	(function (exports$1) {
		var __createBinding = (lib$v && lib$v.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$v && lib$v.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$v && lib$v.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __importDefault = (lib$v && lib$v.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.aliases = exports$1.pseudos = exports$1.filters = exports$1.is = exports$1.selectOne = exports$1.selectAll = exports$1.prepareContext = exports$1._compileToken = exports$1._compileUnsafe = exports$1.compile = void 0;
		var DomUtils = __importStar(/*@__PURE__*/ requireLib$A());
		var boolbase_1 = __importDefault(requireBoolbase());
		var compile_js_1 = requireCompile();
		var subselects_js_1 = requireSubselects();
		var defaultEquals = function (a, b) { return a === b; };
		var defaultOptions = {
		    adapter: DomUtils,
		    equals: defaultEquals,
		};
		function convertOptionFormats(options) {
		    var _a, _b, _c, _d;
		    /*
		     * We force one format of options to the other one.
		     */
		    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
		    var opts = options !== null && options !== void 0 ? options : defaultOptions;
		    // @ts-expect-error Same as above.
		    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
		    // @ts-expect-error `equals` does not exist on `Options`
		    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
		    return opts;
		}
		function wrapCompile(func) {
		    return function addAdapter(selector, options, context) {
		        var opts = convertOptionFormats(options);
		        return func(selector, opts, context);
		    };
		}
		/**
		 * Compiles the query, returns a function.
		 */
		exports$1.compile = wrapCompile(compile_js_1.compile);
		exports$1._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
		exports$1._compileToken = wrapCompile(compile_js_1.compileToken);
		function getSelectorFunc(searchFunc) {
		    return function select(query, elements, options) {
		        var opts = convertOptionFormats(options);
		        if (typeof query !== "function") {
		            query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
		        }
		        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
		        return searchFunc(query, filteredElements, opts);
		    };
		}
		function prepareContext(elems, adapter, shouldTestNextSiblings) {
		    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
		    /*
		     * Add siblings if the query requires them.
		     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
		     */
		    if (shouldTestNextSiblings) {
		        elems = appendNextSiblings(elems, adapter);
		    }
		    return Array.isArray(elems)
		        ? adapter.removeSubsets(elems)
		        : adapter.getChildren(elems);
		}
		exports$1.prepareContext = prepareContext;
		function appendNextSiblings(elem, adapter) {
		    // Order matters because jQuery seems to check the children before the siblings
		    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
		    var elemsLength = elems.length;
		    for (var i = 0; i < elemsLength; i++) {
		        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
		        elems.push.apply(elems, nextSiblings);
		    }
		    return elems;
		}
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns All matching elements.
		 *
		 */
		exports$1.selectAll = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0
		        ? []
		        : options.adapter.findAll(query, elems);
		});
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns the first match, or null if there was no match.
		 */
		exports$1.selectOne = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0
		        ? null
		        : options.adapter.findOne(query, elems);
		});
		/**
		 * Tests whether or not an element is matched by query.
		 *
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elem The element to test if it matches the query.
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns
		 */
		function is(elem, query, options) {
		    var opts = convertOptionFormats(options);
		    return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
		}
		exports$1.is = is;
		/**
		 * Alias for selectAll(query, elems, options).
		 * @see [compile] for supported selector queries.
		 */
		exports$1.default = exports$1.selectAll;
		// Export filters, pseudos and aliases to allow users to supply their own.
		/** @deprecated Use the `pseudos` option instead. */
		var index_js_1 = requirePseudoSelectors();
		Object.defineProperty(exports$1, "filters", { enumerable: true, get: function () { return index_js_1.filters; } });
		Object.defineProperty(exports$1, "pseudos", { enumerable: true, get: function () { return index_js_1.pseudos; } });
		Object.defineProperty(exports$1, "aliases", { enumerable: true, get: function () { return index_js_1.aliases; } });
		
	} (lib$v));
	return lib$v;
}

var helpers$1 = {};

var positionals = {};

var hasRequiredPositionals;

function requirePositionals () {
	if (hasRequiredPositionals) return positionals;
	hasRequiredPositionals = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getLimit = exports$1.isFilter = exports$1.filterNames = void 0;
		exports$1.filterNames = new Set([
		    "first",
		    "last",
		    "eq",
		    "gt",
		    "nth",
		    "lt",
		    "even",
		    "odd",
		]);
		function isFilter(s) {
		    if (s.type !== "pseudo")
		        return false;
		    if (exports$1.filterNames.has(s.name))
		        return true;
		    if (s.name === "not" && Array.isArray(s.data)) {
		        // Only consider `:not` with embedded filters
		        return s.data.some(function (s) { return s.some(isFilter); });
		    }
		    return false;
		}
		exports$1.isFilter = isFilter;
		function getLimit(filter, data, partLimit) {
		    var num = data != null ? parseInt(data, 10) : NaN;
		    switch (filter) {
		        case "first":
		            return 1;
		        case "nth":
		        case "eq":
		            return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;
		        case "lt":
		            return isFinite(num)
		                ? num >= 0
		                    ? Math.min(num, partLimit)
		                    : Infinity
		                : 0;
		        case "gt":
		            return isFinite(num) ? Infinity : 0;
		        case "odd":
		            return 2 * partLimit;
		        case "even":
		            return 2 * partLimit - 1;
		        case "last":
		        case "not":
		            return Infinity;
		    }
		}
		exports$1.getLimit = getLimit;
		
	} (positionals));
	return positionals;
}

var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers$1;
	hasRequiredHelpers$1 = 1;
	Object.defineProperty(helpers$1, "__esModule", { value: true });
	helpers$1.groupSelectors = helpers$1.getDocumentRoot = void 0;
	var positionals_js_1 = /*@__PURE__*/ requirePositionals();
	function getDocumentRoot(node) {
	    while (node.parent)
	        node = node.parent;
	    return node;
	}
	helpers$1.getDocumentRoot = getDocumentRoot;
	function groupSelectors(selectors) {
	    var filteredSelectors = [];
	    var plainSelectors = [];
	    for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
	        var selector = selectors_1[_i];
	        if (selector.some(positionals_js_1.isFilter)) {
	            filteredSelectors.push(selector);
	        }
	        else {
	            plainSelectors.push(selector);
	        }
	    }
	    return [plainSelectors, filteredSelectors];
	}
	helpers$1.groupSelectors = groupSelectors;
	
	return helpers$1;
}

var hasRequiredLib$x;

function requireLib$x () {
	if (hasRequiredLib$x) return lib$w;
	hasRequiredLib$x = 1;
	(function (exports$1) {
		var __assign = (lib$w && lib$w.__assign) || function () {
		    __assign = Object.assign || function(t) {
		        for (var s, i = 1, n = arguments.length; i < n; i++) {
		            s = arguments[i];
		            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
		                t[p] = s[p];
		        }
		        return t;
		    };
		    return __assign.apply(this, arguments);
		};
		var __createBinding = (lib$w && lib$w.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$w && lib$w.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$w && lib$w.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __spreadArray = (lib$w && lib$w.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.select = exports$1.filter = exports$1.some = exports$1.is = exports$1.aliases = exports$1.pseudos = exports$1.filters = void 0;
		var css_what_1 = require$$0;
		var css_select_1 = requireLib$y();
		var DomUtils = __importStar(/*@__PURE__*/ requireLib$A());
		var boolbase = __importStar(requireBoolbase());
		var helpers_js_1 = /*@__PURE__*/ requireHelpers$1();
		var positionals_js_1 = /*@__PURE__*/ requirePositionals();
		// Re-export pseudo extension points
		var css_select_2 = requireLib$y();
		Object.defineProperty(exports$1, "filters", { enumerable: true, get: function () { return css_select_2.filters; } });
		Object.defineProperty(exports$1, "pseudos", { enumerable: true, get: function () { return css_select_2.pseudos; } });
		Object.defineProperty(exports$1, "aliases", { enumerable: true, get: function () { return css_select_2.aliases; } });
		var UNIVERSAL_SELECTOR = {
		    type: css_what_1.SelectorType.Universal,
		    namespace: null,
		};
		var SCOPE_PSEUDO = {
		    type: css_what_1.SelectorType.Pseudo,
		    name: "scope",
		    data: null,
		};
		function is(element, selector, options) {
		    if (options === void 0) { options = {}; }
		    return some([element], selector, options);
		}
		exports$1.is = is;
		function some(elements, selector, options) {
		    if (options === void 0) { options = {}; }
		    if (typeof selector === "function")
		        return elements.some(selector);
		    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_1.parse)(selector)), plain = _a[0], filtered = _a[1];
		    return ((plain.length > 0 && elements.some((0, css_select_1._compileToken)(plain, options))) ||
		        filtered.some(function (sel) { return filterBySelector(sel, elements, options).length > 0; }));
		}
		exports$1.some = some;
		function filterByPosition(filter, elems, data, options) {
		    var num = typeof data === "string" ? parseInt(data, 10) : NaN;
		    switch (filter) {
		        case "first":
		        case "lt":
		            // Already done in `getLimit`
		            return elems;
		        case "last":
		            return elems.length > 0 ? [elems[elems.length - 1]] : elems;
		        case "nth":
		        case "eq":
		            return isFinite(num) && Math.abs(num) < elems.length
		                ? [num < 0 ? elems[elems.length + num] : elems[num]]
		                : [];
		        case "gt":
		            return isFinite(num) ? elems.slice(num + 1) : [];
		        case "even":
		            return elems.filter(function (_, i) { return i % 2 === 0; });
		        case "odd":
		            return elems.filter(function (_, i) { return i % 2 === 1; });
		        case "not": {
		            var filtered_1 = new Set(filterParsed(data, elems, options));
		            return elems.filter(function (e) { return !filtered_1.has(e); });
		        }
		    }
		}
		function filter(selector, elements, options) {
		    if (options === void 0) { options = {}; }
		    return filterParsed((0, css_what_1.parse)(selector), elements, options);
		}
		exports$1.filter = filter;
		/**
		 * Filter a set of elements by a selector.
		 *
		 * Will return elements in the original order.
		 *
		 * @param selector Selector to filter by.
		 * @param elements Elements to filter.
		 * @param options Options for selector.
		 */
		function filterParsed(selector, elements, options) {
		    if (elements.length === 0)
		        return [];
		    var _a = (0, helpers_js_1.groupSelectors)(selector), plainSelectors = _a[0], filteredSelectors = _a[1];
		    var found;
		    if (plainSelectors.length) {
		        var filtered = filterElements(elements, plainSelectors, options);
		        // If there are no filters, just return
		        if (filteredSelectors.length === 0) {
		            return filtered;
		        }
		        // Otherwise, we have to do some filtering
		        if (filtered.length) {
		            found = new Set(filtered);
		        }
		    }
		    for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
		        var filteredSelector = filteredSelectors[i];
		        var missing = found
		            ? elements.filter(function (e) { return DomUtils.isTag(e) && !found.has(e); })
		            : elements;
		        if (missing.length === 0)
		            break;
		        var filtered = filterBySelector(filteredSelector, elements, options);
		        if (filtered.length) {
		            if (!found) {
		                /*
		                 * If we haven't found anything before the last selector,
		                 * just return what we found now.
		                 */
		                if (i === filteredSelectors.length - 1) {
		                    return filtered;
		                }
		                found = new Set(filtered);
		            }
		            else {
		                filtered.forEach(function (el) { return found.add(el); });
		            }
		        }
		    }
		    return typeof found !== "undefined"
		        ? (found.size === elements.length
		            ? elements
		            : // Filter elements to preserve order
		                elements.filter(function (el) {
		                    return found.has(el);
		                }))
		        : [];
		}
		function filterBySelector(selector, elements, options) {
		    var _a;
		    if (selector.some(css_what_1.isTraversal)) {
		        /*
		         * Get root node, run selector with the scope
		         * set to all of our nodes.
		         */
		        var root = (_a = options.root) !== null && _a !== void 0 ? _a : (0, helpers_js_1.getDocumentRoot)(elements[0]);
		        var opts = __assign(__assign({}, options), { context: elements, relativeSelector: false });
		        selector.push(SCOPE_PSEUDO);
		        return findFilterElements(root, selector, opts, true, elements.length);
		    }
		    // Performance optimization: If we don't have to traverse, just filter set.
		    return findFilterElements(elements, selector, options, false, elements.length);
		}
		function select(selector, root, options, limit) {
		    if (options === void 0) { options = {}; }
		    if (limit === void 0) { limit = Infinity; }
		    if (typeof selector === "function") {
		        return find(root, selector);
		    }
		    var _a = (0, helpers_js_1.groupSelectors)((0, css_what_1.parse)(selector)), plain = _a[0], filtered = _a[1];
		    var results = filtered.map(function (sel) {
		        return findFilterElements(root, sel, options, true, limit);
		    });
		    // Plain selectors can be queried in a single go
		    if (plain.length) {
		        results.push(findElements(root, plain, options, limit));
		    }
		    if (results.length === 0) {
		        return [];
		    }
		    // If there was only a single selector, just return the result
		    if (results.length === 1) {
		        return results[0];
		    }
		    // Sort results, filtering for duplicates
		    return DomUtils.uniqueSort(results.reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }));
		}
		exports$1.select = select;
		/**
		 *
		 * @param root Element(s) to search from.
		 * @param selector Selector to look for.
		 * @param options Options for querying.
		 * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.
		 */
		function findFilterElements(root, selector, options, queryForSelector, totalLimit) {
		    var filterIndex = selector.findIndex(positionals_js_1.isFilter);
		    var sub = selector.slice(0, filterIndex);
		    var filter = selector[filterIndex];
		    // If we are at the end of the selector, we can limit the number of elements to retrieve.
		    var partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
		    /*
		     * Set the number of elements to retrieve.
		     * Eg. for :first, we only have to get a single element.
		     */
		    var limit = (0, positionals_js_1.getLimit)(filter.name, filter.data, partLimit);
		    if (limit === 0)
		        return [];
		    /*
		     * Skip `findElements` call if our selector starts with a positional
		     * pseudo.
		     */
		    var elemsNoLimit = sub.length === 0 && !Array.isArray(root)
		        ? DomUtils.getChildren(root).filter(DomUtils.isTag)
		        : sub.length === 0
		            ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag)
		            : queryForSelector || sub.some(css_what_1.isTraversal)
		                ? findElements(root, [sub], options, limit)
		                : filterElements(root, [sub], options);
		    var elems = elemsNoLimit.slice(0, limit);
		    var result = filterByPosition(filter.name, elems, filter.data, options);
		    if (result.length === 0 || selector.length === filterIndex + 1) {
		        return result;
		    }
		    var remainingSelector = selector.slice(filterIndex + 1);
		    var remainingHasTraversal = remainingSelector.some(css_what_1.isTraversal);
		    if (remainingHasTraversal) {
		        if ((0, css_what_1.isTraversal)(remainingSelector[0])) {
		            var type = remainingSelector[0].type;
		            if (type === css_what_1.SelectorType.Sibling ||
		                type === css_what_1.SelectorType.Adjacent) {
		                // If we have a sibling traversal, we need to also look at the siblings.
		                result = (0, css_select_1.prepareContext)(result, DomUtils, true);
		            }
		            // Avoid a traversal-first selector error.
		            remainingSelector.unshift(UNIVERSAL_SELECTOR);
		        }
		        options = __assign(__assign({}, options), { 
		            // Avoid absolutizing the selector
		            relativeSelector: false, 
		            /*
		             * Add a custom root func, to make sure traversals don't match elements
		             * that aren't a part of the considered tree.
		             */
		            rootFunc: function (el) { return result.includes(el); } });
		    }
		    else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {
		        options = __assign(__assign({}, options), { rootFunc: boolbase.trueFunc });
		    }
		    /*
		     * If we have another filter, recursively call `findFilterElements`,
		     * with the `recursive` flag disabled. We only have to look for more
		     * elements when we see a traversal.
		     *
		     * Otherwise,
		     */
		    return remainingSelector.some(positionals_js_1.isFilter)
		        ? findFilterElements(result, remainingSelector, options, false, totalLimit)
		        : remainingHasTraversal
		            ? // Query existing elements to resolve traversal.
		                findElements(result, [remainingSelector], options, totalLimit)
		            : // If we don't have any more traversals, simply filter elements.
		                filterElements(result, [remainingSelector], options);
		}
		function findElements(root, sel, options, limit) {
		    var query = (0, css_select_1._compileToken)(sel, options, root);
		    return find(root, query, limit);
		}
		function find(root, query, limit) {
		    if (limit === void 0) { limit = Infinity; }
		    var elems = (0, css_select_1.prepareContext)(root, DomUtils, query.shouldTestNextSiblings);
		    return DomUtils.find(function (node) { return DomUtils.isTag(node) && query(node); }, elems, true, limit);
		}
		function filterElements(elements, sel, options) {
		    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
		    if (els.length === 0)
		        return els;
		    var query = (0, css_select_1._compileToken)(sel, options);
		    return query === boolbase.trueFunc ? els : els.filter(query);
		}
		
	} (lib$w));
	return lib$w;
}

var hasRequiredTraversing;

function requireTraversing () {
	if (hasRequiredTraversing) return traversing;
	hasRequiredTraversing = 1;
	/**
	 * Methods for traversing the DOM structure.
	 *
	 * @module cheerio/traversing
	 */
	var __createBinding = (traversing && traversing.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (traversing && traversing.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (traversing && traversing.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __spreadArray = (traversing && traversing.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(traversing, "__esModule", { value: true });
	traversing.addBack = traversing.add = traversing.end = traversing.slice = traversing.index = traversing.toArray = traversing.get = traversing.eq = traversing.last = traversing.first = traversing.has = traversing.not = traversing.is = traversing.filterArray = traversing.filter = traversing.map = traversing.each = traversing.contents = traversing.children = traversing.siblings = traversing.prevUntil = traversing.prevAll = traversing.prev = traversing.nextUntil = traversing.nextAll = traversing.next = traversing.closest = traversing.parentsUntil = traversing.parents = traversing.parent = traversing.find = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$B();
	var select = __importStar(/*@__PURE__*/ requireLib$x());
	var utils_js_1 = requireUtils$2();
	var static_js_1 = require_static();
	var domutils_1 = /*@__PURE__*/ requireLib$A();
	var reSiblingSelector = /^\s*[~+]/;
	/**
	 * Get the descendants of each element in the current set of matched elements,
	 * filtered by a selector, jQuery object, or element.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('#fruits').find('li').length;
	 * //=> 3
	 * $('#fruits').find($('.apple')).length;
	 * //=> 1
	 * ```
	 *
	 * @param selectorOrHaystack - Element to look for.
	 * @returns The found elements.
	 * @see {@link https://api.jquery.com/find/}
	 */
	function find(selectorOrHaystack) {
	    var _a;
	    if (!selectorOrHaystack) {
	        return this._make([]);
	    }
	    var context = this.toArray();
	    if (typeof selectorOrHaystack !== 'string') {
	        var haystack = (0, utils_js_1.isCheerio)(selectorOrHaystack)
	            ? selectorOrHaystack.toArray()
	            : [selectorOrHaystack];
	        return this._make(haystack.filter(function (elem) { return context.some(function (node) { return (0, static_js_1.contains)(node, elem); }); }));
	    }
	    var elems = reSiblingSelector.test(selectorOrHaystack)
	        ? context
	        : this.children().toArray();
	    var options = {
	        context: context,
	        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
	        // Pass options that are recognized by `cheerio-select`
	        xmlMode: this.options.xmlMode,
	        lowerCaseTags: this.options.lowerCaseTags,
	        lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
	        pseudos: this.options.pseudos,
	        quirksMode: this.options.quirksMode,
	    };
	    return this._make(select.select(selectorOrHaystack, elems, options));
	}
	traversing.find = find;
	/**
	 * Creates a matcher, using a particular mapping function. Matchers provide a
	 * function that finds elements using a generating function, supporting filtering.
	 *
	 * @private
	 * @param matchMap - Mapping function.
	 * @returns - Function for wrapping generating functions.
	 */
	function _getMatcher(matchMap) {
	    return function (fn) {
	        var postFns = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            postFns[_i - 1] = arguments[_i];
	        }
	        return function (selector) {
	            var _a;
	            var matched = matchMap(fn, this);
	            if (selector) {
	                matched = filterArray(matched, selector, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);
	            }
	            return this._make(
	            // Post processing is only necessary if there is more than one element.
	            this.length > 1 && matched.length > 1
	                ? postFns.reduce(function (elems, fn) { return fn(elems); }, matched)
	                : matched);
	        };
	    };
	}
	/** Matcher that adds multiple elements for each entry in the input. */
	var _matcher = _getMatcher(function (fn, elems) {
	    var _a;
	    var ret = [];
	    for (var i = 0; i < elems.length; i++) {
	        var value = fn(elems[i]);
	        ret.push(value);
	    }
	    return (_a = new Array()).concat.apply(_a, ret);
	});
	/** Matcher that adds at most one element for each entry in the input. */
	var _singleMatcher = _getMatcher(function (fn, elems) {
	    var ret = [];
	    for (var i = 0; i < elems.length; i++) {
	        var value = fn(elems[i]);
	        if (value !== null) {
	            ret.push(value);
	        }
	    }
	    return ret;
	});
	/**
	 * Matcher that supports traversing until a condition is met.
	 *
	 * @returns A function usable for `*Until` methods.
	 */
	function _matchUntil(nextElem) {
	    var postFns = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        postFns[_i - 1] = arguments[_i];
	    }
	    // We use a variable here that is used from within the matcher.
	    var matches = null;
	    var innerMatcher = _getMatcher(function (nextElem, elems) {
	        var matched = [];
	        (0, utils_js_1.domEach)(elems, function (elem) {
	            for (var next_1; (next_1 = nextElem(elem)); elem = next_1) {
	                // FIXME: `matched` might contain duplicates here and the index is too large.
	                if (matches === null || matches === void 0 ? void 0 : matches(next_1, matched.length))
	                    break;
	                matched.push(next_1);
	            }
	        });
	        return matched;
	    }).apply(void 0, __spreadArray([nextElem], postFns, false));
	    return function (selector, filterSelector) {
	        var _this = this;
	        // Override `matches` variable with the new target.
	        matches =
	            typeof selector === 'string'
	                ? function (elem) { return select.is(elem, selector, _this.options); }
	                : selector
	                    ? getFilterFn(selector)
	                    : null;
	        var ret = innerMatcher.call(this, filterSelector);
	        // Set `matches` to `null`, so we don't waste memory.
	        matches = null;
	        return ret;
	    };
	}
	function _removeDuplicates(elems) {
	    return Array.from(new Set(elems));
	}
	/**
	 * Get the parent of each element in the current set of matched elements,
	 * optionally filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.pear').parent().attr('id');
	 * //=> fruits
	 * ```
	 *
	 * @param selector - If specified filter for parent.
	 * @returns The parents.
	 * @see {@link https://api.jquery.com/parent/}
	 */
	traversing.parent = _singleMatcher(function (_a) {
	    var parent = _a.parent;
	    return (parent && !(0, domhandler_1.isDocument)(parent) ? parent : null);
	}, _removeDuplicates);
	/**
	 * Get a set of parents filtered by `selector` of each element in the current
	 * set of match elements.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.orange').parents().length;
	 * //=> 2
	 * $('.orange').parents('#fruits').length;
	 * //=> 1
	 * ```
	 *
	 * @param selector - If specified filter for parents.
	 * @returns The parents.
	 * @see {@link https://api.jquery.com/parents/}
	 */
	traversing.parents = _matcher(function (elem) {
	    var matched = [];
	    while (elem.parent && !(0, domhandler_1.isDocument)(elem.parent)) {
	        matched.push(elem.parent);
	        elem = elem.parent;
	    }
	    return matched;
	}, domutils_1.uniqueSort, function (elems) { return elems.reverse(); });
	/**
	 * Get the ancestors of each element in the current set of matched elements, up
	 * to but not including the element matched by the selector, DOM node, or cheerio object.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.orange').parentsUntil('#food').length;
	 * //=> 1
	 * ```
	 *
	 * @param selector - Selector for element to stop at.
	 * @param filterSelector - Optional filter for parents.
	 * @returns The parents.
	 * @see {@link https://api.jquery.com/parentsUntil/}
	 */
	traversing.parentsUntil = _matchUntil(function (_a) {
	    var parent = _a.parent;
	    return (parent && !(0, domhandler_1.isDocument)(parent) ? parent : null);
	}, domutils_1.uniqueSort, function (elems) { return elems.reverse(); });
	/**
	 * For each element in the set, get the first element that matches the selector
	 * by testing the element itself and traversing up through its ancestors in the DOM tree.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.orange').closest();
	 * //=> []
	 *
	 * $('.orange').closest('.apple');
	 * // => []
	 *
	 * $('.orange').closest('li');
	 * //=> [<li class="orange">Orange</li>]
	 *
	 * $('.orange').closest('#fruits');
	 * //=> [<ul id="fruits"> ... </ul>]
	 * ```
	 *
	 * @param selector - Selector for the element to find.
	 * @returns The closest nodes.
	 * @see {@link https://api.jquery.com/closest/}
	 */
	function closest(selector) {
	    var _a;
	    var set = [];
	    if (!selector) {
	        return this._make(set);
	    }
	    var selectOpts = {
	        xmlMode: this.options.xmlMode,
	        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
	    };
	    var selectFn = typeof selector === 'string'
	        ? function (elem) { return select.is(elem, selector, selectOpts); }
	        : getFilterFn(selector);
	    (0, utils_js_1.domEach)(this, function (elem) {
	        while (elem && (0, utils_js_1.isTag)(elem)) {
	            if (selectFn(elem, 0)) {
	                // Do not add duplicate elements to the set
	                if (!set.includes(elem)) {
	                    set.push(elem);
	                }
	                break;
	            }
	            elem = elem.parent;
	        }
	    });
	    return this._make(set);
	}
	traversing.closest = closest;
	/**
	 * Gets the next sibling of the first selected element, optionally filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.apple').next().hasClass('orange');
	 * //=> true
	 * ```
	 *
	 * @param selector - If specified filter for sibling.
	 * @returns The next nodes.
	 * @see {@link https://api.jquery.com/next/}
	 */
	traversing.next = _singleMatcher(function (elem) { return (0, domutils_1.nextElementSibling)(elem); });
	/**
	 * Gets all the following siblings of the first selected element, optionally
	 * filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.apple').nextAll();
	 * //=> [<li class="orange">Orange</li>, <li class="pear">Pear</li>]
	 * $('.apple').nextAll('.orange');
	 * //=> [<li class="orange">Orange</li>]
	 * ```
	 *
	 * @param selector - If specified filter for siblings.
	 * @returns The next nodes.
	 * @see {@link https://api.jquery.com/nextAll/}
	 */
	traversing.nextAll = _matcher(function (elem) {
	    var matched = [];
	    while (elem.next) {
	        elem = elem.next;
	        if ((0, utils_js_1.isTag)(elem))
	            matched.push(elem);
	    }
	    return matched;
	}, _removeDuplicates);
	/**
	 * Gets all the following siblings up to but not including the element matched
	 * by the selector, optionally filtered by another selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.apple').nextUntil('.pear');
	 * //=> [<li class="orange">Orange</li>]
	 * ```
	 *
	 * @param selector - Selector for element to stop at.
	 * @param filterSelector - If specified filter for siblings.
	 * @returns The next nodes.
	 * @see {@link https://api.jquery.com/nextUntil/}
	 */
	traversing.nextUntil = _matchUntil(function (el) { return (0, domutils_1.nextElementSibling)(el); }, _removeDuplicates);
	/**
	 * Gets the previous sibling of the first selected element optionally filtered
	 * by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.orange').prev().hasClass('apple');
	 * //=> true
	 * ```
	 *
	 * @param selector - If specified filter for siblings.
	 * @returns The previous nodes.
	 * @see {@link https://api.jquery.com/prev/}
	 */
	traversing.prev = _singleMatcher(function (elem) { return (0, domutils_1.prevElementSibling)(elem); });
	/**
	 * Gets all the preceding siblings of the first selected element, optionally
	 * filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.pear').prevAll();
	 * //=> [<li class="orange">Orange</li>, <li class="apple">Apple</li>]
	 *
	 * $('.pear').prevAll('.orange');
	 * //=> [<li class="orange">Orange</li>]
	 * ```
	 *
	 * @param selector - If specified filter for siblings.
	 * @returns The previous nodes.
	 * @see {@link https://api.jquery.com/prevAll/}
	 */
	traversing.prevAll = _matcher(function (elem) {
	    var matched = [];
	    while (elem.prev) {
	        elem = elem.prev;
	        if ((0, utils_js_1.isTag)(elem))
	            matched.push(elem);
	    }
	    return matched;
	}, _removeDuplicates);
	/**
	 * Gets all the preceding siblings up to but not including the element matched
	 * by the selector, optionally filtered by another selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.pear').prevUntil('.apple');
	 * //=> [<li class="orange">Orange</li>]
	 * ```
	 *
	 * @param selector - Selector for element to stop at.
	 * @param filterSelector - If specified filter for siblings.
	 * @returns The previous nodes.
	 * @see {@link https://api.jquery.com/prevUntil/}
	 */
	traversing.prevUntil = _matchUntil(function (el) { return (0, domutils_1.prevElementSibling)(el); }, _removeDuplicates);
	/**
	 * Get the siblings of each element (excluding the element) in the set of
	 * matched elements, optionally filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.pear').siblings().length;
	 * //=> 2
	 *
	 * $('.pear').siblings('.orange').length;
	 * //=> 1
	 * ```
	 *
	 * @param selector - If specified filter for siblings.
	 * @returns The siblings.
	 * @see {@link https://api.jquery.com/siblings/}
	 */
	traversing.siblings = _matcher(function (elem) {
	    return (0, domutils_1.getSiblings)(elem).filter(function (el) { return (0, utils_js_1.isTag)(el) && el !== elem; });
	}, domutils_1.uniqueSort);
	/**
	 * Gets the element children of each element in the set of matched elements.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('#fruits').children().length;
	 * //=> 3
	 *
	 * $('#fruits').children('.pear').text();
	 * //=> Pear
	 * ```
	 *
	 * @param selector - If specified filter for children.
	 * @returns The children.
	 * @see {@link https://api.jquery.com/children/}
	 */
	traversing.children = _matcher(function (elem) { return (0, domutils_1.getChildren)(elem).filter(utils_js_1.isTag); }, _removeDuplicates);
	/**
	 * Gets the children of each element in the set of matched elements, including
	 * text and comment nodes.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('#fruits').contents().length;
	 * //=> 3
	 * ```
	 *
	 * @returns The children.
	 * @see {@link https://api.jquery.com/contents/}
	 */
	function contents() {
	    var elems = this.toArray().reduce(function (newElems, elem) {
	        return (0, domhandler_1.hasChildren)(elem) ? newElems.concat(elem.children) : newElems;
	    }, []);
	    return this._make(elems);
	}
	traversing.contents = contents;
	/**
	 * Iterates over a cheerio object, executing a function for each matched
	 * element. When the callback is fired, the function is fired in the context of
	 * the DOM element, so `this` refers to the current element, which is equivalent
	 * to the function parameter `element`. To break out of the `each` loop early,
	 * return with `false`.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * const fruits = [];
	 *
	 * $('li').each(function (i, elem) {
	 *   fruits[i] = $(this).text();
	 * });
	 *
	 * fruits.join(', ');
	 * //=> Apple, Orange, Pear
	 * ```
	 *
	 * @param fn - Function to execute.
	 * @returns The instance itself, useful for chaining.
	 * @see {@link https://api.jquery.com/each/}
	 */
	function each(fn) {
	    var i = 0;
	    var len = this.length;
	    while (i < len && fn.call(this[i], i, this[i]) !== false)
	        ++i;
	    return this;
	}
	traversing.each = each;
	/**
	 * Pass each element in the current matched set through a function, producing a
	 * new Cheerio object containing the return values. The function can return an
	 * individual data item or an array of data items to be inserted into the
	 * resulting set. If an array is returned, the elements inside the array are
	 * inserted into the set. If the function returns null or undefined, no element
	 * will be inserted.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('li')
	 *   .map(function (i, el) {
	 *     // this === el
	 *     return $(this).text();
	 *   })
	 *   .toArray()
	 *   .join(' ');
	 * //=> "apple orange pear"
	 * ```
	 *
	 * @param fn - Function to execute.
	 * @returns The mapped elements, wrapped in a Cheerio collection.
	 * @see {@link https://api.jquery.com/map/}
	 */
	function map(fn) {
	    var elems = [];
	    for (var i = 0; i < this.length; i++) {
	        var el = this[i];
	        var val = fn.call(el, i, el);
	        if (val != null) {
	            elems = elems.concat(val);
	        }
	    }
	    return this._make(elems);
	}
	traversing.map = map;
	/**
	 * Creates a function to test if a filter is matched.
	 *
	 * @param match - A filter.
	 * @returns A function that determines if a filter has been matched.
	 */
	function getFilterFn(match) {
	    if (typeof match === 'function') {
	        return function (el, i) { return match.call(el, i, el); };
	    }
	    if ((0, utils_js_1.isCheerio)(match)) {
	        return function (el) { return Array.prototype.includes.call(match, el); };
	    }
	    return function (el) {
	        return match === el;
	    };
	}
	function filter(match) {
	    var _a;
	    return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));
	}
	traversing.filter = filter;
	function filterArray(nodes, match, xmlMode, root) {
	    return typeof match === 'string'
	        ? select.filter(match, nodes, { xmlMode: xmlMode, root: root })
	        : nodes.filter(getFilterFn(match));
	}
	traversing.filterArray = filterArray;
	/**
	 * Checks the current list of elements and returns `true` if _any_ of the
	 * elements match the selector. If using an element or Cheerio selection,
	 * returns `true` if _any_ of the elements match. If using a predicate function,
	 * the function is executed in the context of the selected element, so `this`
	 * refers to the current element.
	 *
	 * @category Attributes
	 * @param selector - Selector for the selection.
	 * @returns Whether or not the selector matches an element of the instance.
	 * @see {@link https://api.jquery.com/is/}
	 */
	function is(selector) {
	    var nodes = this.toArray();
	    return typeof selector === 'string'
	        ? select.some(nodes.filter(utils_js_1.isTag), selector, this.options)
	        : selector
	            ? nodes.some(getFilterFn(selector))
	            : false;
	}
	traversing.is = is;
	/**
	 * Remove elements from the set of matched elements. Given a Cheerio object that
	 * represents a set of DOM elements, the `.not()` method constructs a new
	 * Cheerio object from a subset of the matching elements. The supplied selector
	 * is tested against each element; the elements that don't match the selector
	 * will be included in the result.
	 *
	 * The `.not()` method can take a function as its argument in the same way that
	 * `.filter()` does. Elements for which the function returns `true` are excluded
	 * from the filtered set; all other elements are included.
	 *
	 * @category Traversing
	 * @example <caption>Selector</caption>
	 *
	 * ```js
	 * $('li').not('.apple').length;
	 * //=> 2
	 * ```
	 *
	 * @example <caption>Function</caption>
	 *
	 * ```js
	 * $('li').not(function (i, el) {
	 *   // this === el
	 *   return $(this).attr('class') === 'orange';
	 * }).length; //=> 2
	 * ```
	 *
	 * @param match - Value to look for, following the rules above.
	 * @param container - Optional node to filter instead.
	 * @returns The filtered collection.
	 * @see {@link https://api.jquery.com/not/}
	 */
	function not(match) {
	    var nodes = this.toArray();
	    if (typeof match === 'string') {
	        var matches_1 = new Set(select.filter(match, nodes, this.options));
	        nodes = nodes.filter(function (el) { return !matches_1.has(el); });
	    }
	    else {
	        var filterFn_1 = getFilterFn(match);
	        nodes = nodes.filter(function (el, i) { return !filterFn_1(el, i); });
	    }
	    return this._make(nodes);
	}
	traversing.not = not;
	/**
	 * Filters the set of matched elements to only those which have the given DOM
	 * element as a descendant or which have a descendant that matches the given
	 * selector. Equivalent to `.filter(':has(selector)')`.
	 *
	 * @category Traversing
	 * @example <caption>Selector</caption>
	 *
	 * ```js
	 * $('ul').has('.pear').attr('id');
	 * //=> fruits
	 * ```
	 *
	 * @example <caption>Element</caption>
	 *
	 * ```js
	 * $('ul').has($('.pear')[0]).attr('id');
	 * //=> fruits
	 * ```
	 *
	 * @param selectorOrHaystack - Element to look for.
	 * @returns The filtered collection.
	 * @see {@link https://api.jquery.com/has/}
	 */
	function has(selectorOrHaystack) {
	    var _this = this;
	    return this.filter(typeof selectorOrHaystack === 'string'
	        ? // Using the `:has` selector here short-circuits searches.
	            ":has(".concat(selectorOrHaystack, ")")
	        : function (_, el) { return _this._make(el).find(selectorOrHaystack).length > 0; });
	}
	traversing.has = has;
	/**
	 * Will select the first element of a cheerio object.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('#fruits').children().first().text();
	 * //=> Apple
	 * ```
	 *
	 * @returns The first element.
	 * @see {@link https://api.jquery.com/first/}
	 */
	function first() {
	    return this.length > 1 ? this._make(this[0]) : this;
	}
	traversing.first = first;
	/**
	 * Will select the last element of a cheerio object.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('#fruits').children().last().text();
	 * //=> Pear
	 * ```
	 *
	 * @returns The last element.
	 * @see {@link https://api.jquery.com/last/}
	 */
	function last() {
	    return this.length > 0 ? this._make(this[this.length - 1]) : this;
	}
	traversing.last = last;
	/**
	 * Reduce the set of matched elements to the one at the specified index. Use
	 * `.eq(-i)` to count backwards from the last selected element.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('li').eq(0).text();
	 * //=> Apple
	 *
	 * $('li').eq(-1).text();
	 * //=> Pear
	 * ```
	 *
	 * @param i - Index of the element to select.
	 * @returns The element at the `i`th position.
	 * @see {@link https://api.jquery.com/eq/}
	 */
	function eq(i) {
	    var _a;
	    i = +i;
	    // Use the first identity optimization if possible
	    if (i === 0 && this.length <= 1)
	        return this;
	    if (i < 0)
	        i = this.length + i;
	    return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);
	}
	traversing.eq = eq;
	function get(i) {
	    if (i == null) {
	        return this.toArray();
	    }
	    return this[i < 0 ? this.length + i : i];
	}
	traversing.get = get;
	/**
	 * Retrieve all the DOM elements contained in the jQuery set as an array.
	 *
	 * @example
	 *
	 * ```js
	 * $('li').toArray();
	 * //=> [ {...}, {...}, {...} ]
	 * ```
	 *
	 * @returns The contained items.
	 */
	function toArray() {
	    return Array.prototype.slice.call(this);
	}
	traversing.toArray = toArray;
	/**
	 * Search for a given element from among the matched elements.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.pear').index();
	 * //=> 2 $('.orange').index('li');
	 * //=> 1
	 * $('.apple').index($('#fruit, li'));
	 * //=> 1
	 * ```
	 *
	 * @param selectorOrNeedle - Element to look for.
	 * @returns The index of the element.
	 * @see {@link https://api.jquery.com/index/}
	 */
	function index(selectorOrNeedle) {
	    var $haystack;
	    var needle;
	    if (selectorOrNeedle == null) {
	        $haystack = this.parent().children();
	        needle = this[0];
	    }
	    else if (typeof selectorOrNeedle === 'string') {
	        $haystack = this._make(selectorOrNeedle);
	        needle = this[0];
	    }
	    else {
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        $haystack = this;
	        needle = (0, utils_js_1.isCheerio)(selectorOrNeedle)
	            ? selectorOrNeedle[0]
	            : selectorOrNeedle;
	    }
	    return Array.prototype.indexOf.call($haystack, needle);
	}
	traversing.index = index;
	/**
	 * Gets the elements matching the specified range (0-based position).
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('li').slice(1).eq(0).text();
	 * //=> 'Orange'
	 *
	 * $('li').slice(1, 2).length;
	 * //=> 1
	 * ```
	 *
	 * @param start - A position at which the elements begin to be selected. If
	 *   negative, it indicates an offset from the end of the set.
	 * @param end - A position at which the elements stop being selected. If
	 *   negative, it indicates an offset from the end of the set. If omitted, the
	 *   range continues until the end of the set.
	 * @returns The elements matching the specified range.
	 * @see {@link https://api.jquery.com/slice/}
	 */
	function slice(start, end) {
	    return this._make(Array.prototype.slice.call(this, start, end));
	}
	traversing.slice = slice;
	/**
	 * End the most recent filtering operation in the current chain and return the
	 * set of matched elements to its previous state.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('li').eq(0).end().length;
	 * //=> 3
	 * ```
	 *
	 * @returns The previous state of the set of matched elements.
	 * @see {@link https://api.jquery.com/end/}
	 */
	function end() {
	    var _a;
	    return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
	}
	traversing.end = end;
	/**
	 * Add elements to the set of matched elements.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('.apple').add('.orange').length;
	 * //=> 2
	 * ```
	 *
	 * @param other - Elements to add.
	 * @param context - Optionally the context of the new selection.
	 * @returns The combined set.
	 * @see {@link https://api.jquery.com/add/}
	 */
	function add(other, context) {
	    var selection = this._make(other, context);
	    var contents = (0, domutils_1.uniqueSort)(__spreadArray(__spreadArray([], this.get(), true), selection.get(), true));
	    return this._make(contents);
	}
	traversing.add = add;
	/**
	 * Add the previous set of elements on the stack to the current set, optionally
	 * filtered by a selector.
	 *
	 * @category Traversing
	 * @example
	 *
	 * ```js
	 * $('li').eq(0).addBack('.orange').length;
	 * //=> 2
	 * ```
	 *
	 * @param selector - Selector for the elements to add.
	 * @returns The combined set.
	 * @see {@link https://api.jquery.com/addBack/}
	 */
	function addBack(selector) {
	    return this.prevObject
	        ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)
	        : this;
	}
	traversing.addBack = addBack;
	
	return traversing;
}

var manipulation = {};

var parse$1 = {};

var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse$1;
	hasRequiredParse$1 = 1;
	Object.defineProperty(parse$1, "__esModule", { value: true });
	parse$1.update = parse$1.getParse = void 0;
	var domutils_1 = /*@__PURE__*/ requireLib$A();
	var domhandler_1 = /*@__PURE__*/ requireLib$B();
	/**
	 * Get the parse function with options.
	 *
	 * @param parser - The parser function.
	 * @returns The parse function with options.
	 */
	function getParse(parser) {
	    /**
	     * Parse a HTML string or a node.
	     *
	     * @param content - The HTML string or node.
	     * @param options - The parser options.
	     * @param isDocument - If `content` is a document.
	     * @param context - The context node in the DOM tree.
	     * @returns The parsed document node.
	     */
	    return function parse(content, options, isDocument, context) {
	        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {
	            content = content.toString();
	        }
	        if (typeof content === 'string') {
	            return parser(content, options, isDocument, context);
	        }
	        var doc = content;
	        if (!Array.isArray(doc) && (0, domhandler_1.isDocument)(doc)) {
	            // If `doc` is already a root, just return it
	            return doc;
	        }
	        // Add conent to new root element
	        var root = new domhandler_1.Document([]);
	        // Update the DOM using the root
	        update(doc, root);
	        return root;
	    };
	}
	parse$1.getParse = getParse;
	/**
	 * Update the dom structure, for one changed layer.
	 *
	 * @param newChilds - The new children.
	 * @param parent - The new parent.
	 * @returns The parent node.
	 */
	function update(newChilds, parent) {
	    // Normalize
	    var arr = Array.isArray(newChilds) ? newChilds : [newChilds];
	    // Update parent
	    if (parent) {
	        parent.children = arr;
	    }
	    else {
	        parent = null;
	    }
	    // Update neighbors
	    for (var i = 0; i < arr.length; i++) {
	        var node = arr[i];
	        // Cleanly remove existing nodes from their previous structures.
	        if (node.parent && node.parent.children !== arr) {
	            (0, domutils_1.removeElement)(node);
	        }
	        if (parent) {
	            node.prev = arr[i - 1] || null;
	            node.next = arr[i + 1] || null;
	        }
	        else {
	            node.prev = node.next = null;
	        }
	        node.parent = parent;
	    }
	    return parent;
	}
	parse$1.update = update;
	
	return parse$1;
}

var hasRequiredManipulation;

function requireManipulation () {
	if (hasRequiredManipulation) return manipulation;
	hasRequiredManipulation = 1;
	/**
	 * Methods for modifying the DOM structure.
	 *
	 * @module cheerio/manipulation
	 */
	var __spreadArray = (manipulation && manipulation.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(manipulation, "__esModule", { value: true });
	manipulation.clone = manipulation.text = manipulation.toString = manipulation.html = manipulation.empty = manipulation.replaceWith = manipulation.remove = manipulation.insertBefore = manipulation.before = manipulation.insertAfter = manipulation.after = manipulation.wrapAll = manipulation.unwrap = manipulation.wrapInner = manipulation.wrap = manipulation.prepend = manipulation.append = manipulation.prependTo = manipulation.appendTo = manipulation._makeDomArray = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$B();
	var parse_js_1 = requireParse$1();
	var static_js_1 = require_static();
	var utils_js_1 = requireUtils$2();
	var domutils_1 = /*@__PURE__*/ requireLib$A();
	/**
	 * Create an array of nodes, recursing into arrays and parsing strings if necessary.
	 *
	 * @private
	 * @category Manipulation
	 * @param elem - Elements to make an array of.
	 * @param clone - Optionally clone nodes.
	 * @returns The array of nodes.
	 */
	function _makeDomArray(elem, clone) {
	    var _this = this;
	    if (elem == null) {
	        return [];
	    }
	    if ((0, utils_js_1.isCheerio)(elem)) {
	        return clone ? (0, utils_js_1.cloneDom)(elem.get()) : elem.get();
	    }
	    if (Array.isArray(elem)) {
	        return elem.reduce(function (newElems, el) { return newElems.concat(_this._makeDomArray(el, clone)); }, []);
	    }
	    if (typeof elem === 'string') {
	        return this._parse(elem, this.options, false, null).children;
	    }
	    return clone ? (0, utils_js_1.cloneDom)([elem]) : [elem];
	}
	manipulation._makeDomArray = _makeDomArray;
	function _insert(concatenator) {
	    return function () {
	        var _this = this;
	        var elems = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            elems[_i] = arguments[_i];
	        }
	        var lastIdx = this.length - 1;
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            if (!(0, domhandler_1.hasChildren)(el))
	                return;
	            var domSrc = typeof elems[0] === 'function'
	                ? elems[0].call(el, i, _this._render(el.children))
	                : elems;
	            var dom = _this._makeDomArray(domSrc, i < lastIdx);
	            concatenator(dom, el.children, el);
	        });
	    };
	}
	/**
	 * Modify an array in-place, removing some number of elements and adding new
	 * elements directly following them.
	 *
	 * @private
	 * @category Manipulation
	 * @param array - Target array to splice.
	 * @param spliceIdx - Index at which to begin changing the array.
	 * @param spliceCount - Number of elements to remove from the array.
	 * @param newElems - Elements to insert into the array.
	 * @param parent - The parent of the node.
	 * @returns The spliced array.
	 */
	function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
	    var _a, _b;
	    var spliceArgs = __spreadArray([
	        spliceIdx,
	        spliceCount
	    ], newElems, true);
	    var prev = spliceIdx === 0 ? null : array[spliceIdx - 1];
	    var next = spliceIdx + spliceCount >= array.length
	        ? null
	        : array[spliceIdx + spliceCount];
	    /*
	     * Before splicing in new elements, ensure they do not already appear in the
	     * current array.
	     */
	    for (var idx = 0; idx < newElems.length; ++idx) {
	        var node = newElems[idx];
	        var oldParent = node.parent;
	        if (oldParent) {
	            var oldSiblings = oldParent.children;
	            var prevIdx = oldSiblings.indexOf(node);
	            if (prevIdx > -1) {
	                oldParent.children.splice(prevIdx, 1);
	                if (parent === oldParent && spliceIdx > prevIdx) {
	                    spliceArgs[0]--;
	                }
	            }
	        }
	        node.parent = parent;
	        if (node.prev) {
	            node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;
	        }
	        if (node.next) {
	            node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
	        }
	        node.prev = idx === 0 ? prev : newElems[idx - 1];
	        node.next = idx === newElems.length - 1 ? next : newElems[idx + 1];
	    }
	    if (prev) {
	        prev.next = newElems[0];
	    }
	    if (next) {
	        next.prev = newElems[newElems.length - 1];
	    }
	    return array.splice.apply(array, spliceArgs);
	}
	/**
	 * Insert every element in the set of matched elements to the end of the target.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('<li class="plum">Plum</li>').appendTo('#fruits');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //      <li class="plum">Plum</li>
	 * //    </ul>
	 * ```
	 *
	 * @param target - Element to append elements to.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/appendTo/}
	 */
	function appendTo(target) {
	    var appendTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);
	    appendTarget.append(this);
	    return this;
	}
	manipulation.appendTo = appendTo;
	/**
	 * Insert every element in the set of matched elements to the beginning of the target.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('<li class="plum">Plum</li>').prependTo('#fruits');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="plum">Plum</li>
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @param target - Element to prepend elements to.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/prependTo/}
	 */
	function prependTo(target) {
	    var prependTarget = (0, utils_js_1.isCheerio)(target) ? target : this._make(target);
	    prependTarget.prepend(this);
	    return this;
	}
	manipulation.prependTo = prependTo;
	/**
	 * Inserts content as the _last_ child of each of the selected elements.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('ul').append('<li class="plum">Plum</li>');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //      <li class="plum">Plum</li>
	 * //    </ul>
	 * ```
	 *
	 * @see {@link https://api.jquery.com/append/}
	 */
	manipulation.append = _insert(function (dom, children, parent) {
	    uniqueSplice(children, children.length, 0, dom, parent);
	});
	/**
	 * Inserts content as the _first_ child of each of the selected elements.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('ul').prepend('<li class="plum">Plum</li>');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="plum">Plum</li>
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @see {@link https://api.jquery.com/prepend/}
	 */
	manipulation.prepend = _insert(function (dom, children, parent) {
	    uniqueSplice(children, 0, 0, dom, parent);
	});
	function _wrap(insert) {
	    return function (wrapper) {
	        var lastIdx = this.length - 1;
	        var lastParent = this.parents().last();
	        for (var i = 0; i < this.length; i++) {
	            var el = this[i];
	            var wrap_1 = typeof wrapper === 'function'
	                ? wrapper.call(el, i, el)
	                : typeof wrapper === 'string' && !(0, utils_js_1.isHtml)(wrapper)
	                    ? lastParent.find(wrapper).clone()
	                    : wrapper;
	            var wrapperDom = this._makeDomArray(wrap_1, i < lastIdx)[0];
	            if (!wrapperDom || !(0, domhandler_1.hasChildren)(wrapperDom))
	                continue;
	            var elInsertLocation = wrapperDom;
	            /*
	             * Find the deepest child. Only consider the first tag child of each node
	             * (ignore text); stop if no children are found.
	             */
	            var j = 0;
	            while (j < elInsertLocation.children.length) {
	                var child = elInsertLocation.children[j];
	                if ((0, utils_js_1.isTag)(child)) {
	                    elInsertLocation = child;
	                    j = 0;
	                }
	                else {
	                    j++;
	                }
	            }
	            insert(el, elInsertLocation, [wrapperDom]);
	        }
	        return this;
	    };
	}
	/**
	 * The .wrap() function can take any string or object that could be passed to
	 * the $() factory function to specify a DOM structure. This structure may be
	 * nested several levels deep, but should contain only one inmost element. A
	 * copy of this structure will be wrapped around each of the elements in the set
	 * of matched elements. This method returns the original set of elements for
	 * chaining purposes.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * const redFruit = $('<div class="red-fruit"></div>');
	 * $('.apple').wrap(redFruit);
	 *
	 * //=> <ul id="fruits">
	 * //     <div class="red-fruit">
	 * //      <li class="apple">Apple</li>
	 * //     </div>
	 * //     <li class="orange">Orange</li>
	 * //     <li class="plum">Plum</li>
	 * //   </ul>
	 *
	 * const healthy = $('<div class="healthy"></div>');
	 * $('li').wrap(healthy);
	 *
	 * //=> <ul id="fruits">
	 * //     <div class="healthy">
	 * //       <li class="apple">Apple</li>
	 * //     </div>
	 * //     <div class="healthy">
	 * //       <li class="orange">Orange</li>
	 * //     </div>
	 * //     <div class="healthy">
	 * //        <li class="plum">Plum</li>
	 * //     </div>
	 * //   </ul>
	 * ```
	 *
	 * @param wrapper - The DOM structure to wrap around each element in the selection.
	 * @see {@link https://api.jquery.com/wrap/}
	 */
	manipulation.wrap = _wrap(function (el, elInsertLocation, wrapperDom) {
	    var parent = el.parent;
	    if (!parent)
	        return;
	    var siblings = parent.children;
	    var index = siblings.indexOf(el);
	    (0, parse_js_1.update)([el], elInsertLocation);
	    /*
	     * The previous operation removed the current element from the `siblings`
	     * array, so the `dom` array can be inserted without removing any
	     * additional elements.
	     */
	    uniqueSplice(siblings, index, 0, wrapperDom, parent);
	});
	/**
	 * The .wrapInner() function can take any string or object that could be passed
	 * to the $() factory function to specify a DOM structure. This structure may be
	 * nested several levels deep, but should contain only one inmost element. The
	 * structure will be wrapped around the content of each of the elements in the
	 * set of matched elements.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * const redFruit = $('<div class="red-fruit"></div>');
	 * $('.apple').wrapInner(redFruit);
	 *
	 * //=> <ul id="fruits">
	 * //     <li class="apple">
	 * //       <div class="red-fruit">Apple</div>
	 * //     </li>
	 * //     <li class="orange">Orange</li>
	 * //     <li class="pear">Pear</li>
	 * //   </ul>
	 *
	 * const healthy = $('<div class="healthy"></div>');
	 * $('li').wrapInner(healthy);
	 *
	 * //=> <ul id="fruits">
	 * //     <li class="apple">
	 * //       <div class="healthy">Apple</div>
	 * //     </li>
	 * //     <li class="orange">
	 * //       <div class="healthy">Orange</div>
	 * //     </li>
	 * //     <li class="pear">
	 * //       <div class="healthy">Pear</div>
	 * //     </li>
	 * //   </ul>
	 * ```
	 *
	 * @param wrapper - The DOM structure to wrap around the content of each element
	 *   in the selection.
	 * @returns The instance itself, for chaining.
	 * @see {@link https://api.jquery.com/wrapInner/}
	 */
	manipulation.wrapInner = _wrap(function (el, elInsertLocation, wrapperDom) {
	    if (!(0, domhandler_1.hasChildren)(el))
	        return;
	    (0, parse_js_1.update)(el.children, elInsertLocation);
	    (0, parse_js_1.update)(wrapperDom, el);
	});
	/**
	 * The .unwrap() function, removes the parents of the set of matched elements
	 * from the DOM, leaving the matched elements in their place.
	 *
	 * @category Manipulation
	 * @example <caption>without selector</caption>
	 *
	 * ```js
	 * const $ = cheerio.load(
	 *   '<div id=test>\n  <div><p>Hello</p></div>\n  <div><p>World</p></div>\n</div>'
	 * );
	 * $('#test p').unwrap();
	 *
	 * //=> <div id=test>
	 * //     <p>Hello</p>
	 * //     <p>World</p>
	 * //   </div>
	 * ```
	 *
	 * @example <caption>with selector</caption>
	 *
	 * ```js
	 * const $ = cheerio.load(
	 *   '<div id=test>\n  <p>Hello</p>\n  <b><p>World</p></b>\n</div>'
	 * );
	 * $('#test p').unwrap('b');
	 *
	 * //=> <div id=test>
	 * //     <p>Hello</p>
	 * //     <p>World</p>
	 * //   </div>
	 * ```
	 *
	 * @param selector - A selector to check the parent element against. If an
	 *   element's parent does not match the selector, the element won't be unwrapped.
	 * @returns The instance itself, for chaining.
	 * @see {@link https://api.jquery.com/unwrap/}
	 */
	function unwrap(selector) {
	    var _this = this;
	    this.parent(selector)
	        .not('body')
	        .each(function (_, el) {
	        _this._make(el).replaceWith(el.children);
	    });
	    return this;
	}
	manipulation.unwrap = unwrap;
	/**
	 * The .wrapAll() function can take any string or object that could be passed to
	 * the $() function to specify a DOM structure. This structure may be nested
	 * several levels deep, but should contain only one inmost element. The
	 * structure will be wrapped around all of the elements in the set of matched
	 * elements, as a single group.
	 *
	 * @category Manipulation
	 * @example <caption>With markup passed to `wrapAll`</caption>
	 *
	 * ```js
	 * const $ = cheerio.load(
	 *   '<div class="container"><div class="inner">First</div><div class="inner">Second</div></div>'
	 * );
	 * $('.inner').wrapAll("<div class='new'></div>");
	 *
	 * //=> <div class="container">
	 * //     <div class='new'>
	 * //       <div class="inner">First</div>
	 * //       <div class="inner">Second</div>
	 * //     </div>
	 * //   </div>
	 * ```
	 *
	 * @example <caption>With an existing cheerio instance</caption>
	 *
	 * ```js
	 * const $ = cheerio.load(
	 *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'
	 * );
	 * const wrap = $('<div><p><em><b></b></em></p></div>');
	 * $('span').wrapAll(wrap);
	 *
	 * //=> <div>
	 * //     <p>
	 * //       <em>
	 * //         <b>
	 * //           <span>Span 1</span>
	 * //           <span>Span 2</span>
	 * //         </b>
	 * //       </em>
	 * //     </p>
	 * //   </div>
	 * //   <strong>Strong</strong>
	 * ```
	 *
	 * @param wrapper - The DOM structure to wrap around all matched elements in the
	 *   selection.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/wrapAll/}
	 */
	function wrapAll(wrapper) {
	    var el = this[0];
	    if (el) {
	        var wrap_2 = this._make(typeof wrapper === 'function' ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
	        // If html is given as wrapper, wrap may contain text elements
	        var elInsertLocation = void 0;
	        for (var i = 0; i < wrap_2.length; i++) {
	            if (wrap_2[i].type === 'tag')
	                elInsertLocation = wrap_2[i];
	        }
	        var j = 0;
	        /*
	         * Find the deepest child. Only consider the first tag child of each node
	         * (ignore text); stop if no children are found.
	         */
	        while (elInsertLocation && j < elInsertLocation.children.length) {
	            var child = elInsertLocation.children[j];
	            if (child.type === 'tag') {
	                elInsertLocation = child;
	                j = 0;
	            }
	            else {
	                j++;
	            }
	        }
	        if (elInsertLocation)
	            this._make(elInsertLocation).append(this);
	    }
	    return this;
	}
	manipulation.wrapAll = wrapAll;
	/* eslint-disable jsdoc/check-param-names*/
	/**
	 * Insert content next to each element in the set of matched elements.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('.apple').after('<li class="plum">Plum</li>');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="apple">Apple</li>
	 * //      <li class="plum">Plum</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
	 *   to insert after each element in the set of matched elements.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/after/}
	 */
	function after() {
	    var _this = this;
	    var elems = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        elems[_i] = arguments[_i];
	    }
	    var lastIdx = this.length - 1;
	    return (0, utils_js_1.domEach)(this, function (el, i) {
	        var parent = el.parent;
	        if (!(0, domhandler_1.hasChildren)(el) || !parent) {
	            return;
	        }
	        var siblings = parent.children;
	        var index = siblings.indexOf(el);
	        // If not found, move on
	        /* istanbul ignore next */
	        if (index < 0)
	            return;
	        var domSrc = typeof elems[0] === 'function'
	            ? elems[0].call(el, i, _this._render(el.children))
	            : elems;
	        var dom = _this._makeDomArray(domSrc, i < lastIdx);
	        // Add element after `this` element
	        uniqueSplice(siblings, index + 1, 0, dom, parent);
	    });
	}
	manipulation.after = after;
	/* eslint-enable jsdoc/check-param-names*/
	/**
	 * Insert every element in the set of matched elements after the target.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('<li class="plum">Plum</li>').insertAfter('.apple');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="apple">Apple</li>
	 * //      <li class="plum">Plum</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @param target - Element to insert elements after.
	 * @returns The set of newly inserted elements.
	 * @see {@link https://api.jquery.com/insertAfter/}
	 */
	function insertAfter(target) {
	    var _this = this;
	    if (typeof target === 'string') {
	        target = this._make(target);
	    }
	    this.remove();
	    var clones = [];
	    this._makeDomArray(target).forEach(function (el) {
	        var clonedSelf = _this.clone().toArray();
	        var parent = el.parent;
	        if (!parent) {
	            return;
	        }
	        var siblings = parent.children;
	        var index = siblings.indexOf(el);
	        // If not found, move on
	        /* istanbul ignore next */
	        if (index < 0)
	            return;
	        // Add cloned `this` element(s) after target element
	        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
	        clones.push.apply(clones, clonedSelf);
	    });
	    return this._make(clones);
	}
	manipulation.insertAfter = insertAfter;
	/* eslint-disable jsdoc/check-param-names*/
	/**
	 * Insert content previous to each element in the set of matched elements.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('.apple').before('<li class="plum">Plum</li>');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="plum">Plum</li>
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @param content - HTML string, DOM element, array of DOM elements or Cheerio
	 *   to insert before each element in the set of matched elements.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/before/}
	 */
	function before() {
	    var _this = this;
	    var elems = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        elems[_i] = arguments[_i];
	    }
	    var lastIdx = this.length - 1;
	    return (0, utils_js_1.domEach)(this, function (el, i) {
	        var parent = el.parent;
	        if (!(0, domhandler_1.hasChildren)(el) || !parent) {
	            return;
	        }
	        var siblings = parent.children;
	        var index = siblings.indexOf(el);
	        // If not found, move on
	        /* istanbul ignore next */
	        if (index < 0)
	            return;
	        var domSrc = typeof elems[0] === 'function'
	            ? elems[0].call(el, i, _this._render(el.children))
	            : elems;
	        var dom = _this._makeDomArray(domSrc, i < lastIdx);
	        // Add element before `el` element
	        uniqueSplice(siblings, index, 0, dom, parent);
	    });
	}
	manipulation.before = before;
	/* eslint-enable jsdoc/check-param-names*/
	/**
	 * Insert every element in the set of matched elements before the target.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('<li class="plum">Plum</li>').insertBefore('.apple');
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="plum">Plum</li>
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //      <li class="pear">Pear</li>
	 * //    </ul>
	 * ```
	 *
	 * @param target - Element to insert elements before.
	 * @returns The set of newly inserted elements.
	 * @see {@link https://api.jquery.com/insertBefore/}
	 */
	function insertBefore(target) {
	    var _this = this;
	    var targetArr = this._make(target);
	    this.remove();
	    var clones = [];
	    (0, utils_js_1.domEach)(targetArr, function (el) {
	        var clonedSelf = _this.clone().toArray();
	        var parent = el.parent;
	        if (!parent) {
	            return;
	        }
	        var siblings = parent.children;
	        var index = siblings.indexOf(el);
	        // If not found, move on
	        /* istanbul ignore next */
	        if (index < 0)
	            return;
	        // Add cloned `this` element(s) after target element
	        uniqueSplice(siblings, index, 0, clonedSelf, parent);
	        clones.push.apply(clones, clonedSelf);
	    });
	    return this._make(clones);
	}
	manipulation.insertBefore = insertBefore;
	/**
	 * Removes the set of matched elements from the DOM and all their children.
	 * `selector` filters the set of matched elements to be removed.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('.pear').remove();
	 * $.html();
	 * //=>  <ul id="fruits">
	 * //      <li class="apple">Apple</li>
	 * //      <li class="orange">Orange</li>
	 * //    </ul>
	 * ```
	 *
	 * @param selector - Optional selector for elements to remove.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/remove/}
	 */
	function remove(selector) {
	    // Filter if we have selector
	    var elems = selector ? this.filter(selector) : this;
	    (0, utils_js_1.domEach)(elems, function (el) {
	        (0, domutils_1.removeElement)(el);
	        el.prev = el.next = el.parent = null;
	    });
	    return this;
	}
	manipulation.remove = remove;
	/**
	 * Replaces matched elements with `content`.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * const plum = $('<li class="plum">Plum</li>');
	 * $('.pear').replaceWith(plum);
	 * $.html();
	 * //=> <ul id="fruits">
	 * //     <li class="apple">Apple</li>
	 * //     <li class="orange">Orange</li>
	 * //     <li class="plum">Plum</li>
	 * //   </ul>
	 * ```
	 *
	 * @param content - Replacement for matched elements.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/replaceWith/}
	 */
	function replaceWith(content) {
	    var _this = this;
	    return (0, utils_js_1.domEach)(this, function (el, i) {
	        var parent = el.parent;
	        if (!parent) {
	            return;
	        }
	        var siblings = parent.children;
	        var cont = typeof content === 'function' ? content.call(el, i, el) : content;
	        var dom = _this._makeDomArray(cont);
	        /*
	         * In the case that `dom` contains nodes that already exist in other
	         * structures, ensure those nodes are properly removed.
	         */
	        (0, parse_js_1.update)(dom, null);
	        var index = siblings.indexOf(el);
	        // Completely remove old element
	        uniqueSplice(siblings, index, 1, dom, parent);
	        if (!dom.includes(el)) {
	            el.parent = el.prev = el.next = null;
	        }
	    });
	}
	manipulation.replaceWith = replaceWith;
	/**
	 * Empties an element, removing all its children.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * $('ul').empty();
	 * $.html();
	 * //=>  <ul id="fruits"></ul>
	 * ```
	 *
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/empty/}
	 */
	function empty() {
	    return (0, utils_js_1.domEach)(this, function (el) {
	        if (!(0, domhandler_1.hasChildren)(el))
	            return;
	        el.children.forEach(function (child) {
	            child.next = child.prev = child.parent = null;
	        });
	        el.children.length = 0;
	    });
	}
	manipulation.empty = empty;
	function html(str) {
	    var _this = this;
	    if (str === undefined) {
	        var el = this[0];
	        if (!el || !(0, domhandler_1.hasChildren)(el))
	            return null;
	        return this._render(el.children);
	    }
	    return (0, utils_js_1.domEach)(this, function (el) {
	        if (!(0, domhandler_1.hasChildren)(el))
	            return;
	        el.children.forEach(function (child) {
	            child.next = child.prev = child.parent = null;
	        });
	        var content = (0, utils_js_1.isCheerio)(str)
	            ? str.toArray()
	            : _this._parse("".concat(str), _this.options, false, el).children;
	        (0, parse_js_1.update)(content, el);
	    });
	}
	manipulation.html = html;
	/**
	 * Turns the collection to a string. Alias for `.html()`.
	 *
	 * @category Manipulation
	 * @returns The rendered document.
	 */
	function toString() {
	    return this._render(this);
	}
	manipulation.toString = toString;
	function text(str) {
	    var _this = this;
	    // If `str` is undefined, act as a "getter"
	    if (str === undefined) {
	        return (0, static_js_1.text)(this);
	    }
	    if (typeof str === 'function') {
	        // Function support
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            return _this._make(el).text(str.call(el, i, (0, static_js_1.text)([el])));
	        });
	    }
	    // Append text node to each selected elements
	    return (0, utils_js_1.domEach)(this, function (el) {
	        if (!(0, domhandler_1.hasChildren)(el))
	            return;
	        el.children.forEach(function (child) {
	            child.next = child.prev = child.parent = null;
	        });
	        var textNode = new domhandler_1.Text("".concat(str));
	        (0, parse_js_1.update)(textNode, el);
	    });
	}
	manipulation.text = text;
	/**
	 * Clone the cheerio object.
	 *
	 * @category Manipulation
	 * @example
	 *
	 * ```js
	 * const moreFruit = $('#fruits').clone();
	 * ```
	 *
	 * @returns The cloned object.
	 * @see {@link https://api.jquery.com/clone/}
	 */
	function clone() {
	    return this._make((0, utils_js_1.cloneDom)(this.get()));
	}
	manipulation.clone = clone;
	
	return manipulation;
}

var css$1 = {};

var hasRequiredCss$1;

function requireCss$1 () {
	if (hasRequiredCss$1) return css$1;
	hasRequiredCss$1 = 1;
	Object.defineProperty(css$1, "__esModule", { value: true });
	css$1.css = void 0;
	var utils_js_1 = requireUtils$2();
	/**
	 * Set multiple CSS properties for every matched element.
	 *
	 * @category CSS
	 * @param prop - The names of the properties.
	 * @param val - The new values.
	 * @returns The instance itself.
	 * @see {@link https://api.jquery.com/css/}
	 */
	function css(prop, val) {
	    if ((prop != null && val != null) ||
	        // When `prop` is a "plain" object
	        (typeof prop === 'object' && !Array.isArray(prop))) {
	        return (0, utils_js_1.domEach)(this, function (el, i) {
	            if ((0, utils_js_1.isTag)(el)) {
	                // `prop` can't be an array here anymore.
	                setCss(el, prop, val, i);
	            }
	        });
	    }
	    if (this.length === 0) {
	        return undefined;
	    }
	    return getCss(this[0], prop);
	}
	css$1.css = css;
	/**
	 * Set styles of all elements.
	 *
	 * @private
	 * @param el - Element to set style of.
	 * @param prop - Name of property.
	 * @param value - Value to set property to.
	 * @param idx - Optional index within the selection.
	 */
	function setCss(el, prop, value, idx) {
	    if (typeof prop === 'string') {
	        var styles = getCss(el);
	        var val = typeof value === 'function' ? value.call(el, idx, styles[prop]) : value;
	        if (val === '') {
	            delete styles[prop];
	        }
	        else if (val != null) {
	            styles[prop] = val;
	        }
	        el.attribs['style'] = stringify(styles);
	    }
	    else if (typeof prop === 'object') {
	        Object.keys(prop).forEach(function (k, i) {
	            setCss(el, k, prop[k], i);
	        });
	    }
	}
	function getCss(el, prop) {
	    if (!el || !(0, utils_js_1.isTag)(el))
	        return;
	    var styles = parse(el.attribs['style']);
	    if (typeof prop === 'string') {
	        return styles[prop];
	    }
	    if (Array.isArray(prop)) {
	        var newStyles_1 = {};
	        prop.forEach(function (item) {
	            if (styles[item] != null) {
	                newStyles_1[item] = styles[item];
	            }
	        });
	        return newStyles_1;
	    }
	    return styles;
	}
	/**
	 * Stringify `obj` to styles.
	 *
	 * @private
	 * @category CSS
	 * @param obj - Object to stringify.
	 * @returns The serialized styles.
	 */
	function stringify(obj) {
	    return Object.keys(obj).reduce(function (str, prop) { return "".concat(str).concat(str ? ' ' : '').concat(prop, ": ").concat(obj[prop], ";"); }, '');
	}
	/**
	 * Parse `styles`.
	 *
	 * @private
	 * @category CSS
	 * @param styles - Styles to be parsed.
	 * @returns The parsed styles.
	 */
	function parse(styles) {
	    styles = (styles || '').trim();
	    if (!styles)
	        return {};
	    var obj = {};
	    var key;
	    for (var _i = 0, _a = styles.split(';'); _i < _a.length; _i++) {
	        var str = _a[_i];
	        var n = str.indexOf(':');
	        // If there is no :, or if it is the first/last character, add to the previous item's value
	        if (n < 1 || n === str.length - 1) {
	            var trimmed = str.trimEnd();
	            if (trimmed.length > 0 && key !== undefined) {
	                obj[key] += ";".concat(trimmed);
	            }
	        }
	        else {
	            key = str.slice(0, n).trim();
	            obj[key] = str.slice(n + 1).trim();
	        }
	    }
	    return obj;
	}
	
	return css$1;
}

var forms = {};

var hasRequiredForms;

function requireForms () {
	if (hasRequiredForms) return forms;
	hasRequiredForms = 1;
	Object.defineProperty(forms, "__esModule", { value: true });
	forms.serializeArray = forms.serialize = void 0;
	var utils_js_1 = requireUtils$2();
	/*
	 * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
	 * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
	 */
	var submittableSelector = 'input,select,textarea,keygen';
	var r20 = /%20/g;
	var rCRLF = /\r?\n/g;
	/**
	 * Encode a set of form elements as a string for submission.
	 *
	 * @category Forms
	 * @example
	 *
	 * ```js
	 * $('<form><input name="foo" value="bar" /></form>').serialize();
	 * //=> 'foo=bar'
	 * ```
	 *
	 * @returns The serialized form.
	 * @see {@link https://api.jquery.com/serialize/}
	 */
	function serialize() {
	    // Convert form elements into name/value objects
	    var arr = this.serializeArray();
	    // Serialize each element into a key/value string
	    var retArr = arr.map(function (data) {
	        return "".concat(encodeURIComponent(data.name), "=").concat(encodeURIComponent(data.value));
	    });
	    // Return the resulting serialization
	    return retArr.join('&').replace(r20, '+');
	}
	forms.serialize = serialize;
	/**
	 * Encode a set of form elements as an array of names and values.
	 *
	 * @category Forms
	 * @example
	 *
	 * ```js
	 * $('<form><input name="foo" value="bar" /></form>').serializeArray();
	 * //=> [ { name: 'foo', value: 'bar' } ]
	 * ```
	 *
	 * @returns The serialized form.
	 * @see {@link https://api.jquery.com/serializeArray/}
	 */
	function serializeArray() {
	    var _this = this;
	    // Resolve all form elements from either forms or collections of form elements
	    return this.map(function (_, elem) {
	        var $elem = _this._make(elem);
	        if ((0, utils_js_1.isTag)(elem) && elem.name === 'form') {
	            return $elem.find(submittableSelector).toArray();
	        }
	        return $elem.filter(submittableSelector).toArray();
	    })
	        .filter(
	    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
	    '[name!=""]:enabled' +
	        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
	        ':not(:submit, :button, :image, :reset, :file)' +
	        // And are either checked/don't have a checkable state
	        ':matches([checked], :not(:checkbox, :radio))'
	    // Convert each of the elements to its value(s)
	    )
	        .map(function (_, elem) {
	        var _a;
	        var $elem = _this._make(elem);
	        var name = $elem.attr('name'); // We have filtered for elements with a name before.
	        // If there is no value set (e.g. `undefined`, `null`), then default value to empty
	        var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';
	        // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
	        if (Array.isArray(value)) {
	            return value.map(function (val) {
	                /*
	                 * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
	                 * These can occur inside of `<textarea>'s`
	                 */
	                return ({ name: name, value: val.replace(rCRLF, '\r\n') });
	            });
	        }
	        // Otherwise (e.g. `<input type="text">`, return only one key/value pair
	        return { name: name, value: value.replace(rCRLF, '\r\n') };
	    })
	        .toArray();
	}
	forms.serializeArray = serializeArray;
	
	return forms;
}

var hasRequiredCheerio$1;

function requireCheerio$1 () {
	if (hasRequiredCheerio$1) return cheerio;
	hasRequiredCheerio$1 = 1;
	var __createBinding = (cheerio && cheerio.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (cheerio && cheerio.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (cheerio && cheerio.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(cheerio, "__esModule", { value: true });
	cheerio.Cheerio = void 0;
	var Attributes = __importStar(requireAttributes$1());
	var Traversing = __importStar(requireTraversing());
	var Manipulation = __importStar(requireManipulation());
	var Css = __importStar(requireCss$1());
	var Forms = __importStar(requireForms());
	var Cheerio = /** @class */ (function () {
	    /**
	     * Instance of cheerio. Methods are specified in the modules. Usage of this
	     * constructor is not recommended. Please use `$.load` instead.
	     *
	     * @private
	     * @param elements - The new selection.
	     * @param root - Sets the root node.
	     * @param options - Options for the instance.
	     */
	    function Cheerio(elements, root, options) {
	        this.length = 0;
	        this.options = options;
	        this._root = root;
	        if (elements) {
	            for (var idx = 0; idx < elements.length; idx++) {
	                this[idx] = elements[idx];
	            }
	            this.length = elements.length;
	        }
	    }
	    return Cheerio;
	}());
	cheerio.Cheerio = Cheerio;
	/** Set a signature of the object. */
	Cheerio.prototype.cheerio = '[cheerio object]';
	/*
	 * Make cheerio an array-like object
	 */
	Cheerio.prototype.splice = Array.prototype.splice;
	// Support for (const element of $(...)) iteration:
	Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
	// Plug in the API
	Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);
	
	return cheerio;
}

var hasRequiredLoad;

function requireLoad () {
	if (hasRequiredLoad) return load;
	hasRequiredLoad = 1;
	var __extends = (load && load.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (load && load.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __createBinding = (load && load.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (load && load.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (load && load.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(load, "__esModule", { value: true });
	load.getLoad = void 0;
	var options_js_1 = __importStar(requireOptions$5());
	var staticMethods = __importStar(require_static());
	var cheerio_js_1 = requireCheerio$1();
	var utils_js_1 = requireUtils$2();
	function getLoad(parse, render) {
	    /**
	     * Create a querying function, bound to a document created from the provided markup.
	     *
	     * Note that similar to web browser contexts, this operation may introduce
	     * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
	     * switch to fragment mode and disable this.
	     *
	     * @param content - Markup to be loaded.
	     * @param options - Options for the created instance.
	     * @param isDocument - Allows parser to be switched to fragment mode.
	     * @returns The loaded document.
	     * @see {@link https://cheerio.js.org#loading} for additional usage information.
	     */
	    return function load(content, options, isDocument) {
	        if (isDocument === void 0) { isDocument = true; }
	        if (content == null) {
	            throw new Error('cheerio.load() expects a string');
	        }
	        var internalOpts = __assign(__assign({}, options_js_1.default), (0, options_js_1.flatten)(options));
	        var initialRoot = parse(content, internalOpts, isDocument, null);
	        /** Create an extended class here, so that extensions only live on one instance. */
	        var LoadedCheerio = /** @class */ (function (_super) {
	            __extends(LoadedCheerio, _super);
	            function LoadedCheerio() {
	                return _super !== null && _super.apply(this, arguments) || this;
	            }
	            LoadedCheerio.prototype._make = function (selector, context) {
	                var cheerio = initialize(selector, context);
	                cheerio.prevObject = this;
	                return cheerio;
	            };
	            LoadedCheerio.prototype._parse = function (content, options, isDocument, context) {
	                return parse(content, options, isDocument, context);
	            };
	            LoadedCheerio.prototype._render = function (dom) {
	                return render(dom, this.options);
	            };
	            return LoadedCheerio;
	        }(cheerio_js_1.Cheerio));
	        function initialize(selector, context, root, opts) {
	            if (root === void 0) { root = initialRoot; }
	            // $($)
	            if (selector && (0, utils_js_1.isCheerio)(selector))
	                return selector;
	            var options = __assign(__assign({}, internalOpts), (0, options_js_1.flatten)(opts));
	            var r = typeof root === 'string'
	                ? [parse(root, options, false, null)]
	                : 'length' in root
	                    ? root
	                    : [root];
	            var rootInstance = (0, utils_js_1.isCheerio)(r)
	                ? r
	                : new LoadedCheerio(r, null, options);
	            // Add a cyclic reference, so that calling methods on `_root` never fails.
	            rootInstance._root = rootInstance;
	            // $(), $(null), $(undefined), $(false)
	            if (!selector) {
	                return new LoadedCheerio(undefined, rootInstance, options);
	            }
	            var elements = typeof selector === 'string' && (0, utils_js_1.isHtml)(selector)
	                ? // $(<html>)
	                    parse(selector, options, false, null).children
	                : isNode(selector)
	                    ? // $(dom)
	                        [selector]
	                    : Array.isArray(selector)
	                        ? // $([dom])
	                            selector
	                        : undefined;
	            var instance = new LoadedCheerio(elements, rootInstance, options);
	            if (elements) {
	                return instance;
	            }
	            if (typeof selector !== 'string') {
	                throw new Error('Unexpected type of selector');
	            }
	            // We know that our selector is a string now.
	            var search = selector;
	            var searchContext = !context
	                ? // If we don't have a context, maybe we have a root, from loading
	                    rootInstance
	                : typeof context === 'string'
	                    ? (0, utils_js_1.isHtml)(context)
	                        ? // $('li', '<ul>...</ul>')
	                            new LoadedCheerio([parse(context, options, false, null)], rootInstance, options)
	                        : // $('li', 'ul')
	                            ((search = "".concat(context, " ").concat(search)), rootInstance)
	                    : (0, utils_js_1.isCheerio)(context)
	                        ? // $('li', $)
	                            context
	                        : // $('li', node), $('li', [nodes])
	                            new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options);
	            // If we still don't have a context, return
	            if (!searchContext)
	                return instance;
	            /*
	             * #id, .class, tag
	             */
	            return searchContext.find(search);
	        }
	        // Add in static methods & properties
	        Object.assign(initialize, staticMethods, {
	            load: load,
	            // `_root` and `_options` are used in static methods.
	            _root: initialRoot,
	            _options: internalOpts,
	            // Add `fn` for plugins
	            fn: LoadedCheerio.prototype,
	            // Add the prototype here to maintain `instanceof` behavior.
	            prototype: LoadedCheerio.prototype,
	        });
	        return initialize;
	    };
	}
	load.getLoad = getLoad;
	function isNode(obj) {
	    return (!!obj.name ||
	        obj.type === 'root' ||
	        obj.type === 'text' ||
	        obj.type === 'comment');
	}
	
	return load;
}

var parse5Adapter = {};

var cjs$1 = {};

var parser$2 = {};

var tokenizer$3 = {};

var preprocessor = {};

var unicode = {};

var hasRequiredUnicode;

function requireUnicode () {
	if (hasRequiredUnicode) return unicode;
	hasRequiredUnicode = 1;
	Object.defineProperty(unicode, "__esModule", { value: true });
	unicode.SEQUENCES = unicode.CODE_POINTS = unicode.REPLACEMENT_CHARACTER = void 0;
	unicode.isSurrogate = isSurrogate;
	unicode.isSurrogatePair = isSurrogatePair;
	unicode.getSurrogatePairCodePoint = getSurrogatePairCodePoint;
	unicode.isControlCodePoint = isControlCodePoint;
	unicode.isUndefinedCodePoint = isUndefinedCodePoint;
	const UNDEFINED_CODE_POINTS = new Set([
	    65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214,
	    393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894,
	    720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574,
	    1048575, 1114110, 1114111,
	]);
	unicode.REPLACEMENT_CHARACTER = '\uFFFD';
	var CODE_POINTS;
	(function (CODE_POINTS) {
	    CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
	    CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
	    CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
	    CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
	    CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
	    CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
	    CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
	    CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
	    CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
	    CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
	    CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
	    CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
	    CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
	    CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
	    CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
	    CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
	    CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
	    CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
	    CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
	    CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
	    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
	    CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
	    CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
	    CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
	    CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
	    CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
	})(CODE_POINTS || (unicode.CODE_POINTS = CODE_POINTS = {}));
	unicode.SEQUENCES = {
	    DASH_DASH: '--',
	    CDATA_START: '[CDATA[',
	    DOCTYPE: 'doctype',
	    SCRIPT: 'script',
	    PUBLIC: 'public',
	    SYSTEM: 'system',
	};
	//Surrogates
	function isSurrogate(cp) {
	    return cp >= 55296 && cp <= 57343;
	}
	function isSurrogatePair(cp) {
	    return cp >= 56320 && cp <= 57343;
	}
	function getSurrogatePairCodePoint(cp1, cp2) {
	    return (cp1 - 55296) * 1024 + 9216 + cp2;
	}
	//NOTE: excluding NULL and ASCII whitespace
	function isControlCodePoint(cp) {
	    return ((cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
	        (cp >= 0x7f && cp <= 0x9f));
	}
	function isUndefinedCodePoint(cp) {
	    return (cp >= 64976 && cp <= 65007) || UNDEFINED_CODE_POINTS.has(cp);
	}
	return unicode;
}

var errorCodes = {};

var hasRequiredErrorCodes;

function requireErrorCodes () {
	if (hasRequiredErrorCodes) return errorCodes;
	hasRequiredErrorCodes = 1;
	Object.defineProperty(errorCodes, "__esModule", { value: true });
	errorCodes.ERR = void 0;
	var ERR;
	(function (ERR) {
	    ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
	    ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
	    ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
	    ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
	    ERR["endTagWithAttributes"] = "end-tag-with-attributes";
	    ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
	    ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
	    ERR["unexpectedNullCharacter"] = "unexpected-null-character";
	    ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
	    ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
	    ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
	    ERR["missingEndTagName"] = "missing-end-tag-name";
	    ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
	    ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
	    ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
	    ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
	    ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
	    ERR["eofBeforeTagName"] = "eof-before-tag-name";
	    ERR["eofInTag"] = "eof-in-tag";
	    ERR["missingAttributeValue"] = "missing-attribute-value";
	    ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
	    ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
	    ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
	    ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
	    ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
	    ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
	    ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
	    ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
	    ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
	    ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
	    ERR["cdataInHtmlContent"] = "cdata-in-html-content";
	    ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
	    ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
	    ERR["eofInDoctype"] = "eof-in-doctype";
	    ERR["nestedComment"] = "nested-comment";
	    ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
	    ERR["eofInComment"] = "eof-in-comment";
	    ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
	    ERR["eofInCdata"] = "eof-in-cdata";
	    ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
	    ERR["nullCharacterReference"] = "null-character-reference";
	    ERR["surrogateCharacterReference"] = "surrogate-character-reference";
	    ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
	    ERR["controlCharacterReference"] = "control-character-reference";
	    ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
	    ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
	    ERR["missingDoctypeName"] = "missing-doctype-name";
	    ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
	    ERR["duplicateAttribute"] = "duplicate-attribute";
	    ERR["nonConformingDoctype"] = "non-conforming-doctype";
	    ERR["missingDoctype"] = "missing-doctype";
	    ERR["misplacedDoctype"] = "misplaced-doctype";
	    ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
	    ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
	    ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
	    ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
	    ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
	    ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
	    ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
	    ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
	})(ERR || (errorCodes.ERR = ERR = {}));
	return errorCodes;
}

var hasRequiredPreprocessor;

function requirePreprocessor () {
	if (hasRequiredPreprocessor) return preprocessor;
	hasRequiredPreprocessor = 1;
	Object.defineProperty(preprocessor, "__esModule", { value: true });
	preprocessor.Preprocessor = void 0;
	const unicode_js_1 = requireUnicode();
	const error_codes_js_1 = requireErrorCodes();
	//Const
	const DEFAULT_BUFFER_WATERLINE = 1 << 16;
	//Preprocessor
	//NOTE: HTML input preprocessing
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
	class Preprocessor {
	    constructor(handler) {
	        this.handler = handler;
	        this.html = '';
	        this.pos = -1;
	        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0
	        this.lastGapPos = -2;
	        this.gapStack = [];
	        this.skipNextNewLine = false;
	        this.lastChunkWritten = false;
	        this.endOfChunkHit = false;
	        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
	        this.isEol = false;
	        this.lineStartPos = 0;
	        this.droppedBufferSize = 0;
	        this.line = 1;
	        //NOTE: avoid reporting errors twice on advance/retreat
	        this.lastErrOffset = -1;
	    }
	    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
	    get col() {
	        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
	    }
	    get offset() {
	        return this.droppedBufferSize + this.pos;
	    }
	    getError(code, cpOffset) {
	        const { line, col, offset } = this;
	        const startCol = col + cpOffset;
	        const startOffset = offset + cpOffset;
	        return {
	            code,
	            startLine: line,
	            endLine: line,
	            startCol,
	            endCol: startCol,
	            startOffset,
	            endOffset: startOffset,
	        };
	    }
	    _err(code) {
	        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
	            this.lastErrOffset = this.offset;
	            this.handler.onParseError(this.getError(code, 0));
	        }
	    }
	    _addGap() {
	        this.gapStack.push(this.lastGapPos);
	        this.lastGapPos = this.pos;
	    }
	    _processSurrogate(cp) {
	        //NOTE: try to peek a surrogate pair
	        if (this.pos !== this.html.length - 1) {
	            const nextCp = this.html.charCodeAt(this.pos + 1);
	            if ((0, unicode_js_1.isSurrogatePair)(nextCp)) {
	                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
	                this.pos++;
	                //NOTE: add a gap that should be avoided during retreat
	                this._addGap();
	                return (0, unicode_js_1.getSurrogatePairCodePoint)(cp, nextCp);
	            }
	        }
	        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.
	        else if (!this.lastChunkWritten) {
	            this.endOfChunkHit = true;
	            return unicode_js_1.CODE_POINTS.EOF;
	        }
	        //NOTE: isolated surrogate
	        this._err(error_codes_js_1.ERR.surrogateInInputStream);
	        return cp;
	    }
	    willDropParsedChunk() {
	        return this.pos > this.bufferWaterline;
	    }
	    dropParsedChunk() {
	        if (this.willDropParsedChunk()) {
	            this.html = this.html.substring(this.pos);
	            this.lineStartPos -= this.pos;
	            this.droppedBufferSize += this.pos;
	            this.pos = 0;
	            this.lastGapPos = -2;
	            this.gapStack.length = 0;
	        }
	    }
	    write(chunk, isLastChunk) {
	        if (this.html.length > 0) {
	            this.html += chunk;
	        }
	        else {
	            this.html = chunk;
	        }
	        this.endOfChunkHit = false;
	        this.lastChunkWritten = isLastChunk;
	    }
	    insertHtmlAtCurrentPos(chunk) {
	        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
	        this.endOfChunkHit = false;
	    }
	    startsWith(pattern, caseSensitive) {
	        // Check if our buffer has enough characters
	        if (this.pos + pattern.length > this.html.length) {
	            this.endOfChunkHit = !this.lastChunkWritten;
	            return false;
	        }
	        if (caseSensitive) {
	            return this.html.startsWith(pattern, this.pos);
	        }
	        for (let i = 0; i < pattern.length; i++) {
	            const cp = this.html.charCodeAt(this.pos + i) | 0x20;
	            if (cp !== pattern.charCodeAt(i)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    peek(offset) {
	        const pos = this.pos + offset;
	        if (pos >= this.html.length) {
	            this.endOfChunkHit = !this.lastChunkWritten;
	            return unicode_js_1.CODE_POINTS.EOF;
	        }
	        const code = this.html.charCodeAt(pos);
	        return code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1.CODE_POINTS.LINE_FEED : code;
	    }
	    advance() {
	        this.pos++;
	        //NOTE: LF should be in the last column of the line
	        if (this.isEol) {
	            this.isEol = false;
	            this.line++;
	            this.lineStartPos = this.pos;
	        }
	        if (this.pos >= this.html.length) {
	            this.endOfChunkHit = !this.lastChunkWritten;
	            return unicode_js_1.CODE_POINTS.EOF;
	        }
	        let cp = this.html.charCodeAt(this.pos);
	        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
	        if (cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
	            this.isEol = true;
	            this.skipNextNewLine = true;
	            return unicode_js_1.CODE_POINTS.LINE_FEED;
	        }
	        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
	        //must be ignored.
	        if (cp === unicode_js_1.CODE_POINTS.LINE_FEED) {
	            this.isEol = true;
	            if (this.skipNextNewLine) {
	                // `line` will be bumped again in the recursive call.
	                this.line--;
	                this.skipNextNewLine = false;
	                this._addGap();
	                return this.advance();
	            }
	        }
	        this.skipNextNewLine = false;
	        if ((0, unicode_js_1.isSurrogate)(cp)) {
	            cp = this._processSurrogate(cp);
	        }
	        //OPTIMIZATION: first check if code point is in the common allowed
	        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
	        //before going into detailed performance cost validation.
	        const isCommonValidRange = this.handler.onParseError === null ||
	            (cp > 0x1f && cp < 0x7f) ||
	            cp === unicode_js_1.CODE_POINTS.LINE_FEED ||
	            cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ||
	            (cp > 0x9f && cp < 64976);
	        if (!isCommonValidRange) {
	            this._checkForProblematicCharacters(cp);
	        }
	        return cp;
	    }
	    _checkForProblematicCharacters(cp) {
	        if ((0, unicode_js_1.isControlCodePoint)(cp)) {
	            this._err(error_codes_js_1.ERR.controlCharacterInInputStream);
	        }
	        else if ((0, unicode_js_1.isUndefinedCodePoint)(cp)) {
	            this._err(error_codes_js_1.ERR.noncharacterInInputStream);
	        }
	    }
	    retreat(count) {
	        this.pos -= count;
	        while (this.pos < this.lastGapPos) {
	            this.lastGapPos = this.gapStack.pop();
	            this.pos--;
	        }
	        this.isEol = false;
	    }
	}
	preprocessor.Preprocessor = Preprocessor;
	return preprocessor;
}

var token$2 = {};

var hasRequiredToken$2;

function requireToken$2 () {
	if (hasRequiredToken$2) return token$2;
	hasRequiredToken$2 = 1;
	Object.defineProperty(token$2, "__esModule", { value: true });
	token$2.TokenType = void 0;
	token$2.getTokenAttr = getTokenAttr;
	var TokenType;
	(function (TokenType) {
	    TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
	    TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
	    TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
	    TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
	    TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
	    TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
	    TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
	    TokenType[TokenType["EOF"] = 7] = "EOF";
	    TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
	})(TokenType || (token$2.TokenType = TokenType = {}));
	function getTokenAttr(token, attrName) {
	    for (let i = token.attrs.length - 1; i >= 0; i--) {
	        if (token.attrs[i].name === attrName) {
	            return token.attrs[i].value;
	        }
	    }
	    return null;
	}
	return token$2;
}

var decode$1 = {};

var decodeDataHtml$1 = {};

var hasRequiredDecodeDataHtml$1;

function requireDecodeDataHtml$1 () {
	if (hasRequiredDecodeDataHtml$1) return decodeDataHtml$1;
	hasRequiredDecodeDataHtml$1 = 1;
	// Generated using scripts/write-decode-map.ts
	Object.defineProperty(decodeDataHtml$1, "__esModule", { value: true });
	decodeDataHtml$1.htmlDecodeTree = void 0;
	decodeDataHtml$1.htmlDecodeTree = new Uint16Array(
	// prettier-ignore
	/* #__PURE__ */ "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
	    .split("")
	    .map((c) => c.charCodeAt(0)));
	
	return decodeDataHtml$1;
}

var decodeDataXml$1 = {};

var hasRequiredDecodeDataXml$1;

function requireDecodeDataXml$1 () {
	if (hasRequiredDecodeDataXml$1) return decodeDataXml$1;
	hasRequiredDecodeDataXml$1 = 1;
	// Generated using scripts/write-decode-map.ts
	Object.defineProperty(decodeDataXml$1, "__esModule", { value: true });
	decodeDataXml$1.xmlDecodeTree = void 0;
	decodeDataXml$1.xmlDecodeTree = new Uint16Array(
	// prettier-ignore
	/* #__PURE__ */ "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
	    .split("")
	    .map((c) => c.charCodeAt(0)));
	
	return decodeDataXml$1;
}

var decodeCodepoint = {};

var hasRequiredDecodeCodepoint;

function requireDecodeCodepoint () {
	if (hasRequiredDecodeCodepoint) return decodeCodepoint;
	hasRequiredDecodeCodepoint = 1;
	(function (exports$1) {
		// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
		var _a;
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.fromCodePoint = void 0;
		exports$1.replaceCodePoint = replaceCodePoint;
		exports$1.decodeCodePoint = decodeCodePoint;
		const decodeMap = new Map([
		    [0, 65533],
		    // C1 Unicode control character reference replacements
		    [128, 8364],
		    [130, 8218],
		    [131, 402],
		    [132, 8222],
		    [133, 8230],
		    [134, 8224],
		    [135, 8225],
		    [136, 710],
		    [137, 8240],
		    [138, 352],
		    [139, 8249],
		    [140, 338],
		    [142, 381],
		    [145, 8216],
		    [146, 8217],
		    [147, 8220],
		    [148, 8221],
		    [149, 8226],
		    [150, 8211],
		    [151, 8212],
		    [152, 732],
		    [153, 8482],
		    [154, 353],
		    [155, 8250],
		    [156, 339],
		    [158, 382],
		    [159, 376],
		]);
		/**
		 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
		 */
		exports$1.fromCodePoint = 
		// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
		(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
		    let output = "";
		    if (codePoint > 65535) {
		        codePoint -= 65536;
		        output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
		        codePoint = 56320 | (codePoint & 1023);
		    }
		    output += String.fromCharCode(codePoint);
		    return output;
		};
		/**
		 * Replace the given code point with a replacement character if it is a
		 * surrogate or is outside the valid range. Otherwise return the code
		 * point unchanged.
		 */
		function replaceCodePoint(codePoint) {
		    var _a;
		    if ((codePoint >= 55296 && codePoint <= 57343) ||
		        codePoint > 1114111) {
		        return 65533;
		    }
		    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
		}
		/**
		 * Replace the code point if relevant, then convert it to a string.
		 *
		 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
		 * @param codePoint The code point to decode.
		 * @returns The decoded code point.
		 */
		function decodeCodePoint(codePoint) {
		    return (0, exports$1.fromCodePoint)(replaceCodePoint(codePoint));
		}
		
	} (decodeCodepoint));
	return decodeCodepoint;
}

var hasRequiredDecode$1;

function requireDecode$1 () {
	if (hasRequiredDecode$1) return decode$1;
	hasRequiredDecode$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.fromCodePoint = exports$1.replaceCodePoint = exports$1.decodeCodePoint = exports$1.xmlDecodeTree = exports$1.htmlDecodeTree = exports$1.EntityDecoder = exports$1.DecodingMode = exports$1.BinTrieFlags = void 0;
		exports$1.determineBranch = determineBranch;
		exports$1.decodeHTML = decodeHTML;
		exports$1.decodeHTMLAttribute = decodeHTMLAttribute;
		exports$1.decodeHTMLStrict = decodeHTMLStrict;
		exports$1.decodeXML = decodeXML;
		const decode_data_html_js_1 = requireDecodeDataHtml$1();
		const decode_data_xml_js_1 = requireDecodeDataXml$1();
		const decode_codepoint_js_1 = requireDecodeCodepoint();
		var CharCodes;
		(function (CharCodes) {
		    CharCodes[CharCodes["NUM"] = 35] = "NUM";
		    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
		    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
		    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
		    CharCodes[CharCodes["NINE"] = 57] = "NINE";
		    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
		    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
		    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
		    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
		    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
		    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
		    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
		})(CharCodes || (CharCodes = {}));
		/** Bit that needs to be set to convert an upper case ASCII character to lower case */
		const TO_LOWER_BIT = 32;
		var BinTrieFlags;
		(function (BinTrieFlags) {
		    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
		    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
		    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
		})(BinTrieFlags || (exports$1.BinTrieFlags = BinTrieFlags = {}));
		function isNumber(code) {
		    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
		}
		function isHexadecimalCharacter(code) {
		    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
		        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
		}
		function isAsciiAlphaNumeric(code) {
		    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
		        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
		        isNumber(code));
		}
		/**
		 * Checks if the given character is a valid end character for an entity in an attribute.
		 *
		 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
		 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
		 */
		function isEntityInAttributeInvalidEnd(code) {
		    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
		}
		var EntityDecoderState;
		(function (EntityDecoderState) {
		    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
		    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
		    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
		    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
		    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
		})(EntityDecoderState || (EntityDecoderState = {}));
		var DecodingMode;
		(function (DecodingMode) {
		    /** Entities in text nodes that can end with any character. */
		    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
		    /** Only allow entities terminated with a semicolon. */
		    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
		    /** Entities in attributes have limitations on ending characters. */
		    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
		})(DecodingMode || (exports$1.DecodingMode = DecodingMode = {}));
		/**
		 * Token decoder with support of writing partial entities.
		 */
		class EntityDecoder {
		    constructor(
		    /** The tree used to decode entities. */
		    decodeTree, 
		    /**
		     * The function that is called when a codepoint is decoded.
		     *
		     * For multi-byte named entities, this will be called multiple times,
		     * with the second codepoint, and the same `consumed` value.
		     *
		     * @param codepoint The decoded codepoint.
		     * @param consumed The number of bytes consumed by the decoder.
		     */
		    emitCodePoint, 
		    /** An object that is used to produce errors. */
		    errors) {
		        this.decodeTree = decodeTree;
		        this.emitCodePoint = emitCodePoint;
		        this.errors = errors;
		        /** The current state of the decoder. */
		        this.state = EntityDecoderState.EntityStart;
		        /** Characters that were consumed while parsing an entity. */
		        this.consumed = 1;
		        /**
		         * The result of the entity.
		         *
		         * Either the result index of a numeric entity, or the codepoint of a
		         * numeric entity.
		         */
		        this.result = 0;
		        /** The current index in the decode tree. */
		        this.treeIndex = 0;
		        /** The number of characters that were consumed in excess. */
		        this.excess = 1;
		        /** The mode in which the decoder is operating. */
		        this.decodeMode = DecodingMode.Strict;
		    }
		    /** Resets the instance to make it reusable. */
		    startEntity(decodeMode) {
		        this.decodeMode = decodeMode;
		        this.state = EntityDecoderState.EntityStart;
		        this.result = 0;
		        this.treeIndex = 0;
		        this.excess = 1;
		        this.consumed = 1;
		    }
		    /**
		     * Write an entity to the decoder. This can be called multiple times with partial entities.
		     * If the entity is incomplete, the decoder will return -1.
		     *
		     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
		     * entity is incomplete, and resume when the next string is written.
		     *
		     * @param input The string containing the entity (or a continuation of the entity).
		     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    write(input, offset) {
		        switch (this.state) {
		            case EntityDecoderState.EntityStart: {
		                if (input.charCodeAt(offset) === CharCodes.NUM) {
		                    this.state = EntityDecoderState.NumericStart;
		                    this.consumed += 1;
		                    return this.stateNumericStart(input, offset + 1);
		                }
		                this.state = EntityDecoderState.NamedEntity;
		                return this.stateNamedEntity(input, offset);
		            }
		            case EntityDecoderState.NumericStart: {
		                return this.stateNumericStart(input, offset);
		            }
		            case EntityDecoderState.NumericDecimal: {
		                return this.stateNumericDecimal(input, offset);
		            }
		            case EntityDecoderState.NumericHex: {
		                return this.stateNumericHex(input, offset);
		            }
		            case EntityDecoderState.NamedEntity: {
		                return this.stateNamedEntity(input, offset);
		            }
		        }
		    }
		    /**
		     * Switches between the numeric decimal and hexadecimal states.
		     *
		     * Equivalent to the `Numeric character reference state` in the HTML spec.
		     *
		     * @param input The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    stateNumericStart(input, offset) {
		        if (offset >= input.length) {
		            return -1;
		        }
		        if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
		            this.state = EntityDecoderState.NumericHex;
		            this.consumed += 1;
		            return this.stateNumericHex(input, offset + 1);
		        }
		        this.state = EntityDecoderState.NumericDecimal;
		        return this.stateNumericDecimal(input, offset);
		    }
		    addToNumericResult(input, start, end, base) {
		        if (start !== end) {
		            const digitCount = end - start;
		            this.result =
		                this.result * Math.pow(base, digitCount) +
		                    Number.parseInt(input.substr(start, digitCount), base);
		            this.consumed += digitCount;
		        }
		    }
		    /**
		     * Parses a hexadecimal numeric entity.
		     *
		     * Equivalent to the `Hexademical character reference state` in the HTML spec.
		     *
		     * @param input The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    stateNumericHex(input, offset) {
		        const startIndex = offset;
		        while (offset < input.length) {
		            const char = input.charCodeAt(offset);
		            if (isNumber(char) || isHexadecimalCharacter(char)) {
		                offset += 1;
		            }
		            else {
		                this.addToNumericResult(input, startIndex, offset, 16);
		                return this.emitNumericEntity(char, 3);
		            }
		        }
		        this.addToNumericResult(input, startIndex, offset, 16);
		        return -1;
		    }
		    /**
		     * Parses a decimal numeric entity.
		     *
		     * Equivalent to the `Decimal character reference state` in the HTML spec.
		     *
		     * @param input The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    stateNumericDecimal(input, offset) {
		        const startIndex = offset;
		        while (offset < input.length) {
		            const char = input.charCodeAt(offset);
		            if (isNumber(char)) {
		                offset += 1;
		            }
		            else {
		                this.addToNumericResult(input, startIndex, offset, 10);
		                return this.emitNumericEntity(char, 2);
		            }
		        }
		        this.addToNumericResult(input, startIndex, offset, 10);
		        return -1;
		    }
		    /**
		     * Validate and emit a numeric entity.
		     *
		     * Implements the logic from the `Hexademical character reference start
		     * state` and `Numeric character reference end state` in the HTML spec.
		     *
		     * @param lastCp The last code point of the entity. Used to see if the
		     *               entity was terminated with a semicolon.
		     * @param expectedLength The minimum number of characters that should be
		     *                       consumed. Used to validate that at least one digit
		     *                       was consumed.
		     * @returns The number of characters that were consumed.
		     */
		    emitNumericEntity(lastCp, expectedLength) {
		        var _a;
		        // Ensure we consumed at least one digit.
		        if (this.consumed <= expectedLength) {
		            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
		            return 0;
		        }
		        // Figure out if this is a legit end of the entity
		        if (lastCp === CharCodes.SEMI) {
		            this.consumed += 1;
		        }
		        else if (this.decodeMode === DecodingMode.Strict) {
		            return 0;
		        }
		        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
		        if (this.errors) {
		            if (lastCp !== CharCodes.SEMI) {
		                this.errors.missingSemicolonAfterCharacterReference();
		            }
		            this.errors.validateNumericCharacterReference(this.result);
		        }
		        return this.consumed;
		    }
		    /**
		     * Parses a named entity.
		     *
		     * Equivalent to the `Named character reference state` in the HTML spec.
		     *
		     * @param input The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    stateNamedEntity(input, offset) {
		        const { decodeTree } = this;
		        let current = decodeTree[this.treeIndex];
		        // The mask is the number of bytes of the value, including the current byte.
		        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		        for (; offset < input.length; offset++, this.excess++) {
		            const char = input.charCodeAt(offset);
		            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
		            if (this.treeIndex < 0) {
		                return this.result === 0 ||
		                    // If we are parsing an attribute
		                    (this.decodeMode === DecodingMode.Attribute &&
		                        // We shouldn't have consumed any characters after the entity,
		                        (valueLength === 0 ||
		                            // And there should be no invalid characters.
		                            isEntityInAttributeInvalidEnd(char)))
		                    ? 0
		                    : this.emitNotTerminatedNamedEntity();
		            }
		            current = decodeTree[this.treeIndex];
		            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		            // If the branch is a value, store it and continue
		            if (valueLength !== 0) {
		                // If the entity is terminated by a semicolon, we are done.
		                if (char === CharCodes.SEMI) {
		                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
		                }
		                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
		                if (this.decodeMode !== DecodingMode.Strict) {
		                    this.result = this.treeIndex;
		                    this.consumed += this.excess;
		                    this.excess = 0;
		                }
		            }
		        }
		        return -1;
		    }
		    /**
		     * Emit a named entity that was not terminated with a semicolon.
		     *
		     * @returns The number of characters consumed.
		     */
		    emitNotTerminatedNamedEntity() {
		        var _a;
		        const { result, decodeTree } = this;
		        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		        this.emitNamedEntityData(result, valueLength, this.consumed);
		        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
		        return this.consumed;
		    }
		    /**
		     * Emit a named entity.
		     *
		     * @param result The index of the entity in the decode tree.
		     * @param valueLength The number of bytes in the entity.
		     * @param consumed The number of characters consumed.
		     *
		     * @returns The number of characters consumed.
		     */
		    emitNamedEntityData(result, valueLength, consumed) {
		        const { decodeTree } = this;
		        this.emitCodePoint(valueLength === 1
		            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
		            : decodeTree[result + 1], consumed);
		        if (valueLength === 3) {
		            // For multi-byte values, we need to emit the second byte.
		            this.emitCodePoint(decodeTree[result + 2], consumed);
		        }
		        return consumed;
		    }
		    /**
		     * Signal to the parser that the end of the input was reached.
		     *
		     * Remaining data will be emitted and relevant errors will be produced.
		     *
		     * @returns The number of characters consumed.
		     */
		    end() {
		        var _a;
		        switch (this.state) {
		            case EntityDecoderState.NamedEntity: {
		                // Emit a named entity if we have one.
		                return this.result !== 0 &&
		                    (this.decodeMode !== DecodingMode.Attribute ||
		                        this.result === this.treeIndex)
		                    ? this.emitNotTerminatedNamedEntity()
		                    : 0;
		            }
		            // Otherwise, emit a numeric entity if we have one.
		            case EntityDecoderState.NumericDecimal: {
		                return this.emitNumericEntity(0, 2);
		            }
		            case EntityDecoderState.NumericHex: {
		                return this.emitNumericEntity(0, 3);
		            }
		            case EntityDecoderState.NumericStart: {
		                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
		                return 0;
		            }
		            case EntityDecoderState.EntityStart: {
		                // Return 0 if we have no entity.
		                return 0;
		            }
		        }
		    }
		}
		exports$1.EntityDecoder = EntityDecoder;
		/**
		 * Creates a function that decodes entities in a string.
		 *
		 * @param decodeTree The decode tree.
		 * @returns A function that decodes entities in a string.
		 */
		function getDecoder(decodeTree) {
		    let returnValue = "";
		    const decoder = new EntityDecoder(decodeTree, (data) => (returnValue += (0, decode_codepoint_js_1.fromCodePoint)(data)));
		    return function decodeWithTrie(input, decodeMode) {
		        let lastIndex = 0;
		        let offset = 0;
		        while ((offset = input.indexOf("&", offset)) >= 0) {
		            returnValue += input.slice(lastIndex, offset);
		            decoder.startEntity(decodeMode);
		            const length = decoder.write(input, 
		            // Skip the "&"
		            offset + 1);
		            if (length < 0) {
		                lastIndex = offset + decoder.end();
		                break;
		            }
		            lastIndex = offset + length;
		            // If `length` is 0, skip the current `&` and continue.
		            offset = length === 0 ? lastIndex + 1 : lastIndex;
		        }
		        const result = returnValue + input.slice(lastIndex);
		        // Make sure we don't keep a reference to the final string.
		        returnValue = "";
		        return result;
		    };
		}
		/**
		 * Determines the branch of the current node that is taken given the current
		 * character. This function is used to traverse the trie.
		 *
		 * @param decodeTree The trie.
		 * @param current The current node.
		 * @param nodeIdx The index right after the current node and its value.
		 * @param char The current character.
		 * @returns The index of the next node, or -1 if no branch is taken.
		 */
		function determineBranch(decodeTree, current, nodeIndex, char) {
		    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
		    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
		    // Case 1: Single branch encoded in jump offset
		    if (branchCount === 0) {
		        return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
		    }
		    // Case 2: Multiple branches encoded in jump table
		    if (jumpOffset) {
		        const value = char - jumpOffset;
		        return value < 0 || value >= branchCount
		            ? -1
		            : decodeTree[nodeIndex + value] - 1;
		    }
		    // Case 3: Multiple branches encoded in dictionary
		    // Binary search for the character.
		    let lo = nodeIndex;
		    let hi = lo + branchCount - 1;
		    while (lo <= hi) {
		        const mid = (lo + hi) >>> 1;
		        const midValue = decodeTree[mid];
		        if (midValue < char) {
		            lo = mid + 1;
		        }
		        else if (midValue > char) {
		            hi = mid - 1;
		        }
		        else {
		            return decodeTree[mid + branchCount];
		        }
		    }
		    return -1;
		}
		const htmlDecoder = /* #__PURE__ */ getDecoder(decode_data_html_js_1.htmlDecodeTree);
		const xmlDecoder = /* #__PURE__ */ getDecoder(decode_data_xml_js_1.xmlDecodeTree);
		/**
		 * Decodes an HTML string.
		 *
		 * @param htmlString The string to decode.
		 * @param mode The decoding mode.
		 * @returns The decoded string.
		 */
		function decodeHTML(htmlString, mode = DecodingMode.Legacy) {
		    return htmlDecoder(htmlString, mode);
		}
		/**
		 * Decodes an HTML string in an attribute.
		 *
		 * @param htmlAttribute The string to decode.
		 * @returns The decoded string.
		 */
		function decodeHTMLAttribute(htmlAttribute) {
		    return htmlDecoder(htmlAttribute, DecodingMode.Attribute);
		}
		/**
		 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
		 *
		 * @param htmlString The string to decode.
		 * @returns The decoded string.
		 */
		function decodeHTMLStrict(htmlString) {
		    return htmlDecoder(htmlString, DecodingMode.Strict);
		}
		/**
		 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
		 *
		 * @param xmlString The string to decode.
		 * @returns The decoded string.
		 */
		function decodeXML(xmlString) {
		    return xmlDecoder(xmlString, DecodingMode.Strict);
		}
		// Re-export for use by eg. htmlparser2
		var decode_data_html_js_2 = requireDecodeDataHtml$1();
		Object.defineProperty(exports$1, "htmlDecodeTree", { enumerable: true, get: function () { return decode_data_html_js_2.htmlDecodeTree; } });
		var decode_data_xml_js_2 = requireDecodeDataXml$1();
		Object.defineProperty(exports$1, "xmlDecodeTree", { enumerable: true, get: function () { return decode_data_xml_js_2.xmlDecodeTree; } });
		var decode_codepoint_js_2 = requireDecodeCodepoint();
		Object.defineProperty(exports$1, "decodeCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.decodeCodePoint; } });
		Object.defineProperty(exports$1, "replaceCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });
		Object.defineProperty(exports$1, "fromCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });
		
	} (decode$1));
	return decode$1;
}

var html$1 = {};

var hasRequiredHtml$1;

function requireHtml$1 () {
	if (hasRequiredHtml$1) return html$1;
	hasRequiredHtml$1 = 1;
	Object.defineProperty(html$1, "__esModule", { value: true });
	html$1.NUMBERED_HEADERS = html$1.SPECIAL_ELEMENTS = html$1.TAG_ID = html$1.TAG_NAMES = html$1.DOCUMENT_MODE = html$1.ATTRS = html$1.NS = void 0;
	html$1.getTagID = getTagID;
	html$1.hasUnescapedText = hasUnescapedText;
	/** All valid namespaces in HTML. */
	var NS;
	(function (NS) {
	    NS["HTML"] = "http://www.w3.org/1999/xhtml";
	    NS["MATHML"] = "http://www.w3.org/1998/Math/MathML";
	    NS["SVG"] = "http://www.w3.org/2000/svg";
	    NS["XLINK"] = "http://www.w3.org/1999/xlink";
	    NS["XML"] = "http://www.w3.org/XML/1998/namespace";
	    NS["XMLNS"] = "http://www.w3.org/2000/xmlns/";
	})(NS || (html$1.NS = NS = {}));
	var ATTRS;
	(function (ATTRS) {
	    ATTRS["TYPE"] = "type";
	    ATTRS["ACTION"] = "action";
	    ATTRS["ENCODING"] = "encoding";
	    ATTRS["PROMPT"] = "prompt";
	    ATTRS["NAME"] = "name";
	    ATTRS["COLOR"] = "color";
	    ATTRS["FACE"] = "face";
	    ATTRS["SIZE"] = "size";
	})(ATTRS || (html$1.ATTRS = ATTRS = {}));
	/**
	 * The mode of the document.
	 *
	 * @see {@link https://dom.spec.whatwg.org/#concept-document-limited-quirks}
	 */
	var DOCUMENT_MODE;
	(function (DOCUMENT_MODE) {
	    DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
	    DOCUMENT_MODE["QUIRKS"] = "quirks";
	    DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
	})(DOCUMENT_MODE || (html$1.DOCUMENT_MODE = DOCUMENT_MODE = {}));
	var TAG_NAMES;
	(function (TAG_NAMES) {
	    TAG_NAMES["A"] = "a";
	    TAG_NAMES["ADDRESS"] = "address";
	    TAG_NAMES["ANNOTATION_XML"] = "annotation-xml";
	    TAG_NAMES["APPLET"] = "applet";
	    TAG_NAMES["AREA"] = "area";
	    TAG_NAMES["ARTICLE"] = "article";
	    TAG_NAMES["ASIDE"] = "aside";
	    TAG_NAMES["B"] = "b";
	    TAG_NAMES["BASE"] = "base";
	    TAG_NAMES["BASEFONT"] = "basefont";
	    TAG_NAMES["BGSOUND"] = "bgsound";
	    TAG_NAMES["BIG"] = "big";
	    TAG_NAMES["BLOCKQUOTE"] = "blockquote";
	    TAG_NAMES["BODY"] = "body";
	    TAG_NAMES["BR"] = "br";
	    TAG_NAMES["BUTTON"] = "button";
	    TAG_NAMES["CAPTION"] = "caption";
	    TAG_NAMES["CENTER"] = "center";
	    TAG_NAMES["CODE"] = "code";
	    TAG_NAMES["COL"] = "col";
	    TAG_NAMES["COLGROUP"] = "colgroup";
	    TAG_NAMES["DD"] = "dd";
	    TAG_NAMES["DESC"] = "desc";
	    TAG_NAMES["DETAILS"] = "details";
	    TAG_NAMES["DIALOG"] = "dialog";
	    TAG_NAMES["DIR"] = "dir";
	    TAG_NAMES["DIV"] = "div";
	    TAG_NAMES["DL"] = "dl";
	    TAG_NAMES["DT"] = "dt";
	    TAG_NAMES["EM"] = "em";
	    TAG_NAMES["EMBED"] = "embed";
	    TAG_NAMES["FIELDSET"] = "fieldset";
	    TAG_NAMES["FIGCAPTION"] = "figcaption";
	    TAG_NAMES["FIGURE"] = "figure";
	    TAG_NAMES["FONT"] = "font";
	    TAG_NAMES["FOOTER"] = "footer";
	    TAG_NAMES["FOREIGN_OBJECT"] = "foreignObject";
	    TAG_NAMES["FORM"] = "form";
	    TAG_NAMES["FRAME"] = "frame";
	    TAG_NAMES["FRAMESET"] = "frameset";
	    TAG_NAMES["H1"] = "h1";
	    TAG_NAMES["H2"] = "h2";
	    TAG_NAMES["H3"] = "h3";
	    TAG_NAMES["H4"] = "h4";
	    TAG_NAMES["H5"] = "h5";
	    TAG_NAMES["H6"] = "h6";
	    TAG_NAMES["HEAD"] = "head";
	    TAG_NAMES["HEADER"] = "header";
	    TAG_NAMES["HGROUP"] = "hgroup";
	    TAG_NAMES["HR"] = "hr";
	    TAG_NAMES["HTML"] = "html";
	    TAG_NAMES["I"] = "i";
	    TAG_NAMES["IMG"] = "img";
	    TAG_NAMES["IMAGE"] = "image";
	    TAG_NAMES["INPUT"] = "input";
	    TAG_NAMES["IFRAME"] = "iframe";
	    TAG_NAMES["KEYGEN"] = "keygen";
	    TAG_NAMES["LABEL"] = "label";
	    TAG_NAMES["LI"] = "li";
	    TAG_NAMES["LINK"] = "link";
	    TAG_NAMES["LISTING"] = "listing";
	    TAG_NAMES["MAIN"] = "main";
	    TAG_NAMES["MALIGNMARK"] = "malignmark";
	    TAG_NAMES["MARQUEE"] = "marquee";
	    TAG_NAMES["MATH"] = "math";
	    TAG_NAMES["MENU"] = "menu";
	    TAG_NAMES["META"] = "meta";
	    TAG_NAMES["MGLYPH"] = "mglyph";
	    TAG_NAMES["MI"] = "mi";
	    TAG_NAMES["MO"] = "mo";
	    TAG_NAMES["MN"] = "mn";
	    TAG_NAMES["MS"] = "ms";
	    TAG_NAMES["MTEXT"] = "mtext";
	    TAG_NAMES["NAV"] = "nav";
	    TAG_NAMES["NOBR"] = "nobr";
	    TAG_NAMES["NOFRAMES"] = "noframes";
	    TAG_NAMES["NOEMBED"] = "noembed";
	    TAG_NAMES["NOSCRIPT"] = "noscript";
	    TAG_NAMES["OBJECT"] = "object";
	    TAG_NAMES["OL"] = "ol";
	    TAG_NAMES["OPTGROUP"] = "optgroup";
	    TAG_NAMES["OPTION"] = "option";
	    TAG_NAMES["P"] = "p";
	    TAG_NAMES["PARAM"] = "param";
	    TAG_NAMES["PLAINTEXT"] = "plaintext";
	    TAG_NAMES["PRE"] = "pre";
	    TAG_NAMES["RB"] = "rb";
	    TAG_NAMES["RP"] = "rp";
	    TAG_NAMES["RT"] = "rt";
	    TAG_NAMES["RTC"] = "rtc";
	    TAG_NAMES["RUBY"] = "ruby";
	    TAG_NAMES["S"] = "s";
	    TAG_NAMES["SCRIPT"] = "script";
	    TAG_NAMES["SEARCH"] = "search";
	    TAG_NAMES["SECTION"] = "section";
	    TAG_NAMES["SELECT"] = "select";
	    TAG_NAMES["SOURCE"] = "source";
	    TAG_NAMES["SMALL"] = "small";
	    TAG_NAMES["SPAN"] = "span";
	    TAG_NAMES["STRIKE"] = "strike";
	    TAG_NAMES["STRONG"] = "strong";
	    TAG_NAMES["STYLE"] = "style";
	    TAG_NAMES["SUB"] = "sub";
	    TAG_NAMES["SUMMARY"] = "summary";
	    TAG_NAMES["SUP"] = "sup";
	    TAG_NAMES["TABLE"] = "table";
	    TAG_NAMES["TBODY"] = "tbody";
	    TAG_NAMES["TEMPLATE"] = "template";
	    TAG_NAMES["TEXTAREA"] = "textarea";
	    TAG_NAMES["TFOOT"] = "tfoot";
	    TAG_NAMES["TD"] = "td";
	    TAG_NAMES["TH"] = "th";
	    TAG_NAMES["THEAD"] = "thead";
	    TAG_NAMES["TITLE"] = "title";
	    TAG_NAMES["TR"] = "tr";
	    TAG_NAMES["TRACK"] = "track";
	    TAG_NAMES["TT"] = "tt";
	    TAG_NAMES["U"] = "u";
	    TAG_NAMES["UL"] = "ul";
	    TAG_NAMES["SVG"] = "svg";
	    TAG_NAMES["VAR"] = "var";
	    TAG_NAMES["WBR"] = "wbr";
	    TAG_NAMES["XMP"] = "xmp";
	})(TAG_NAMES || (html$1.TAG_NAMES = TAG_NAMES = {}));
	/**
	 * Tag IDs are numeric IDs for known tag names.
	 *
	 * We use tag IDs to improve the performance of tag name comparisons.
	 */
	var TAG_ID;
	(function (TAG_ID) {
	    TAG_ID[TAG_ID["UNKNOWN"] = 0] = "UNKNOWN";
	    TAG_ID[TAG_ID["A"] = 1] = "A";
	    TAG_ID[TAG_ID["ADDRESS"] = 2] = "ADDRESS";
	    TAG_ID[TAG_ID["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
	    TAG_ID[TAG_ID["APPLET"] = 4] = "APPLET";
	    TAG_ID[TAG_ID["AREA"] = 5] = "AREA";
	    TAG_ID[TAG_ID["ARTICLE"] = 6] = "ARTICLE";
	    TAG_ID[TAG_ID["ASIDE"] = 7] = "ASIDE";
	    TAG_ID[TAG_ID["B"] = 8] = "B";
	    TAG_ID[TAG_ID["BASE"] = 9] = "BASE";
	    TAG_ID[TAG_ID["BASEFONT"] = 10] = "BASEFONT";
	    TAG_ID[TAG_ID["BGSOUND"] = 11] = "BGSOUND";
	    TAG_ID[TAG_ID["BIG"] = 12] = "BIG";
	    TAG_ID[TAG_ID["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
	    TAG_ID[TAG_ID["BODY"] = 14] = "BODY";
	    TAG_ID[TAG_ID["BR"] = 15] = "BR";
	    TAG_ID[TAG_ID["BUTTON"] = 16] = "BUTTON";
	    TAG_ID[TAG_ID["CAPTION"] = 17] = "CAPTION";
	    TAG_ID[TAG_ID["CENTER"] = 18] = "CENTER";
	    TAG_ID[TAG_ID["CODE"] = 19] = "CODE";
	    TAG_ID[TAG_ID["COL"] = 20] = "COL";
	    TAG_ID[TAG_ID["COLGROUP"] = 21] = "COLGROUP";
	    TAG_ID[TAG_ID["DD"] = 22] = "DD";
	    TAG_ID[TAG_ID["DESC"] = 23] = "DESC";
	    TAG_ID[TAG_ID["DETAILS"] = 24] = "DETAILS";
	    TAG_ID[TAG_ID["DIALOG"] = 25] = "DIALOG";
	    TAG_ID[TAG_ID["DIR"] = 26] = "DIR";
	    TAG_ID[TAG_ID["DIV"] = 27] = "DIV";
	    TAG_ID[TAG_ID["DL"] = 28] = "DL";
	    TAG_ID[TAG_ID["DT"] = 29] = "DT";
	    TAG_ID[TAG_ID["EM"] = 30] = "EM";
	    TAG_ID[TAG_ID["EMBED"] = 31] = "EMBED";
	    TAG_ID[TAG_ID["FIELDSET"] = 32] = "FIELDSET";
	    TAG_ID[TAG_ID["FIGCAPTION"] = 33] = "FIGCAPTION";
	    TAG_ID[TAG_ID["FIGURE"] = 34] = "FIGURE";
	    TAG_ID[TAG_ID["FONT"] = 35] = "FONT";
	    TAG_ID[TAG_ID["FOOTER"] = 36] = "FOOTER";
	    TAG_ID[TAG_ID["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
	    TAG_ID[TAG_ID["FORM"] = 38] = "FORM";
	    TAG_ID[TAG_ID["FRAME"] = 39] = "FRAME";
	    TAG_ID[TAG_ID["FRAMESET"] = 40] = "FRAMESET";
	    TAG_ID[TAG_ID["H1"] = 41] = "H1";
	    TAG_ID[TAG_ID["H2"] = 42] = "H2";
	    TAG_ID[TAG_ID["H3"] = 43] = "H3";
	    TAG_ID[TAG_ID["H4"] = 44] = "H4";
	    TAG_ID[TAG_ID["H5"] = 45] = "H5";
	    TAG_ID[TAG_ID["H6"] = 46] = "H6";
	    TAG_ID[TAG_ID["HEAD"] = 47] = "HEAD";
	    TAG_ID[TAG_ID["HEADER"] = 48] = "HEADER";
	    TAG_ID[TAG_ID["HGROUP"] = 49] = "HGROUP";
	    TAG_ID[TAG_ID["HR"] = 50] = "HR";
	    TAG_ID[TAG_ID["HTML"] = 51] = "HTML";
	    TAG_ID[TAG_ID["I"] = 52] = "I";
	    TAG_ID[TAG_ID["IMG"] = 53] = "IMG";
	    TAG_ID[TAG_ID["IMAGE"] = 54] = "IMAGE";
	    TAG_ID[TAG_ID["INPUT"] = 55] = "INPUT";
	    TAG_ID[TAG_ID["IFRAME"] = 56] = "IFRAME";
	    TAG_ID[TAG_ID["KEYGEN"] = 57] = "KEYGEN";
	    TAG_ID[TAG_ID["LABEL"] = 58] = "LABEL";
	    TAG_ID[TAG_ID["LI"] = 59] = "LI";
	    TAG_ID[TAG_ID["LINK"] = 60] = "LINK";
	    TAG_ID[TAG_ID["LISTING"] = 61] = "LISTING";
	    TAG_ID[TAG_ID["MAIN"] = 62] = "MAIN";
	    TAG_ID[TAG_ID["MALIGNMARK"] = 63] = "MALIGNMARK";
	    TAG_ID[TAG_ID["MARQUEE"] = 64] = "MARQUEE";
	    TAG_ID[TAG_ID["MATH"] = 65] = "MATH";
	    TAG_ID[TAG_ID["MENU"] = 66] = "MENU";
	    TAG_ID[TAG_ID["META"] = 67] = "META";
	    TAG_ID[TAG_ID["MGLYPH"] = 68] = "MGLYPH";
	    TAG_ID[TAG_ID["MI"] = 69] = "MI";
	    TAG_ID[TAG_ID["MO"] = 70] = "MO";
	    TAG_ID[TAG_ID["MN"] = 71] = "MN";
	    TAG_ID[TAG_ID["MS"] = 72] = "MS";
	    TAG_ID[TAG_ID["MTEXT"] = 73] = "MTEXT";
	    TAG_ID[TAG_ID["NAV"] = 74] = "NAV";
	    TAG_ID[TAG_ID["NOBR"] = 75] = "NOBR";
	    TAG_ID[TAG_ID["NOFRAMES"] = 76] = "NOFRAMES";
	    TAG_ID[TAG_ID["NOEMBED"] = 77] = "NOEMBED";
	    TAG_ID[TAG_ID["NOSCRIPT"] = 78] = "NOSCRIPT";
	    TAG_ID[TAG_ID["OBJECT"] = 79] = "OBJECT";
	    TAG_ID[TAG_ID["OL"] = 80] = "OL";
	    TAG_ID[TAG_ID["OPTGROUP"] = 81] = "OPTGROUP";
	    TAG_ID[TAG_ID["OPTION"] = 82] = "OPTION";
	    TAG_ID[TAG_ID["P"] = 83] = "P";
	    TAG_ID[TAG_ID["PARAM"] = 84] = "PARAM";
	    TAG_ID[TAG_ID["PLAINTEXT"] = 85] = "PLAINTEXT";
	    TAG_ID[TAG_ID["PRE"] = 86] = "PRE";
	    TAG_ID[TAG_ID["RB"] = 87] = "RB";
	    TAG_ID[TAG_ID["RP"] = 88] = "RP";
	    TAG_ID[TAG_ID["RT"] = 89] = "RT";
	    TAG_ID[TAG_ID["RTC"] = 90] = "RTC";
	    TAG_ID[TAG_ID["RUBY"] = 91] = "RUBY";
	    TAG_ID[TAG_ID["S"] = 92] = "S";
	    TAG_ID[TAG_ID["SCRIPT"] = 93] = "SCRIPT";
	    TAG_ID[TAG_ID["SEARCH"] = 94] = "SEARCH";
	    TAG_ID[TAG_ID["SECTION"] = 95] = "SECTION";
	    TAG_ID[TAG_ID["SELECT"] = 96] = "SELECT";
	    TAG_ID[TAG_ID["SOURCE"] = 97] = "SOURCE";
	    TAG_ID[TAG_ID["SMALL"] = 98] = "SMALL";
	    TAG_ID[TAG_ID["SPAN"] = 99] = "SPAN";
	    TAG_ID[TAG_ID["STRIKE"] = 100] = "STRIKE";
	    TAG_ID[TAG_ID["STRONG"] = 101] = "STRONG";
	    TAG_ID[TAG_ID["STYLE"] = 102] = "STYLE";
	    TAG_ID[TAG_ID["SUB"] = 103] = "SUB";
	    TAG_ID[TAG_ID["SUMMARY"] = 104] = "SUMMARY";
	    TAG_ID[TAG_ID["SUP"] = 105] = "SUP";
	    TAG_ID[TAG_ID["TABLE"] = 106] = "TABLE";
	    TAG_ID[TAG_ID["TBODY"] = 107] = "TBODY";
	    TAG_ID[TAG_ID["TEMPLATE"] = 108] = "TEMPLATE";
	    TAG_ID[TAG_ID["TEXTAREA"] = 109] = "TEXTAREA";
	    TAG_ID[TAG_ID["TFOOT"] = 110] = "TFOOT";
	    TAG_ID[TAG_ID["TD"] = 111] = "TD";
	    TAG_ID[TAG_ID["TH"] = 112] = "TH";
	    TAG_ID[TAG_ID["THEAD"] = 113] = "THEAD";
	    TAG_ID[TAG_ID["TITLE"] = 114] = "TITLE";
	    TAG_ID[TAG_ID["TR"] = 115] = "TR";
	    TAG_ID[TAG_ID["TRACK"] = 116] = "TRACK";
	    TAG_ID[TAG_ID["TT"] = 117] = "TT";
	    TAG_ID[TAG_ID["U"] = 118] = "U";
	    TAG_ID[TAG_ID["UL"] = 119] = "UL";
	    TAG_ID[TAG_ID["SVG"] = 120] = "SVG";
	    TAG_ID[TAG_ID["VAR"] = 121] = "VAR";
	    TAG_ID[TAG_ID["WBR"] = 122] = "WBR";
	    TAG_ID[TAG_ID["XMP"] = 123] = "XMP";
	})(TAG_ID || (html$1.TAG_ID = TAG_ID = {}));
	const TAG_NAME_TO_ID = new Map([
	    [TAG_NAMES.A, TAG_ID.A],
	    [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
	    [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
	    [TAG_NAMES.APPLET, TAG_ID.APPLET],
	    [TAG_NAMES.AREA, TAG_ID.AREA],
	    [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
	    [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
	    [TAG_NAMES.B, TAG_ID.B],
	    [TAG_NAMES.BASE, TAG_ID.BASE],
	    [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
	    [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
	    [TAG_NAMES.BIG, TAG_ID.BIG],
	    [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
	    [TAG_NAMES.BODY, TAG_ID.BODY],
	    [TAG_NAMES.BR, TAG_ID.BR],
	    [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
	    [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
	    [TAG_NAMES.CENTER, TAG_ID.CENTER],
	    [TAG_NAMES.CODE, TAG_ID.CODE],
	    [TAG_NAMES.COL, TAG_ID.COL],
	    [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
	    [TAG_NAMES.DD, TAG_ID.DD],
	    [TAG_NAMES.DESC, TAG_ID.DESC],
	    [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
	    [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
	    [TAG_NAMES.DIR, TAG_ID.DIR],
	    [TAG_NAMES.DIV, TAG_ID.DIV],
	    [TAG_NAMES.DL, TAG_ID.DL],
	    [TAG_NAMES.DT, TAG_ID.DT],
	    [TAG_NAMES.EM, TAG_ID.EM],
	    [TAG_NAMES.EMBED, TAG_ID.EMBED],
	    [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
	    [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
	    [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
	    [TAG_NAMES.FONT, TAG_ID.FONT],
	    [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
	    [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
	    [TAG_NAMES.FORM, TAG_ID.FORM],
	    [TAG_NAMES.FRAME, TAG_ID.FRAME],
	    [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
	    [TAG_NAMES.H1, TAG_ID.H1],
	    [TAG_NAMES.H2, TAG_ID.H2],
	    [TAG_NAMES.H3, TAG_ID.H3],
	    [TAG_NAMES.H4, TAG_ID.H4],
	    [TAG_NAMES.H5, TAG_ID.H5],
	    [TAG_NAMES.H6, TAG_ID.H6],
	    [TAG_NAMES.HEAD, TAG_ID.HEAD],
	    [TAG_NAMES.HEADER, TAG_ID.HEADER],
	    [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
	    [TAG_NAMES.HR, TAG_ID.HR],
	    [TAG_NAMES.HTML, TAG_ID.HTML],
	    [TAG_NAMES.I, TAG_ID.I],
	    [TAG_NAMES.IMG, TAG_ID.IMG],
	    [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
	    [TAG_NAMES.INPUT, TAG_ID.INPUT],
	    [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
	    [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
	    [TAG_NAMES.LABEL, TAG_ID.LABEL],
	    [TAG_NAMES.LI, TAG_ID.LI],
	    [TAG_NAMES.LINK, TAG_ID.LINK],
	    [TAG_NAMES.LISTING, TAG_ID.LISTING],
	    [TAG_NAMES.MAIN, TAG_ID.MAIN],
	    [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
	    [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
	    [TAG_NAMES.MATH, TAG_ID.MATH],
	    [TAG_NAMES.MENU, TAG_ID.MENU],
	    [TAG_NAMES.META, TAG_ID.META],
	    [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
	    [TAG_NAMES.MI, TAG_ID.MI],
	    [TAG_NAMES.MO, TAG_ID.MO],
	    [TAG_NAMES.MN, TAG_ID.MN],
	    [TAG_NAMES.MS, TAG_ID.MS],
	    [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
	    [TAG_NAMES.NAV, TAG_ID.NAV],
	    [TAG_NAMES.NOBR, TAG_ID.NOBR],
	    [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
	    [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
	    [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
	    [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
	    [TAG_NAMES.OL, TAG_ID.OL],
	    [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
	    [TAG_NAMES.OPTION, TAG_ID.OPTION],
	    [TAG_NAMES.P, TAG_ID.P],
	    [TAG_NAMES.PARAM, TAG_ID.PARAM],
	    [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
	    [TAG_NAMES.PRE, TAG_ID.PRE],
	    [TAG_NAMES.RB, TAG_ID.RB],
	    [TAG_NAMES.RP, TAG_ID.RP],
	    [TAG_NAMES.RT, TAG_ID.RT],
	    [TAG_NAMES.RTC, TAG_ID.RTC],
	    [TAG_NAMES.RUBY, TAG_ID.RUBY],
	    [TAG_NAMES.S, TAG_ID.S],
	    [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
	    [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
	    [TAG_NAMES.SECTION, TAG_ID.SECTION],
	    [TAG_NAMES.SELECT, TAG_ID.SELECT],
	    [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
	    [TAG_NAMES.SMALL, TAG_ID.SMALL],
	    [TAG_NAMES.SPAN, TAG_ID.SPAN],
	    [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
	    [TAG_NAMES.STRONG, TAG_ID.STRONG],
	    [TAG_NAMES.STYLE, TAG_ID.STYLE],
	    [TAG_NAMES.SUB, TAG_ID.SUB],
	    [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
	    [TAG_NAMES.SUP, TAG_ID.SUP],
	    [TAG_NAMES.TABLE, TAG_ID.TABLE],
	    [TAG_NAMES.TBODY, TAG_ID.TBODY],
	    [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
	    [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
	    [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
	    [TAG_NAMES.TD, TAG_ID.TD],
	    [TAG_NAMES.TH, TAG_ID.TH],
	    [TAG_NAMES.THEAD, TAG_ID.THEAD],
	    [TAG_NAMES.TITLE, TAG_ID.TITLE],
	    [TAG_NAMES.TR, TAG_ID.TR],
	    [TAG_NAMES.TRACK, TAG_ID.TRACK],
	    [TAG_NAMES.TT, TAG_ID.TT],
	    [TAG_NAMES.U, TAG_ID.U],
	    [TAG_NAMES.UL, TAG_ID.UL],
	    [TAG_NAMES.SVG, TAG_ID.SVG],
	    [TAG_NAMES.VAR, TAG_ID.VAR],
	    [TAG_NAMES.WBR, TAG_ID.WBR],
	    [TAG_NAMES.XMP, TAG_ID.XMP],
	]);
	function getTagID(tagName) {
	    var _a;
	    return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
	}
	const $ = TAG_ID;
	html$1.SPECIAL_ELEMENTS = {
	    [NS.HTML]: new Set([
	        $.ADDRESS,
	        $.APPLET,
	        $.AREA,
	        $.ARTICLE,
	        $.ASIDE,
	        $.BASE,
	        $.BASEFONT,
	        $.BGSOUND,
	        $.BLOCKQUOTE,
	        $.BODY,
	        $.BR,
	        $.BUTTON,
	        $.CAPTION,
	        $.CENTER,
	        $.COL,
	        $.COLGROUP,
	        $.DD,
	        $.DETAILS,
	        $.DIR,
	        $.DIV,
	        $.DL,
	        $.DT,
	        $.EMBED,
	        $.FIELDSET,
	        $.FIGCAPTION,
	        $.FIGURE,
	        $.FOOTER,
	        $.FORM,
	        $.FRAME,
	        $.FRAMESET,
	        $.H1,
	        $.H2,
	        $.H3,
	        $.H4,
	        $.H5,
	        $.H6,
	        $.HEAD,
	        $.HEADER,
	        $.HGROUP,
	        $.HR,
	        $.HTML,
	        $.IFRAME,
	        $.IMG,
	        $.INPUT,
	        $.LI,
	        $.LINK,
	        $.LISTING,
	        $.MAIN,
	        $.MARQUEE,
	        $.MENU,
	        $.META,
	        $.NAV,
	        $.NOEMBED,
	        $.NOFRAMES,
	        $.NOSCRIPT,
	        $.OBJECT,
	        $.OL,
	        $.P,
	        $.PARAM,
	        $.PLAINTEXT,
	        $.PRE,
	        $.SCRIPT,
	        $.SECTION,
	        $.SELECT,
	        $.SOURCE,
	        $.STYLE,
	        $.SUMMARY,
	        $.TABLE,
	        $.TBODY,
	        $.TD,
	        $.TEMPLATE,
	        $.TEXTAREA,
	        $.TFOOT,
	        $.TH,
	        $.THEAD,
	        $.TITLE,
	        $.TR,
	        $.TRACK,
	        $.UL,
	        $.WBR,
	        $.XMP,
	    ]),
	    [NS.MATHML]: new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
	    [NS.SVG]: new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
	    [NS.XLINK]: new Set(),
	    [NS.XML]: new Set(),
	    [NS.XMLNS]: new Set(),
	};
	html$1.NUMBERED_HEADERS = new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
	const UNESCAPED_TEXT = new Set([
	    TAG_NAMES.STYLE,
	    TAG_NAMES.SCRIPT,
	    TAG_NAMES.XMP,
	    TAG_NAMES.IFRAME,
	    TAG_NAMES.NOEMBED,
	    TAG_NAMES.NOFRAMES,
	    TAG_NAMES.PLAINTEXT,
	]);
	function hasUnescapedText(tn, scriptingEnabled) {
	    return UNESCAPED_TEXT.has(tn) || (scriptingEnabled && tn === TAG_NAMES.NOSCRIPT);
	}
	return html$1;
}

var hasRequiredTokenizer$4;

function requireTokenizer$4 () {
	if (hasRequiredTokenizer$4) return tokenizer$3;
	hasRequiredTokenizer$4 = 1;
	Object.defineProperty(tokenizer$3, "__esModule", { value: true });
	tokenizer$3.Tokenizer = tokenizer$3.TokenizerMode = void 0;
	const preprocessor_js_1 = requirePreprocessor();
	const unicode_js_1 = requireUnicode();
	const token_js_1 = requireToken$2();
	const decode_1 = /*@__PURE__*/ requireDecode$1();
	const error_codes_js_1 = requireErrorCodes();
	const html_js_1 = requireHtml$1();
	//States
	var State;
	(function (State) {
	    State[State["DATA"] = 0] = "DATA";
	    State[State["RCDATA"] = 1] = "RCDATA";
	    State[State["RAWTEXT"] = 2] = "RAWTEXT";
	    State[State["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
	    State[State["PLAINTEXT"] = 4] = "PLAINTEXT";
	    State[State["TAG_OPEN"] = 5] = "TAG_OPEN";
	    State[State["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
	    State[State["TAG_NAME"] = 7] = "TAG_NAME";
	    State[State["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
	    State[State["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
	    State[State["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
	    State[State["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
	    State[State["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
	    State[State["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
	    State[State["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
	    State[State["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
	    State[State["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
	    State[State["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
	    State[State["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
	    State[State["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
	    State[State["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
	    State[State["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
	    State[State["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
	    State[State["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
	    State[State["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
	    State[State["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
	    State[State["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
	    State[State["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
	    State[State["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
	    State[State["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
	    State[State["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
	    State[State["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
	    State[State["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
	    State[State["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
	    State[State["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
	    State[State["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
	    State[State["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
	    State[State["COMMENT_START"] = 42] = "COMMENT_START";
	    State[State["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
	    State[State["COMMENT"] = 44] = "COMMENT";
	    State[State["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
	    State[State["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
	    State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
	    State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
	    State[State["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
	    State[State["COMMENT_END"] = 50] = "COMMENT_END";
	    State[State["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
	    State[State["DOCTYPE"] = 52] = "DOCTYPE";
	    State[State["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
	    State[State["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
	    State[State["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
	    State[State["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
	    State[State["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
	    State[State["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
	    State[State["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
	    State[State["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
	    State[State["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
	    State[State["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
	    State[State["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
	    State[State["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
	    State[State["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
	    State[State["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
	    State[State["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
	    State[State["CDATA_SECTION"] = 68] = "CDATA_SECTION";
	    State[State["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
	    State[State["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
	    State[State["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
	    State[State["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
	})(State || (State = {}));
	//Tokenizer initial states for different modes
	tokenizer$3.TokenizerMode = {
	    DATA: State.DATA,
	    RCDATA: State.RCDATA,
	    RAWTEXT: State.RAWTEXT,
	    SCRIPT_DATA: State.SCRIPT_DATA,
	    PLAINTEXT: State.PLAINTEXT,
	    CDATA_SECTION: State.CDATA_SECTION,
	};
	//Utils
	//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
	//this functions if they will be situated in another module due to context switch.
	//Always perform inlining check before modifying this functions ('node --trace-inlining').
	function isAsciiDigit(cp) {
	    return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;
	}
	function isAsciiUpper(cp) {
	    return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;
	}
	function isAsciiLower(cp) {
	    return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;
	}
	function isAsciiLetter(cp) {
	    return isAsciiLower(cp) || isAsciiUpper(cp);
	}
	function isAsciiAlphaNumeric(cp) {
	    return isAsciiLetter(cp) || isAsciiDigit(cp);
	}
	function toAsciiLower(cp) {
	    return cp + 32;
	}
	function isWhitespace(cp) {
	    return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;
	}
	function isScriptDataDoubleEscapeSequenceEnd(cp) {
	    return isWhitespace(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;
	}
	function getErrorForNumericCharacterReference(code) {
	    if (code === unicode_js_1.CODE_POINTS.NULL) {
	        return error_codes_js_1.ERR.nullCharacterReference;
	    }
	    else if (code > 1114111) {
	        return error_codes_js_1.ERR.characterReferenceOutsideUnicodeRange;
	    }
	    else if ((0, unicode_js_1.isSurrogate)(code)) {
	        return error_codes_js_1.ERR.surrogateCharacterReference;
	    }
	    else if ((0, unicode_js_1.isUndefinedCodePoint)(code)) {
	        return error_codes_js_1.ERR.noncharacterCharacterReference;
	    }
	    else if ((0, unicode_js_1.isControlCodePoint)(code) || code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
	        return error_codes_js_1.ERR.controlCharacterReference;
	    }
	    return null;
	}
	//Tokenizer
	class Tokenizer {
	    constructor(options, handler) {
	        this.options = options;
	        this.handler = handler;
	        this.paused = false;
	        /** Ensures that the parsing loop isn't run multiple times at once. */
	        this.inLoop = false;
	        /**
	         * Indicates that the current adjusted node exists, is not an element in the HTML namespace,
	         * and that it is not an integration point for either MathML or HTML.
	         *
	         * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}
	         */
	        this.inForeignNode = false;
	        this.lastStartTagName = '';
	        this.active = false;
	        this.state = State.DATA;
	        this.returnState = State.DATA;
	        this.entityStartPos = 0;
	        this.consumedAfterSnapshot = -1;
	        this.currentCharacterToken = null;
	        this.currentToken = null;
	        this.currentAttr = { name: '', value: '' };
	        this.preprocessor = new preprocessor_js_1.Preprocessor(handler);
	        this.currentLocation = this.getCurrentLocation(-1);
	        this.entityDecoder = new decode_1.EntityDecoder(decode_1.htmlDecodeTree, (cp, consumed) => {
	            // Note: Set `pos` _before_ flushing, as flushing might drop
	            // the current chunk and invalidate `entityStartPos`.
	            this.preprocessor.pos = this.entityStartPos + consumed - 1;
	            this._flushCodePointConsumedAsCharacterReference(cp);
	        }, handler.onParseError
	            ? {
	                missingSemicolonAfterCharacterReference: () => {
	                    this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference, 1);
	                },
	                absenceOfDigitsInNumericCharacterReference: (consumed) => {
	                    this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
	                },
	                validateNumericCharacterReference: (code) => {
	                    const error = getErrorForNumericCharacterReference(code);
	                    if (error)
	                        this._err(error, 1);
	                },
	            }
	            : undefined);
	    }
	    //Errors
	    _err(code, cpOffset = 0) {
	        var _a, _b;
	        (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code, cpOffset));
	    }
	    // NOTE: `offset` may never run across line boundaries.
	    getCurrentLocation(offset) {
	        if (!this.options.sourceCodeLocationInfo) {
	            return null;
	        }
	        return {
	            startLine: this.preprocessor.line,
	            startCol: this.preprocessor.col - offset,
	            startOffset: this.preprocessor.offset - offset,
	            endLine: -1,
	            endCol: -1,
	            endOffset: -1,
	        };
	    }
	    _runParsingLoop() {
	        if (this.inLoop)
	            return;
	        this.inLoop = true;
	        while (this.active && !this.paused) {
	            this.consumedAfterSnapshot = 0;
	            const cp = this._consume();
	            if (!this._ensureHibernation()) {
	                this._callState(cp);
	            }
	        }
	        this.inLoop = false;
	    }
	    //API
	    pause() {
	        this.paused = true;
	    }
	    resume(writeCallback) {
	        if (!this.paused) {
	            throw new Error('Parser was already resumed');
	        }
	        this.paused = false;
	        // Necessary for synchronous resume.
	        if (this.inLoop)
	            return;
	        this._runParsingLoop();
	        if (!this.paused) {
	            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
	        }
	    }
	    write(chunk, isLastChunk, writeCallback) {
	        this.active = true;
	        this.preprocessor.write(chunk, isLastChunk);
	        this._runParsingLoop();
	        if (!this.paused) {
	            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
	        }
	    }
	    insertHtmlAtCurrentPos(chunk) {
	        this.active = true;
	        this.preprocessor.insertHtmlAtCurrentPos(chunk);
	        this._runParsingLoop();
	    }
	    //Hibernation
	    _ensureHibernation() {
	        if (this.preprocessor.endOfChunkHit) {
	            this.preprocessor.retreat(this.consumedAfterSnapshot);
	            this.consumedAfterSnapshot = 0;
	            this.active = false;
	            return true;
	        }
	        return false;
	    }
	    //Consumption
	    _consume() {
	        this.consumedAfterSnapshot++;
	        return this.preprocessor.advance();
	    }
	    _advanceBy(count) {
	        this.consumedAfterSnapshot += count;
	        for (let i = 0; i < count; i++) {
	            this.preprocessor.advance();
	        }
	    }
	    _consumeSequenceIfMatch(pattern, caseSensitive) {
	        if (this.preprocessor.startsWith(pattern, caseSensitive)) {
	            // We will already have consumed one character before calling this method.
	            this._advanceBy(pattern.length - 1);
	            return true;
	        }
	        return false;
	    }
	    //Token creation
	    _createStartTagToken() {
	        this.currentToken = {
	            type: token_js_1.TokenType.START_TAG,
	            tagName: '',
	            tagID: html_js_1.TAG_ID.UNKNOWN,
	            selfClosing: false,
	            ackSelfClosing: false,
	            attrs: [],
	            location: this.getCurrentLocation(1),
	        };
	    }
	    _createEndTagToken() {
	        this.currentToken = {
	            type: token_js_1.TokenType.END_TAG,
	            tagName: '',
	            tagID: html_js_1.TAG_ID.UNKNOWN,
	            selfClosing: false,
	            ackSelfClosing: false,
	            attrs: [],
	            location: this.getCurrentLocation(2),
	        };
	    }
	    _createCommentToken(offset) {
	        this.currentToken = {
	            type: token_js_1.TokenType.COMMENT,
	            data: '',
	            location: this.getCurrentLocation(offset),
	        };
	    }
	    _createDoctypeToken(initialName) {
	        this.currentToken = {
	            type: token_js_1.TokenType.DOCTYPE,
	            name: initialName,
	            forceQuirks: false,
	            publicId: null,
	            systemId: null,
	            location: this.currentLocation,
	        };
	    }
	    _createCharacterToken(type, chars) {
	        this.currentCharacterToken = {
	            type,
	            chars,
	            location: this.currentLocation,
	        };
	    }
	    //Tag attributes
	    _createAttr(attrNameFirstCh) {
	        this.currentAttr = {
	            name: attrNameFirstCh,
	            value: '',
	        };
	        this.currentLocation = this.getCurrentLocation(0);
	    }
	    _leaveAttrName() {
	        var _a;
	        var _b;
	        const token = this.currentToken;
	        if ((0, token_js_1.getTokenAttr)(token, this.currentAttr.name) === null) {
	            token.attrs.push(this.currentAttr);
	            if (token.location && this.currentLocation) {
	                const attrLocations = ((_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : (_b.attrs = Object.create(null)));
	                attrLocations[this.currentAttr.name] = this.currentLocation;
	                // Set end location
	                this._leaveAttrValue();
	            }
	        }
	        else {
	            this._err(error_codes_js_1.ERR.duplicateAttribute);
	        }
	    }
	    _leaveAttrValue() {
	        if (this.currentLocation) {
	            this.currentLocation.endLine = this.preprocessor.line;
	            this.currentLocation.endCol = this.preprocessor.col;
	            this.currentLocation.endOffset = this.preprocessor.offset;
	        }
	    }
	    //Token emission
	    prepareToken(ct) {
	        this._emitCurrentCharacterToken(ct.location);
	        this.currentToken = null;
	        if (ct.location) {
	            ct.location.endLine = this.preprocessor.line;
	            ct.location.endCol = this.preprocessor.col + 1;
	            ct.location.endOffset = this.preprocessor.offset + 1;
	        }
	        this.currentLocation = this.getCurrentLocation(-1);
	    }
	    emitCurrentTagToken() {
	        const ct = this.currentToken;
	        this.prepareToken(ct);
	        ct.tagID = (0, html_js_1.getTagID)(ct.tagName);
	        if (ct.type === token_js_1.TokenType.START_TAG) {
	            this.lastStartTagName = ct.tagName;
	            this.handler.onStartTag(ct);
	        }
	        else {
	            if (ct.attrs.length > 0) {
	                this._err(error_codes_js_1.ERR.endTagWithAttributes);
	            }
	            if (ct.selfClosing) {
	                this._err(error_codes_js_1.ERR.endTagWithTrailingSolidus);
	            }
	            this.handler.onEndTag(ct);
	        }
	        this.preprocessor.dropParsedChunk();
	    }
	    emitCurrentComment(ct) {
	        this.prepareToken(ct);
	        this.handler.onComment(ct);
	        this.preprocessor.dropParsedChunk();
	    }
	    emitCurrentDoctype(ct) {
	        this.prepareToken(ct);
	        this.handler.onDoctype(ct);
	        this.preprocessor.dropParsedChunk();
	    }
	    _emitCurrentCharacterToken(nextLocation) {
	        if (this.currentCharacterToken) {
	            //NOTE: if we have a pending character token, make it's end location equal to the
	            //current token's start location.
	            if (nextLocation && this.currentCharacterToken.location) {
	                this.currentCharacterToken.location.endLine = nextLocation.startLine;
	                this.currentCharacterToken.location.endCol = nextLocation.startCol;
	                this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
	            }
	            switch (this.currentCharacterToken.type) {
	                case token_js_1.TokenType.CHARACTER: {
	                    this.handler.onCharacter(this.currentCharacterToken);
	                    break;
	                }
	                case token_js_1.TokenType.NULL_CHARACTER: {
	                    this.handler.onNullCharacter(this.currentCharacterToken);
	                    break;
	                }
	                case token_js_1.TokenType.WHITESPACE_CHARACTER: {
	                    this.handler.onWhitespaceCharacter(this.currentCharacterToken);
	                    break;
	                }
	            }
	            this.currentCharacterToken = null;
	        }
	    }
	    _emitEOFToken() {
	        const location = this.getCurrentLocation(0);
	        if (location) {
	            location.endLine = location.startLine;
	            location.endCol = location.startCol;
	            location.endOffset = location.startOffset;
	        }
	        this._emitCurrentCharacterToken(location);
	        this.handler.onEof({ type: token_js_1.TokenType.EOF, location });
	        this.active = false;
	    }
	    //Characters emission
	    //OPTIMIZATION: The specification uses only one type of character token (one token per character).
	    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
	    //If we have a sequence of characters that belong to the same group, the parser can process it
	    //as a single solid character token.
	    //So, there are 3 types of character tokens in parse5:
	    //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
	    //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
	    //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
	    _appendCharToCurrentCharacterToken(type, ch) {
	        if (this.currentCharacterToken) {
	            if (this.currentCharacterToken.type === type) {
	                this.currentCharacterToken.chars += ch;
	                return;
	            }
	            else {
	                this.currentLocation = this.getCurrentLocation(0);
	                this._emitCurrentCharacterToken(this.currentLocation);
	                this.preprocessor.dropParsedChunk();
	            }
	        }
	        this._createCharacterToken(type, ch);
	    }
	    _emitCodePoint(cp) {
	        const type = isWhitespace(cp)
	            ? token_js_1.TokenType.WHITESPACE_CHARACTER
	            : cp === unicode_js_1.CODE_POINTS.NULL
	                ? token_js_1.TokenType.NULL_CHARACTER
	                : token_js_1.TokenType.CHARACTER;
	        this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
	    }
	    //NOTE: used when we emit characters explicitly.
	    //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
	    _emitChars(ch) {
	        this._appendCharToCurrentCharacterToken(token_js_1.TokenType.CHARACTER, ch);
	    }
	    // Character reference helpers
	    _startCharacterReference() {
	        this.returnState = this.state;
	        this.state = State.CHARACTER_REFERENCE;
	        this.entityStartPos = this.preprocessor.pos;
	        this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? decode_1.DecodingMode.Attribute : decode_1.DecodingMode.Legacy);
	    }
	    _isCharacterReferenceInAttribute() {
	        return (this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
	            this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
	            this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED);
	    }
	    _flushCodePointConsumedAsCharacterReference(cp) {
	        if (this._isCharacterReferenceInAttribute()) {
	            this.currentAttr.value += String.fromCodePoint(cp);
	        }
	        else {
	            this._emitCodePoint(cp);
	        }
	    }
	    // Calling states this way turns out to be much faster than any other approach.
	    _callState(cp) {
	        switch (this.state) {
	            case State.DATA: {
	                this._stateData(cp);
	                break;
	            }
	            case State.RCDATA: {
	                this._stateRcdata(cp);
	                break;
	            }
	            case State.RAWTEXT: {
	                this._stateRawtext(cp);
	                break;
	            }
	            case State.SCRIPT_DATA: {
	                this._stateScriptData(cp);
	                break;
	            }
	            case State.PLAINTEXT: {
	                this._statePlaintext(cp);
	                break;
	            }
	            case State.TAG_OPEN: {
	                this._stateTagOpen(cp);
	                break;
	            }
	            case State.END_TAG_OPEN: {
	                this._stateEndTagOpen(cp);
	                break;
	            }
	            case State.TAG_NAME: {
	                this._stateTagName(cp);
	                break;
	            }
	            case State.RCDATA_LESS_THAN_SIGN: {
	                this._stateRcdataLessThanSign(cp);
	                break;
	            }
	            case State.RCDATA_END_TAG_OPEN: {
	                this._stateRcdataEndTagOpen(cp);
	                break;
	            }
	            case State.RCDATA_END_TAG_NAME: {
	                this._stateRcdataEndTagName(cp);
	                break;
	            }
	            case State.RAWTEXT_LESS_THAN_SIGN: {
	                this._stateRawtextLessThanSign(cp);
	                break;
	            }
	            case State.RAWTEXT_END_TAG_OPEN: {
	                this._stateRawtextEndTagOpen(cp);
	                break;
	            }
	            case State.RAWTEXT_END_TAG_NAME: {
	                this._stateRawtextEndTagName(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_LESS_THAN_SIGN: {
	                this._stateScriptDataLessThanSign(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_END_TAG_OPEN: {
	                this._stateScriptDataEndTagOpen(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_END_TAG_NAME: {
	                this._stateScriptDataEndTagName(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPE_START: {
	                this._stateScriptDataEscapeStart(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPE_START_DASH: {
	                this._stateScriptDataEscapeStartDash(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED: {
	                this._stateScriptDataEscaped(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED_DASH: {
	                this._stateScriptDataEscapedDash(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
	                this._stateScriptDataEscapedDashDash(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
	                this._stateScriptDataEscapedLessThanSign(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
	                this._stateScriptDataEscapedEndTagOpen(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
	                this._stateScriptDataEscapedEndTagName(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
	                this._stateScriptDataDoubleEscapeStart(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
	                this._stateScriptDataDoubleEscaped(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
	                this._stateScriptDataDoubleEscapedDash(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
	                this._stateScriptDataDoubleEscapedDashDash(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
	                this._stateScriptDataDoubleEscapedLessThanSign(cp);
	                break;
	            }
	            case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
	                this._stateScriptDataDoubleEscapeEnd(cp);
	                break;
	            }
	            case State.BEFORE_ATTRIBUTE_NAME: {
	                this._stateBeforeAttributeName(cp);
	                break;
	            }
	            case State.ATTRIBUTE_NAME: {
	                this._stateAttributeName(cp);
	                break;
	            }
	            case State.AFTER_ATTRIBUTE_NAME: {
	                this._stateAfterAttributeName(cp);
	                break;
	            }
	            case State.BEFORE_ATTRIBUTE_VALUE: {
	                this._stateBeforeAttributeValue(cp);
	                break;
	            }
	            case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
	                this._stateAttributeValueDoubleQuoted(cp);
	                break;
	            }
	            case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
	                this._stateAttributeValueSingleQuoted(cp);
	                break;
	            }
	            case State.ATTRIBUTE_VALUE_UNQUOTED: {
	                this._stateAttributeValueUnquoted(cp);
	                break;
	            }
	            case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
	                this._stateAfterAttributeValueQuoted(cp);
	                break;
	            }
	            case State.SELF_CLOSING_START_TAG: {
	                this._stateSelfClosingStartTag(cp);
	                break;
	            }
	            case State.BOGUS_COMMENT: {
	                this._stateBogusComment(cp);
	                break;
	            }
	            case State.MARKUP_DECLARATION_OPEN: {
	                this._stateMarkupDeclarationOpen(cp);
	                break;
	            }
	            case State.COMMENT_START: {
	                this._stateCommentStart(cp);
	                break;
	            }
	            case State.COMMENT_START_DASH: {
	                this._stateCommentStartDash(cp);
	                break;
	            }
	            case State.COMMENT: {
	                this._stateComment(cp);
	                break;
	            }
	            case State.COMMENT_LESS_THAN_SIGN: {
	                this._stateCommentLessThanSign(cp);
	                break;
	            }
	            case State.COMMENT_LESS_THAN_SIGN_BANG: {
	                this._stateCommentLessThanSignBang(cp);
	                break;
	            }
	            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
	                this._stateCommentLessThanSignBangDash(cp);
	                break;
	            }
	            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
	                this._stateCommentLessThanSignBangDashDash(cp);
	                break;
	            }
	            case State.COMMENT_END_DASH: {
	                this._stateCommentEndDash(cp);
	                break;
	            }
	            case State.COMMENT_END: {
	                this._stateCommentEnd(cp);
	                break;
	            }
	            case State.COMMENT_END_BANG: {
	                this._stateCommentEndBang(cp);
	                break;
	            }
	            case State.DOCTYPE: {
	                this._stateDoctype(cp);
	                break;
	            }
	            case State.BEFORE_DOCTYPE_NAME: {
	                this._stateBeforeDoctypeName(cp);
	                break;
	            }
	            case State.DOCTYPE_NAME: {
	                this._stateDoctypeName(cp);
	                break;
	            }
	            case State.AFTER_DOCTYPE_NAME: {
	                this._stateAfterDoctypeName(cp);
	                break;
	            }
	            case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
	                this._stateAfterDoctypePublicKeyword(cp);
	                break;
	            }
	            case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
	                this._stateBeforeDoctypePublicIdentifier(cp);
	                break;
	            }
	            case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
	                this._stateDoctypePublicIdentifierDoubleQuoted(cp);
	                break;
	            }
	            case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
	                this._stateDoctypePublicIdentifierSingleQuoted(cp);
	                break;
	            }
	            case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
	                this._stateAfterDoctypePublicIdentifier(cp);
	                break;
	            }
	            case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
	                this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
	                break;
	            }
	            case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
	                this._stateAfterDoctypeSystemKeyword(cp);
	                break;
	            }
	            case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
	                this._stateBeforeDoctypeSystemIdentifier(cp);
	                break;
	            }
	            case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
	                this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
	                break;
	            }
	            case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
	                this._stateDoctypeSystemIdentifierSingleQuoted(cp);
	                break;
	            }
	            case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
	                this._stateAfterDoctypeSystemIdentifier(cp);
	                break;
	            }
	            case State.BOGUS_DOCTYPE: {
	                this._stateBogusDoctype(cp);
	                break;
	            }
	            case State.CDATA_SECTION: {
	                this._stateCdataSection(cp);
	                break;
	            }
	            case State.CDATA_SECTION_BRACKET: {
	                this._stateCdataSectionBracket(cp);
	                break;
	            }
	            case State.CDATA_SECTION_END: {
	                this._stateCdataSectionEnd(cp);
	                break;
	            }
	            case State.CHARACTER_REFERENCE: {
	                this._stateCharacterReference();
	                break;
	            }
	            case State.AMBIGUOUS_AMPERSAND: {
	                this._stateAmbiguousAmpersand(cp);
	                break;
	            }
	            default: {
	                throw new Error('Unknown state');
	            }
	        }
	    }
	    // State machine
	    // Data state
	    //------------------------------------------------------------------
	    _stateData(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.TAG_OPEN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.AMPERSAND: {
	                this._startCharacterReference();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitCodePoint(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    //  RCDATA state
	    //------------------------------------------------------------------
	    _stateRcdata(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.AMPERSAND: {
	                this._startCharacterReference();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.RCDATA_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // RAWTEXT state
	    //------------------------------------------------------------------
	    _stateRawtext(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.RAWTEXT_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data state
	    //------------------------------------------------------------------
	    _stateScriptData(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // PLAINTEXT state
	    //------------------------------------------------------------------
	    _statePlaintext(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Tag open state
	    //------------------------------------------------------------------
	    _stateTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this._createStartTagToken();
	            this.state = State.TAG_NAME;
	            this._stateTagName(cp);
	        }
	        else
	            switch (cp) {
	                case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
	                    this.state = State.MARKUP_DECLARATION_OPEN;
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                    this.state = State.END_TAG_OPEN;
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.QUESTION_MARK: {
	                    this._err(error_codes_js_1.ERR.unexpectedQuestionMarkInsteadOfTagName);
	                    this._createCommentToken(1);
	                    this.state = State.BOGUS_COMMENT;
	                    this._stateBogusComment(cp);
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.EOF: {
	                    this._err(error_codes_js_1.ERR.eofBeforeTagName);
	                    this._emitChars('<');
	                    this._emitEOFToken();
	                    break;
	                }
	                default: {
	                    this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
	                    this._emitChars('<');
	                    this.state = State.DATA;
	                    this._stateData(cp);
	                }
	            }
	    }
	    // End tag open state
	    //------------------------------------------------------------------
	    _stateEndTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this.state = State.TAG_NAME;
	            this._stateTagName(cp);
	        }
	        else
	            switch (cp) {
	                case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                    this._err(error_codes_js_1.ERR.missingEndTagName);
	                    this.state = State.DATA;
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.EOF: {
	                    this._err(error_codes_js_1.ERR.eofBeforeTagName);
	                    this._emitChars('</');
	                    this._emitEOFToken();
	                    break;
	                }
	                default: {
	                    this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
	                    this._createCommentToken(2);
	                    this.state = State.BOGUS_COMMENT;
	                    this._stateBogusComment(cp);
	                }
	            }
	    }
	    // Tag name state
	    //------------------------------------------------------------------
	    _stateTagName(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                this.state = State.SELF_CLOSING_START_TAG;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.tagName += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
	            }
	        }
	    }
	    // RCDATA less-than sign state
	    //------------------------------------------------------------------
	    _stateRcdataLessThanSign(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
	            this.state = State.RCDATA_END_TAG_OPEN;
	        }
	        else {
	            this._emitChars('<');
	            this.state = State.RCDATA;
	            this._stateRcdata(cp);
	        }
	    }
	    // RCDATA end tag open state
	    //------------------------------------------------------------------
	    _stateRcdataEndTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this.state = State.RCDATA_END_TAG_NAME;
	            this._stateRcdataEndTagName(cp);
	        }
	        else {
	            this._emitChars('</');
	            this.state = State.RCDATA;
	            this._stateRcdata(cp);
	        }
	    }
	    handleSpecialEndTag(_cp) {
	        if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
	            return !this._ensureHibernation();
	        }
	        this._createEndTagToken();
	        const token = this.currentToken;
	        token.tagName = this.lastStartTagName;
	        const cp = this.preprocessor.peek(this.lastStartTagName.length);
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this._advanceBy(this.lastStartTagName.length);
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                return false;
	            }
	            case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                this._advanceBy(this.lastStartTagName.length);
	                this.state = State.SELF_CLOSING_START_TAG;
	                return false;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._advanceBy(this.lastStartTagName.length);
	                this.emitCurrentTagToken();
	                this.state = State.DATA;
	                return false;
	            }
	            default: {
	                return !this._ensureHibernation();
	            }
	        }
	    }
	    // RCDATA end tag name state
	    //------------------------------------------------------------------
	    _stateRcdataEndTagName(cp) {
	        if (this.handleSpecialEndTag(cp)) {
	            this._emitChars('</');
	            this.state = State.RCDATA;
	            this._stateRcdata(cp);
	        }
	    }
	    // RAWTEXT less-than sign state
	    //------------------------------------------------------------------
	    _stateRawtextLessThanSign(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
	            this.state = State.RAWTEXT_END_TAG_OPEN;
	        }
	        else {
	            this._emitChars('<');
	            this.state = State.RAWTEXT;
	            this._stateRawtext(cp);
	        }
	    }
	    // RAWTEXT end tag open state
	    //------------------------------------------------------------------
	    _stateRawtextEndTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this.state = State.RAWTEXT_END_TAG_NAME;
	            this._stateRawtextEndTagName(cp);
	        }
	        else {
	            this._emitChars('</');
	            this.state = State.RAWTEXT;
	            this._stateRawtext(cp);
	        }
	    }
	    // RAWTEXT end tag name state
	    //------------------------------------------------------------------
	    _stateRawtextEndTagName(cp) {
	        if (this.handleSpecialEndTag(cp)) {
	            this._emitChars('</');
	            this.state = State.RAWTEXT;
	            this._stateRawtext(cp);
	        }
	    }
	    // Script data less-than sign state
	    //------------------------------------------------------------------
	    _stateScriptDataLessThanSign(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                this.state = State.SCRIPT_DATA_END_TAG_OPEN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
	                this.state = State.SCRIPT_DATA_ESCAPE_START;
	                this._emitChars('<!');
	                break;
	            }
	            default: {
	                this._emitChars('<');
	                this.state = State.SCRIPT_DATA;
	                this._stateScriptData(cp);
	            }
	        }
	    }
	    // Script data end tag open state
	    //------------------------------------------------------------------
	    _stateScriptDataEndTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this.state = State.SCRIPT_DATA_END_TAG_NAME;
	            this._stateScriptDataEndTagName(cp);
	        }
	        else {
	            this._emitChars('</');
	            this.state = State.SCRIPT_DATA;
	            this._stateScriptData(cp);
	        }
	    }
	    // Script data end tag name state
	    //------------------------------------------------------------------
	    _stateScriptDataEndTagName(cp) {
	        if (this.handleSpecialEndTag(cp)) {
	            this._emitChars('</');
	            this.state = State.SCRIPT_DATA;
	            this._stateScriptData(cp);
	        }
	    }
	    // Script data escape start state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapeStart(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
	            this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
	            this._emitChars('-');
	        }
	        else {
	            this.state = State.SCRIPT_DATA;
	            this._stateScriptData(cp);
	        }
	    }
	    // Script data escape start dash state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapeStartDash(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
	            this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
	            this._emitChars('-');
	        }
	        else {
	            this.state = State.SCRIPT_DATA;
	            this._stateScriptData(cp);
	        }
	    }
	    // Script data escaped state
	    //------------------------------------------------------------------
	    _stateScriptDataEscaped(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.SCRIPT_DATA_ESCAPED_DASH;
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data escaped dash state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapedDash(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.state = State.SCRIPT_DATA_ESCAPED;
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.state = State.SCRIPT_DATA_ESCAPED;
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data escaped dash dash state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapedDashDash(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA;
	                this._emitChars('>');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.state = State.SCRIPT_DATA_ESCAPED;
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.state = State.SCRIPT_DATA_ESCAPED;
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data escaped less-than sign state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapedLessThanSign(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
	            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
	        }
	        else if (isAsciiLetter(cp)) {
	            this._emitChars('<');
	            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
	            this._stateScriptDataDoubleEscapeStart(cp);
	        }
	        else {
	            this._emitChars('<');
	            this.state = State.SCRIPT_DATA_ESCAPED;
	            this._stateScriptDataEscaped(cp);
	        }
	    }
	    // Script data escaped end tag open state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapedEndTagOpen(cp) {
	        if (isAsciiLetter(cp)) {
	            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
	            this._stateScriptDataEscapedEndTagName(cp);
	        }
	        else {
	            this._emitChars('</');
	            this.state = State.SCRIPT_DATA_ESCAPED;
	            this._stateScriptDataEscaped(cp);
	        }
	    }
	    // Script data escaped end tag name state
	    //------------------------------------------------------------------
	    _stateScriptDataEscapedEndTagName(cp) {
	        if (this.handleSpecialEndTag(cp)) {
	            this._emitChars('</');
	            this.state = State.SCRIPT_DATA_ESCAPED;
	            this._stateScriptDataEscaped(cp);
	        }
	    }
	    // Script data double escape start state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscapeStart(cp) {
	        if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) &&
	            isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
	            this._emitCodePoint(cp);
	            for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
	                this._emitCodePoint(this._consume());
	            }
	            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	        }
	        else if (!this._ensureHibernation()) {
	            this.state = State.SCRIPT_DATA_ESCAPED;
	            this._stateScriptDataEscaped(cp);
	        }
	    }
	    // Script data double escaped state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscaped(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
	                this._emitChars('<');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data double escaped dash state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscapedDash(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
	                this._emitChars('<');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data double escaped dash dash state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscapedDashDash(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this._emitChars('-');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
	                this._emitChars('<');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.SCRIPT_DATA;
	                this._emitChars('>');
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	                this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // Script data double escaped less-than sign state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscapedLessThanSign(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
	            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
	            this._emitChars('/');
	        }
	        else {
	            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	            this._stateScriptDataDoubleEscaped(cp);
	        }
	    }
	    // Script data double escape end state
	    //------------------------------------------------------------------
	    _stateScriptDataDoubleEscapeEnd(cp) {
	        if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) &&
	            isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
	            this._emitCodePoint(cp);
	            for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
	                this._emitCodePoint(this._consume());
	            }
	            this.state = State.SCRIPT_DATA_ESCAPED;
	        }
	        else if (!this._ensureHibernation()) {
	            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
	            this._stateScriptDataDoubleEscaped(cp);
	        }
	    }
	    // Before attribute name state
	    //------------------------------------------------------------------
	    _stateBeforeAttributeName(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.SOLIDUS:
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this.state = State.AFTER_ATTRIBUTE_NAME;
	                this._stateAfterAttributeName(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
	                this._err(error_codes_js_1.ERR.unexpectedEqualsSignBeforeAttributeName);
	                this._createAttr('=');
	                this.state = State.ATTRIBUTE_NAME;
	                break;
	            }
	            default: {
	                this._createAttr('');
	                this.state = State.ATTRIBUTE_NAME;
	                this._stateAttributeName(cp);
	            }
	        }
	    }
	    // Attribute name state
	    //------------------------------------------------------------------
	    _stateAttributeName(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED:
	            case unicode_js_1.CODE_POINTS.SOLIDUS:
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._leaveAttrName();
	                this.state = State.AFTER_ATTRIBUTE_NAME;
	                this._stateAfterAttributeName(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
	                this._leaveAttrName();
	                this.state = State.BEFORE_ATTRIBUTE_VALUE;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
	            case unicode_js_1.CODE_POINTS.APOSTROPHE:
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.unexpectedCharacterInAttributeName);
	                this.currentAttr.name += String.fromCodePoint(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            default: {
	                this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
	            }
	        }
	    }
	    // After attribute name state
	    //------------------------------------------------------------------
	    _stateAfterAttributeName(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                this.state = State.SELF_CLOSING_START_TAG;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EQUALS_SIGN: {
	                this.state = State.BEFORE_ATTRIBUTE_VALUE;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._createAttr('');
	                this.state = State.ATTRIBUTE_NAME;
	                this._stateAttributeName(cp);
	            }
	        }
	    }
	    // Before attribute value state
	    //------------------------------------------------------------------
	    _stateBeforeAttributeValue(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.missingAttributeValue);
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            default: {
	                this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
	                this._stateAttributeValueUnquoted(cp);
	            }
	        }
	    }
	    // Attribute value (double-quoted) state
	    //------------------------------------------------------------------
	    _stateAttributeValueDoubleQuoted(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.AMPERSAND: {
	                this._startCharacterReference();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.currentAttr.value += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // Attribute value (single-quoted) state
	    //------------------------------------------------------------------
	    _stateAttributeValueSingleQuoted(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.AMPERSAND: {
	                this._startCharacterReference();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.currentAttr.value += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // Attribute value (unquoted) state
	    //------------------------------------------------------------------
	    _stateAttributeValueUnquoted(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this._leaveAttrValue();
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.AMPERSAND: {
	                this._startCharacterReference();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._leaveAttrValue();
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
	            case unicode_js_1.CODE_POINTS.APOSTROPHE:
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
	            case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
	            case unicode_js_1.CODE_POINTS.GRAVE_ACCENT: {
	                this._err(error_codes_js_1.ERR.unexpectedCharacterInUnquotedAttributeValue);
	                this.currentAttr.value += String.fromCodePoint(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this.currentAttr.value += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // After attribute value (quoted) state
	    //------------------------------------------------------------------
	    _stateAfterAttributeValueQuoted(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this._leaveAttrValue();
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.SOLIDUS: {
	                this._leaveAttrValue();
	                this.state = State.SELF_CLOSING_START_TAG;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._leaveAttrValue();
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceBetweenAttributes);
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                this._stateBeforeAttributeName(cp);
	            }
	        }
	    }
	    // Self-closing start tag state
	    //------------------------------------------------------------------
	    _stateSelfClosingStartTag(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                const token = this.currentToken;
	                token.selfClosing = true;
	                this.state = State.DATA;
	                this.emitCurrentTagToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInTag);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.unexpectedSolidusInTag);
	                this.state = State.BEFORE_ATTRIBUTE_NAME;
	                this._stateBeforeAttributeName(cp);
	            }
	        }
	    }
	    // Bogus comment state
	    //------------------------------------------------------------------
	    _stateBogusComment(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentComment(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.data += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            default: {
	                token.data += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // Markup declaration open state
	    //------------------------------------------------------------------
	    _stateMarkupDeclarationOpen(cp) {
	        if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {
	            this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);
	            this.state = State.COMMENT_START;
	        }
	        else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {
	            // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.
	            this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);
	            this.state = State.DOCTYPE;
	        }
	        else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {
	            if (this.inForeignNode) {
	                this.state = State.CDATA_SECTION;
	            }
	            else {
	                this._err(error_codes_js_1.ERR.cdataInHtmlContent);
	                this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);
	                this.currentToken.data = '[CDATA[';
	                this.state = State.BOGUS_COMMENT;
	            }
	        }
	        //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup
	        //results are no longer valid and we will need to start over.
	        else if (!this._ensureHibernation()) {
	            this._err(error_codes_js_1.ERR.incorrectlyOpenedComment);
	            this._createCommentToken(2);
	            this.state = State.BOGUS_COMMENT;
	            this._stateBogusComment(cp);
	        }
	    }
	    // Comment start state
	    //------------------------------------------------------------------
	    _stateCommentStart(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.COMMENT_START_DASH;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
	                this.state = State.DATA;
	                const token = this.currentToken;
	                this.emitCurrentComment(token);
	                break;
	            }
	            default: {
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // Comment start dash state
	    //------------------------------------------------------------------
	    _stateCommentStartDash(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.COMMENT_END;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
	                this.state = State.DATA;
	                this.emitCurrentComment(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInComment);
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.data += '-';
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // Comment state
	    //------------------------------------------------------------------
	    _stateComment(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.COMMENT_END_DASH;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                token.data += '<';
	                this.state = State.COMMENT_LESS_THAN_SIGN;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.data += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInComment);
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.data += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // Comment less-than sign state
	    //------------------------------------------------------------------
	    _stateCommentLessThanSign(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
	                token.data += '!';
	                this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN: {
	                token.data += '<';
	                break;
	            }
	            default: {
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // Comment less-than sign bang state
	    //------------------------------------------------------------------
	    _stateCommentLessThanSignBang(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
	            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
	        }
	        else {
	            this.state = State.COMMENT;
	            this._stateComment(cp);
	        }
	    }
	    // Comment less-than sign bang dash state
	    //------------------------------------------------------------------
	    _stateCommentLessThanSignBangDash(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
	            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
	        }
	        else {
	            this.state = State.COMMENT_END_DASH;
	            this._stateCommentEndDash(cp);
	        }
	    }
	    // Comment less-than sign bang dash dash state
	    //------------------------------------------------------------------
	    _stateCommentLessThanSignBangDashDash(cp) {
	        if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {
	            this._err(error_codes_js_1.ERR.nestedComment);
	        }
	        this.state = State.COMMENT_END;
	        this._stateCommentEnd(cp);
	    }
	    // Comment end dash state
	    //------------------------------------------------------------------
	    _stateCommentEndDash(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                this.state = State.COMMENT_END;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInComment);
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.data += '-';
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // Comment end state
	    //------------------------------------------------------------------
	    _stateCommentEnd(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentComment(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK: {
	                this.state = State.COMMENT_END_BANG;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                token.data += '-';
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInComment);
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.data += '--';
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // Comment end bang state
	    //------------------------------------------------------------------
	    _stateCommentEndBang(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.HYPHEN_MINUS: {
	                token.data += '--!';
	                this.state = State.COMMENT_END_DASH;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.incorrectlyClosedComment);
	                this.state = State.DATA;
	                this.emitCurrentComment(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInComment);
	                this.emitCurrentComment(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.data += '--!';
	                this.state = State.COMMENT;
	                this._stateComment(cp);
	            }
	        }
	    }
	    // DOCTYPE state
	    //------------------------------------------------------------------
	    _stateDoctype(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.BEFORE_DOCTYPE_NAME;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.BEFORE_DOCTYPE_NAME;
	                this._stateBeforeDoctypeName(cp);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                this._createDoctypeToken(null);
	                const token = this.currentToken;
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceBeforeDoctypeName);
	                this.state = State.BEFORE_DOCTYPE_NAME;
	                this._stateBeforeDoctypeName(cp);
	            }
	        }
	    }
	    // Before DOCTYPE name state
	    //------------------------------------------------------------------
	    _stateBeforeDoctypeName(cp) {
	        if (isAsciiUpper(cp)) {
	            this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
	            this.state = State.DOCTYPE_NAME;
	        }
	        else
	            switch (cp) {
	                case unicode_js_1.CODE_POINTS.SPACE:
	                case unicode_js_1.CODE_POINTS.LINE_FEED:
	                case unicode_js_1.CODE_POINTS.TABULATION:
	                case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                    // Ignore whitespace
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.NULL: {
	                    this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                    this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);
	                    this.state = State.DOCTYPE_NAME;
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                    this._err(error_codes_js_1.ERR.missingDoctypeName);
	                    this._createDoctypeToken(null);
	                    const token = this.currentToken;
	                    token.forceQuirks = true;
	                    this.emitCurrentDoctype(token);
	                    this.state = State.DATA;
	                    break;
	                }
	                case unicode_js_1.CODE_POINTS.EOF: {
	                    this._err(error_codes_js_1.ERR.eofInDoctype);
	                    this._createDoctypeToken(null);
	                    const token = this.currentToken;
	                    token.forceQuirks = true;
	                    this.emitCurrentDoctype(token);
	                    this._emitEOFToken();
	                    break;
	                }
	                default: {
	                    this._createDoctypeToken(String.fromCodePoint(cp));
	                    this.state = State.DOCTYPE_NAME;
	                }
	            }
	    }
	    // DOCTYPE name state
	    //------------------------------------------------------------------
	    _stateDoctypeName(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.AFTER_DOCTYPE_NAME;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.name += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
	            }
	        }
	    }
	    // After DOCTYPE name state
	    //------------------------------------------------------------------
	    _stateAfterDoctypeName(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {
	                    this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
	                }
	                else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {
	                    this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
	                }
	                //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
	                //results are no longer valid and we will need to start over.
	                else if (!this._ensureHibernation()) {
	                    this._err(error_codes_js_1.ERR.invalidCharacterSequenceAfterDoctypeName);
	                    token.forceQuirks = true;
	                    this.state = State.BOGUS_DOCTYPE;
	                    this._stateBogusDoctype(cp);
	                }
	            }
	        }
	    }
	    // After DOCTYPE public keyword state
	    //------------------------------------------------------------------
	    _stateAfterDoctypePublicKeyword(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
	                token.publicId = '';
	                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
	                token.publicId = '';
	                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // Before DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    _stateBeforeDoctypePublicIdentifier(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                token.publicId = '';
	                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                token.publicId = '';
	                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // DOCTYPE public identifier (double-quoted) state
	    //------------------------------------------------------------------
	    _stateDoctypePublicIdentifierDoubleQuoted(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.publicId += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // DOCTYPE public identifier (single-quoted) state
	    //------------------------------------------------------------------
	    _stateDoctypePublicIdentifierSingleQuoted(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.publicId += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // After DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    _stateAfterDoctypePublicIdentifier(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // Between DOCTYPE public and system identifiers state
	    //------------------------------------------------------------------
	    _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // After DOCTYPE system keyword state
	    //------------------------------------------------------------------
	    _stateAfterDoctypeSystemKeyword(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // Before DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    _stateBeforeDoctypeSystemIdentifier(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                token.systemId = '';
	                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.DATA;
	                this.emitCurrentDoctype(token);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // DOCTYPE system identifier (double-quoted) state
	    //------------------------------------------------------------------
	    _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.QUOTATION_MARK: {
	                this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.systemId += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // DOCTYPE system identifier (single-quoted) state
	    //------------------------------------------------------------------
	    _stateDoctypeSystemIdentifierSingleQuoted(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.APOSTROPHE: {
	                this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                token.systemId += String.fromCodePoint(cp);
	            }
	        }
	    }
	    // After DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    _stateAfterDoctypeSystemIdentifier(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.SPACE:
	            case unicode_js_1.CODE_POINTS.LINE_FEED:
	            case unicode_js_1.CODE_POINTS.TABULATION:
	            case unicode_js_1.CODE_POINTS.FORM_FEED: {
	                // Ignore whitespace
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInDoctype);
	                token.forceQuirks = true;
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._err(error_codes_js_1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
	                this.state = State.BOGUS_DOCTYPE;
	                this._stateBogusDoctype(cp);
	            }
	        }
	    }
	    // Bogus DOCTYPE state
	    //------------------------------------------------------------------
	    _stateBogusDoctype(cp) {
	        const token = this.currentToken;
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.emitCurrentDoctype(token);
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.NULL: {
	                this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this.emitCurrentDoctype(token);
	                this._emitEOFToken();
	                break;
	            }
	            // Do nothing
	        }
	    }
	    // CDATA section state
	    //------------------------------------------------------------------
	    _stateCdataSection(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
	                this.state = State.CDATA_SECTION_BRACKET;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.EOF: {
	                this._err(error_codes_js_1.ERR.eofInCdata);
	                this._emitEOFToken();
	                break;
	            }
	            default: {
	                this._emitCodePoint(cp);
	            }
	        }
	    }
	    // CDATA section bracket state
	    //------------------------------------------------------------------
	    _stateCdataSectionBracket(cp) {
	        if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {
	            this.state = State.CDATA_SECTION_END;
	        }
	        else {
	            this._emitChars(']');
	            this.state = State.CDATA_SECTION;
	            this._stateCdataSection(cp);
	        }
	    }
	    // CDATA section end state
	    //------------------------------------------------------------------
	    _stateCdataSectionEnd(cp) {
	        switch (cp) {
	            case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN: {
	                this.state = State.DATA;
	                break;
	            }
	            case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET: {
	                this._emitChars(']');
	                break;
	            }
	            default: {
	                this._emitChars(']]');
	                this.state = State.CDATA_SECTION;
	                this._stateCdataSection(cp);
	            }
	        }
	    }
	    // Character reference state
	    //------------------------------------------------------------------
	    _stateCharacterReference() {
	        let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
	        if (length < 0) {
	            if (this.preprocessor.lastChunkWritten) {
	                length = this.entityDecoder.end();
	            }
	            else {
	                // Wait for the rest of the entity.
	                this.active = false;
	                // Mark the entire buffer as read.
	                this.preprocessor.pos = this.preprocessor.html.length - 1;
	                this.consumedAfterSnapshot = 0;
	                this.preprocessor.endOfChunkHit = true;
	                return;
	            }
	        }
	        if (length === 0) {
	            // This was not a valid entity. Go back to the beginning, and
	            // figure out what to do.
	            this.preprocessor.pos = this.entityStartPos;
	            this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
	            this.state =
	                !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric(this.preprocessor.peek(1))
	                    ? State.AMBIGUOUS_AMPERSAND
	                    : this.returnState;
	        }
	        else {
	            // We successfully parsed an entity. Switch to the return state.
	            this.state = this.returnState;
	        }
	    }
	    // Ambiguos ampersand state
	    //------------------------------------------------------------------
	    _stateAmbiguousAmpersand(cp) {
	        if (isAsciiAlphaNumeric(cp)) {
	            this._flushCodePointConsumedAsCharacterReference(cp);
	        }
	        else {
	            if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
	                this._err(error_codes_js_1.ERR.unknownNamedCharacterReference);
	            }
	            this.state = this.returnState;
	            this._callState(cp);
	        }
	    }
	}
	tokenizer$3.Tokenizer = Tokenizer;
	return tokenizer$3;
}

var openElementStack = {};

var hasRequiredOpenElementStack;

function requireOpenElementStack () {
	if (hasRequiredOpenElementStack) return openElementStack;
	hasRequiredOpenElementStack = 1;
	Object.defineProperty(openElementStack, "__esModule", { value: true });
	openElementStack.OpenElementStack = void 0;
	const html_js_1 = requireHtml$1();
	//Element utils
	const IMPLICIT_END_TAG_REQUIRED = new Set([html_js_1.TAG_ID.DD, html_js_1.TAG_ID.DT, html_js_1.TAG_ID.LI, html_js_1.TAG_ID.OPTGROUP, html_js_1.TAG_ID.OPTION, html_js_1.TAG_ID.P, html_js_1.TAG_ID.RB, html_js_1.TAG_ID.RP, html_js_1.TAG_ID.RT, html_js_1.TAG_ID.RTC]);
	const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([
	    ...IMPLICIT_END_TAG_REQUIRED,
	    html_js_1.TAG_ID.CAPTION,
	    html_js_1.TAG_ID.COLGROUP,
	    html_js_1.TAG_ID.TBODY,
	    html_js_1.TAG_ID.TD,
	    html_js_1.TAG_ID.TFOOT,
	    html_js_1.TAG_ID.TH,
	    html_js_1.TAG_ID.THEAD,
	    html_js_1.TAG_ID.TR,
	]);
	const SCOPING_ELEMENTS_HTML = new Set([
	    html_js_1.TAG_ID.APPLET,
	    html_js_1.TAG_ID.CAPTION,
	    html_js_1.TAG_ID.HTML,
	    html_js_1.TAG_ID.MARQUEE,
	    html_js_1.TAG_ID.OBJECT,
	    html_js_1.TAG_ID.TABLE,
	    html_js_1.TAG_ID.TD,
	    html_js_1.TAG_ID.TEMPLATE,
	    html_js_1.TAG_ID.TH,
	]);
	const SCOPING_ELEMENTS_HTML_LIST = new Set([...SCOPING_ELEMENTS_HTML, html_js_1.TAG_ID.OL, html_js_1.TAG_ID.UL]);
	const SCOPING_ELEMENTS_HTML_BUTTON = new Set([...SCOPING_ELEMENTS_HTML, html_js_1.TAG_ID.BUTTON]);
	const SCOPING_ELEMENTS_MATHML = new Set([html_js_1.TAG_ID.ANNOTATION_XML, html_js_1.TAG_ID.MI, html_js_1.TAG_ID.MN, html_js_1.TAG_ID.MO, html_js_1.TAG_ID.MS, html_js_1.TAG_ID.MTEXT]);
	const SCOPING_ELEMENTS_SVG = new Set([html_js_1.TAG_ID.DESC, html_js_1.TAG_ID.FOREIGN_OBJECT, html_js_1.TAG_ID.TITLE]);
	const TABLE_ROW_CONTEXT = new Set([html_js_1.TAG_ID.TR, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
	const TABLE_BODY_CONTEXT = new Set([html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
	const TABLE_CONTEXT = new Set([html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
	const TABLE_CELLS = new Set([html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TH]);
	//Stack of open elements
	class OpenElementStack {
	    get currentTmplContentOrNode() {
	        return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
	    }
	    constructor(document, treeAdapter, handler) {
	        this.treeAdapter = treeAdapter;
	        this.handler = handler;
	        this.items = [];
	        this.tagIDs = [];
	        this.stackTop = -1;
	        this.tmplCount = 0;
	        this.currentTagId = html_js_1.TAG_ID.UNKNOWN;
	        this.current = document;
	    }
	    //Index of element
	    _indexOf(element) {
	        return this.items.lastIndexOf(element, this.stackTop);
	    }
	    //Update current element
	    _isInTemplate() {
	        return this.currentTagId === html_js_1.TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === html_js_1.NS.HTML;
	    }
	    _updateCurrentElement() {
	        this.current = this.items[this.stackTop];
	        this.currentTagId = this.tagIDs[this.stackTop];
	    }
	    //Mutations
	    push(element, tagID) {
	        this.stackTop++;
	        this.items[this.stackTop] = element;
	        this.current = element;
	        this.tagIDs[this.stackTop] = tagID;
	        this.currentTagId = tagID;
	        if (this._isInTemplate()) {
	            this.tmplCount++;
	        }
	        this.handler.onItemPush(element, tagID, true);
	    }
	    pop() {
	        const popped = this.current;
	        if (this.tmplCount > 0 && this._isInTemplate()) {
	            this.tmplCount--;
	        }
	        this.stackTop--;
	        this._updateCurrentElement();
	        this.handler.onItemPop(popped, true);
	    }
	    replace(oldElement, newElement) {
	        const idx = this._indexOf(oldElement);
	        this.items[idx] = newElement;
	        if (idx === this.stackTop) {
	            this.current = newElement;
	        }
	    }
	    insertAfter(referenceElement, newElement, newElementID) {
	        const insertionIdx = this._indexOf(referenceElement) + 1;
	        this.items.splice(insertionIdx, 0, newElement);
	        this.tagIDs.splice(insertionIdx, 0, newElementID);
	        this.stackTop++;
	        if (insertionIdx === this.stackTop) {
	            this._updateCurrentElement();
	        }
	        if (this.current && this.currentTagId !== undefined) {
	            this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
	        }
	    }
	    popUntilTagNamePopped(tagName) {
	        let targetIdx = this.stackTop + 1;
	        do {
	            targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
	        } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== html_js_1.NS.HTML);
	        this.shortenToLength(Math.max(targetIdx, 0));
	    }
	    shortenToLength(idx) {
	        while (this.stackTop >= idx) {
	            const popped = this.current;
	            if (this.tmplCount > 0 && this._isInTemplate()) {
	                this.tmplCount -= 1;
	            }
	            this.stackTop--;
	            this._updateCurrentElement();
	            this.handler.onItemPop(popped, this.stackTop < idx);
	        }
	    }
	    popUntilElementPopped(element) {
	        const idx = this._indexOf(element);
	        this.shortenToLength(Math.max(idx, 0));
	    }
	    popUntilPopped(tagNames, targetNS) {
	        const idx = this._indexOfTagNames(tagNames, targetNS);
	        this.shortenToLength(Math.max(idx, 0));
	    }
	    popUntilNumberedHeaderPopped() {
	        this.popUntilPopped(html_js_1.NUMBERED_HEADERS, html_js_1.NS.HTML);
	    }
	    popUntilTableCellPopped() {
	        this.popUntilPopped(TABLE_CELLS, html_js_1.NS.HTML);
	    }
	    popAllUpToHtmlElement() {
	        //NOTE: here we assume that the root <html> element is always first in the open element stack, so
	        //we perform this fast stack clean up.
	        this.tmplCount = 0;
	        this.shortenToLength(1);
	    }
	    _indexOfTagNames(tagNames, namespace) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
	                return i;
	            }
	        }
	        return -1;
	    }
	    clearBackTo(tagNames, targetNS) {
	        const idx = this._indexOfTagNames(tagNames, targetNS);
	        this.shortenToLength(idx + 1);
	    }
	    clearBackToTableContext() {
	        this.clearBackTo(TABLE_CONTEXT, html_js_1.NS.HTML);
	    }
	    clearBackToTableBodyContext() {
	        this.clearBackTo(TABLE_BODY_CONTEXT, html_js_1.NS.HTML);
	    }
	    clearBackToTableRowContext() {
	        this.clearBackTo(TABLE_ROW_CONTEXT, html_js_1.NS.HTML);
	    }
	    remove(element) {
	        const idx = this._indexOf(element);
	        if (idx >= 0) {
	            if (idx === this.stackTop) {
	                this.pop();
	            }
	            else {
	                this.items.splice(idx, 1);
	                this.tagIDs.splice(idx, 1);
	                this.stackTop--;
	                this._updateCurrentElement();
	                this.handler.onItemPop(element, false);
	            }
	        }
	    }
	    //Search
	    tryPeekProperlyNestedBodyElement() {
	        //Properly nested <body> element (should be second element in stack).
	        return this.stackTop >= 1 && this.tagIDs[1] === html_js_1.TAG_ID.BODY ? this.items[1] : null;
	    }
	    contains(element) {
	        return this._indexOf(element) > -1;
	    }
	    getCommonAncestor(element) {
	        const elementIdx = this._indexOf(element) - 1;
	        return elementIdx >= 0 ? this.items[elementIdx] : null;
	    }
	    isRootHtmlElementCurrent() {
	        return this.stackTop === 0 && this.tagIDs[0] === html_js_1.TAG_ID.HTML;
	    }
	    //Element in scope
	    hasInDynamicScope(tagName, htmlScope) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.tagIDs[i];
	            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
	                case html_js_1.NS.HTML: {
	                    if (tn === tagName)
	                        return true;
	                    if (htmlScope.has(tn))
	                        return false;
	                    break;
	                }
	                case html_js_1.NS.SVG: {
	                    if (SCOPING_ELEMENTS_SVG.has(tn))
	                        return false;
	                    break;
	                }
	                case html_js_1.NS.MATHML: {
	                    if (SCOPING_ELEMENTS_MATHML.has(tn))
	                        return false;
	                    break;
	                }
	            }
	        }
	        return true;
	    }
	    hasInScope(tagName) {
	        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
	    }
	    hasInListItemScope(tagName) {
	        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
	    }
	    hasInButtonScope(tagName) {
	        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
	    }
	    hasNumberedHeaderInScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.tagIDs[i];
	            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
	                case html_js_1.NS.HTML: {
	                    if (html_js_1.NUMBERED_HEADERS.has(tn))
	                        return true;
	                    if (SCOPING_ELEMENTS_HTML.has(tn))
	                        return false;
	                    break;
	                }
	                case html_js_1.NS.SVG: {
	                    if (SCOPING_ELEMENTS_SVG.has(tn))
	                        return false;
	                    break;
	                }
	                case html_js_1.NS.MATHML: {
	                    if (SCOPING_ELEMENTS_MATHML.has(tn))
	                        return false;
	                    break;
	                }
	            }
	        }
	        return true;
	    }
	    hasInTableScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
	                continue;
	            }
	            switch (this.tagIDs[i]) {
	                case tagName: {
	                    return true;
	                }
	                case html_js_1.TAG_ID.TABLE:
	                case html_js_1.TAG_ID.HTML: {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	    hasTableBodyContextInTableScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
	                continue;
	            }
	            switch (this.tagIDs[i]) {
	                case html_js_1.TAG_ID.TBODY:
	                case html_js_1.TAG_ID.THEAD:
	                case html_js_1.TAG_ID.TFOOT: {
	                    return true;
	                }
	                case html_js_1.TAG_ID.TABLE:
	                case html_js_1.TAG_ID.HTML: {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	    hasInSelectScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
	                continue;
	            }
	            switch (this.tagIDs[i]) {
	                case tagName: {
	                    return true;
	                }
	                case html_js_1.TAG_ID.OPTION:
	                case html_js_1.TAG_ID.OPTGROUP: {
	                    break;
	                }
	                default: {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	    //Implied end tags
	    generateImpliedEndTags() {
	        while (this.currentTagId !== undefined && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
	            this.pop();
	        }
	    }
	    generateImpliedEndTagsThoroughly() {
	        while (this.currentTagId !== undefined && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
	            this.pop();
	        }
	    }
	    generateImpliedEndTagsWithExclusion(exclusionId) {
	        while (this.currentTagId !== undefined &&
	            this.currentTagId !== exclusionId &&
	            IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
	            this.pop();
	        }
	    }
	}
	openElementStack.OpenElementStack = OpenElementStack;
	return openElementStack;
}

var formattingElementList = {};

var hasRequiredFormattingElementList;

function requireFormattingElementList () {
	if (hasRequiredFormattingElementList) return formattingElementList;
	hasRequiredFormattingElementList = 1;
	Object.defineProperty(formattingElementList, "__esModule", { value: true });
	formattingElementList.FormattingElementList = formattingElementList.EntryType = void 0;
	//Const
	const NOAH_ARK_CAPACITY = 3;
	var EntryType;
	(function (EntryType) {
	    EntryType[EntryType["Marker"] = 0] = "Marker";
	    EntryType[EntryType["Element"] = 1] = "Element";
	})(EntryType || (formattingElementList.EntryType = EntryType = {}));
	const MARKER = { type: EntryType.Marker };
	//List of formatting elements
	class FormattingElementList {
	    constructor(treeAdapter) {
	        this.treeAdapter = treeAdapter;
	        this.entries = [];
	        this.bookmark = null;
	    }
	    //Noah Ark's condition
	    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
	    //lightweight heuristics without thorough attributes check.
	    _getNoahArkConditionCandidates(newElement, neAttrs) {
	        const candidates = [];
	        const neAttrsLength = neAttrs.length;
	        const neTagName = this.treeAdapter.getTagName(newElement);
	        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
	        for (let i = 0; i < this.entries.length; i++) {
	            const entry = this.entries[i];
	            if (entry.type === EntryType.Marker) {
	                break;
	            }
	            const { element } = entry;
	            if (this.treeAdapter.getTagName(element) === neTagName &&
	                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
	                const elementAttrs = this.treeAdapter.getAttrList(element);
	                if (elementAttrs.length === neAttrsLength) {
	                    candidates.push({ idx: i, attrs: elementAttrs });
	                }
	            }
	        }
	        return candidates;
	    }
	    _ensureNoahArkCondition(newElement) {
	        if (this.entries.length < NOAH_ARK_CAPACITY)
	            return;
	        const neAttrs = this.treeAdapter.getAttrList(newElement);
	        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
	        if (candidates.length < NOAH_ARK_CAPACITY)
	            return;
	        //NOTE: build attrs map for the new element, so we can perform fast lookups
	        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
	        let validCandidates = 0;
	        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met
	        for (let i = 0; i < candidates.length; i++) {
	            const candidate = candidates[i];
	            // We know that `candidate.attrs.length === neAttrs.length`
	            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
	                validCandidates += 1;
	                if (validCandidates >= NOAH_ARK_CAPACITY) {
	                    this.entries.splice(candidate.idx, 1);
	                }
	            }
	        }
	    }
	    //Mutations
	    insertMarker() {
	        this.entries.unshift(MARKER);
	    }
	    pushElement(element, token) {
	        this._ensureNoahArkCondition(element);
	        this.entries.unshift({
	            type: EntryType.Element,
	            element,
	            token,
	        });
	    }
	    insertElementAfterBookmark(element, token) {
	        const bookmarkIdx = this.entries.indexOf(this.bookmark);
	        this.entries.splice(bookmarkIdx, 0, {
	            type: EntryType.Element,
	            element,
	            token,
	        });
	    }
	    removeEntry(entry) {
	        const entryIndex = this.entries.indexOf(entry);
	        if (entryIndex !== -1) {
	            this.entries.splice(entryIndex, 1);
	        }
	    }
	    /**
	     * Clears the list of formatting elements up to the last marker.
	     *
	     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
	     */
	    clearToLastMarker() {
	        const markerIdx = this.entries.indexOf(MARKER);
	        if (markerIdx === -1) {
	            this.entries.length = 0;
	        }
	        else {
	            this.entries.splice(0, markerIdx + 1);
	        }
	    }
	    //Search
	    getElementEntryInScopeWithTagName(tagName) {
	        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);
	        return entry && entry.type === EntryType.Element ? entry : null;
	    }
	    getElementEntry(element) {
	        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
	    }
	}
	formattingElementList.FormattingElementList = FormattingElementList;
	return formattingElementList;
}

var _default = {};

var hasRequired_default;

function require_default () {
	if (hasRequired_default) return _default;
	hasRequired_default = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.defaultTreeAdapter = void 0;
		const html_js_1 = requireHtml$1();
		exports$1.defaultTreeAdapter = {
		    //Node construction
		    createDocument() {
		        return {
		            nodeName: '#document',
		            mode: html_js_1.DOCUMENT_MODE.NO_QUIRKS,
		            childNodes: [],
		        };
		    },
		    createDocumentFragment() {
		        return {
		            nodeName: '#document-fragment',
		            childNodes: [],
		        };
		    },
		    createElement(tagName, namespaceURI, attrs) {
		        return {
		            nodeName: tagName,
		            tagName,
		            attrs,
		            namespaceURI,
		            childNodes: [],
		            parentNode: null,
		        };
		    },
		    createCommentNode(data) {
		        return {
		            nodeName: '#comment',
		            data,
		            parentNode: null,
		        };
		    },
		    createTextNode(value) {
		        return {
		            nodeName: '#text',
		            value,
		            parentNode: null,
		        };
		    },
		    //Tree mutation
		    appendChild(parentNode, newNode) {
		        parentNode.childNodes.push(newNode);
		        newNode.parentNode = parentNode;
		    },
		    insertBefore(parentNode, newNode, referenceNode) {
		        const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
		        parentNode.childNodes.splice(insertionIdx, 0, newNode);
		        newNode.parentNode = parentNode;
		    },
		    setTemplateContent(templateElement, contentElement) {
		        templateElement.content = contentElement;
		    },
		    getTemplateContent(templateElement) {
		        return templateElement.content;
		    },
		    setDocumentType(document, name, publicId, systemId) {
		        const doctypeNode = document.childNodes.find((node) => node.nodeName === '#documentType');
		        if (doctypeNode) {
		            doctypeNode.name = name;
		            doctypeNode.publicId = publicId;
		            doctypeNode.systemId = systemId;
		        }
		        else {
		            const node = {
		                nodeName: '#documentType',
		                name,
		                publicId,
		                systemId,
		                parentNode: null,
		            };
		            exports$1.defaultTreeAdapter.appendChild(document, node);
		        }
		    },
		    setDocumentMode(document, mode) {
		        document.mode = mode;
		    },
		    getDocumentMode(document) {
		        return document.mode;
		    },
		    detachNode(node) {
		        if (node.parentNode) {
		            const idx = node.parentNode.childNodes.indexOf(node);
		            node.parentNode.childNodes.splice(idx, 1);
		            node.parentNode = null;
		        }
		    },
		    insertText(parentNode, text) {
		        if (parentNode.childNodes.length > 0) {
		            const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
		            if (exports$1.defaultTreeAdapter.isTextNode(prevNode)) {
		                prevNode.value += text;
		                return;
		            }
		        }
		        exports$1.defaultTreeAdapter.appendChild(parentNode, exports$1.defaultTreeAdapter.createTextNode(text));
		    },
		    insertTextBefore(parentNode, text, referenceNode) {
		        const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
		        if (prevNode && exports$1.defaultTreeAdapter.isTextNode(prevNode)) {
		            prevNode.value += text;
		        }
		        else {
		            exports$1.defaultTreeAdapter.insertBefore(parentNode, exports$1.defaultTreeAdapter.createTextNode(text), referenceNode);
		        }
		    },
		    adoptAttributes(recipient, attrs) {
		        const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
		        for (let j = 0; j < attrs.length; j++) {
		            if (!recipientAttrsMap.has(attrs[j].name)) {
		                recipient.attrs.push(attrs[j]);
		            }
		        }
		    },
		    //Tree traversing
		    getFirstChild(node) {
		        return node.childNodes[0];
		    },
		    getChildNodes(node) {
		        return node.childNodes;
		    },
		    getParentNode(node) {
		        return node.parentNode;
		    },
		    getAttrList(element) {
		        return element.attrs;
		    },
		    //Node data
		    getTagName(element) {
		        return element.tagName;
		    },
		    getNamespaceURI(element) {
		        return element.namespaceURI;
		    },
		    getTextNodeContent(textNode) {
		        return textNode.value;
		    },
		    getCommentNodeContent(commentNode) {
		        return commentNode.data;
		    },
		    getDocumentTypeNodeName(doctypeNode) {
		        return doctypeNode.name;
		    },
		    getDocumentTypeNodePublicId(doctypeNode) {
		        return doctypeNode.publicId;
		    },
		    getDocumentTypeNodeSystemId(doctypeNode) {
		        return doctypeNode.systemId;
		    },
		    //Node types
		    isTextNode(node) {
		        return node.nodeName === '#text';
		    },
		    isCommentNode(node) {
		        return node.nodeName === '#comment';
		    },
		    isDocumentTypeNode(node) {
		        return node.nodeName === '#documentType';
		    },
		    isElementNode(node) {
		        return Object.prototype.hasOwnProperty.call(node, 'tagName');
		    },
		    // Source code location
		    setNodeSourceCodeLocation(node, location) {
		        node.sourceCodeLocation = location;
		    },
		    getNodeSourceCodeLocation(node) {
		        return node.sourceCodeLocation;
		    },
		    updateNodeSourceCodeLocation(node, endLocation) {
		        node.sourceCodeLocation = Object.assign(Object.assign({}, node.sourceCodeLocation), endLocation);
		    },
		}; 
	} (_default));
	return _default;
}

var doctype = {};

var hasRequiredDoctype;

function requireDoctype () {
	if (hasRequiredDoctype) return doctype;
	hasRequiredDoctype = 1;
	Object.defineProperty(doctype, "__esModule", { value: true });
	doctype.isConforming = isConforming;
	doctype.getDocumentMode = getDocumentMode;
	const html_js_1 = requireHtml$1();
	//Const
	const VALID_DOCTYPE_NAME = 'html';
	const VALID_SYSTEM_ID = 'about:legacy-compat';
	const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
	const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
	    '+//silmaril//dtd html pro v0r11 19970101//',
	    '-//as//dtd html 3.0 aswedit + extensions//',
	    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
	    '-//ietf//dtd html 2.0 level 1//',
	    '-//ietf//dtd html 2.0 level 2//',
	    '-//ietf//dtd html 2.0 strict level 1//',
	    '-//ietf//dtd html 2.0 strict level 2//',
	    '-//ietf//dtd html 2.0 strict//',
	    '-//ietf//dtd html 2.0//',
	    '-//ietf//dtd html 2.1e//',
	    '-//ietf//dtd html 3.0//',
	    '-//ietf//dtd html 3.2 final//',
	    '-//ietf//dtd html 3.2//',
	    '-//ietf//dtd html 3//',
	    '-//ietf//dtd html level 0//',
	    '-//ietf//dtd html level 1//',
	    '-//ietf//dtd html level 2//',
	    '-//ietf//dtd html level 3//',
	    '-//ietf//dtd html strict level 0//',
	    '-//ietf//dtd html strict level 1//',
	    '-//ietf//dtd html strict level 2//',
	    '-//ietf//dtd html strict level 3//',
	    '-//ietf//dtd html strict//',
	    '-//ietf//dtd html//',
	    '-//metrius//dtd metrius presentational//',
	    '-//microsoft//dtd internet explorer 2.0 html strict//',
	    '-//microsoft//dtd internet explorer 2.0 html//',
	    '-//microsoft//dtd internet explorer 2.0 tables//',
	    '-//microsoft//dtd internet explorer 3.0 html strict//',
	    '-//microsoft//dtd internet explorer 3.0 html//',
	    '-//microsoft//dtd internet explorer 3.0 tables//',
	    '-//netscape comm. corp.//dtd html//',
	    '-//netscape comm. corp.//dtd strict html//',
	    "-//o'reilly and associates//dtd html 2.0//",
	    "-//o'reilly and associates//dtd html extended 1.0//",
	    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
	    '-//sq//dtd html 2.0 hotmetal + extensions//',
	    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
	    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
	    '-//spyglass//dtd html 2.0 extended//',
	    '-//sun microsystems corp.//dtd hotjava html//',
	    '-//sun microsystems corp.//dtd hotjava strict html//',
	    '-//w3c//dtd html 3 1995-03-24//',
	    '-//w3c//dtd html 3.2 draft//',
	    '-//w3c//dtd html 3.2 final//',
	    '-//w3c//dtd html 3.2//',
	    '-//w3c//dtd html 3.2s draft//',
	    '-//w3c//dtd html 4.0 frameset//',
	    '-//w3c//dtd html 4.0 transitional//',
	    '-//w3c//dtd html experimental 19960712//',
	    '-//w3c//dtd html experimental 970421//',
	    '-//w3c//dtd w3 html//',
	    '-//w3o//dtd w3 html 3.0//',
	    '-//webtechs//dtd mozilla html 2.0//',
	    '-//webtechs//dtd mozilla html//',
	];
	const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	    ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//',
	];
	const QUIRKS_MODE_PUBLIC_IDS = new Set([
	    '-//w3o//dtd w3 html strict 3.0//en//',
	    '-/w3c/dtd html 4.0 transitional/en',
	    'html',
	]);
	const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
	const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	    ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//',
	];
	//Utils
	function hasPrefix(publicId, prefixes) {
	    return prefixes.some((prefix) => publicId.startsWith(prefix));
	}
	//API
	function isConforming(token) {
	    return (token.name === VALID_DOCTYPE_NAME &&
	        token.publicId === null &&
	        (token.systemId === null || token.systemId === VALID_SYSTEM_ID));
	}
	function getDocumentMode(token) {
	    if (token.name !== VALID_DOCTYPE_NAME) {
	        return html_js_1.DOCUMENT_MODE.QUIRKS;
	    }
	    const { systemId } = token;
	    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
	        return html_js_1.DOCUMENT_MODE.QUIRKS;
	    }
	    let { publicId } = token;
	    if (publicId !== null) {
	        publicId = publicId.toLowerCase();
	        if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
	            return html_js_1.DOCUMENT_MODE.QUIRKS;
	        }
	        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
	        if (hasPrefix(publicId, prefixes)) {
	            return html_js_1.DOCUMENT_MODE.QUIRKS;
	        }
	        prefixes =
	            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
	        if (hasPrefix(publicId, prefixes)) {
	            return html_js_1.DOCUMENT_MODE.LIMITED_QUIRKS;
	        }
	    }
	    return html_js_1.DOCUMENT_MODE.NO_QUIRKS;
	}
	return doctype;
}

var foreignContent = {};

var hasRequiredForeignContent;

function requireForeignContent () {
	if (hasRequiredForeignContent) return foreignContent;
	hasRequiredForeignContent = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = void 0;
		exports$1.causesExit = causesExit;
		exports$1.adjustTokenMathMLAttrs = adjustTokenMathMLAttrs;
		exports$1.adjustTokenSVGAttrs = adjustTokenSVGAttrs;
		exports$1.adjustTokenXMLAttrs = adjustTokenXMLAttrs;
		exports$1.adjustTokenSVGTagName = adjustTokenSVGTagName;
		exports$1.isIntegrationPoint = isIntegrationPoint;
		const html_js_1 = requireHtml$1();
		//MIME types
		const MIME_TYPES = {
		    TEXT_HTML: 'text/html',
		    APPLICATION_XML: 'application/xhtml+xml',
		};
		//Attributes
		const DEFINITION_URL_ATTR = 'definitionurl';
		const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
		const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
		    'attributeName',
		    'attributeType',
		    'baseFrequency',
		    'baseProfile',
		    'calcMode',
		    'clipPathUnits',
		    'diffuseConstant',
		    'edgeMode',
		    'filterUnits',
		    'glyphRef',
		    'gradientTransform',
		    'gradientUnits',
		    'kernelMatrix',
		    'kernelUnitLength',
		    'keyPoints',
		    'keySplines',
		    'keyTimes',
		    'lengthAdjust',
		    'limitingConeAngle',
		    'markerHeight',
		    'markerUnits',
		    'markerWidth',
		    'maskContentUnits',
		    'maskUnits',
		    'numOctaves',
		    'pathLength',
		    'patternContentUnits',
		    'patternTransform',
		    'patternUnits',
		    'pointsAtX',
		    'pointsAtY',
		    'pointsAtZ',
		    'preserveAlpha',
		    'preserveAspectRatio',
		    'primitiveUnits',
		    'refX',
		    'refY',
		    'repeatCount',
		    'repeatDur',
		    'requiredExtensions',
		    'requiredFeatures',
		    'specularConstant',
		    'specularExponent',
		    'spreadMethod',
		    'startOffset',
		    'stdDeviation',
		    'stitchTiles',
		    'surfaceScale',
		    'systemLanguage',
		    'tableValues',
		    'targetX',
		    'targetY',
		    'textLength',
		    'viewBox',
		    'viewTarget',
		    'xChannelSelector',
		    'yChannelSelector',
		    'zoomAndPan',
		].map((attr) => [attr.toLowerCase(), attr]));
		const XML_ATTRS_ADJUSTMENT_MAP = new Map([
		    ['xlink:actuate', { prefix: 'xlink', name: 'actuate', namespace: html_js_1.NS.XLINK }],
		    ['xlink:arcrole', { prefix: 'xlink', name: 'arcrole', namespace: html_js_1.NS.XLINK }],
		    ['xlink:href', { prefix: 'xlink', name: 'href', namespace: html_js_1.NS.XLINK }],
		    ['xlink:role', { prefix: 'xlink', name: 'role', namespace: html_js_1.NS.XLINK }],
		    ['xlink:show', { prefix: 'xlink', name: 'show', namespace: html_js_1.NS.XLINK }],
		    ['xlink:title', { prefix: 'xlink', name: 'title', namespace: html_js_1.NS.XLINK }],
		    ['xlink:type', { prefix: 'xlink', name: 'type', namespace: html_js_1.NS.XLINK }],
		    ['xml:lang', { prefix: 'xml', name: 'lang', namespace: html_js_1.NS.XML }],
		    ['xml:space', { prefix: 'xml', name: 'space', namespace: html_js_1.NS.XML }],
		    ['xmlns', { prefix: '', name: 'xmlns', namespace: html_js_1.NS.XMLNS }],
		    ['xmlns:xlink', { prefix: 'xmlns', name: 'xlink', namespace: html_js_1.NS.XMLNS }],
		]);
		//SVG tag names adjustment map
		exports$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
		    'altGlyph',
		    'altGlyphDef',
		    'altGlyphItem',
		    'animateColor',
		    'animateMotion',
		    'animateTransform',
		    'clipPath',
		    'feBlend',
		    'feColorMatrix',
		    'feComponentTransfer',
		    'feComposite',
		    'feConvolveMatrix',
		    'feDiffuseLighting',
		    'feDisplacementMap',
		    'feDistantLight',
		    'feFlood',
		    'feFuncA',
		    'feFuncB',
		    'feFuncG',
		    'feFuncR',
		    'feGaussianBlur',
		    'feImage',
		    'feMerge',
		    'feMergeNode',
		    'feMorphology',
		    'feOffset',
		    'fePointLight',
		    'feSpecularLighting',
		    'feSpotLight',
		    'feTile',
		    'feTurbulence',
		    'foreignObject',
		    'glyphRef',
		    'linearGradient',
		    'radialGradient',
		    'textPath',
		].map((tn) => [tn.toLowerCase(), tn]));
		//Tags that causes exit from foreign content
		const EXITS_FOREIGN_CONTENT = new Set([
		    html_js_1.TAG_ID.B,
		    html_js_1.TAG_ID.BIG,
		    html_js_1.TAG_ID.BLOCKQUOTE,
		    html_js_1.TAG_ID.BODY,
		    html_js_1.TAG_ID.BR,
		    html_js_1.TAG_ID.CENTER,
		    html_js_1.TAG_ID.CODE,
		    html_js_1.TAG_ID.DD,
		    html_js_1.TAG_ID.DIV,
		    html_js_1.TAG_ID.DL,
		    html_js_1.TAG_ID.DT,
		    html_js_1.TAG_ID.EM,
		    html_js_1.TAG_ID.EMBED,
		    html_js_1.TAG_ID.H1,
		    html_js_1.TAG_ID.H2,
		    html_js_1.TAG_ID.H3,
		    html_js_1.TAG_ID.H4,
		    html_js_1.TAG_ID.H5,
		    html_js_1.TAG_ID.H6,
		    html_js_1.TAG_ID.HEAD,
		    html_js_1.TAG_ID.HR,
		    html_js_1.TAG_ID.I,
		    html_js_1.TAG_ID.IMG,
		    html_js_1.TAG_ID.LI,
		    html_js_1.TAG_ID.LISTING,
		    html_js_1.TAG_ID.MENU,
		    html_js_1.TAG_ID.META,
		    html_js_1.TAG_ID.NOBR,
		    html_js_1.TAG_ID.OL,
		    html_js_1.TAG_ID.P,
		    html_js_1.TAG_ID.PRE,
		    html_js_1.TAG_ID.RUBY,
		    html_js_1.TAG_ID.S,
		    html_js_1.TAG_ID.SMALL,
		    html_js_1.TAG_ID.SPAN,
		    html_js_1.TAG_ID.STRONG,
		    html_js_1.TAG_ID.STRIKE,
		    html_js_1.TAG_ID.SUB,
		    html_js_1.TAG_ID.SUP,
		    html_js_1.TAG_ID.TABLE,
		    html_js_1.TAG_ID.TT,
		    html_js_1.TAG_ID.U,
		    html_js_1.TAG_ID.UL,
		    html_js_1.TAG_ID.VAR,
		]);
		//Check exit from foreign content
		function causesExit(startTagToken) {
		    const tn = startTagToken.tagID;
		    const isFontWithAttrs = tn === html_js_1.TAG_ID.FONT &&
		        startTagToken.attrs.some(({ name }) => name === html_js_1.ATTRS.COLOR || name === html_js_1.ATTRS.SIZE || name === html_js_1.ATTRS.FACE);
		    return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
		}
		//Token adjustments
		function adjustTokenMathMLAttrs(token) {
		    for (let i = 0; i < token.attrs.length; i++) {
		        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
		            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
		            break;
		        }
		    }
		}
		function adjustTokenSVGAttrs(token) {
		    for (let i = 0; i < token.attrs.length; i++) {
		        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		        if (adjustedAttrName != null) {
		            token.attrs[i].name = adjustedAttrName;
		        }
		    }
		}
		function adjustTokenXMLAttrs(token) {
		    for (let i = 0; i < token.attrs.length; i++) {
		        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		        if (adjustedAttrEntry) {
		            token.attrs[i].prefix = adjustedAttrEntry.prefix;
		            token.attrs[i].name = adjustedAttrEntry.name;
		            token.attrs[i].namespace = adjustedAttrEntry.namespace;
		        }
		    }
		}
		function adjustTokenSVGTagName(token) {
		    const adjustedTagName = exports$1.SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
		    if (adjustedTagName != null) {
		        token.tagName = adjustedTagName;
		        token.tagID = (0, html_js_1.getTagID)(token.tagName);
		    }
		}
		//Integration points
		function isMathMLTextIntegrationPoint(tn, ns) {
		    return ns === html_js_1.NS.MATHML && (tn === html_js_1.TAG_ID.MI || tn === html_js_1.TAG_ID.MO || tn === html_js_1.TAG_ID.MN || tn === html_js_1.TAG_ID.MS || tn === html_js_1.TAG_ID.MTEXT);
		}
		function isHtmlIntegrationPoint(tn, ns, attrs) {
		    if (ns === html_js_1.NS.MATHML && tn === html_js_1.TAG_ID.ANNOTATION_XML) {
		        for (let i = 0; i < attrs.length; i++) {
		            if (attrs[i].name === html_js_1.ATTRS.ENCODING) {
		                const value = attrs[i].value.toLowerCase();
		                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
		            }
		        }
		    }
		    return ns === html_js_1.NS.SVG && (tn === html_js_1.TAG_ID.FOREIGN_OBJECT || tn === html_js_1.TAG_ID.DESC || tn === html_js_1.TAG_ID.TITLE);
		}
		function isIntegrationPoint(tn, ns, attrs, foreignNS) {
		    return (((!foreignNS || foreignNS === html_js_1.NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) ||
		        ((!foreignNS || foreignNS === html_js_1.NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)));
		} 
	} (foreignContent));
	return foreignContent;
}

var hasRequiredParser$3;

function requireParser$3 () {
	if (hasRequiredParser$3) return parser$2;
	hasRequiredParser$3 = 1;
	Object.defineProperty(parser$2, "__esModule", { value: true });
	parser$2.Parser = void 0;
	const index_js_1 = requireTokenizer$4();
	const open_element_stack_js_1 = requireOpenElementStack();
	const formatting_element_list_js_1 = requireFormattingElementList();
	const default_js_1 = require_default();
	const doctype = requireDoctype();
	const foreignContent = requireForeignContent();
	const error_codes_js_1 = requireErrorCodes();
	const unicode = requireUnicode();
	const html_js_1 = requireHtml$1();
	const token_js_1 = requireToken$2();
	//Misc constants
	const HIDDEN_INPUT_TYPE = 'hidden';
	//Adoption agency loops iteration count
	const AA_OUTER_LOOP_ITER = 8;
	const AA_INNER_LOOP_ITER = 3;
	//Insertion modes
	var InsertionMode;
	(function (InsertionMode) {
	    InsertionMode[InsertionMode["INITIAL"] = 0] = "INITIAL";
	    InsertionMode[InsertionMode["BEFORE_HTML"] = 1] = "BEFORE_HTML";
	    InsertionMode[InsertionMode["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
	    InsertionMode[InsertionMode["IN_HEAD"] = 3] = "IN_HEAD";
	    InsertionMode[InsertionMode["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
	    InsertionMode[InsertionMode["AFTER_HEAD"] = 5] = "AFTER_HEAD";
	    InsertionMode[InsertionMode["IN_BODY"] = 6] = "IN_BODY";
	    InsertionMode[InsertionMode["TEXT"] = 7] = "TEXT";
	    InsertionMode[InsertionMode["IN_TABLE"] = 8] = "IN_TABLE";
	    InsertionMode[InsertionMode["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
	    InsertionMode[InsertionMode["IN_CAPTION"] = 10] = "IN_CAPTION";
	    InsertionMode[InsertionMode["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
	    InsertionMode[InsertionMode["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
	    InsertionMode[InsertionMode["IN_ROW"] = 13] = "IN_ROW";
	    InsertionMode[InsertionMode["IN_CELL"] = 14] = "IN_CELL";
	    InsertionMode[InsertionMode["IN_SELECT"] = 15] = "IN_SELECT";
	    InsertionMode[InsertionMode["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
	    InsertionMode[InsertionMode["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
	    InsertionMode[InsertionMode["AFTER_BODY"] = 18] = "AFTER_BODY";
	    InsertionMode[InsertionMode["IN_FRAMESET"] = 19] = "IN_FRAMESET";
	    InsertionMode[InsertionMode["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
	    InsertionMode[InsertionMode["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
	    InsertionMode[InsertionMode["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
	})(InsertionMode || (InsertionMode = {}));
	const BASE_LOC = {
	    startLine: -1,
	    startCol: -1,
	    startOffset: -1,
	    endLine: -1,
	    endCol: -1,
	    endOffset: -1,
	};
	const TABLE_STRUCTURE_TAGS = new Set([html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
	const defaultParserOptions = {
	    scriptingEnabled: true,
	    sourceCodeLocationInfo: false,
	    treeAdapter: default_js_1.defaultTreeAdapter,
	    onParseError: null,
	};
	//Parser
	class Parser {
	    constructor(options, document, 
	    /** @internal */
	    fragmentContext = null, 
	    /** @internal */
	    scriptHandler = null) {
	        this.fragmentContext = fragmentContext;
	        this.scriptHandler = scriptHandler;
	        this.currentToken = null;
	        this.stopped = false;
	        /** @internal */
	        this.insertionMode = InsertionMode.INITIAL;
	        /** @internal */
	        this.originalInsertionMode = InsertionMode.INITIAL;
	        /** @internal */
	        this.headElement = null;
	        /** @internal */
	        this.formElement = null;
	        /** Indicates that the current node is not an element in the HTML namespace */
	        this.currentNotInHTML = false;
	        /**
	         * The template insertion mode stack is maintained from the left.
	         * Ie. the topmost element will always have index 0.
	         *
	         * @internal
	         */
	        this.tmplInsertionModeStack = [];
	        /** @internal */
	        this.pendingCharacterTokens = [];
	        /** @internal */
	        this.hasNonWhitespacePendingCharacterToken = false;
	        /** @internal */
	        this.framesetOk = true;
	        /** @internal */
	        this.skipNextNewLine = false;
	        /** @internal */
	        this.fosterParentingEnabled = false;
	        this.options = Object.assign(Object.assign({}, defaultParserOptions), options);
	        this.treeAdapter = this.options.treeAdapter;
	        this.onParseError = this.options.onParseError;
	        // Always enable location info if we report parse errors.
	        if (this.onParseError) {
	            this.options.sourceCodeLocationInfo = true;
	        }
	        this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
	        this.tokenizer = new index_js_1.Tokenizer(this.options, this);
	        this.activeFormattingElements = new formatting_element_list_js_1.FormattingElementList(this.treeAdapter);
	        this.fragmentContextID = fragmentContext ? (0, html_js_1.getTagID)(this.treeAdapter.getTagName(fragmentContext)) : html_js_1.TAG_ID.UNKNOWN;
	        this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
	        this.openElements = new open_element_stack_js_1.OpenElementStack(this.document, this.treeAdapter, this);
	    }
	    // API
	    static parse(html, options) {
	        const parser = new this(options);
	        parser.tokenizer.write(html, true);
	        return parser.document;
	    }
	    static getFragmentParser(fragmentContext, options) {
	        const opts = Object.assign(Object.assign({}, defaultParserOptions), options);
	        //NOTE: use a <template> element as the fragment context if no context element was provided,
	        //so we will parse in a "forgiving" manner
	        fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : (fragmentContext = opts.treeAdapter.createElement(html_js_1.TAG_NAMES.TEMPLATE, html_js_1.NS.HTML, []));
	        //NOTE: create a fake element which will be used as the `document` for fragment parsing.
	        //This is important for jsdom, where a new `document` cannot be created. This led to
	        //fragment parsing messing with the main `document`.
	        const documentMock = opts.treeAdapter.createElement('documentmock', html_js_1.NS.HTML, []);
	        const parser = new this(opts, documentMock, fragmentContext);
	        if (parser.fragmentContextID === html_js_1.TAG_ID.TEMPLATE) {
	            parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
	        }
	        parser._initTokenizerForFragmentParsing();
	        parser._insertFakeRootElement();
	        parser._resetInsertionMode();
	        parser._findFormInFragmentContext();
	        return parser;
	    }
	    getFragment() {
	        const rootElement = this.treeAdapter.getFirstChild(this.document);
	        const fragment = this.treeAdapter.createDocumentFragment();
	        this._adoptNodes(rootElement, fragment);
	        return fragment;
	    }
	    //Errors
	    /** @internal */
	    _err(token, code, beforeToken) {
	        var _a;
	        if (!this.onParseError)
	            return;
	        const loc = (_a = token.location) !== null && _a !== void 0 ? _a : BASE_LOC;
	        const err = {
	            code,
	            startLine: loc.startLine,
	            startCol: loc.startCol,
	            startOffset: loc.startOffset,
	            endLine: beforeToken ? loc.startLine : loc.endLine,
	            endCol: beforeToken ? loc.startCol : loc.endCol,
	            endOffset: beforeToken ? loc.startOffset : loc.endOffset,
	        };
	        this.onParseError(err);
	    }
	    //Stack events
	    /** @internal */
	    onItemPush(node, tid, isTop) {
	        var _a, _b;
	        (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node);
	        if (isTop && this.openElements.stackTop > 0)
	            this._setContextModes(node, tid);
	    }
	    /** @internal */
	    onItemPop(node, isTop) {
	        var _a, _b;
	        if (this.options.sourceCodeLocationInfo) {
	            this._setEndLocation(node, this.currentToken);
	        }
	        (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node, this.openElements.current);
	        if (isTop) {
	            let current;
	            let currentTagId;
	            if (this.openElements.stackTop === 0 && this.fragmentContext) {
	                current = this.fragmentContext;
	                currentTagId = this.fragmentContextID;
	            }
	            else {
	                ({ current, currentTagId } = this.openElements);
	            }
	            this._setContextModes(current, currentTagId);
	        }
	    }
	    _setContextModes(current, tid) {
	        const isHTML = current === this.document || (current && this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.HTML);
	        this.currentNotInHTML = !isHTML;
	        this.tokenizer.inForeignNode =
	            !isHTML && current !== undefined && tid !== undefined && !this._isIntegrationPoint(tid, current);
	    }
	    /** @protected */
	    _switchToTextParsing(currentToken, nextTokenizerState) {
	        this._insertElement(currentToken, html_js_1.NS.HTML);
	        this.tokenizer.state = nextTokenizerState;
	        this.originalInsertionMode = this.insertionMode;
	        this.insertionMode = InsertionMode.TEXT;
	    }
	    switchToPlaintextParsing() {
	        this.insertionMode = InsertionMode.TEXT;
	        this.originalInsertionMode = InsertionMode.IN_BODY;
	        this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
	    }
	    //Fragment parsing
	    /** @protected */
	    _getAdjustedCurrentElement() {
	        return this.openElements.stackTop === 0 && this.fragmentContext
	            ? this.fragmentContext
	            : this.openElements.current;
	    }
	    /** @protected */
	    _findFormInFragmentContext() {
	        let node = this.fragmentContext;
	        while (node) {
	            if (this.treeAdapter.getTagName(node) === html_js_1.TAG_NAMES.FORM) {
	                this.formElement = node;
	                break;
	            }
	            node = this.treeAdapter.getParentNode(node);
	        }
	    }
	    _initTokenizerForFragmentParsing() {
	        if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== html_js_1.NS.HTML) {
	            return;
	        }
	        switch (this.fragmentContextID) {
	            case html_js_1.TAG_ID.TITLE:
	            case html_js_1.TAG_ID.TEXTAREA: {
	                this.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
	                break;
	            }
	            case html_js_1.TAG_ID.STYLE:
	            case html_js_1.TAG_ID.XMP:
	            case html_js_1.TAG_ID.IFRAME:
	            case html_js_1.TAG_ID.NOEMBED:
	            case html_js_1.TAG_ID.NOFRAMES:
	            case html_js_1.TAG_ID.NOSCRIPT: {
	                this.tokenizer.state = index_js_1.TokenizerMode.RAWTEXT;
	                break;
	            }
	            case html_js_1.TAG_ID.SCRIPT: {
	                this.tokenizer.state = index_js_1.TokenizerMode.SCRIPT_DATA;
	                break;
	            }
	            case html_js_1.TAG_ID.PLAINTEXT: {
	                this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
	                break;
	            }
	            // Do nothing
	        }
	    }
	    //Tree mutation
	    /** @protected */
	    _setDocumentType(token) {
	        const name = token.name || '';
	        const publicId = token.publicId || '';
	        const systemId = token.systemId || '';
	        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
	        if (token.location) {
	            const documentChildren = this.treeAdapter.getChildNodes(this.document);
	            const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
	            if (docTypeNode) {
	                this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
	            }
	        }
	    }
	    /** @protected */
	    _attachElementToTree(element, location) {
	        if (this.options.sourceCodeLocationInfo) {
	            const loc = location && Object.assign(Object.assign({}, location), { startTag: location });
	            this.treeAdapter.setNodeSourceCodeLocation(element, loc);
	        }
	        if (this._shouldFosterParentOnInsertion()) {
	            this._fosterParentElement(element);
	        }
	        else {
	            const parent = this.openElements.currentTmplContentOrNode;
	            this.treeAdapter.appendChild(parent !== null && parent !== void 0 ? parent : this.document, element);
	        }
	    }
	    /**
	     * For self-closing tags. Add an element to the tree, but skip adding it
	     * to the stack.
	     */
	    /** @protected */
	    _appendElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
	        this._attachElementToTree(element, token.location);
	    }
	    /** @protected */
	    _insertElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
	        this._attachElementToTree(element, token.location);
	        this.openElements.push(element, token.tagID);
	    }
	    /** @protected */
	    _insertFakeElement(tagName, tagID) {
	        const element = this.treeAdapter.createElement(tagName, html_js_1.NS.HTML, []);
	        this._attachElementToTree(element, null);
	        this.openElements.push(element, tagID);
	    }
	    /** @protected */
	    _insertTemplate(token) {
	        const tmpl = this.treeAdapter.createElement(token.tagName, html_js_1.NS.HTML, token.attrs);
	        const content = this.treeAdapter.createDocumentFragment();
	        this.treeAdapter.setTemplateContent(tmpl, content);
	        this._attachElementToTree(tmpl, token.location);
	        this.openElements.push(tmpl, token.tagID);
	        if (this.options.sourceCodeLocationInfo)
	            this.treeAdapter.setNodeSourceCodeLocation(content, null);
	    }
	    /** @protected */
	    _insertFakeRootElement() {
	        const element = this.treeAdapter.createElement(html_js_1.TAG_NAMES.HTML, html_js_1.NS.HTML, []);
	        if (this.options.sourceCodeLocationInfo)
	            this.treeAdapter.setNodeSourceCodeLocation(element, null);
	        this.treeAdapter.appendChild(this.openElements.current, element);
	        this.openElements.push(element, html_js_1.TAG_ID.HTML);
	    }
	    /** @protected */
	    _appendCommentNode(token, parent) {
	        const commentNode = this.treeAdapter.createCommentNode(token.data);
	        this.treeAdapter.appendChild(parent, commentNode);
	        if (this.options.sourceCodeLocationInfo) {
	            this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
	        }
	    }
	    /** @protected */
	    _insertCharacters(token) {
	        let parent;
	        let beforeElement;
	        if (this._shouldFosterParentOnInsertion()) {
	            ({ parent, beforeElement } = this._findFosterParentingLocation());
	            if (beforeElement) {
	                this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
	            }
	            else {
	                this.treeAdapter.insertText(parent, token.chars);
	            }
	        }
	        else {
	            parent = this.openElements.currentTmplContentOrNode;
	            this.treeAdapter.insertText(parent, token.chars);
	        }
	        if (!token.location)
	            return;
	        const siblings = this.treeAdapter.getChildNodes(parent);
	        const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
	        const textNode = siblings[textNodeIdx - 1];
	        //NOTE: if we have a location assigned by another token, then just update the end position
	        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
	        if (tnLoc) {
	            const { endLine, endCol, endOffset } = token.location;
	            this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
	        }
	        else if (this.options.sourceCodeLocationInfo) {
	            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
	        }
	    }
	    /** @protected */
	    _adoptNodes(donor, recipient) {
	        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
	            this.treeAdapter.detachNode(child);
	            this.treeAdapter.appendChild(recipient, child);
	        }
	    }
	    /** @protected */
	    _setEndLocation(element, closingToken) {
	        if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
	            const ctLoc = closingToken.location;
	            const tn = this.treeAdapter.getTagName(element);
	            const endLoc = 
	            // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
	            // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
	            closingToken.type === token_js_1.TokenType.END_TAG && tn === closingToken.tagName
	                ? {
	                    endTag: Object.assign({}, ctLoc),
	                    endLine: ctLoc.endLine,
	                    endCol: ctLoc.endCol,
	                    endOffset: ctLoc.endOffset,
	                }
	                : {
	                    endLine: ctLoc.startLine,
	                    endCol: ctLoc.startCol,
	                    endOffset: ctLoc.startOffset,
	                };
	            this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
	        }
	    }
	    //Token processing
	    shouldProcessStartTagTokenInForeignContent(token) {
	        // Check that neither current === document, or ns === NS.HTML
	        if (!this.currentNotInHTML)
	            return false;
	        let current;
	        let currentTagId;
	        if (this.openElements.stackTop === 0 && this.fragmentContext) {
	            current = this.fragmentContext;
	            currentTagId = this.fragmentContextID;
	        }
	        else {
	            ({ current, currentTagId } = this.openElements);
	        }
	        if (token.tagID === html_js_1.TAG_ID.SVG &&
	            this.treeAdapter.getTagName(current) === html_js_1.TAG_NAMES.ANNOTATION_XML &&
	            this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.MATHML) {
	            return false;
	        }
	        return (
	        // Check that `current` is not an integration point for HTML or MathML elements.
	        this.tokenizer.inForeignNode ||
	            // If it _is_ an integration point, then we might have to check that it is not an HTML
	            // integration point.
	            ((token.tagID === html_js_1.TAG_ID.MGLYPH || token.tagID === html_js_1.TAG_ID.MALIGNMARK) &&
	                currentTagId !== undefined &&
	                !this._isIntegrationPoint(currentTagId, current, html_js_1.NS.HTML)));
	    }
	    /** @protected */
	    _processToken(token) {
	        switch (token.type) {
	            case token_js_1.TokenType.CHARACTER: {
	                this.onCharacter(token);
	                break;
	            }
	            case token_js_1.TokenType.NULL_CHARACTER: {
	                this.onNullCharacter(token);
	                break;
	            }
	            case token_js_1.TokenType.COMMENT: {
	                this.onComment(token);
	                break;
	            }
	            case token_js_1.TokenType.DOCTYPE: {
	                this.onDoctype(token);
	                break;
	            }
	            case token_js_1.TokenType.START_TAG: {
	                this._processStartTag(token);
	                break;
	            }
	            case token_js_1.TokenType.END_TAG: {
	                this.onEndTag(token);
	                break;
	            }
	            case token_js_1.TokenType.EOF: {
	                this.onEof(token);
	                break;
	            }
	            case token_js_1.TokenType.WHITESPACE_CHARACTER: {
	                this.onWhitespaceCharacter(token);
	                break;
	            }
	        }
	    }
	    //Integration points
	    /** @protected */
	    _isIntegrationPoint(tid, element, foreignNS) {
	        const ns = this.treeAdapter.getNamespaceURI(element);
	        const attrs = this.treeAdapter.getAttrList(element);
	        return foreignContent.isIntegrationPoint(tid, ns, attrs, foreignNS);
	    }
	    //Active formatting elements reconstruction
	    /** @protected */
	    _reconstructActiveFormattingElements() {
	        const listLength = this.activeFormattingElements.entries.length;
	        if (listLength) {
	            const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === formatting_element_list_js_1.EntryType.Marker || this.openElements.contains(entry.element));
	            const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
	            for (let i = unopenIdx; i >= 0; i--) {
	                const entry = this.activeFormattingElements.entries[i];
	                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
	                entry.element = this.openElements.current;
	            }
	        }
	    }
	    //Close elements
	    /** @protected */
	    _closeTableCell() {
	        this.openElements.generateImpliedEndTags();
	        this.openElements.popUntilTableCellPopped();
	        this.activeFormattingElements.clearToLastMarker();
	        this.insertionMode = InsertionMode.IN_ROW;
	    }
	    /** @protected */
	    _closePElement() {
	        this.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.P);
	        this.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.P);
	    }
	    //Insertion modes
	    /** @protected */
	    _resetInsertionMode() {
	        for (let i = this.openElements.stackTop; i >= 0; i--) {
	            //Insertion mode reset map
	            switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
	                case html_js_1.TAG_ID.TR: {
	                    this.insertionMode = InsertionMode.IN_ROW;
	                    return;
	                }
	                case html_js_1.TAG_ID.TBODY:
	                case html_js_1.TAG_ID.THEAD:
	                case html_js_1.TAG_ID.TFOOT: {
	                    this.insertionMode = InsertionMode.IN_TABLE_BODY;
	                    return;
	                }
	                case html_js_1.TAG_ID.CAPTION: {
	                    this.insertionMode = InsertionMode.IN_CAPTION;
	                    return;
	                }
	                case html_js_1.TAG_ID.COLGROUP: {
	                    this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	                    return;
	                }
	                case html_js_1.TAG_ID.TABLE: {
	                    this.insertionMode = InsertionMode.IN_TABLE;
	                    return;
	                }
	                case html_js_1.TAG_ID.BODY: {
	                    this.insertionMode = InsertionMode.IN_BODY;
	                    return;
	                }
	                case html_js_1.TAG_ID.FRAMESET: {
	                    this.insertionMode = InsertionMode.IN_FRAMESET;
	                    return;
	                }
	                case html_js_1.TAG_ID.SELECT: {
	                    this._resetInsertionModeForSelect(i);
	                    return;
	                }
	                case html_js_1.TAG_ID.TEMPLATE: {
	                    this.insertionMode = this.tmplInsertionModeStack[0];
	                    return;
	                }
	                case html_js_1.TAG_ID.HTML: {
	                    this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
	                    return;
	                }
	                case html_js_1.TAG_ID.TD:
	                case html_js_1.TAG_ID.TH: {
	                    if (i > 0) {
	                        this.insertionMode = InsertionMode.IN_CELL;
	                        return;
	                    }
	                    break;
	                }
	                case html_js_1.TAG_ID.HEAD: {
	                    if (i > 0) {
	                        this.insertionMode = InsertionMode.IN_HEAD;
	                        return;
	                    }
	                    break;
	                }
	            }
	        }
	        this.insertionMode = InsertionMode.IN_BODY;
	    }
	    /** @protected */
	    _resetInsertionModeForSelect(selectIdx) {
	        if (selectIdx > 0) {
	            for (let i = selectIdx - 1; i > 0; i--) {
	                const tn = this.openElements.tagIDs[i];
	                if (tn === html_js_1.TAG_ID.TEMPLATE) {
	                    break;
	                }
	                else if (tn === html_js_1.TAG_ID.TABLE) {
	                    this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
	                    return;
	                }
	            }
	        }
	        this.insertionMode = InsertionMode.IN_SELECT;
	    }
	    //Foster parenting
	    /** @protected */
	    _isElementCausesFosterParenting(tn) {
	        return TABLE_STRUCTURE_TAGS.has(tn);
	    }
	    /** @protected */
	    _shouldFosterParentOnInsertion() {
	        return (this.fosterParentingEnabled &&
	            this.openElements.currentTagId !== undefined &&
	            this._isElementCausesFosterParenting(this.openElements.currentTagId));
	    }
	    /** @protected */
	    _findFosterParentingLocation() {
	        for (let i = this.openElements.stackTop; i >= 0; i--) {
	            const openElement = this.openElements.items[i];
	            switch (this.openElements.tagIDs[i]) {
	                case html_js_1.TAG_ID.TEMPLATE: {
	                    if (this.treeAdapter.getNamespaceURI(openElement) === html_js_1.NS.HTML) {
	                        return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
	                    }
	                    break;
	                }
	                case html_js_1.TAG_ID.TABLE: {
	                    const parent = this.treeAdapter.getParentNode(openElement);
	                    if (parent) {
	                        return { parent, beforeElement: openElement };
	                    }
	                    return { parent: this.openElements.items[i - 1], beforeElement: null };
	                }
	                // Do nothing
	            }
	        }
	        return { parent: this.openElements.items[0], beforeElement: null };
	    }
	    /** @protected */
	    _fosterParentElement(element) {
	        const location = this._findFosterParentingLocation();
	        if (location.beforeElement) {
	            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
	        }
	        else {
	            this.treeAdapter.appendChild(location.parent, element);
	        }
	    }
	    //Special elements
	    /** @protected */
	    _isSpecialElement(element, id) {
	        const ns = this.treeAdapter.getNamespaceURI(element);
	        return html_js_1.SPECIAL_ELEMENTS[ns].has(id);
	    }
	    /** @internal */
	    onCharacter(token) {
	        this.skipNextNewLine = false;
	        if (this.tokenizer.inForeignNode) {
	            characterInForeignContent(this, token);
	            return;
	        }
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                tokenInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HTML: {
	                tokenBeforeHtml(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD: {
	                tokenBeforeHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD: {
	                tokenInHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD_NO_SCRIPT: {
	                tokenInHeadNoScript(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_HEAD: {
	                tokenAfterHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_BODY:
	            case InsertionMode.IN_CAPTION:
	            case InsertionMode.IN_CELL:
	            case InsertionMode.IN_TEMPLATE: {
	                characterInBody(this, token);
	                break;
	            }
	            case InsertionMode.TEXT:
	            case InsertionMode.IN_SELECT:
	            case InsertionMode.IN_SELECT_IN_TABLE: {
	                this._insertCharacters(token);
	                break;
	            }
	            case InsertionMode.IN_TABLE:
	            case InsertionMode.IN_TABLE_BODY:
	            case InsertionMode.IN_ROW: {
	                characterInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                characterInTableText(this, token);
	                break;
	            }
	            case InsertionMode.IN_COLUMN_GROUP: {
	                tokenInColumnGroup(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY: {
	                tokenAfterBody(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_BODY: {
	                tokenAfterAfterBody(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onNullCharacter(token) {
	        this.skipNextNewLine = false;
	        if (this.tokenizer.inForeignNode) {
	            nullCharacterInForeignContent(this, token);
	            return;
	        }
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                tokenInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HTML: {
	                tokenBeforeHtml(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD: {
	                tokenBeforeHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD: {
	                tokenInHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD_NO_SCRIPT: {
	                tokenInHeadNoScript(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_HEAD: {
	                tokenAfterHead(this, token);
	                break;
	            }
	            case InsertionMode.TEXT: {
	                this._insertCharacters(token);
	                break;
	            }
	            case InsertionMode.IN_TABLE:
	            case InsertionMode.IN_TABLE_BODY:
	            case InsertionMode.IN_ROW: {
	                characterInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_COLUMN_GROUP: {
	                tokenInColumnGroup(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY: {
	                tokenAfterBody(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_BODY: {
	                tokenAfterAfterBody(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onComment(token) {
	        this.skipNextNewLine = false;
	        if (this.currentNotInHTML) {
	            appendComment(this, token);
	            return;
	        }
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL:
	            case InsertionMode.BEFORE_HTML:
	            case InsertionMode.BEFORE_HEAD:
	            case InsertionMode.IN_HEAD:
	            case InsertionMode.IN_HEAD_NO_SCRIPT:
	            case InsertionMode.AFTER_HEAD:
	            case InsertionMode.IN_BODY:
	            case InsertionMode.IN_TABLE:
	            case InsertionMode.IN_CAPTION:
	            case InsertionMode.IN_COLUMN_GROUP:
	            case InsertionMode.IN_TABLE_BODY:
	            case InsertionMode.IN_ROW:
	            case InsertionMode.IN_CELL:
	            case InsertionMode.IN_SELECT:
	            case InsertionMode.IN_SELECT_IN_TABLE:
	            case InsertionMode.IN_TEMPLATE:
	            case InsertionMode.IN_FRAMESET:
	            case InsertionMode.AFTER_FRAMESET: {
	                appendComment(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                tokenInTableText(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY: {
	                appendCommentToRootHtmlElement(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_BODY:
	            case InsertionMode.AFTER_AFTER_FRAMESET: {
	                appendCommentToDocument(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onDoctype(token) {
	        this.skipNextNewLine = false;
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                doctypeInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD:
	            case InsertionMode.IN_HEAD:
	            case InsertionMode.IN_HEAD_NO_SCRIPT:
	            case InsertionMode.AFTER_HEAD: {
	                this._err(token, error_codes_js_1.ERR.misplacedDoctype);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                tokenInTableText(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onStartTag(token) {
	        this.skipNextNewLine = false;
	        this.currentToken = token;
	        this._processStartTag(token);
	        if (token.selfClosing && !token.ackSelfClosing) {
	            this._err(token, error_codes_js_1.ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
	        }
	    }
	    /**
	     * Processes a given start tag.
	     *
	     * `onStartTag` checks if a self-closing tag was recognized. When a token
	     * is moved inbetween multiple insertion modes, this check for self-closing
	     * could lead to false positives. To avoid this, `_processStartTag` is used
	     * for nested calls.
	     *
	     * @param token The token to process.
	     * @protected
	     */
	    _processStartTag(token) {
	        if (this.shouldProcessStartTagTokenInForeignContent(token)) {
	            startTagInForeignContent(this, token);
	        }
	        else {
	            this._startTagOutsideForeignContent(token);
	        }
	    }
	    /** @protected */
	    _startTagOutsideForeignContent(token) {
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                tokenInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HTML: {
	                startTagBeforeHtml(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD: {
	                startTagBeforeHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD: {
	                startTagInHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD_NO_SCRIPT: {
	                startTagInHeadNoScript(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_HEAD: {
	                startTagAfterHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_BODY: {
	                startTagInBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE: {
	                startTagInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                tokenInTableText(this, token);
	                break;
	            }
	            case InsertionMode.IN_CAPTION: {
	                startTagInCaption(this, token);
	                break;
	            }
	            case InsertionMode.IN_COLUMN_GROUP: {
	                startTagInColumnGroup(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_BODY: {
	                startTagInTableBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_ROW: {
	                startTagInRow(this, token);
	                break;
	            }
	            case InsertionMode.IN_CELL: {
	                startTagInCell(this, token);
	                break;
	            }
	            case InsertionMode.IN_SELECT: {
	                startTagInSelect(this, token);
	                break;
	            }
	            case InsertionMode.IN_SELECT_IN_TABLE: {
	                startTagInSelectInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TEMPLATE: {
	                startTagInTemplate(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY: {
	                startTagAfterBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_FRAMESET: {
	                startTagInFrameset(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_FRAMESET: {
	                startTagAfterFrameset(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_BODY: {
	                startTagAfterAfterBody(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_FRAMESET: {
	                startTagAfterAfterFrameset(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onEndTag(token) {
	        this.skipNextNewLine = false;
	        this.currentToken = token;
	        if (this.currentNotInHTML) {
	            endTagInForeignContent(this, token);
	        }
	        else {
	            this._endTagOutsideForeignContent(token);
	        }
	    }
	    /** @protected */
	    _endTagOutsideForeignContent(token) {
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                tokenInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HTML: {
	                endTagBeforeHtml(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD: {
	                endTagBeforeHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD: {
	                endTagInHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD_NO_SCRIPT: {
	                endTagInHeadNoScript(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_HEAD: {
	                endTagAfterHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_BODY: {
	                endTagInBody(this, token);
	                break;
	            }
	            case InsertionMode.TEXT: {
	                endTagInText(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE: {
	                endTagInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                tokenInTableText(this, token);
	                break;
	            }
	            case InsertionMode.IN_CAPTION: {
	                endTagInCaption(this, token);
	                break;
	            }
	            case InsertionMode.IN_COLUMN_GROUP: {
	                endTagInColumnGroup(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_BODY: {
	                endTagInTableBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_ROW: {
	                endTagInRow(this, token);
	                break;
	            }
	            case InsertionMode.IN_CELL: {
	                endTagInCell(this, token);
	                break;
	            }
	            case InsertionMode.IN_SELECT: {
	                endTagInSelect(this, token);
	                break;
	            }
	            case InsertionMode.IN_SELECT_IN_TABLE: {
	                endTagInSelectInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TEMPLATE: {
	                endTagInTemplate(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY: {
	                endTagAfterBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_FRAMESET: {
	                endTagInFrameset(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_FRAMESET: {
	                endTagAfterFrameset(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_AFTER_BODY: {
	                tokenAfterAfterBody(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onEof(token) {
	        switch (this.insertionMode) {
	            case InsertionMode.INITIAL: {
	                tokenInInitialMode(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HTML: {
	                tokenBeforeHtml(this, token);
	                break;
	            }
	            case InsertionMode.BEFORE_HEAD: {
	                tokenBeforeHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD: {
	                tokenInHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_HEAD_NO_SCRIPT: {
	                tokenInHeadNoScript(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_HEAD: {
	                tokenAfterHead(this, token);
	                break;
	            }
	            case InsertionMode.IN_BODY:
	            case InsertionMode.IN_TABLE:
	            case InsertionMode.IN_CAPTION:
	            case InsertionMode.IN_COLUMN_GROUP:
	            case InsertionMode.IN_TABLE_BODY:
	            case InsertionMode.IN_ROW:
	            case InsertionMode.IN_CELL:
	            case InsertionMode.IN_SELECT:
	            case InsertionMode.IN_SELECT_IN_TABLE: {
	                eofInBody(this, token);
	                break;
	            }
	            case InsertionMode.TEXT: {
	                eofInText(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                tokenInTableText(this, token);
	                break;
	            }
	            case InsertionMode.IN_TEMPLATE: {
	                eofInTemplate(this, token);
	                break;
	            }
	            case InsertionMode.AFTER_BODY:
	            case InsertionMode.IN_FRAMESET:
	            case InsertionMode.AFTER_FRAMESET:
	            case InsertionMode.AFTER_AFTER_BODY:
	            case InsertionMode.AFTER_AFTER_FRAMESET: {
	                stopParsing(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	    /** @internal */
	    onWhitespaceCharacter(token) {
	        if (this.skipNextNewLine) {
	            this.skipNextNewLine = false;
	            if (token.chars.charCodeAt(0) === unicode.CODE_POINTS.LINE_FEED) {
	                if (token.chars.length === 1) {
	                    return;
	                }
	                token.chars = token.chars.substr(1);
	            }
	        }
	        if (this.tokenizer.inForeignNode) {
	            this._insertCharacters(token);
	            return;
	        }
	        switch (this.insertionMode) {
	            case InsertionMode.IN_HEAD:
	            case InsertionMode.IN_HEAD_NO_SCRIPT:
	            case InsertionMode.AFTER_HEAD:
	            case InsertionMode.TEXT:
	            case InsertionMode.IN_COLUMN_GROUP:
	            case InsertionMode.IN_SELECT:
	            case InsertionMode.IN_SELECT_IN_TABLE:
	            case InsertionMode.IN_FRAMESET:
	            case InsertionMode.AFTER_FRAMESET: {
	                this._insertCharacters(token);
	                break;
	            }
	            case InsertionMode.IN_BODY:
	            case InsertionMode.IN_CAPTION:
	            case InsertionMode.IN_CELL:
	            case InsertionMode.IN_TEMPLATE:
	            case InsertionMode.AFTER_BODY:
	            case InsertionMode.AFTER_AFTER_BODY:
	            case InsertionMode.AFTER_AFTER_FRAMESET: {
	                whitespaceCharacterInBody(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE:
	            case InsertionMode.IN_TABLE_BODY:
	            case InsertionMode.IN_ROW: {
	                characterInTable(this, token);
	                break;
	            }
	            case InsertionMode.IN_TABLE_TEXT: {
	                whitespaceCharacterInTableText(this, token);
	                break;
	            }
	            // Do nothing
	        }
	    }
	}
	parser$2.Parser = Parser;
	//Adoption agency algorithm
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
	//------------------------------------------------------------------
	//Steps 5-8 of the algorithm
	function aaObtainFormattingElementEntry(p, token) {
	    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
	    if (formattingElementEntry) {
	        if (!p.openElements.contains(formattingElementEntry.element)) {
	            p.activeFormattingElements.removeEntry(formattingElementEntry);
	            formattingElementEntry = null;
	        }
	        else if (!p.openElements.hasInScope(token.tagID)) {
	            formattingElementEntry = null;
	        }
	    }
	    else {
	        genericEndTagInBody(p, token);
	    }
	    return formattingElementEntry;
	}
	//Steps 9 and 10 of the algorithm
	function aaObtainFurthestBlock(p, formattingElementEntry) {
	    let furthestBlock = null;
	    let idx = p.openElements.stackTop;
	    for (; idx >= 0; idx--) {
	        const element = p.openElements.items[idx];
	        if (element === formattingElementEntry.element) {
	            break;
	        }
	        if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
	            furthestBlock = element;
	        }
	    }
	    if (!furthestBlock) {
	        p.openElements.shortenToLength(Math.max(idx, 0));
	        p.activeFormattingElements.removeEntry(formattingElementEntry);
	    }
	    return furthestBlock;
	}
	//Step 13 of the algorithm
	function aaInnerLoop(p, furthestBlock, formattingElement) {
	    let lastElement = furthestBlock;
	    let nextElement = p.openElements.getCommonAncestor(furthestBlock);
	    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
	        //NOTE: store the next element for the next loop iteration (it may be deleted from the stack by step 9.5)
	        nextElement = p.openElements.getCommonAncestor(element);
	        const elementEntry = p.activeFormattingElements.getElementEntry(element);
	        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
	        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
	        if (shouldRemoveFromOpenElements) {
	            if (counterOverflow) {
	                p.activeFormattingElements.removeEntry(elementEntry);
	            }
	            p.openElements.remove(element);
	        }
	        else {
	            element = aaRecreateElementFromEntry(p, elementEntry);
	            if (lastElement === furthestBlock) {
	                p.activeFormattingElements.bookmark = elementEntry;
	            }
	            p.treeAdapter.detachNode(lastElement);
	            p.treeAdapter.appendChild(element, lastElement);
	            lastElement = element;
	        }
	    }
	    return lastElement;
	}
	//Step 13.7 of the algorithm
	function aaRecreateElementFromEntry(p, elementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
	    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
	    p.openElements.replace(elementEntry.element, newElement);
	    elementEntry.element = newElement;
	    return newElement;
	}
	//Step 14 of the algorithm
	function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
	    const tn = p.treeAdapter.getTagName(commonAncestor);
	    const tid = (0, html_js_1.getTagID)(tn);
	    if (p._isElementCausesFosterParenting(tid)) {
	        p._fosterParentElement(lastElement);
	    }
	    else {
	        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
	        if (tid === html_js_1.TAG_ID.TEMPLATE && ns === html_js_1.NS.HTML) {
	            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
	        }
	        p.treeAdapter.appendChild(commonAncestor, lastElement);
	    }
	}
	//Steps 15-19 of the algorithm
	function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
	    const { token } = formattingElementEntry;
	    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
	    p._adoptNodes(furthestBlock, newElement);
	    p.treeAdapter.appendChild(furthestBlock, newElement);
	    p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
	    p.activeFormattingElements.removeEntry(formattingElementEntry);
	    p.openElements.remove(formattingElementEntry.element);
	    p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
	}
	//Algorithm entry point
	function callAdoptionAgency(p, token) {
	    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
	        const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
	        if (!formattingElementEntry) {
	            break;
	        }
	        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
	        if (!furthestBlock) {
	            break;
	        }
	        p.activeFormattingElements.bookmark = formattingElementEntry;
	        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
	        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
	        p.treeAdapter.detachNode(lastElement);
	        if (commonAncestor)
	            aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
	        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
	    }
	}
	//Generic token handlers
	//------------------------------------------------------------------
	function appendComment(p, token) {
	    p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
	}
	function appendCommentToRootHtmlElement(p, token) {
	    p._appendCommentNode(token, p.openElements.items[0]);
	}
	function appendCommentToDocument(p, token) {
	    p._appendCommentNode(token, p.document);
	}
	function stopParsing(p, token) {
	    p.stopped = true;
	    // NOTE: Set end locations for elements that remain on the open element stack.
	    if (token.location) {
	        // NOTE: If we are not in a fragment, `html` and `body` will stay on the stack.
	        // This is a problem, as we might overwrite their end position here.
	        const target = p.fragmentContext ? 0 : 2;
	        for (let i = p.openElements.stackTop; i >= target; i--) {
	            p._setEndLocation(p.openElements.items[i], token);
	        }
	        // Handle `html` and `body`
	        if (!p.fragmentContext && p.openElements.stackTop >= 0) {
	            const htmlElement = p.openElements.items[0];
	            const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
	            if (htmlLocation && !htmlLocation.endTag) {
	                p._setEndLocation(htmlElement, token);
	                if (p.openElements.stackTop >= 1) {
	                    const bodyElement = p.openElements.items[1];
	                    const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
	                    if (bodyLocation && !bodyLocation.endTag) {
	                        p._setEndLocation(bodyElement, token);
	                    }
	                }
	            }
	        }
	    }
	}
	// The "initial" insertion mode
	//------------------------------------------------------------------
	function doctypeInInitialMode(p, token) {
	    p._setDocumentType(token);
	    const mode = token.forceQuirks ? html_js_1.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);
	    if (!doctype.isConforming(token)) {
	        p._err(token, error_codes_js_1.ERR.nonConformingDoctype);
	    }
	    p.treeAdapter.setDocumentMode(p.document, mode);
	    p.insertionMode = InsertionMode.BEFORE_HTML;
	}
	function tokenInInitialMode(p, token) {
	    p._err(token, error_codes_js_1.ERR.missingDoctype, true);
	    p.treeAdapter.setDocumentMode(p.document, html_js_1.DOCUMENT_MODE.QUIRKS);
	    p.insertionMode = InsertionMode.BEFORE_HTML;
	    p._processToken(token);
	}
	// The "before html" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHtml(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.HTML) {
	        p._insertElement(token, html_js_1.NS.HTML);
	        p.insertionMode = InsertionMode.BEFORE_HEAD;
	    }
	    else {
	        tokenBeforeHtml(p, token);
	    }
	}
	function endTagBeforeHtml(p, token) {
	    const tn = token.tagID;
	    if (tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.BR) {
	        tokenBeforeHtml(p, token);
	    }
	}
	function tokenBeforeHtml(p, token) {
	    p._insertFakeRootElement();
	    p.insertionMode = InsertionMode.BEFORE_HEAD;
	    p._processToken(token);
	}
	// The "before head" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHead(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.HEAD: {
	            p._insertElement(token, html_js_1.NS.HTML);
	            p.headElement = p.openElements.current;
	            p.insertionMode = InsertionMode.IN_HEAD;
	            break;
	        }
	        default: {
	            tokenBeforeHead(p, token);
	        }
	    }
	}
	function endTagBeforeHead(p, token) {
	    const tn = token.tagID;
	    if (tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.BR) {
	        tokenBeforeHead(p, token);
	    }
	    else {
	        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
	    }
	}
	function tokenBeforeHead(p, token) {
	    p._insertFakeElement(html_js_1.TAG_NAMES.HEAD, html_js_1.TAG_ID.HEAD);
	    p.headElement = p.openElements.current;
	    p.insertionMode = InsertionMode.IN_HEAD;
	    p._processToken(token);
	}
	// The "in head" insertion mode
	//------------------------------------------------------------------
	function startTagInHead(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BASE:
	        case html_js_1.TAG_ID.BASEFONT:
	        case html_js_1.TAG_ID.BGSOUND:
	        case html_js_1.TAG_ID.LINK:
	        case html_js_1.TAG_ID.META: {
	            p._appendElement(token, html_js_1.NS.HTML);
	            token.ackSelfClosing = true;
	            break;
	        }
	        case html_js_1.TAG_ID.TITLE: {
	            p._switchToTextParsing(token, index_js_1.TokenizerMode.RCDATA);
	            break;
	        }
	        case html_js_1.TAG_ID.NOSCRIPT: {
	            if (p.options.scriptingEnabled) {
	                p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
	            }
	            else {
	                p._insertElement(token, html_js_1.NS.HTML);
	                p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.NOFRAMES:
	        case html_js_1.TAG_ID.STYLE: {
	            p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
	            break;
	        }
	        case html_js_1.TAG_ID.SCRIPT: {
	            p._switchToTextParsing(token, index_js_1.TokenizerMode.SCRIPT_DATA);
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            p._insertTemplate(token);
	            p.activeFormattingElements.insertMarker();
	            p.framesetOk = false;
	            p.insertionMode = InsertionMode.IN_TEMPLATE;
	            p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
	            break;
	        }
	        case html_js_1.TAG_ID.HEAD: {
	            p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
	            break;
	        }
	        default: {
	            tokenInHead(p, token);
	        }
	    }
	}
	function endTagInHead(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HEAD: {
	            p.openElements.pop();
	            p.insertionMode = InsertionMode.AFTER_HEAD;
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.BR:
	        case html_js_1.TAG_ID.HTML: {
	            tokenInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        default: {
	            p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
	        }
	    }
	}
	function templateEndTagInHead(p, token) {
	    if (p.openElements.tmplCount > 0) {
	        p.openElements.generateImpliedEndTagsThoroughly();
	        if (p.openElements.currentTagId !== html_js_1.TAG_ID.TEMPLATE) {
	            p._err(token, error_codes_js_1.ERR.closingOfElementWithOpenChildElements);
	        }
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
	        p.activeFormattingElements.clearToLastMarker();
	        p.tmplInsertionModeStack.shift();
	        p._resetInsertionMode();
	    }
	    else {
	        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
	    }
	}
	function tokenInHead(p, token) {
	    p.openElements.pop();
	    p.insertionMode = InsertionMode.AFTER_HEAD;
	    p._processToken(token);
	}
	// The "in head no script" insertion mode
	//------------------------------------------------------------------
	function startTagInHeadNoScript(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BASEFONT:
	        case html_js_1.TAG_ID.BGSOUND:
	        case html_js_1.TAG_ID.HEAD:
	        case html_js_1.TAG_ID.LINK:
	        case html_js_1.TAG_ID.META:
	        case html_js_1.TAG_ID.NOFRAMES:
	        case html_js_1.TAG_ID.STYLE: {
	            startTagInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOSCRIPT: {
	            p._err(token, error_codes_js_1.ERR.nestedNoscriptInHead);
	            break;
	        }
	        default: {
	            tokenInHeadNoScript(p, token);
	        }
	    }
	}
	function endTagInHeadNoScript(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.NOSCRIPT: {
	            p.openElements.pop();
	            p.insertionMode = InsertionMode.IN_HEAD;
	            break;
	        }
	        case html_js_1.TAG_ID.BR: {
	            tokenInHeadNoScript(p, token);
	            break;
	        }
	        default: {
	            p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
	        }
	    }
	}
	function tokenInHeadNoScript(p, token) {
	    const errCode = token.type === token_js_1.TokenType.EOF ? error_codes_js_1.ERR.openElementsLeftAfterEof : error_codes_js_1.ERR.disallowedContentInNoscriptInHead;
	    p._err(token, errCode);
	    p.openElements.pop();
	    p.insertionMode = InsertionMode.IN_HEAD;
	    p._processToken(token);
	}
	// The "after head" insertion mode
	//------------------------------------------------------------------
	function startTagAfterHead(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BODY: {
	            p._insertElement(token, html_js_1.NS.HTML);
	            p.framesetOk = false;
	            p.insertionMode = InsertionMode.IN_BODY;
	            break;
	        }
	        case html_js_1.TAG_ID.FRAMESET: {
	            p._insertElement(token, html_js_1.NS.HTML);
	            p.insertionMode = InsertionMode.IN_FRAMESET;
	            break;
	        }
	        case html_js_1.TAG_ID.BASE:
	        case html_js_1.TAG_ID.BASEFONT:
	        case html_js_1.TAG_ID.BGSOUND:
	        case html_js_1.TAG_ID.LINK:
	        case html_js_1.TAG_ID.META:
	        case html_js_1.TAG_ID.NOFRAMES:
	        case html_js_1.TAG_ID.SCRIPT:
	        case html_js_1.TAG_ID.STYLE:
	        case html_js_1.TAG_ID.TEMPLATE:
	        case html_js_1.TAG_ID.TITLE: {
	            p._err(token, error_codes_js_1.ERR.abandonedHeadElementChild);
	            p.openElements.push(p.headElement, html_js_1.TAG_ID.HEAD);
	            startTagInHead(p, token);
	            p.openElements.remove(p.headElement);
	            break;
	        }
	        case html_js_1.TAG_ID.HEAD: {
	            p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
	            break;
	        }
	        default: {
	            tokenAfterHead(p, token);
	        }
	    }
	}
	function endTagAfterHead(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.HTML:
	        case html_js_1.TAG_ID.BR: {
	            tokenAfterHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        default: {
	            p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
	        }
	    }
	}
	function tokenAfterHead(p, token) {
	    p._insertFakeElement(html_js_1.TAG_NAMES.BODY, html_js_1.TAG_ID.BODY);
	    p.insertionMode = InsertionMode.IN_BODY;
	    modeInBody(p, token);
	}
	// The "in body" insertion mode
	//------------------------------------------------------------------
	function modeInBody(p, token) {
	    switch (token.type) {
	        case token_js_1.TokenType.CHARACTER: {
	            characterInBody(p, token);
	            break;
	        }
	        case token_js_1.TokenType.WHITESPACE_CHARACTER: {
	            whitespaceCharacterInBody(p, token);
	            break;
	        }
	        case token_js_1.TokenType.COMMENT: {
	            appendComment(p, token);
	            break;
	        }
	        case token_js_1.TokenType.START_TAG: {
	            startTagInBody(p, token);
	            break;
	        }
	        case token_js_1.TokenType.END_TAG: {
	            endTagInBody(p, token);
	            break;
	        }
	        case token_js_1.TokenType.EOF: {
	            eofInBody(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	function whitespaceCharacterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	}
	function characterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}
	function htmlStartTagInBody(p, token) {
	    if (p.openElements.tmplCount === 0) {
	        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
	    }
	}
	function bodyStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
	    if (bodyElement && p.openElements.tmplCount === 0) {
	        p.framesetOk = false;
	        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
	    }
	}
	function framesetStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
	    if (p.framesetOk && bodyElement) {
	        p.treeAdapter.detachNode(bodyElement);
	        p.openElements.popAllUpToHtmlElement();
	        p._insertElement(token, html_js_1.NS.HTML);
	        p.insertionMode = InsertionMode.IN_FRAMESET;
	    }
	}
	function addressStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function numberedHeaderStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    if (p.openElements.currentTagId !== undefined && html_js_1.NUMBERED_HEADERS.has(p.openElements.currentTagId)) {
	        p.openElements.pop();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function preStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.framesetOk = false;
	}
	function formStartTagInBody(p, token) {
	    const inTemplate = p.openElements.tmplCount > 0;
	    if (!p.formElement || inTemplate) {
	        if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	            p._closePElement();
	        }
	        p._insertElement(token, html_js_1.NS.HTML);
	        if (!inTemplate) {
	            p.formElement = p.openElements.current;
	        }
	    }
	}
	function listItemStartTagInBody(p, token) {
	    p.framesetOk = false;
	    const tn = token.tagID;
	    for (let i = p.openElements.stackTop; i >= 0; i--) {
	        const elementId = p.openElements.tagIDs[i];
	        if ((tn === html_js_1.TAG_ID.LI && elementId === html_js_1.TAG_ID.LI) ||
	            ((tn === html_js_1.TAG_ID.DD || tn === html_js_1.TAG_ID.DT) && (elementId === html_js_1.TAG_ID.DD || elementId === html_js_1.TAG_ID.DT))) {
	            p.openElements.generateImpliedEndTagsWithExclusion(elementId);
	            p.openElements.popUntilTagNamePopped(elementId);
	            break;
	        }
	        if (elementId !== html_js_1.TAG_ID.ADDRESS &&
	            elementId !== html_js_1.TAG_ID.DIV &&
	            elementId !== html_js_1.TAG_ID.P &&
	            p._isSpecialElement(p.openElements.items[i], elementId)) {
	            break;
	        }
	    }
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function plaintextStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
	}
	function buttonStartTagInBody(p, token) {
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.BUTTON)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.BUTTON);
	    }
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.framesetOk = false;
	}
	function aStartTagInBody(p, token) {
	    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(html_js_1.TAG_NAMES.A);
	    if (activeElementEntry) {
	        callAdoptionAgency(p, token);
	        p.openElements.remove(activeElementEntry.element);
	        p.activeFormattingElements.removeEntry(activeElementEntry);
	    }
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}
	function bStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}
	function nobrStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.NOBR)) {
	        callAdoptionAgency(p, token);
	        p._reconstructActiveFormattingElements();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}
	function appletStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.activeFormattingElements.insertMarker();
	    p.framesetOk = false;
	}
	function tableStartTagInBody(p, token) {
	    if (p.treeAdapter.getDocumentMode(p.document) !== html_js_1.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.framesetOk = false;
	    p.insertionMode = InsertionMode.IN_TABLE;
	}
	function areaStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, html_js_1.NS.HTML);
	    p.framesetOk = false;
	    token.ackSelfClosing = true;
	}
	function isHiddenInput(token) {
	    const inputType = (0, token_js_1.getTokenAttr)(token, html_js_1.ATTRS.TYPE);
	    return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
	}
	function inputStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, html_js_1.NS.HTML);
	    if (!isHiddenInput(token)) {
	        p.framesetOk = false;
	    }
	    token.ackSelfClosing = true;
	}
	function paramStartTagInBody(p, token) {
	    p._appendElement(token, html_js_1.NS.HTML);
	    token.ackSelfClosing = true;
	}
	function hrStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._appendElement(token, html_js_1.NS.HTML);
	    p.framesetOk = false;
	    token.ackSelfClosing = true;
	}
	function imageStartTagInBody(p, token) {
	    token.tagName = html_js_1.TAG_NAMES.IMG;
	    token.tagID = html_js_1.TAG_ID.IMG;
	    areaStartTagInBody(p, token);
	}
	function textareaStartTagInBody(p, token) {
	    p._insertElement(token, html_js_1.NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
	    p.originalInsertionMode = p.insertionMode;
	    p.framesetOk = false;
	    p.insertionMode = InsertionMode.TEXT;
	}
	function xmpStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._closePElement();
	    }
	    p._reconstructActiveFormattingElements();
	    p.framesetOk = false;
	    p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
	}
	function iframeStartTagInBody(p, token) {
	    p.framesetOk = false;
	    p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
	}
	//NOTE: here we assume that we always act as a user agent with enabled plugins/frames, so we parse
	//<noembed>/<noframes> as rawtext.
	function rawTextStartTagInBody(p, token) {
	    p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
	}
	function selectStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.framesetOk = false;
	    p.insertionMode =
	        p.insertionMode === InsertionMode.IN_TABLE ||
	            p.insertionMode === InsertionMode.IN_CAPTION ||
	            p.insertionMode === InsertionMode.IN_TABLE_BODY ||
	            p.insertionMode === InsertionMode.IN_ROW ||
	            p.insertionMode === InsertionMode.IN_CELL
	            ? InsertionMode.IN_SELECT_IN_TABLE
	            : InsertionMode.IN_SELECT;
	}
	function optgroupStartTagInBody(p, token) {
	    if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
	        p.openElements.pop();
	    }
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function rbStartTagInBody(p, token) {
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
	        p.openElements.generateImpliedEndTags();
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function rtStartTagInBody(p, token) {
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
	        p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.RTC);
	    }
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function mathStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    foreignContent.adjustTokenMathMLAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);
	    if (token.selfClosing) {
	        p._appendElement(token, html_js_1.NS.MATHML);
	    }
	    else {
	        p._insertElement(token, html_js_1.NS.MATHML);
	    }
	    token.ackSelfClosing = true;
	}
	function svgStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    foreignContent.adjustTokenSVGAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);
	    if (token.selfClosing) {
	        p._appendElement(token, html_js_1.NS.SVG);
	    }
	    else {
	        p._insertElement(token, html_js_1.NS.SVG);
	    }
	    token.ackSelfClosing = true;
	}
	function genericStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, html_js_1.NS.HTML);
	}
	function startTagInBody(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.I:
	        case html_js_1.TAG_ID.S:
	        case html_js_1.TAG_ID.B:
	        case html_js_1.TAG_ID.U:
	        case html_js_1.TAG_ID.EM:
	        case html_js_1.TAG_ID.TT:
	        case html_js_1.TAG_ID.BIG:
	        case html_js_1.TAG_ID.CODE:
	        case html_js_1.TAG_ID.FONT:
	        case html_js_1.TAG_ID.SMALL:
	        case html_js_1.TAG_ID.STRIKE:
	        case html_js_1.TAG_ID.STRONG: {
	            bStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.A: {
	            aStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.H1:
	        case html_js_1.TAG_ID.H2:
	        case html_js_1.TAG_ID.H3:
	        case html_js_1.TAG_ID.H4:
	        case html_js_1.TAG_ID.H5:
	        case html_js_1.TAG_ID.H6: {
	            numberedHeaderStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.P:
	        case html_js_1.TAG_ID.DL:
	        case html_js_1.TAG_ID.OL:
	        case html_js_1.TAG_ID.UL:
	        case html_js_1.TAG_ID.DIV:
	        case html_js_1.TAG_ID.DIR:
	        case html_js_1.TAG_ID.NAV:
	        case html_js_1.TAG_ID.MAIN:
	        case html_js_1.TAG_ID.MENU:
	        case html_js_1.TAG_ID.ASIDE:
	        case html_js_1.TAG_ID.CENTER:
	        case html_js_1.TAG_ID.FIGURE:
	        case html_js_1.TAG_ID.FOOTER:
	        case html_js_1.TAG_ID.HEADER:
	        case html_js_1.TAG_ID.HGROUP:
	        case html_js_1.TAG_ID.DIALOG:
	        case html_js_1.TAG_ID.DETAILS:
	        case html_js_1.TAG_ID.ADDRESS:
	        case html_js_1.TAG_ID.ARTICLE:
	        case html_js_1.TAG_ID.SEARCH:
	        case html_js_1.TAG_ID.SECTION:
	        case html_js_1.TAG_ID.SUMMARY:
	        case html_js_1.TAG_ID.FIELDSET:
	        case html_js_1.TAG_ID.BLOCKQUOTE:
	        case html_js_1.TAG_ID.FIGCAPTION: {
	            addressStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.LI:
	        case html_js_1.TAG_ID.DD:
	        case html_js_1.TAG_ID.DT: {
	            listItemStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BR:
	        case html_js_1.TAG_ID.IMG:
	        case html_js_1.TAG_ID.WBR:
	        case html_js_1.TAG_ID.AREA:
	        case html_js_1.TAG_ID.EMBED:
	        case html_js_1.TAG_ID.KEYGEN: {
	            areaStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.HR: {
	            hrStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.RB:
	        case html_js_1.TAG_ID.RTC: {
	            rbStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.RT:
	        case html_js_1.TAG_ID.RP: {
	            rtStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.PRE:
	        case html_js_1.TAG_ID.LISTING: {
	            preStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.XMP: {
	            xmpStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.SVG: {
	            svgStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.HTML: {
	            htmlStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BASE:
	        case html_js_1.TAG_ID.LINK:
	        case html_js_1.TAG_ID.META:
	        case html_js_1.TAG_ID.STYLE:
	        case html_js_1.TAG_ID.TITLE:
	        case html_js_1.TAG_ID.SCRIPT:
	        case html_js_1.TAG_ID.BGSOUND:
	        case html_js_1.TAG_ID.BASEFONT:
	        case html_js_1.TAG_ID.TEMPLATE: {
	            startTagInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BODY: {
	            bodyStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.FORM: {
	            formStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOBR: {
	            nobrStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.MATH: {
	            mathStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TABLE: {
	            tableStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.INPUT: {
	            inputStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.PARAM:
	        case html_js_1.TAG_ID.TRACK:
	        case html_js_1.TAG_ID.SOURCE: {
	            paramStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.IMAGE: {
	            imageStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BUTTON: {
	            buttonStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.APPLET:
	        case html_js_1.TAG_ID.OBJECT:
	        case html_js_1.TAG_ID.MARQUEE: {
	            appletStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.IFRAME: {
	            iframeStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.SELECT: {
	            selectStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.OPTION:
	        case html_js_1.TAG_ID.OPTGROUP: {
	            optgroupStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOEMBED:
	        case html_js_1.TAG_ID.NOFRAMES: {
	            rawTextStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.FRAMESET: {
	            framesetStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TEXTAREA: {
	            textareaStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOSCRIPT: {
	            if (p.options.scriptingEnabled) {
	                rawTextStartTagInBody(p, token);
	            }
	            else {
	                genericStartTagInBody(p, token);
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.PLAINTEXT: {
	            plaintextStartTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TR:
	        case html_js_1.TAG_ID.HEAD:
	        case html_js_1.TAG_ID.FRAME:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD:
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COLGROUP: {
	            // Ignore token
	            break;
	        }
	        default: {
	            genericStartTagInBody(p, token);
	        }
	    }
	}
	function bodyEndTagInBody(p, token) {
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
	        p.insertionMode = InsertionMode.AFTER_BODY;
	        //NOTE: <body> is never popped from the stack, so we need to updated
	        //the end location explicitly.
	        if (p.options.sourceCodeLocationInfo) {
	            const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
	            if (bodyElement) {
	                p._setEndLocation(bodyElement, token);
	            }
	        }
	    }
	}
	function htmlEndTagInBody(p, token) {
	    if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
	        p.insertionMode = InsertionMode.AFTER_BODY;
	        endTagAfterBody(p, token);
	    }
	}
	function addressEndTagInBody(p, token) {
	    const tn = token.tagID;
	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}
	function formEndTagInBody(p) {
	    const inTemplate = p.openElements.tmplCount > 0;
	    const { formElement } = p;
	    if (!inTemplate) {
	        p.formElement = null;
	    }
	    if ((formElement || inTemplate) && p.openElements.hasInScope(html_js_1.TAG_ID.FORM)) {
	        p.openElements.generateImpliedEndTags();
	        if (inTemplate) {
	            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.FORM);
	        }
	        else if (formElement) {
	            p.openElements.remove(formElement);
	        }
	    }
	}
	function pEndTagInBody(p) {
	    if (!p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
	        p._insertFakeElement(html_js_1.TAG_NAMES.P, html_js_1.TAG_ID.P);
	    }
	    p._closePElement();
	}
	function liEndTagInBody(p) {
	    if (p.openElements.hasInListItemScope(html_js_1.TAG_ID.LI)) {
	        p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.LI);
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.LI);
	    }
	}
	function ddEndTagInBody(p, token) {
	    const tn = token.tagID;
	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTagsWithExclusion(tn);
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}
	function numberedHeaderEndTagInBody(p) {
	    if (p.openElements.hasNumberedHeaderInScope()) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilNumberedHeaderPopped();
	    }
	}
	function appletEndTagInBody(p, token) {
	    const tn = token.tagID;
	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	        p.activeFormattingElements.clearToLastMarker();
	    }
	}
	function brEndTagInBody(p) {
	    p._reconstructActiveFormattingElements();
	    p._insertFakeElement(html_js_1.TAG_NAMES.BR, html_js_1.TAG_ID.BR);
	    p.openElements.pop();
	    p.framesetOk = false;
	}
	function genericEndTagInBody(p, token) {
	    const tn = token.tagName;
	    const tid = token.tagID;
	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];
	        const elementId = p.openElements.tagIDs[i];
	        // Compare the tag name here, as the tag might not be a known tag with an ID.
	        if (tid === elementId && (tid !== html_js_1.TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
	            p.openElements.generateImpliedEndTagsWithExclusion(tid);
	            if (p.openElements.stackTop >= i)
	                p.openElements.shortenToLength(i);
	            break;
	        }
	        if (p._isSpecialElement(element, elementId)) {
	            break;
	        }
	    }
	}
	function endTagInBody(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.A:
	        case html_js_1.TAG_ID.B:
	        case html_js_1.TAG_ID.I:
	        case html_js_1.TAG_ID.S:
	        case html_js_1.TAG_ID.U:
	        case html_js_1.TAG_ID.EM:
	        case html_js_1.TAG_ID.TT:
	        case html_js_1.TAG_ID.BIG:
	        case html_js_1.TAG_ID.CODE:
	        case html_js_1.TAG_ID.FONT:
	        case html_js_1.TAG_ID.NOBR:
	        case html_js_1.TAG_ID.SMALL:
	        case html_js_1.TAG_ID.STRIKE:
	        case html_js_1.TAG_ID.STRONG: {
	            callAdoptionAgency(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.P: {
	            pEndTagInBody(p);
	            break;
	        }
	        case html_js_1.TAG_ID.DL:
	        case html_js_1.TAG_ID.UL:
	        case html_js_1.TAG_ID.OL:
	        case html_js_1.TAG_ID.DIR:
	        case html_js_1.TAG_ID.DIV:
	        case html_js_1.TAG_ID.NAV:
	        case html_js_1.TAG_ID.PRE:
	        case html_js_1.TAG_ID.MAIN:
	        case html_js_1.TAG_ID.MENU:
	        case html_js_1.TAG_ID.ASIDE:
	        case html_js_1.TAG_ID.BUTTON:
	        case html_js_1.TAG_ID.CENTER:
	        case html_js_1.TAG_ID.FIGURE:
	        case html_js_1.TAG_ID.FOOTER:
	        case html_js_1.TAG_ID.HEADER:
	        case html_js_1.TAG_ID.HGROUP:
	        case html_js_1.TAG_ID.DIALOG:
	        case html_js_1.TAG_ID.ADDRESS:
	        case html_js_1.TAG_ID.ARTICLE:
	        case html_js_1.TAG_ID.DETAILS:
	        case html_js_1.TAG_ID.SEARCH:
	        case html_js_1.TAG_ID.SECTION:
	        case html_js_1.TAG_ID.SUMMARY:
	        case html_js_1.TAG_ID.LISTING:
	        case html_js_1.TAG_ID.FIELDSET:
	        case html_js_1.TAG_ID.BLOCKQUOTE:
	        case html_js_1.TAG_ID.FIGCAPTION: {
	            addressEndTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.LI: {
	            liEndTagInBody(p);
	            break;
	        }
	        case html_js_1.TAG_ID.DD:
	        case html_js_1.TAG_ID.DT: {
	            ddEndTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.H1:
	        case html_js_1.TAG_ID.H2:
	        case html_js_1.TAG_ID.H3:
	        case html_js_1.TAG_ID.H4:
	        case html_js_1.TAG_ID.H5:
	        case html_js_1.TAG_ID.H6: {
	            numberedHeaderEndTagInBody(p);
	            break;
	        }
	        case html_js_1.TAG_ID.BR: {
	            brEndTagInBody(p);
	            break;
	        }
	        case html_js_1.TAG_ID.BODY: {
	            bodyEndTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.HTML: {
	            htmlEndTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.FORM: {
	            formEndTagInBody(p);
	            break;
	        }
	        case html_js_1.TAG_ID.APPLET:
	        case html_js_1.TAG_ID.OBJECT:
	        case html_js_1.TAG_ID.MARQUEE: {
	            appletEndTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        default: {
	            genericEndTagInBody(p, token);
	        }
	    }
	}
	function eofInBody(p, token) {
	    if (p.tmplInsertionModeStack.length > 0) {
	        eofInTemplate(p, token);
	    }
	    else {
	        stopParsing(p, token);
	    }
	}
	// The "text" insertion mode
	//------------------------------------------------------------------
	function endTagInText(p, token) {
	    var _a;
	    if (token.tagID === html_js_1.TAG_ID.SCRIPT) {
	        (_a = p.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p, p.openElements.current);
	    }
	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	}
	function eofInText(p, token) {
	    p._err(token, error_codes_js_1.ERR.eofInElementThatCanContainOnlyText);
	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	    p.onEof(token);
	}
	// The "in table" insertion mode
	//------------------------------------------------------------------
	function characterInTable(p, token) {
	    if (p.openElements.currentTagId !== undefined && TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
	        p.pendingCharacterTokens.length = 0;
	        p.hasNonWhitespacePendingCharacterToken = false;
	        p.originalInsertionMode = p.insertionMode;
	        p.insertionMode = InsertionMode.IN_TABLE_TEXT;
	        switch (token.type) {
	            case token_js_1.TokenType.CHARACTER: {
	                characterInTableText(p, token);
	                break;
	            }
	            case token_js_1.TokenType.WHITESPACE_CHARACTER: {
	                whitespaceCharacterInTableText(p, token);
	                break;
	            }
	            // Ignore null
	        }
	    }
	    else {
	        tokenInTable(p, token);
	    }
	}
	function captionStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p.activeFormattingElements.insertMarker();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.insertionMode = InsertionMode.IN_CAPTION;
	}
	function colgroupStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	}
	function colStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement(html_js_1.TAG_NAMES.COLGROUP, html_js_1.TAG_ID.COLGROUP);
	    p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	    startTagInColumnGroup(p, token);
	}
	function tbodyStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, html_js_1.NS.HTML);
	    p.insertionMode = InsertionMode.IN_TABLE_BODY;
	}
	function tdStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement(html_js_1.TAG_NAMES.TBODY, html_js_1.TAG_ID.TBODY);
	    p.insertionMode = InsertionMode.IN_TABLE_BODY;
	    startTagInTableBody(p, token);
	}
	function tableStartTagInTable(p, token) {
	    if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
	        p._resetInsertionMode();
	        p._processStartTag(token);
	    }
	}
	function inputStartTagInTable(p, token) {
	    if (isHiddenInput(token)) {
	        p._appendElement(token, html_js_1.NS.HTML);
	    }
	    else {
	        tokenInTable(p, token);
	    }
	    token.ackSelfClosing = true;
	}
	function formStartTagInTable(p, token) {
	    if (!p.formElement && p.openElements.tmplCount === 0) {
	        p._insertElement(token, html_js_1.NS.HTML);
	        p.formElement = p.openElements.current;
	        p.openElements.pop();
	    }
	}
	function startTagInTable(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.TR: {
	            tdStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.STYLE:
	        case html_js_1.TAG_ID.SCRIPT:
	        case html_js_1.TAG_ID.TEMPLATE: {
	            startTagInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COL: {
	            colStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.FORM: {
	            formStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TABLE: {
	            tableStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD: {
	            tbodyStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.INPUT: {
	            inputStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.CAPTION: {
	            captionStartTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COLGROUP: {
	            colgroupStartTagInTable(p, token);
	            break;
	        }
	        default: {
	            tokenInTable(p, token);
	        }
	    }
	}
	function endTagInTable(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TABLE: {
	            if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
	                p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
	                p._resetInsertionMode();
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.HTML:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.THEAD:
	        case html_js_1.TAG_ID.TR: {
	            // Ignore token
	            break;
	        }
	        default: {
	            tokenInTable(p, token);
	        }
	    }
	}
	function tokenInTable(p, token) {
	    const savedFosterParentingState = p.fosterParentingEnabled;
	    p.fosterParentingEnabled = true;
	    // Process token in `In Body` mode
	    modeInBody(p, token);
	    p.fosterParentingEnabled = savedFosterParentingState;
	}
	// The "in table text" insertion mode
	//------------------------------------------------------------------
	function whitespaceCharacterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	}
	function characterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	    p.hasNonWhitespacePendingCharacterToken = true;
	}
	function tokenInTableText(p, token) {
	    let i = 0;
	    if (p.hasNonWhitespacePendingCharacterToken) {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            tokenInTable(p, p.pendingCharacterTokens[i]);
	        }
	    }
	    else {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            p._insertCharacters(p.pendingCharacterTokens[i]);
	        }
	    }
	    p.insertionMode = p.originalInsertionMode;
	    p._processToken(token);
	}
	// The "in caption" insertion mode
	//------------------------------------------------------------------
	const TABLE_VOID_ELEMENTS = new Set([html_js_1.TAG_ID.CAPTION, html_js_1.TAG_ID.COL, html_js_1.TAG_ID.COLGROUP, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.TH, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
	function startTagInCaption(p, token) {
	    const tn = token.tagID;
	    if (TABLE_VOID_ELEMENTS.has(tn)) {
	        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = InsertionMode.IN_TABLE;
	            startTagInTable(p, token);
	        }
	    }
	    else {
	        startTagInBody(p, token);
	    }
	}
	function endTagInCaption(p, token) {
	    const tn = token.tagID;
	    switch (tn) {
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.TABLE: {
	            if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
	                p.openElements.generateImpliedEndTags();
	                p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
	                p.activeFormattingElements.clearToLastMarker();
	                p.insertionMode = InsertionMode.IN_TABLE;
	                if (tn === html_js_1.TAG_ID.TABLE) {
	                    endTagInTable(p, token);
	                }
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.HTML:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.THEAD:
	        case html_js_1.TAG_ID.TR: {
	            // Ignore token
	            break;
	        }
	        default: {
	            endTagInBody(p, token);
	        }
	    }
	}
	// The "in column group" insertion mode
	//------------------------------------------------------------------
	function startTagInColumnGroup(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COL: {
	            p._appendElement(token, html_js_1.NS.HTML);
	            token.ackSelfClosing = true;
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            startTagInHead(p, token);
	            break;
	        }
	        default: {
	            tokenInColumnGroup(p, token);
	        }
	    }
	}
	function endTagInColumnGroup(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.COLGROUP: {
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE;
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COL: {
	            // Ignore token
	            break;
	        }
	        default: {
	            tokenInColumnGroup(p, token);
	        }
	    }
	}
	function tokenInColumnGroup(p, token) {
	    if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
	        p.openElements.pop();
	        p.insertionMode = InsertionMode.IN_TABLE;
	        p._processToken(token);
	    }
	}
	// The "in table body" insertion mode
	//------------------------------------------------------------------
	function startTagInTableBody(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TR: {
	            p.openElements.clearBackToTableBodyContext();
	            p._insertElement(token, html_js_1.NS.HTML);
	            p.insertionMode = InsertionMode.IN_ROW;
	            break;
	        }
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.TD: {
	            p.openElements.clearBackToTableBodyContext();
	            p._insertFakeElement(html_js_1.TAG_NAMES.TR, html_js_1.TAG_ID.TR);
	            p.insertionMode = InsertionMode.IN_ROW;
	            startTagInRow(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD: {
	            if (p.openElements.hasTableBodyContextInTableScope()) {
	                p.openElements.clearBackToTableBodyContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE;
	                startTagInTable(p, token);
	            }
	            break;
	        }
	        default: {
	            startTagInTable(p, token);
	        }
	    }
	}
	function endTagInTableBody(p, token) {
	    const tn = token.tagID;
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD: {
	            if (p.openElements.hasInTableScope(tn)) {
	                p.openElements.clearBackToTableBodyContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE;
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TABLE: {
	            if (p.openElements.hasTableBodyContextInTableScope()) {
	                p.openElements.clearBackToTableBodyContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE;
	                endTagInTable(p, token);
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.HTML:
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.TR: {
	            // Ignore token
	            break;
	        }
	        default: {
	            endTagInTable(p, token);
	        }
	    }
	}
	// The "in row" insertion mode
	//------------------------------------------------------------------
	function startTagInRow(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TH:
	        case html_js_1.TAG_ID.TD: {
	            p.openElements.clearBackToTableRowContext();
	            p._insertElement(token, html_js_1.NS.HTML);
	            p.insertionMode = InsertionMode.IN_CELL;
	            p.activeFormattingElements.insertMarker();
	            break;
	        }
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD:
	        case html_js_1.TAG_ID.TR: {
	            if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
	                p.openElements.clearBackToTableRowContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE_BODY;
	                startTagInTableBody(p, token);
	            }
	            break;
	        }
	        default: {
	            startTagInTable(p, token);
	        }
	    }
	}
	function endTagInRow(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.TR: {
	            if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
	                p.openElements.clearBackToTableRowContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE_BODY;
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TABLE: {
	            if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
	                p.openElements.clearBackToTableRowContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE_BODY;
	                endTagInTableBody(p, token);
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD: {
	            if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
	                p.openElements.clearBackToTableRowContext();
	                p.openElements.pop();
	                p.insertionMode = InsertionMode.IN_TABLE_BODY;
	                endTagInTableBody(p, token);
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.HTML:
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TH: {
	            // Ignore end tag
	            break;
	        }
	        default: {
	            endTagInTable(p, token);
	        }
	    }
	}
	// The "in cell" insertion mode
	//------------------------------------------------------------------
	function startTagInCell(p, token) {
	    const tn = token.tagID;
	    if (TABLE_VOID_ELEMENTS.has(tn)) {
	        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TD) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TH)) {
	            p._closeTableCell();
	            startTagInRow(p, token);
	        }
	    }
	    else {
	        startTagInBody(p, token);
	    }
	}
	function endTagInCell(p, token) {
	    const tn = token.tagID;
	    switch (tn) {
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TH: {
	            if (p.openElements.hasInTableScope(tn)) {
	                p.openElements.generateImpliedEndTags();
	                p.openElements.popUntilTagNamePopped(tn);
	                p.activeFormattingElements.clearToLastMarker();
	                p.insertionMode = InsertionMode.IN_ROW;
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TABLE:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD:
	        case html_js_1.TAG_ID.TR: {
	            if (p.openElements.hasInTableScope(tn)) {
	                p._closeTableCell();
	                endTagInRow(p, token);
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.BODY:
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COL:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.HTML: {
	            // Ignore token
	            break;
	        }
	        default: {
	            endTagInBody(p, token);
	        }
	    }
	}
	// The "in select" insertion mode
	//------------------------------------------------------------------
	function startTagInSelect(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.OPTION: {
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
	                p.openElements.pop();
	            }
	            p._insertElement(token, html_js_1.NS.HTML);
	            break;
	        }
	        case html_js_1.TAG_ID.OPTGROUP: {
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
	                p.openElements.pop();
	            }
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
	                p.openElements.pop();
	            }
	            p._insertElement(token, html_js_1.NS.HTML);
	            break;
	        }
	        case html_js_1.TAG_ID.HR: {
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
	                p.openElements.pop();
	            }
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
	                p.openElements.pop();
	            }
	            p._appendElement(token, html_js_1.NS.HTML);
	            token.ackSelfClosing = true;
	            break;
	        }
	        case html_js_1.TAG_ID.INPUT:
	        case html_js_1.TAG_ID.KEYGEN:
	        case html_js_1.TAG_ID.TEXTAREA:
	        case html_js_1.TAG_ID.SELECT: {
	            if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
	                p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
	                p._resetInsertionMode();
	                if (token.tagID !== html_js_1.TAG_ID.SELECT) {
	                    p._processStartTag(token);
	                }
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.SCRIPT:
	        case html_js_1.TAG_ID.TEMPLATE: {
	            startTagInHead(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	function endTagInSelect(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.OPTGROUP: {
	            if (p.openElements.stackTop > 0 &&
	                p.openElements.currentTagId === html_js_1.TAG_ID.OPTION &&
	                p.openElements.tagIDs[p.openElements.stackTop - 1] === html_js_1.TAG_ID.OPTGROUP) {
	                p.openElements.pop();
	            }
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
	                p.openElements.pop();
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.OPTION: {
	            if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
	                p.openElements.pop();
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.SELECT: {
	            if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
	                p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
	                p._resetInsertionMode();
	            }
	            break;
	        }
	        case html_js_1.TAG_ID.TEMPLATE: {
	            templateEndTagInHead(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	// The "in select in table" insertion mode
	//------------------------------------------------------------------
	function startTagInSelectInTable(p, token) {
	    const tn = token.tagID;
	    if (tn === html_js_1.TAG_ID.CAPTION ||
	        tn === html_js_1.TAG_ID.TABLE ||
	        tn === html_js_1.TAG_ID.TBODY ||
	        tn === html_js_1.TAG_ID.TFOOT ||
	        tn === html_js_1.TAG_ID.THEAD ||
	        tn === html_js_1.TAG_ID.TR ||
	        tn === html_js_1.TAG_ID.TD ||
	        tn === html_js_1.TAG_ID.TH) {
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
	        p._resetInsertionMode();
	        p._processStartTag(token);
	    }
	    else {
	        startTagInSelect(p, token);
	    }
	}
	function endTagInSelectInTable(p, token) {
	    const tn = token.tagID;
	    if (tn === html_js_1.TAG_ID.CAPTION ||
	        tn === html_js_1.TAG_ID.TABLE ||
	        tn === html_js_1.TAG_ID.TBODY ||
	        tn === html_js_1.TAG_ID.TFOOT ||
	        tn === html_js_1.TAG_ID.THEAD ||
	        tn === html_js_1.TAG_ID.TR ||
	        tn === html_js_1.TAG_ID.TD ||
	        tn === html_js_1.TAG_ID.TH) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
	            p._resetInsertionMode();
	            p.onEndTag(token);
	        }
	    }
	    else {
	        endTagInSelect(p, token);
	    }
	}
	// The "in template" insertion mode
	//------------------------------------------------------------------
	function startTagInTemplate(p, token) {
	    switch (token.tagID) {
	        // First, handle tags that can start without a mode change
	        case html_js_1.TAG_ID.BASE:
	        case html_js_1.TAG_ID.BASEFONT:
	        case html_js_1.TAG_ID.BGSOUND:
	        case html_js_1.TAG_ID.LINK:
	        case html_js_1.TAG_ID.META:
	        case html_js_1.TAG_ID.NOFRAMES:
	        case html_js_1.TAG_ID.SCRIPT:
	        case html_js_1.TAG_ID.STYLE:
	        case html_js_1.TAG_ID.TEMPLATE:
	        case html_js_1.TAG_ID.TITLE: {
	            startTagInHead(p, token);
	            break;
	        }
	        // Re-process the token in the appropriate mode
	        case html_js_1.TAG_ID.CAPTION:
	        case html_js_1.TAG_ID.COLGROUP:
	        case html_js_1.TAG_ID.TBODY:
	        case html_js_1.TAG_ID.TFOOT:
	        case html_js_1.TAG_ID.THEAD: {
	            p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
	            p.insertionMode = InsertionMode.IN_TABLE;
	            startTagInTable(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.COL: {
	            p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
	            p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	            startTagInColumnGroup(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TR: {
	            p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
	            p.insertionMode = InsertionMode.IN_TABLE_BODY;
	            startTagInTableBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.TD:
	        case html_js_1.TAG_ID.TH: {
	            p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
	            p.insertionMode = InsertionMode.IN_ROW;
	            startTagInRow(p, token);
	            break;
	        }
	        default: {
	            p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
	            p.insertionMode = InsertionMode.IN_BODY;
	            startTagInBody(p, token);
	        }
	    }
	}
	function endTagInTemplate(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.TEMPLATE) {
	        templateEndTagInHead(p, token);
	    }
	}
	function eofInTemplate(p, token) {
	    if (p.openElements.tmplCount > 0) {
	        p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
	        p.activeFormattingElements.clearToLastMarker();
	        p.tmplInsertionModeStack.shift();
	        p._resetInsertionMode();
	        p.onEof(token);
	    }
	    else {
	        stopParsing(p, token);
	    }
	}
	// The "after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterBody(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.HTML) {
	        startTagInBody(p, token);
	    }
	    else {
	        tokenAfterBody(p, token);
	    }
	}
	function endTagAfterBody(p, token) {
	    var _a;
	    if (token.tagID === html_js_1.TAG_ID.HTML) {
	        if (!p.fragmentContext) {
	            p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
	        }
	        //NOTE: <html> is never popped from the stack, so we need to updated
	        //the end location explicitly.
	        if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === html_js_1.TAG_ID.HTML) {
	            p._setEndLocation(p.openElements.items[0], token);
	            // Update the body element, if it doesn't have an end tag
	            const bodyElement = p.openElements.items[1];
	            if (bodyElement && !((_a = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
	                p._setEndLocation(bodyElement, token);
	            }
	        }
	    }
	    else {
	        tokenAfterBody(p, token);
	    }
	}
	function tokenAfterBody(p, token) {
	    p.insertionMode = InsertionMode.IN_BODY;
	    modeInBody(p, token);
	}
	// The "in frameset" insertion mode
	//------------------------------------------------------------------
	function startTagInFrameset(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.FRAMESET: {
	            p._insertElement(token, html_js_1.NS.HTML);
	            break;
	        }
	        case html_js_1.TAG_ID.FRAME: {
	            p._appendElement(token, html_js_1.NS.HTML);
	            token.ackSelfClosing = true;
	            break;
	        }
	        case html_js_1.TAG_ID.NOFRAMES: {
	            startTagInHead(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	function endTagInFrameset(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
	        p.openElements.pop();
	        if (!p.fragmentContext && p.openElements.currentTagId !== html_js_1.TAG_ID.FRAMESET) {
	            p.insertionMode = InsertionMode.AFTER_FRAMESET;
	        }
	    }
	}
	// The "after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterFrameset(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOFRAMES: {
	            startTagInHead(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	function endTagAfterFrameset(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.HTML) {
	        p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
	    }
	}
	// The "after after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterBody(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.HTML) {
	        startTagInBody(p, token);
	    }
	    else {
	        tokenAfterAfterBody(p, token);
	    }
	}
	function tokenAfterAfterBody(p, token) {
	    p.insertionMode = InsertionMode.IN_BODY;
	    modeInBody(p, token);
	}
	// The "after after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterFrameset(p, token) {
	    switch (token.tagID) {
	        case html_js_1.TAG_ID.HTML: {
	            startTagInBody(p, token);
	            break;
	        }
	        case html_js_1.TAG_ID.NOFRAMES: {
	            startTagInHead(p, token);
	            break;
	        }
	        // Do nothing
	    }
	}
	// The rules for parsing tokens in foreign content
	//------------------------------------------------------------------
	function nullCharacterInForeignContent(p, token) {
	    token.chars = unicode.REPLACEMENT_CHARACTER;
	    p._insertCharacters(token);
	}
	function characterInForeignContent(p, token) {
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}
	function popUntilHtmlOrIntegrationPoint(p) {
	    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== html_js_1.NS.HTML &&
	        p.openElements.currentTagId !== undefined &&
	        !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
	        p.openElements.pop();
	    }
	}
	function startTagInForeignContent(p, token) {
	    if (foreignContent.causesExit(token)) {
	        popUntilHtmlOrIntegrationPoint(p);
	        p._startTagOutsideForeignContent(token);
	    }
	    else {
	        const current = p._getAdjustedCurrentElement();
	        const currentNs = p.treeAdapter.getNamespaceURI(current);
	        if (currentNs === html_js_1.NS.MATHML) {
	            foreignContent.adjustTokenMathMLAttrs(token);
	        }
	        else if (currentNs === html_js_1.NS.SVG) {
	            foreignContent.adjustTokenSVGTagName(token);
	            foreignContent.adjustTokenSVGAttrs(token);
	        }
	        foreignContent.adjustTokenXMLAttrs(token);
	        if (token.selfClosing) {
	            p._appendElement(token, currentNs);
	        }
	        else {
	            p._insertElement(token, currentNs);
	        }
	        token.ackSelfClosing = true;
	    }
	}
	function endTagInForeignContent(p, token) {
	    if (token.tagID === html_js_1.TAG_ID.P || token.tagID === html_js_1.TAG_ID.BR) {
	        popUntilHtmlOrIntegrationPoint(p);
	        p._endTagOutsideForeignContent(token);
	        return;
	    }
	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];
	        if (p.treeAdapter.getNamespaceURI(element) === html_js_1.NS.HTML) {
	            p._endTagOutsideForeignContent(token);
	            break;
	        }
	        const tagName = p.treeAdapter.getTagName(element);
	        if (tagName.toLowerCase() === token.tagName) {
	            //NOTE: update the token tag name for `_setEndLocation`.
	            token.tagName = tagName;
	            p.openElements.shortenToLength(i);
	            break;
	        }
	    }
	}
	return parser$2;
}

var serializer = {};

var _escape = {};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.escapeText = exports$1.escapeAttribute = exports$1.escapeUTF8 = exports$1.escape = exports$1.getCodePoint = exports$1.xmlReplacer = void 0;
		exports$1.encodeXML = encodeXML;
		exports$1.xmlReplacer = /["$&'<>\u0080-\uFFFF]/g;
		const xmlCodeMap = new Map([
		    [34, "&quot;"],
		    [38, "&amp;"],
		    [39, "&apos;"],
		    [60, "&lt;"],
		    [62, "&gt;"],
		]);
		// For compatibility with node < 4, we wrap `codePointAt`
		exports$1.getCodePoint = 
		// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
		String.prototype.codePointAt == null
		    ? (c, index) => (c.charCodeAt(index) & 64512) === 55296
		        ? (c.charCodeAt(index) - 55296) * 1024 +
		            c.charCodeAt(index + 1) -
		            56320 +
		            65536
		        : c.charCodeAt(index)
		    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
		        (input, index) => input.codePointAt(index);
		/**
		 * Encodes all non-ASCII characters, as well as characters not valid in XML
		 * documents using XML entities.
		 *
		 * If a character has no equivalent entity, a
		 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
		 */
		function encodeXML(input) {
		    let returnValue = "";
		    let lastIndex = 0;
		    let match;
		    while ((match = exports$1.xmlReplacer.exec(input)) !== null) {
		        const { index } = match;
		        const char = input.charCodeAt(index);
		        const next = xmlCodeMap.get(char);
		        if (next === undefined) {
		            returnValue += `${input.substring(lastIndex, index)}&#x${(0, exports$1.getCodePoint)(input, index).toString(16)};`;
		            // Increase by 1 if we have a surrogate pair
		            lastIndex = exports$1.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
		        }
		        else {
		            returnValue += input.substring(lastIndex, index) + next;
		            lastIndex = index + 1;
		        }
		    }
		    return returnValue + input.substr(lastIndex);
		}
		/**
		 * Encodes all non-ASCII characters, as well as characters not valid in XML
		 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
		 *
		 * Have a look at `escapeUTF8` if you want a more concise output at the expense
		 * of reduced transportability.
		 *
		 * @param data String to escape.
		 */
		exports$1.escape = encodeXML;
		/**
		 * Creates a function that escapes all characters matched by the given regular
		 * expression using the given map of characters to escape to their entities.
		 *
		 * @param regex Regular expression to match characters to escape.
		 * @param map Map of characters to escape to their entities.
		 *
		 * @returns Function that escapes all characters matched by the given regular
		 * expression using the given map of characters to escape to their entities.
		 */
		function getEscaper(regex, map) {
		    return function escape(data) {
		        let match;
		        let lastIndex = 0;
		        let result = "";
		        while ((match = regex.exec(data))) {
		            if (lastIndex !== match.index) {
		                result += data.substring(lastIndex, match.index);
		            }
		            // We know that this character will be in the map.
		            result += map.get(match[0].charCodeAt(0));
		            // Every match will be of length 1
		            lastIndex = match.index + 1;
		        }
		        return result + data.substring(lastIndex);
		    };
		}
		/**
		 * Encodes all characters not valid in XML documents using XML entities.
		 *
		 * Note that the output will be character-set dependent.
		 *
		 * @param data String to escape.
		 */
		exports$1.escapeUTF8 = getEscaper(/["&'<>]/g, xmlCodeMap);
		/**
		 * Encodes all characters that have to be escaped in HTML attributes,
		 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
		 *
		 * @param data String to escape.
		 */
		exports$1.escapeAttribute = 
		/* #__PURE__ */ getEscaper(/["&\u00A0]/g, new Map([
		    [34, "&quot;"],
		    [38, "&amp;"],
		    [160, "&nbsp;"],
		]));
		/**
		 * Encodes all characters that have to be escaped in HTML text,
		 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
		 *
		 * @param data String to escape.
		 */
		exports$1.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
		    [38, "&amp;"],
		    [60, "&lt;"],
		    [62, "&gt;"],
		    [160, "&nbsp;"],
		]));
		
	} (_escape));
	return _escape;
}

var hasRequiredSerializer;

function requireSerializer () {
	if (hasRequiredSerializer) return serializer;
	hasRequiredSerializer = 1;
	Object.defineProperty(serializer, "__esModule", { value: true });
	serializer.serialize = serialize;
	serializer.serializeOuter = serializeOuter;
	const html_js_1 = requireHtml$1();
	const escape_1 = /*@__PURE__*/ require_escape();
	const default_js_1 = require_default();
	// Sets
	const VOID_ELEMENTS = new Set([
	    html_js_1.TAG_NAMES.AREA,
	    html_js_1.TAG_NAMES.BASE,
	    html_js_1.TAG_NAMES.BASEFONT,
	    html_js_1.TAG_NAMES.BGSOUND,
	    html_js_1.TAG_NAMES.BR,
	    html_js_1.TAG_NAMES.COL,
	    html_js_1.TAG_NAMES.EMBED,
	    html_js_1.TAG_NAMES.FRAME,
	    html_js_1.TAG_NAMES.HR,
	    html_js_1.TAG_NAMES.IMG,
	    html_js_1.TAG_NAMES.INPUT,
	    html_js_1.TAG_NAMES.KEYGEN,
	    html_js_1.TAG_NAMES.LINK,
	    html_js_1.TAG_NAMES.META,
	    html_js_1.TAG_NAMES.PARAM,
	    html_js_1.TAG_NAMES.SOURCE,
	    html_js_1.TAG_NAMES.TRACK,
	    html_js_1.TAG_NAMES.WBR,
	]);
	function isVoidElement(node, options) {
	    return (options.treeAdapter.isElementNode(node) &&
	        options.treeAdapter.getNamespaceURI(node) === html_js_1.NS.HTML &&
	        VOID_ELEMENTS.has(options.treeAdapter.getTagName(node)));
	}
	const defaultOpts = { treeAdapter: default_js_1.defaultTreeAdapter, scriptingEnabled: true };
	/**
	 * Serializes an AST node to an HTML string.
	 *
	 * @example
	 *
	 * ```js
	 * const parse5 = require('parse5');
	 *
	 * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
	 *
	 * // Serializes a document.
	 * const html = parse5.serialize(document);
	 *
	 * // Serializes the <html> element content.
	 * const str = parse5.serialize(document.childNodes[1]);
	 *
	 * console.log(str); //> '<head></head><body>Hi there!</body>'
	 * ```
	 *
	 * @param node Node to serialize.
	 * @param options Serialization options.
	 */
	function serialize(node, options) {
	    const opts = Object.assign(Object.assign({}, defaultOpts), options);
	    if (isVoidElement(node, opts)) {
	        return '';
	    }
	    return serializeChildNodes(node, opts);
	}
	/**
	 * Serializes an AST element node to an HTML string, including the element node.
	 *
	 * @example
	 *
	 * ```js
	 * const parse5 = require('parse5');
	 *
	 * const document = parse5.parseFragment('<div>Hello, <b>world</b>!</div>');
	 *
	 * // Serializes the <div> element.
	 * const str = parse5.serializeOuter(document.childNodes[0]);
	 *
	 * console.log(str); //> '<div>Hello, <b>world</b>!</div>'
	 * ```
	 *
	 * @param node Node to serialize.
	 * @param options Serialization options.
	 */
	function serializeOuter(node, options) {
	    const opts = Object.assign(Object.assign({}, defaultOpts), options);
	    return serializeNode(node, opts);
	}
	function serializeChildNodes(parentNode, options) {
	    let html = '';
	    // Get container of the child nodes
	    const container = options.treeAdapter.isElementNode(parentNode) &&
	        options.treeAdapter.getTagName(parentNode) === html_js_1.TAG_NAMES.TEMPLATE &&
	        options.treeAdapter.getNamespaceURI(parentNode) === html_js_1.NS.HTML
	        ? options.treeAdapter.getTemplateContent(parentNode)
	        : parentNode;
	    const childNodes = options.treeAdapter.getChildNodes(container);
	    if (childNodes) {
	        for (const currentNode of childNodes) {
	            html += serializeNode(currentNode, options);
	        }
	    }
	    return html;
	}
	function serializeNode(node, options) {
	    if (options.treeAdapter.isElementNode(node)) {
	        return serializeElement(node, options);
	    }
	    if (options.treeAdapter.isTextNode(node)) {
	        return serializeTextNode(node, options);
	    }
	    if (options.treeAdapter.isCommentNode(node)) {
	        return serializeCommentNode(node, options);
	    }
	    if (options.treeAdapter.isDocumentTypeNode(node)) {
	        return serializeDocumentTypeNode(node, options);
	    }
	    // Return an empty string for unknown nodes
	    return '';
	}
	function serializeElement(node, options) {
	    const tn = options.treeAdapter.getTagName(node);
	    return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? '' : `${serializeChildNodes(node, options)}</${tn}>`}`;
	}
	function serializeAttributes(node, { treeAdapter }) {
	    let html = '';
	    for (const attr of treeAdapter.getAttrList(node)) {
	        html += ' ';
	        if (attr.namespace) {
	            switch (attr.namespace) {
	                case html_js_1.NS.XML: {
	                    html += `xml:${attr.name}`;
	                    break;
	                }
	                case html_js_1.NS.XMLNS: {
	                    if (attr.name !== 'xmlns') {
	                        html += 'xmlns:';
	                    }
	                    html += attr.name;
	                    break;
	                }
	                case html_js_1.NS.XLINK: {
	                    html += `xlink:${attr.name}`;
	                    break;
	                }
	                default: {
	                    html += `${attr.prefix}:${attr.name}`;
	                }
	            }
	        }
	        else {
	            html += attr.name;
	        }
	        html += `="${(0, escape_1.escapeAttribute)(attr.value)}"`;
	    }
	    return html;
	}
	function serializeTextNode(node, options) {
	    const { treeAdapter } = options;
	    const content = treeAdapter.getTextNodeContent(node);
	    const parent = treeAdapter.getParentNode(node);
	    const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
	    return parentTn &&
	        treeAdapter.getNamespaceURI(parent) === html_js_1.NS.HTML &&
	        (0, html_js_1.hasUnescapedText)(parentTn, options.scriptingEnabled)
	        ? content
	        : (0, escape_1.escapeText)(content);
	}
	function serializeCommentNode(node, { treeAdapter }) {
	    return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
	}
	function serializeDocumentTypeNode(node, { treeAdapter }) {
	    return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
	}
	return serializer;
}

var hasRequiredCjs$1;

function requireCjs$1 () {
	if (hasRequiredCjs$1) return cjs$1;
	hasRequiredCjs$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.TokenizerMode = exports$1.Tokenizer = exports$1.Token = exports$1.html = exports$1.foreignContent = exports$1.ErrorCodes = exports$1.serializeOuter = exports$1.serialize = exports$1.Parser = exports$1.defaultTreeAdapter = void 0;
		exports$1.parse = parse;
		exports$1.parseFragment = parseFragment;
		const index_js_1 = requireParser$3();
		var default_js_1 = require_default();
		Object.defineProperty(exports$1, "defaultTreeAdapter", { enumerable: true, get: function () { return default_js_1.defaultTreeAdapter; } });
		var index_js_2 = requireParser$3();
		Object.defineProperty(exports$1, "Parser", { enumerable: true, get: function () { return index_js_2.Parser; } });
		var index_js_3 = requireSerializer();
		Object.defineProperty(exports$1, "serialize", { enumerable: true, get: function () { return index_js_3.serialize; } });
		Object.defineProperty(exports$1, "serializeOuter", { enumerable: true, get: function () { return index_js_3.serializeOuter; } });
		var error_codes_js_1 = requireErrorCodes();
		Object.defineProperty(exports$1, "ErrorCodes", { enumerable: true, get: function () { return error_codes_js_1.ERR; } });
		/** @internal */
		exports$1.foreignContent = requireForeignContent();
		exports$1.html = requireHtml$1();
		exports$1.Token = requireToken$2();
		/** @internal */
		var index_js_4 = requireTokenizer$4();
		Object.defineProperty(exports$1, "Tokenizer", { enumerable: true, get: function () { return index_js_4.Tokenizer; } });
		Object.defineProperty(exports$1, "TokenizerMode", { enumerable: true, get: function () { return index_js_4.TokenizerMode; } });
		// Shorthands
		/**
		 * Parses an HTML string.
		 *
		 * @param html Input HTML string.
		 * @param options Parsing options.
		 * @returns Document
		 *
		 * @example
		 *
		 * ```js
		 * const parse5 = require('parse5');
		 *
		 * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
		 *
		 * console.log(document.childNodes[1].tagName); //> 'html'
		 *```
		 */
		function parse(html, options) {
		    return index_js_1.Parser.parse(html, options);
		}
		function parseFragment(fragmentContext, html, options) {
		    if (typeof fragmentContext === 'string') {
		        options = html;
		        html = fragmentContext;
		        fragmentContext = null;
		    }
		    const parser = index_js_1.Parser.getFragmentParser(fragmentContext, options);
		    parser.tokenizer.write(html, true);
		    return parser.getFragment();
		} 
	} (cjs$1));
	return cjs$1;
}

var cjs = {};

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.adapter = void 0;
		exports$1.serializeDoctypeContent = serializeDoctypeContent;
		const parse5_1 = requireCjs$1();
		const domhandler_1 = /*@__PURE__*/ requireLib$B();
		function enquoteDoctypeId(id) {
		    const quote = id.includes('"') ? "'" : '"';
		    return quote + id + quote;
		}
		/** @internal */
		function serializeDoctypeContent(name, publicId, systemId) {
		    let str = '!DOCTYPE ';
		    if (name) {
		        str += name;
		    }
		    if (publicId) {
		        str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
		    }
		    else if (systemId) {
		        str += ' SYSTEM';
		    }
		    if (systemId) {
		        str += ` ${enquoteDoctypeId(systemId)}`;
		    }
		    return str;
		}
		exports$1.adapter = {
		    // Re-exports from domhandler
		    isCommentNode: domhandler_1.isComment,
		    isElementNode: domhandler_1.isTag,
		    isTextNode: domhandler_1.isText,
		    //Node construction
		    createDocument() {
		        const node = new domhandler_1.Document([]);
		        node['x-mode'] = parse5_1.html.DOCUMENT_MODE.NO_QUIRKS;
		        return node;
		    },
		    createDocumentFragment() {
		        return new domhandler_1.Document([]);
		    },
		    createElement(tagName, namespaceURI, attrs) {
		        const attribs = Object.create(null);
		        const attribsNamespace = Object.create(null);
		        const attribsPrefix = Object.create(null);
		        for (let i = 0; i < attrs.length; i++) {
		            const attrName = attrs[i].name;
		            attribs[attrName] = attrs[i].value;
		            attribsNamespace[attrName] = attrs[i].namespace;
		            attribsPrefix[attrName] = attrs[i].prefix;
		        }
		        const node = new domhandler_1.Element(tagName, attribs, []);
		        node.namespace = namespaceURI;
		        node['x-attribsNamespace'] = attribsNamespace;
		        node['x-attribsPrefix'] = attribsPrefix;
		        return node;
		    },
		    createCommentNode(data) {
		        return new domhandler_1.Comment(data);
		    },
		    createTextNode(value) {
		        return new domhandler_1.Text(value);
		    },
		    //Tree mutation
		    appendChild(parentNode, newNode) {
		        const prev = parentNode.children[parentNode.children.length - 1];
		        if (prev) {
		            prev.next = newNode;
		            newNode.prev = prev;
		        }
		        parentNode.children.push(newNode);
		        newNode.parent = parentNode;
		    },
		    insertBefore(parentNode, newNode, referenceNode) {
		        const insertionIdx = parentNode.children.indexOf(referenceNode);
		        const { prev } = referenceNode;
		        if (prev) {
		            prev.next = newNode;
		            newNode.prev = prev;
		        }
		        referenceNode.prev = newNode;
		        newNode.next = referenceNode;
		        parentNode.children.splice(insertionIdx, 0, newNode);
		        newNode.parent = parentNode;
		    },
		    setTemplateContent(templateElement, contentElement) {
		        exports$1.adapter.appendChild(templateElement, contentElement);
		    },
		    getTemplateContent(templateElement) {
		        return templateElement.children[0];
		    },
		    setDocumentType(document, name, publicId, systemId) {
		        const data = serializeDoctypeContent(name, publicId, systemId);
		        let doctypeNode = document.children.find((node) => (0, domhandler_1.isDirective)(node) && node.name === '!doctype');
		        if (doctypeNode) {
		            doctypeNode.data = data !== null && data !== void 0 ? data : null;
		        }
		        else {
		            doctypeNode = new domhandler_1.ProcessingInstruction('!doctype', data);
		            exports$1.adapter.appendChild(document, doctypeNode);
		        }
		        doctypeNode['x-name'] = name;
		        doctypeNode['x-publicId'] = publicId;
		        doctypeNode['x-systemId'] = systemId;
		    },
		    setDocumentMode(document, mode) {
		        document['x-mode'] = mode;
		    },
		    getDocumentMode(document) {
		        return document['x-mode'];
		    },
		    detachNode(node) {
		        if (node.parent) {
		            const idx = node.parent.children.indexOf(node);
		            const { prev, next } = node;
		            node.prev = null;
		            node.next = null;
		            if (prev) {
		                prev.next = next;
		            }
		            if (next) {
		                next.prev = prev;
		            }
		            node.parent.children.splice(idx, 1);
		            node.parent = null;
		        }
		    },
		    insertText(parentNode, text) {
		        const lastChild = parentNode.children[parentNode.children.length - 1];
		        if (lastChild && (0, domhandler_1.isText)(lastChild)) {
		            lastChild.data += text;
		        }
		        else {
		            exports$1.adapter.appendChild(parentNode, exports$1.adapter.createTextNode(text));
		        }
		    },
		    insertTextBefore(parentNode, text, referenceNode) {
		        const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
		        if (prevNode && (0, domhandler_1.isText)(prevNode)) {
		            prevNode.data += text;
		        }
		        else {
		            exports$1.adapter.insertBefore(parentNode, exports$1.adapter.createTextNode(text), referenceNode);
		        }
		    },
		    adoptAttributes(recipient, attrs) {
		        for (let i = 0; i < attrs.length; i++) {
		            const attrName = attrs[i].name;
		            if (recipient.attribs[attrName] === undefined) {
		                recipient.attribs[attrName] = attrs[i].value;
		                recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
		                recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
		            }
		        }
		    },
		    //Tree traversing
		    getFirstChild(node) {
		        return node.children[0];
		    },
		    getChildNodes(node) {
		        return node.children;
		    },
		    getParentNode(node) {
		        return node.parent;
		    },
		    getAttrList(element) {
		        return element.attributes;
		    },
		    //Node data
		    getTagName(element) {
		        return element.name;
		    },
		    getNamespaceURI(element) {
		        return element.namespace;
		    },
		    getTextNodeContent(textNode) {
		        return textNode.data;
		    },
		    getCommentNodeContent(commentNode) {
		        return commentNode.data;
		    },
		    getDocumentTypeNodeName(doctypeNode) {
		        var _a;
		        return (_a = doctypeNode['x-name']) !== null && _a !== void 0 ? _a : '';
		    },
		    getDocumentTypeNodePublicId(doctypeNode) {
		        var _a;
		        return (_a = doctypeNode['x-publicId']) !== null && _a !== void 0 ? _a : '';
		    },
		    getDocumentTypeNodeSystemId(doctypeNode) {
		        var _a;
		        return (_a = doctypeNode['x-systemId']) !== null && _a !== void 0 ? _a : '';
		    },
		    //Node types
		    isDocumentTypeNode(node) {
		        return (0, domhandler_1.isDirective)(node) && node.name === '!doctype';
		    },
		    // Source code location
		    setNodeSourceCodeLocation(node, location) {
		        if (location) {
		            node.startIndex = location.startOffset;
		            node.endIndex = location.endOffset;
		        }
		        node.sourceCodeLocation = location;
		    },
		    getNodeSourceCodeLocation(node) {
		        return node.sourceCodeLocation;
		    },
		    updateNodeSourceCodeLocation(node, endLocation) {
		        if (endLocation.endOffset != null)
		            node.endIndex = endLocation.endOffset;
		        node.sourceCodeLocation = Object.assign(Object.assign({}, node.sourceCodeLocation), endLocation);
		    },
		}; 
	} (cjs));
	return cjs;
}

var hasRequiredParse5Adapter;

function requireParse5Adapter () {
	if (hasRequiredParse5Adapter) return parse5Adapter;
	hasRequiredParse5Adapter = 1;
	var __spreadArray = (parse5Adapter && parse5Adapter.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(parse5Adapter, "__esModule", { value: true });
	parse5Adapter.renderWithParse5 = parse5Adapter.parseWithParse5 = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$B();
	var parse5_1 = requireCjs$1();
	var parse5_htmlparser2_tree_adapter_1 = requireCjs();
	/**
	 * Parse the content with `parse5` in the context of the given `ParentNode`.
	 *
	 * @param content - The content to parse.
	 * @param options - A set of options to use to parse.
	 * @param isDocument - Whether to parse the content as a full HTML document.
	 * @param context - The context in which to parse the content.
	 * @returns The parsed content.
	 */
	function parseWithParse5(content, options, isDocument, context) {
	    var opts = {
	        scriptingEnabled: typeof options.scriptingEnabled === 'boolean'
	            ? options.scriptingEnabled
	            : true,
	        treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter,
	        sourceCodeLocationInfo: options.sourceCodeLocationInfo,
	    };
	    return isDocument
	        ? (0, parse5_1.parse)(content, opts)
	        : (0, parse5_1.parseFragment)(context, content, opts);
	}
	parse5Adapter.parseWithParse5 = parseWithParse5;
	var renderOpts = { treeAdapter: parse5_htmlparser2_tree_adapter_1.adapter };
	/**
	 * Renders the given DOM tree with `parse5` and returns the result as a string.
	 *
	 * @param dom - The DOM tree to render.
	 * @returns The rendered document.
	 */
	function renderWithParse5(dom) {
	    var _a;
	    /*
	     * `dom-serializer` passes over the special "root" node and renders the
	     * node's children in its place. To mimic this behavior with `parse5`, an
	     * equivalent operation must be applied to the input array.
	     */
	    var nodes = 'length' in dom ? dom : [dom];
	    for (var index = 0; index < nodes.length; index += 1) {
	        var node = nodes[index];
	        if ((0, domhandler_1.isDocument)(node)) {
	            (_a = Array.prototype.splice).call.apply(_a, __spreadArray([nodes, index, 1], node.children, false));
	        }
	    }
	    var result = '';
	    for (var index = 0; index < nodes.length; index += 1) {
	        var node = nodes[index];
	        result += (0, parse5_1.serializeOuter)(node, renderOpts);
	    }
	    return result;
	}
	parse5Adapter.renderWithParse5 = renderWithParse5;
	
	return parse5Adapter;
}

var hasRequiredLib$w;

function requireLib$w () {
	if (hasRequiredLib$w) return lib$x;
	hasRequiredLib$w = 1;
	(function (exports$1) {
		var __createBinding = (lib$x && lib$x.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$x && lib$x.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __exportStar = (lib$x && lib$x.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		var __importStar = (lib$x && lib$x.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __importDefault = (lib$x && lib$x.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.root = exports$1.parseHTML = exports$1.merge = exports$1.contains = exports$1.text = exports$1.xml = exports$1.html = exports$1.load = void 0;
		/**
		 * Types used in signatures of Cheerio methods.
		 *
		 * @category Cheerio
		 */
		__exportStar(requireTypes$1(), exports$1);
		var load_js_1 = requireLoad();
		var parse_js_1 = requireParse$1();
		var parse5_adapter_js_1 = requireParse5Adapter();
		var dom_serializer_1 = __importDefault(/*@__PURE__*/ requireLib$C());
		var htmlparser2_1 = /*@__PURE__*/ requireLib$D();
		var parse = (0, parse_js_1.getParse)(function (content, options, isDocument, context) {
		    return options.xmlMode || options._useHtmlParser2
		        ? (0, htmlparser2_1.parseDocument)(content, options)
		        : (0, parse5_adapter_js_1.parseWithParse5)(content, options, isDocument, context);
		});
		// Duplicate docs due to https://github.com/TypeStrong/typedoc/issues/1616
		/**
		 * Create a querying function, bound to a document created from the provided markup.
		 *
		 * Note that similar to web browser contexts, this operation may introduce
		 * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
		 * switch to fragment mode and disable this.
		 *
		 * @param content - Markup to be loaded.
		 * @param options - Options for the created instance.
		 * @param isDocument - Allows parser to be switched to fragment mode.
		 * @returns The loaded document.
		 * @see {@link https://cheerio.js.org#loading} for additional usage information.
		 */
		exports$1.load = (0, load_js_1.getLoad)(parse, function (dom, options) {
		    return options.xmlMode || options._useHtmlParser2
		        ? (0, dom_serializer_1.default)(dom, options)
		        : (0, parse5_adapter_js_1.renderWithParse5)(dom);
		});
		/**
		 * The default cheerio instance.
		 *
		 * @deprecated Use the function returned by `load` instead.
		 */
		exports$1.default = (0, exports$1.load)([]);
		var static_js_1 = require_static();
		Object.defineProperty(exports$1, "html", { enumerable: true, get: function () { return static_js_1.html; } });
		Object.defineProperty(exports$1, "xml", { enumerable: true, get: function () { return static_js_1.xml; } });
		Object.defineProperty(exports$1, "text", { enumerable: true, get: function () { return static_js_1.text; } });
		var staticMethods = __importStar(require_static());
		/**
		 * In order to promote consistency with the jQuery library, users are encouraged
		 * to instead use the static method of the same name.
		 *
		 * @deprecated
		 * @example
		 *
		 * ```js
		 * const $ = cheerio.load('<div><p></p></div>');
		 *
		 * $.contains($('div').get(0), $('p').get(0));
		 * //=> true
		 *
		 * $.contains($('p').get(0), $('div').get(0));
		 * //=> false
		 * ```
		 *
		 * @returns {boolean}
		 */
		exports$1.contains = staticMethods.contains;
		/**
		 * In order to promote consistency with the jQuery library, users are encouraged
		 * to instead use the static method of the same name.
		 *
		 * @deprecated
		 * @example
		 *
		 * ```js
		 * const $ = cheerio.load('');
		 *
		 * $.merge([1, 2], [3, 4]);
		 * //=> [1, 2, 3, 4]
		 * ```
		 */
		exports$1.merge = staticMethods.merge;
		/**
		 * In order to promote consistency with the jQuery library, users are encouraged
		 * to instead use the static method of the same name as it is defined on the
		 * "loaded" Cheerio factory function.
		 *
		 * @deprecated See {@link static/parseHTML}.
		 * @example
		 *
		 * ```js
		 * const $ = cheerio.load('');
		 * $.parseHTML('<b>markup</b>');
		 * ```
		 */
		exports$1.parseHTML = staticMethods.parseHTML;
		/**
		 * Users seeking to access the top-level element of a parsed document should
		 * instead use the `root` static method of a "loaded" Cheerio function.
		 *
		 * @deprecated
		 * @example
		 *
		 * ```js
		 * const $ = cheerio.load('');
		 * $.root();
		 * ```
		 */
		exports$1.root = staticMethods.root;
		
	} (lib$x));
	return lib$x;
}

var utils$1 = {};

var lexer = {exports: {}};

var debug = {exports: {}};

var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug.exports;
	hasRequiredDebug = 1;
	(function (module, exports$1) {
		module.exports = debug;

		function debug(label) {
		  return _debug.bind(null, label);
		}

		function _debug(label) {
		  var args = [].slice.call(arguments, 1);
		  args.unshift('[' + label + ']');
		  process.stderr.write(args.join(' ') + '\n');
		} 
	} (debug));
	return debug.exports;
}

var hasRequiredLexer;

function requireLexer () {
	if (hasRequiredLexer) return lexer.exports;
	hasRequiredLexer = 1;
	(function (module, exports$1) {

		requireDebug()('lex');

		module.exports = lex;

		/**
		 * Convert a CSS string into an array of lexical tokens.
		 *
		 * @param {String} css CSS
		 * @returns {Array} lexical tokens
		 */
		function lex(css) {

		  var buffer = '';      // Character accumulator
		  var ch;               // Current character
		  var column = 0;       // Current source column number
		  var cursor = -1;      // Current source cursor position
		  var depth = 0;        // Current nesting depth
		  var line = 1;         // Current source line number
		  var state = 'before-selector'; // Current state
		  var stack = [state];  // State stack
		  var token = {};       // Current token
		  var tokens = [];      // Token accumulator

		  // Supported @-rules, in roughly descending order of usage probability.
		  var atRules = [
		    'media',
		    'keyframes',
		    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },
		    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },
		    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },
		    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },
		    'font-face',
		    { name: 'import', state: 'before-at-value' },
		    { name: 'charset', state: 'before-at-value' },
		    'supports',
		    'viewport',
		    { name: 'namespace', state: 'before-at-value' },
		    'document',
		    { name: '-moz-document', type: 'document', prefix: '-moz-' },
		    'page'
		  ];

		  // -- Functions ------------------------------------------------------------

		  /**
		   * Advance the character cursor and return the next character.
		   *
		   * @returns {String} The next character.
		   */
		  function getCh() {
		    skip();
		    return css[cursor];
		  }

		  /**
		   * Return the state at the given index in the stack.
		   * The stack is LIFO so indexing is from the right.
		   *
		   * @param {Number} [index=0] Index to return.
		   * @returns {String} state
		   */
		  function getState(index) {
		    return index ? stack[stack.length - 1 - index] : state;
		  }

		  /**
		   * Look ahead for a string beginning from the next position. The string
		   * being looked for must start at the next position.
		   *
		   * @param {String} str The string to look for.
		   * @returns {Boolean} Whether the string was found.
		   */
		  function isNextString(str) {
		    var start = cursor + 1;
		    return (str === css.slice(start, start + str.length));
		  }

		  /**
		   * Find the start position of a substring beginning from the next
		   * position. The string being looked for may begin anywhere.
		   *
		   * @param {String} str The substring to look for.
		   * @returns {Number|false} The position, or `false` if not found.
		   */
		  function find(str) {
		    var pos = css.slice(cursor).indexOf(str);

		    return pos > 0 ? pos : false;
		  }

		  /**
		   * Determine whether a character is next.
		   *
		   * @param {String} ch Character.
		   * @returns {Boolean} Whether the character is next.
		   */
		  function isNextChar(ch) {
		    return ch === peek(1);
		  }

		  /**
		   * Return the character at the given cursor offset. The offset is relative
		   * to the cursor, so negative values move backwards.
		   *
		   * @param {Number} [offset=1] Cursor offset.
		   * @returns {String} Character.
		   */
		  function peek(offset) {
		    return css[cursor + (offset || 1)];
		  }

		  /**
		   * Remove the current state from the stack and set the new current state.
		   *
		   * @returns {String} The removed state.
		   */
		  function popState() {
		    var removed = stack.pop();
		    state = stack[stack.length - 1];

		    return removed;
		  }

		  /**
		   * Set the current state and add it to the stack.
		   *
		   * @param {String} newState The new state.
		   * @returns {Number} The new stack length.
		   */
		  function pushState(newState) {
		    state = newState;
		    stack.push(state);

		    return stack.length;
		  }

		  /**
		   * Replace the current state with a new state.
		   *
		   * @param {String} newState The new state.
		   * @returns {String} The replaced state.
		   */
		  function replaceState(newState) {
		    var previousState = state;
		    stack[stack.length - 1] = state = newState;

		    return previousState;
		  }

		  /**
		   * Move the character cursor. Positive numbers move the cursor forward.
		   * Negative numbers are not supported!
		   *
		   * @param {Number} [n=1] Number of characters to skip.
		   */
		  function skip(n) {
		    if ((n || 1) == 1) {
		      if (css[cursor] == '\n') {
		        line++;
		        column = 1;
		      } else {
		        column++;
		      }
		      cursor++;
		    } else {
		      var skipStr = css.slice(cursor, cursor + n).split('\n');
		      if (skipStr.length > 1) {
		        line += skipStr.length - 1;
		        column = 1;
		      }
		      column += skipStr[skipStr.length - 1].length;
		      cursor = cursor + n;
		    }
		  }

		  /**
		   * Add the current token to the pile and reset the buffer.
		   */
		  function addToken() {
		    token.end = {
		      line: line,
		      col: column
		    };

		    tokens.push(token);

		    buffer = '';
		    token = {};
		  }

		  /**
		   * Set the current token.
		   *
		   * @param {String} type Token type.
		   */
		  function initializeToken(type) {
		    token = {
		      type: type,
		      start: {
		        line: line,
		        col : column
		      }
		    };
		  }

		  while (ch = getCh()) {

		    // column += 1;

		    switch (ch) {
		    // Space
		    case ' ':
		      switch (getState()) {
		      case 'selector':
		      case 'value':
		      case 'value-paren':
		      case 'at-group':
		      case 'at-value':
		      case 'comment':
		      case 'double-string':
		      case 'single-string':
		        buffer += ch;
		        break;
		      }
		      break;

		    // Newline or tab
		    case '\n':
		    case '\t':
		    case '\r':
		    case '\f':
		      switch (getState()) {
		      case 'value':
		      case 'value-paren':
		      case 'at-group':
		      case 'comment':
		      case 'single-string':
		      case 'double-string':
		      case 'selector':
		        buffer += ch;
		        break;

		      case 'at-value':
		        // Tokenize an @-rule if a semi-colon was omitted.
		        if ('\n' === ch) {
		          token.value = buffer.trim();
		          addToken();
		          popState();
		        }
		        break;
		      }

		      // if ('\n' === ch) {
		      //   column = 0;
		      //   line += 1;
		      // }
		      break;

		    case ':':
		      switch (getState()) {
		      case 'name':
		        token.name = buffer.trim();
		        buffer = '';

		        replaceState('before-value');
		        break;

		      case 'before-selector':
		        buffer += ch;

		        initializeToken('selector');
		        pushState('selector');
		        break;

		      case 'before-value':
		        replaceState('value');
		        buffer += ch;
		        break;

		      default:
		        buffer += ch;
		        break;
		      }
		      break;

		    case ';':
		      switch (getState()) {
		      case 'name':
		      case 'before-value':
		      case 'value':
		        // Tokenize a declaration
		        // if value is empty skip the declaration
		        if (buffer.trim().length > 0) {
		          token.value = buffer.trim(),
		          addToken();
		        }
		        replaceState('before-name');
		        break;

		      case 'value-paren':
		        // Insignificant semi-colon
		        buffer += ch;
		        break;

		      case 'at-value':
		        // Tokenize an @-rule
		        token.value = buffer.trim();
		        addToken();
		        popState();
		        break;

		      case 'before-name':
		        // Extraneous semi-colon
		        break;

		      default:
		        buffer += ch;
		        break;
		      }
		      break;

		    case '{':
		      switch (getState()) {
		      case 'selector':
		        // If the sequence is `\{` then assume that the brace should be escaped.
		        if (peek(-1) === '\\') {
		            buffer += ch;
		            break;
		        }

		        // Tokenize a selector
		        token.text = buffer.trim();
		        addToken();
		        replaceState('before-name');
		        depth = depth + 1;
		        break;

		      case 'at-group':
		        // Tokenize an @-group
		        token.name = buffer.trim();

		        // XXX: @-rules are starting to get hairy
		        switch (token.type) {
		        case 'font-face':
		        case 'viewport' :
		        case 'page'     :
		          pushState('before-name');
		          break;

		        default:
		          pushState('before-selector');
		        }

		        addToken();
		        depth = depth + 1;
		        break;

		      case 'name':
		      case 'at-rule':
		        // Tokenize a declaration or an @-rule
		        token.name = buffer.trim();
		        addToken();
		        pushState('before-name');
		        depth = depth + 1;
		        break;

		      case 'comment':
		      case 'double-string':
		      case 'single-string':
		        // Ignore braces in comments and strings
		        buffer += ch;
		        break;
		      case 'before-value':
		        replaceState('value');
		        buffer += ch;
		        break;
		      }

		      break;

		    case '}':
		      switch (getState()) {
		      case 'before-name':
		      case 'name':
		      case 'before-value':
		      case 'value':
		        // If the buffer contains anything, it is a value
		        if (buffer) {
		          token.value = buffer.trim();
		        }

		        // If the current token has a name and a value it should be tokenized.
		        if (token.name && token.value) {
		          addToken();
		        }

		        // Leave the block
		        initializeToken('end');
		        addToken();
		        popState();

		        // We might need to leave again.
		        // XXX: What about 3 levels deep?
		        if ('at-group' === getState()) {
		          initializeToken('at-group-end');
		          addToken();
		          popState();
		        }
		        
		        if (depth > 0) {
		          depth = depth - 1;
		        }

		        break;

		      case 'at-group':
		      case 'before-selector':
		      case 'selector':
		        // If the sequence is `\}` then assume that the brace should be escaped.
		        if (peek(-1) === '\\') {
		            buffer += ch;
		            break;
		        }

		        if (depth > 0) {
		          // Leave block if in an at-group
		          if ('at-group' === getState(1)) {
		            initializeToken('at-group-end');
		            addToken();
		          }
		        }

		        if (depth > 1) {
		          popState();
		        }

		        if (depth > 0) {
		          depth = depth - 1;
		        }
		        break;

		      case 'double-string':
		      case 'single-string':
		      case 'comment':
		        // Ignore braces in comments and strings.
		        buffer += ch;
		        break;
		      }

		      break;

		    // Strings
		    case '"':
		    case "'":
		      switch (getState()) {
		      case 'double-string':
		        if ('"' === ch && '\\' !== peek(-1)) {
		          popState();
		        }
		        break;

		      case 'single-string':
		        if ("'" === ch && '\\' !== peek(-1)) {
		          popState();
		        }
		        break;

		      case 'before-at-value':
		        replaceState('at-value');
		        pushState('"' === ch ? 'double-string' : 'single-string');
		        break;

		      case 'before-value':
		        replaceState('value');
		        pushState('"' === ch ? 'double-string' : 'single-string');
		        break;

		      case 'comment':
		        // Ignore strings within comments.
		        break;

		      default:
		        if ('\\' !== peek(-1)) {
		          pushState('"' === ch ? 'double-string' : 'single-string');
		        }
		      }

		      buffer += ch;
		      break;

		    // Comments
		    case '/':
		      switch (getState()) {
		      case 'comment':
		      case 'double-string':
		      case 'single-string':
		        // Ignore
		        buffer += ch;
		        break;

		      case 'before-value':
		      case 'selector':
		      case 'name':
		      case 'value':
		        if (isNextChar('*')) {
		          // Ignore comments in selectors, properties and values. They are
		          // difficult to represent in the AST.
		          var pos = find('*/');

		          if (pos) {
		            skip(pos + 1);
		          }
		        } else {
		          if (getState() == 'before-value') replaceState('value');
		          buffer += ch;
		        }
		        break;

		      default:
		        if (isNextChar('*')) {
		          // Create a comment token
		          initializeToken('comment');
		          pushState('comment');
		          skip();
		        }
		        else {
		          buffer += ch;
		        }
		        break;
		      }
		      break;

		    // Comment end or universal selector
		    case '*':
		      switch (getState()) {
		      case 'comment':
		        if (isNextChar('/')) {
		          // Tokenize a comment
		          token.text = buffer; // Don't trim()!
		          skip();
		          addToken();
		          popState();
		        }
		        else {
		          buffer += ch;
		        }
		        break;

		      case 'before-selector':
		        buffer += ch;
		        initializeToken('selector');
		        pushState('selector');
		        break;

		      case 'before-value':
		        replaceState('value');
		        buffer += ch;
		        break;

		      default:
		        buffer += ch;
		      }
		      break;

		    // @-rules
		    case '@':
		      switch (getState()) {
		      case 'comment':
		      case 'double-string':
		      case 'single-string':
		        buffer += ch;
		        break;
		      case 'before-value':
		        replaceState('value');
		        buffer += ch;
		        break;

		      default:
		        // Iterate over the supported @-rules and attempt to tokenize one.
		        var tokenized = false;
		        var name;
		        var rule;

		        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
		          rule = atRules[j];
		          name = rule.name || rule;

		          if (!isNextString(name)) { continue; }

		          tokenized = true;

		          initializeToken(name);
		          pushState(rule.state || 'at-group');
		          skip(name.length);

		          if (rule.prefix) {
		            token.prefix = rule.prefix;
		          }

		          if (rule.type) {
		            token.type = rule.type;
		          }
		        }

		        if (!tokenized) {
		          // Keep on truckin' America!
		          buffer += ch;
		        }
		        break;
		      }
		      break;

		    // Parentheses are tracked to disambiguate semi-colons, such as within a
		    // data URI.
		    case '(':
		      switch (getState()) {
		      case 'value':
		        pushState('value-paren');
		        break;
		      case 'before-value':
		        replaceState('value');
		        break;
		      }

		      buffer += ch;
		      break;

		    case ')':
		      switch (getState()) {
		      case 'value-paren':
		        popState();
		        break;
		      case 'before-value':
		        replaceState('value');
		        break;
		      }

		      buffer += ch;
		      break;

		    default:
		      switch (getState()) {
		      case 'before-selector':
		        initializeToken('selector');
		        pushState('selector');
		        break;

		      case 'before-name':
		        initializeToken('property');
		        replaceState('name');
		        break;

		      case 'before-value':
		        replaceState('value');
		        break;

		      case 'before-at-value':
		        replaceState('at-value');
		        break;
		      }

		      buffer += ch;
		      break;
		    }
		  }

		  return tokens;
		} 
	} (lexer));
	return lexer.exports;
}

var parser$1 = {exports: {}};

var hasRequiredParser$2;

function requireParser$2 () {
	if (hasRequiredParser$2) return parser$1.exports;
	hasRequiredParser$2 = 1;
	(function (module, exports$1) {

		requireDebug()('parse');
		var lex = requireLexer();

		module.exports = parse;

		var _comments;   // Whether comments are allowed.
		var _depth;      // Current block nesting depth.
		var _position;   // Whether to include line/column position.
		var _tokens;     // Array of lexical tokens.

		/**
		 * Convert a CSS string or array of lexical tokens into a `stringify`-able AST.
		 *
		 * @param {String} css CSS string or array of lexical token
		 * @param {Object} [options]
		 * @param {Boolean} [options.comments=false] allow comment nodes in the AST
		 * @returns {Object} `stringify`-able AST
		 */
		function parse(css, options) {

		  options || (options = {});
		  _comments = !!options.comments;
		  _position = !!options.position;

		  _depth = 0;

		  // Operate on a copy of the given tokens, or the lex()'d CSS string.
		  _tokens = Array.isArray(css) ? css.slice() : lex(css);

		  var rule;
		  var rules = [];
		  var token;

		  while ((token = next())) {
		    rule = parseToken(token);
		    rule && rules.push(rule);
		  }

		  return {
		    type: "stylesheet",
		    stylesheet: {
		      rules: rules
		    }
		  };
		}

		// -- Functions --------------------------------------------------------------

		/**
		 * Build an AST node from a lexical token.
		 *
		 * @param {Object} token lexical token
		 * @param {Object} [override] object hash of properties that override those
		 *   already in the token, or that will be added to the token.
		 * @returns {Object} AST node
		 */
		function astNode(token, override) {
		  override || (override = {});

		  var key;
		  var keys = ['type', 'name', 'value'];
		  var node = {};

		  // Avoiding [].forEach for performance reasons.
		  for (var i = 0; i < keys.length; ++i) {
		    key = keys[i];

		    if (token[key]) {
		      node[key] = override[key] || token[key];
		    }
		  }

		  keys = Object.keys(override);

		  for (i = 0; i < keys.length; ++i) {
		    key = keys[i];

		    if (!node[key]) {
		      node[key] = override[key];
		    }
		  }

		  if (_position) {
		    node.position = {
		      start: token.start,
		      end: token.end
		    };
		  }

		  return node;
		}

		/**
		 * Remove a lexical token from the stack and return the removed token.
		 *
		 * @returns {Object} lexical token
		 */
		function next() {
		  var token = _tokens.shift();
		  return token;
		}

		// -- Parse* Functions ---------------------------------------------------------

		/**
		 * Convert an @-group lexical token to an AST node.
		 *
		 * @param {Object} token @-group lexical token
		 * @returns {Object} @-group AST node
		 */
		function parseAtGroup(token) {
		  _depth = _depth + 1;

		  // As the @-group token is assembled, relevant token values are captured here
		  // temporarily. They will later be used as `tokenize()` overrides.
		  var overrides = {};

		  switch (token.type) {
		  case 'font-face':
		  case 'viewport' :
		    overrides.declarations = parseDeclarations();
		    break;

		  case 'page':
		    overrides.prefix = token.prefix;
		    overrides.declarations = parseDeclarations();
		    break;

		  default:
		    overrides.prefix = token.prefix;
		    overrides.rules = parseRules();
		  }

		  return astNode(token, overrides);
		}

		/**
		 * Convert an @import lexical token to an AST node.
		 *
		 * @param {Object} token @import lexical token
		 * @returns {Object} @import AST node
		 */
		function parseAtImport(token) {
		  return astNode(token);
		}

		/**
		 * Convert an @charset token to an AST node.
		 *
		 * @param {Object} token @charset lexical token
		 * @returns {Object} @charset node
		 */
		function parseCharset(token) {
		  return astNode(token);
		}

		/**
		 * Convert a comment token to an AST Node.
		 *
		 * @param {Object} token comment lexical token
		 * @returns {Object} comment node
		 */
		function parseComment(token) {
		  return astNode(token, {text: token.text});
		}

		function parseNamespace(token) {
		  return astNode(token);
		}

		/**
		 * Convert a property lexical token to a property AST node.
		 *
		 * @returns {Object} property node
		 */
		function parseProperty(token) {
		  return astNode(token);
		}

		/**
		 * Convert a selector lexical token to a selector AST node.
		 *
		 * @param {Object} token selector lexical token
		 * @returns {Object} selector node
		 */
		function parseSelector(token) {
		  function trim(str) {
		    return str.trim();
		  }

		  return astNode(token, {
		    type: 'rule',
		    selectors: token.text.split(',').map(trim),
		    declarations: parseDeclarations()
		  });
		}

		/**
		 * Convert a lexical token to an AST node.
		 *
		 * @returns {Object|undefined} AST node
		 */
		function parseToken(token) {
		  switch (token.type) {
		  // Cases are listed in roughly descending order of probability.
		  case 'property': return parseProperty(token);

		  case 'selector': return parseSelector(token);

		  case 'at-group-end': _depth = _depth - 1; return;

		  case 'media'     :
		  case 'keyframes' :return parseAtGroup(token);

		  case 'comment': if (_comments) { return parseComment(token); } break;

		  case 'charset': return parseCharset(token);
		  case 'import': return parseAtImport(token);

		  case 'namespace': return parseNamespace(token);

		  case 'font-face':
		  case 'supports' :
		  case 'viewport' :
		  case 'document' :
		  case 'page'     : return parseAtGroup(token);
		  }
		}

		// -- Parse Helper Functions ---------------------------------------------------

		/**
		 * Iteratively parses lexical tokens from the stack into AST nodes until a
		 * conditional function returns `false`, at which point iteration terminates
		 * and any AST nodes collected are returned.
		 *
		 * @param {Function} conditionFn
		 *   @param {Object} token the lexical token being parsed
		 *   @returns {Boolean} `true` if the token should be parsed, `false` otherwise
		 * @return {Array} AST nodes
		 */
		function parseTokensWhile(conditionFn) {
		  var node;
		  var nodes = [];
		  var token;

		  while ((token = next()) && (conditionFn && conditionFn(token))) {
		    node = parseToken(token);
		    node && nodes.push(node);
		  }

		  // Place an unused non-`end` lexical token back onto the stack.
		  if (token && token.type !== 'end') {
		    _tokens.unshift(token);
		  }

		  return nodes;
		}

		/**
		 * Convert a series of tokens into a sequence of declaration AST nodes.
		 *
		 * @returns {Array} declaration nodes
		 */
		function parseDeclarations() {
		  return parseTokensWhile(function (token) {
		    return (token.type === 'property' || token.type === 'comment');
		  });
		}

		/**
		 * Convert a series of tokens into a sequence of rule nodes.
		 *
		 * @returns {Array} rule nodes
		 */
		function parseRules() {
		  return parseTokensWhile(function () { return _depth; });
		} 
	} (parser$1));
	return parser$1.exports;
}

var stringify = {exports: {}};

var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify.exports;
	hasRequiredStringify = 1;
	(function (module, exports$1) {

		requireDebug()('stringify');

		var _comments;      // Whether comments are allowed in the stringified CSS.
		var _compress;      // Whether the stringified CSS should be compressed.
		var _indentation;   // Indentation option value.
		var _level;         // Current indentation level.
		var _n;             // Compression-aware newline character.
		var _s;             // Compression-aware space character.

		module.exports = stringify;

		/**
		 * Convert a `stringify`-able AST into a CSS string.
		 *
		 * @param {Object} `stringify`-able AST
		 * @param {Object} [options]
		 * @param {Boolean} [options.comments=false] allow comments in the CSS
		 * @param {Boolean} [options.compress=false] compress whitespace
		 * @param {String} [options.indentation=''] indentation sequence
		 * @returns {String} CSS
		 */
		function stringify(ast, options) {

		  options || (options = {});
		  _indentation = options.indentation || '';
		  _compress = !!options.compress;
		  _comments = !!options.comments;
		  _level = 1;

		  if (_compress) {
		    _n = _s = '';
		  } else {
		    _n = '\n';
		    _s = ' ';
		  }

		  var css = reduce(ast.stylesheet.rules, stringifyNode).join('\n').trim();

		  return css;
		}

		// -- Functions --------------------------------------------------------------

		/**
		 * Modify the indentation level, or return a compression-aware sequence of
		 * spaces equal to the current indentation level.
		 *
		 * @param {Number} [level=undefined] indentation level modifier
		 * @returns {String} sequence of spaces
		 */
		function indent(level) {
		  if (level) {
		    _level += level;
		    return;
		  }

		  if (_compress) { return ''; }

		  return Array(_level).join(_indentation || '');
		}

		// -- Stringify Functions ------------------------------------------------------

		/**
		 * Stringify an @-rule AST node.
		 *
		 * Use `stringifyAtGroup()` when dealing with @-groups that may contain blocks
		 * such as @media.
		 *
		 * @param {String} type @-rule type. E.g., import, charset
		 * @returns {String} Stringified @-rule
		 */
		function stringifyAtRule(node) {
		  return '@' + node.type + ' ' + node.value + ';' + _n;
		}

		/**
		 * Stringify an @-group AST node.
		 *
		 * Use `stringifyAtRule()` when dealing with @-rules that may not contain blocks
		 * such as @import.
		 *
		 * @param {Object} node @-group AST node
		 * @returns {String}
		 */
		function stringifyAtGroup(node) {
		  var label = '';
		  var prefix = node.prefix || '';

		  if (node.name) {
		    label = ' ' + node.name;
		  }

		  // FIXME: @-rule conditional logic is leaking everywhere.
		  var chomp = node.type !== 'page';

		  return '@' + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n;
		}

		/**
		 * Stringify a comment AST node.
		 *
		 * @param {Object} node comment AST node
		 * @returns {String}
		 */
		function stringifyComment(node) {
		  if (!_comments) { return ''; }

		  return '/*' + (node.text || '') + '*/' + _n;
		}

		/**
		 * Stringify a rule AST node.
		 *
		 * @param {Object} node rule AST node
		 * @returns {String}
		 */
		function stringifyRule(node) {
		  var label;

		  if (node.selectors) {
		    label = node.selectors.join(',' + _n);
		  } else {
		    label = '@' + node.type;
		    label += node.name ? ' ' + node.name : '';
		  }

		  return indent() + label + _s + stringifyBlock(node) + _n;
		}


		// -- Stringify Helper Functions -----------------------------------------------

		/**
		 * Reduce an array by applying a function to each item and retaining the truthy
		 * results.
		 *
		 * When `item.type` is `'comment'` `stringifyComment` will be applied instead.
		 *
		 * @param {Array} items array to reduce
		 * @param {Function} fn function to call for each item in the array
		 *   @returns {Mixed} Truthy values will be retained, falsy values omitted
		 * @returns {Array} retained results
		 */
		function reduce(items, fn) {
		  return items.reduce(function (results, item) {
		    var result = (item.type === 'comment') ? stringifyComment(item) : fn(item);
		    result && results.push(result);
		    return results;
		  }, []);
		}

		/**
		 * Stringify an AST node with the assumption that it represents a block of
		 * declarations or other @-group contents.
		 *
		 * @param {Object} node AST node
		 * @returns {String}
		 */
		// FIXME: chomp should not be a magic boolean parameter
		function stringifyBlock(node, chomp) {
		  var children = node.declarations;
		  var fn = stringifyDeclaration;

		  if (node.rules) {
		    children = node.rules;
		    fn = stringifyRule;
		  }

		  children = stringifyChildren(children, fn);
		  children && (children = _n + children + (chomp ? '' : _n));

		  return '{' + children + indent() + '}';
		}

		/**
		 * Stringify an array of child AST nodes by calling the given stringify function
		 * once for each child, and concatenating the results.
		 *
		 * @param {Array} children `node.rules` or `node.declarations`
		 * @param {Function} fn stringify function
		 * @returns {String}
		 */
		function stringifyChildren(children, fn) {
		  if (!children) { return ''; }

		  indent(1);
		  var results = reduce(children, fn);
		  indent(-1);

		  if (!results.length) { return ''; }

		  return results.join(_n);
		}

		/**
		 * Stringify a declaration AST node.
		 *
		 * @param {Object} node declaration AST node
		 * @returns {String}
		 */
		function stringifyDeclaration(node) {
		  if (node.type === 'property') {
		    return stringifyProperty(node);
		  }
		}

		/**
		 * Stringify an AST node.
		 *
		 * @param {Object} node AST node
		 * @returns {String}
		 */
		function stringifyNode(node) {
		  switch (node.type) {
		  // Cases are listed in roughly descending order of probability.
		  case 'rule': return stringifyRule(node);

		  case 'media'    :
		  case 'keyframes': return stringifyAtGroup(node);

		  case 'comment': return stringifyComment(node);

		  case 'import'   :
		  case 'charset'  :
		  case 'namespace': return stringifyAtRule(node);

		  case 'font-face':
		  case 'supports' :
		  case 'viewport' :
		  case 'document' :
		  case 'page'     : return stringifyAtGroup(node);
		  }
		}

		/**
		 * Stringify an AST property node.
		 *
		 * @param {Object} node AST property node
		 * @returns {String}
		 */
		function stringifyProperty(node) {
		  var name = node.name ? node.name + ':' + _s : '';

		  return indent() + name + node.value + ';';
		} 
	} (stringify));
	return stringify.exports;
}

var mensch;
var hasRequiredMensch;

function requireMensch () {
	if (hasRequiredMensch) return mensch;
	hasRequiredMensch = 1;
	mensch = {
	    lex  : requireLexer(),
	    parse: requireParser$2(),
	    stringify: requireStringify()
	};
	return mensch;
}

var selector = {exports: {}};

/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/

var parser;
var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser;
	hasRequiredParser$1 = 1;

	// Notable changes from Slick.Parser 1.0.x

	// The parser now uses 2 classes: Expressions and Expression
	// `new Expressions` produces an array-like object containing a list of Expression objects
	// - Expressions::toString() produces a cleaned up expressions string
	// `new Expression` produces an array-like object
	// - Expression::toString() produces a cleaned up expression string
	// The only exposed method is parse, which produces a (cached) `new Expressions` instance
	// parsed.raw is no longer present, use .toString()
	// parsed.expression is now useless, just use the indices
	// parsed.reverse() has been removed for now, due to its apparent uselessness
	// Other changes in the Expressions object:
	// - classNames are now unique, and save both escaped and unescaped values
	// - attributes now save both escaped and unescaped values
	// - pseudos now save both escaped and unescaped values

	var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
	    unescapeRe = /\\/g;

	var escape = function(string){
	    // XRegExp v2.0.0-beta-3
	    //  https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
	    return (string + "").replace(escapeRe, '\\$1')
	};

	var unescape = function(string){
	    return (string + "").replace(unescapeRe, '')
	};

	var slickRe = RegExp(
	/*
	#!/usr/bin/env ruby
	puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
	__END__
	    "(?x)^(?:\
	      \\s* ( , ) \\s*               # Separator          \n\
	    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
	    |      ( \\s+ )                 # CombinatorChildren \n\
	    |      ( <unicode>+ | \\* )     # Tag                \n\
	    | \\#  ( <unicode>+       )     # ID                 \n\
	    | \\.  ( <unicode>+       )     # ClassName          \n\
	    |                               # Attribute          \n\
	    \\[  \
	        \\s* (<unicode1>+)  (?:  \
	            \\s* ([*^$!~|]?=)  (?:  \
	                \\s* (?:\
	                    ([\"']?)(.*?)\\9 \
	                )\
	            )  \
	        )?  \\s*  \
	    \\](?!\\]) \n\
	    |   :+ ( <unicode>+ )(?:\
	    \\( (?:\
	        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
	    ) \\)\
	    )?\
	    )"
	*/
	"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
	    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
	    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
	    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
	);

	// Part

	var Part = function Part(combinator){
	    this.combinator = combinator || " ";
	    this.tag = "*";
	};

	Part.prototype.toString = function(){

	    if (!this.raw){

	        var xpr = "", k, part;

	        xpr += this.tag || "*";
	        if (this.id) xpr += "#" + this.id;
	        if (this.classes) xpr += "." + this.classList.join(".");
	        if (this.attributes) for (k = 0; part = this.attributes[k++];){
	            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]";
	        }
	        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
	            xpr += ":" + part.name;
	            if (part.value) xpr += "(" + part.value + ")";
	        }

	        this.raw = xpr;

	    }

	    return this.raw
	};

	// Expression

	var Expression = function Expression(){
	    this.length = 0;
	};

	Expression.prototype.toString = function(){

	    if (!this.raw){

	        var xpr = "";

	        for (var j = 0, bit; bit = this[j++];){
	            if (j !== 1) xpr += " ";
	            if (bit.combinator !== " ") xpr += bit.combinator + " ";
	            xpr += bit;
	        }

	        this.raw = xpr;

	    }

	    return this.raw
	};

	var replacer = function(
	    rawMatch,

	    separator,
	    combinator,
	    combinatorChildren,

	    tagName,
	    id,
	    className,

	    attributeKey,
	    attributeOperator,
	    attributeQuote,
	    attributeValue,

	    pseudoMarker,
	    pseudoClass,
	    pseudoQuote,
	    pseudoClassQuotedValue,
	    pseudoClassValue
	){

	    var expression, current;

	    if (separator || !this.length){
	        expression = this[this.length++] = new Expression;
	        if (separator) return ''
	    }

	    if (!expression) expression = this[this.length - 1];

	    if (combinator || combinatorChildren || !expression.length){
	        current = expression[expression.length++] = new Part(combinator);
	    }

	    if (!current) current = expression[expression.length - 1];

	    if (tagName){

	        current.tag = unescape(tagName);

	    } else if (id){

	        current.id = unescape(id);

	    } else if (className){

	        var unescaped = unescape(className);

	        var classes = current.classes || (current.classes = {});
	        if (!classes[unescaped]){
	            classes[unescaped] = escape(className);
	            var classList = current.classList || (current.classList = []);
	            classList.push(unescaped);
	            classList.sort();
	        }

	    } else if (pseudoClass){

	        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

	        ;(current.pseudos || (current.pseudos = [])).push({
	            type         : pseudoMarker.length == 1 ? 'class' : 'element',
	            name         : unescape(pseudoClass),
	            escapedName  : escape(pseudoClass),
	            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
	            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
	        });

	    } else if (attributeKey){

	        attributeValue = attributeValue ? escape(attributeValue) : null

	        ;(current.attributes || (current.attributes = [])).push({
	            operator     : attributeOperator,
	            name         : unescape(attributeKey),
	            escapedName  : escape(attributeKey),
	            value        : attributeValue ? unescape(attributeValue) : null,
	            escapedValue : attributeValue ? escape(attributeValue) : null
	        });

	    }

	    return ''

	};

	// Expressions

	var Expressions = function Expressions(expression){
	    this.length = 0;

	    var self = this;

	    var original = expression, replaced;

	    while (expression){
	        replaced = expression.replace(slickRe, function(){
	            return replacer.apply(self, arguments)
	        });
	        if (replaced === expression) throw new Error(original + ' is an invalid expression')
	        expression = replaced;
	    }
	};

	Expressions.prototype.toString = function(){
	    if (!this.raw){
	        var expressions = [];
	        for (var i = 0, expression; expression = this[i++];) expressions.push(expression);
	        this.raw = expressions.join(", ");
	    }

	    return this.raw
	};

	var cache = {};

	var parse = function(expression){
	    if (expression == null) return null
	    expression = ('' + expression).replace(/^\s+|\s+$/g, '');
	    return cache[expression] || (cache[expression] = new Expressions(expression))
	};

	parser = parse;
	return parser;
}

var hasRequiredSelector;

function requireSelector () {
	if (hasRequiredSelector) return selector.exports;
	hasRequiredSelector = 1;
	(function (module, exports$1) {

		var parser = requireParser$1();

		module.exports = Selector;

		/**
		 * CSS selector constructor.
		 *
		 * @param {String} selector text
		 * @param {Array} optionally, precalculated specificity
		 * @api public
		 */

		function Selector(text, styleAttribute) {
		  this.text = text;
		  this.spec = undefined;
		  this.styleAttribute = styleAttribute || false;
		}

		/**
		 * Get parsed selector.
		 *
		 * @api public
		 */

		Selector.prototype.parsed = function() {
		  if (!this.tokens) { this.tokens = parse(this.text); }
		  return this.tokens;
		};

		/**
		 * Lazy specificity getter
		 *
		 * @api public
		 */

		Selector.prototype.specificity = function() {
		  var styleAttribute = this.styleAttribute;
		  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }
		  return this.spec;

		  function specificity(text, parsed) {
		    var expressions = parsed || parse(text);
		    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
		    var nots = [];

		    for (var i = 0; i < expressions.length; i++) {
		      var expression = expressions[i];
		      var pseudos = expression.pseudos;

		      // id awards a point in the second column
		      if (expression.id) { spec[1]++; }

		      // classes and attributes award a point each in the third column
		      if (expression.attributes) { spec[2] += expression.attributes.length; }
		      if (expression.classList) { spec[2] += expression.classList.length; }

		      // tag awards a point in the fourth column
		      if (expression.tag && expression.tag !== '*') { spec[3]++; }

		      // pseudos award a point each in the fourth column
		      if (pseudos) {
		        spec[3] += pseudos.length;

		        for (var p = 0; p < pseudos.length; p++) {
		          if (pseudos[p].name === 'not') {
		            nots.push(pseudos[p].value);
		            spec[3]--;
		          }
		        }
		      }
		    }

		    for (var ii = nots.length; ii--;) {
		      var not = specificity(nots[ii]);
		      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }
		    }

		    return spec;
		  }
		};

		/**
		 * Parses a selector and returns the tokens.
		 *
		 * @param {String} selector
		 * @api private.
		 */

		function parse(text) {
		  try {
		    return parser(text)[0];
		  } catch (e) {
		    return [];
		  }
		} 
	} (selector));
	return selector.exports;
}

var property = {exports: {}};

var hasRequiredProperty;

function requireProperty () {
	if (hasRequiredProperty) return property.exports;
	hasRequiredProperty = 1;
	(function (module, exports$1) {

		module.exports = Property;

		/**
		 * Module dependencies.
		 */

		var utils = requireUtils$1();

		/**
		 * CSS property constructor.
		 *
		 * @param {String} property
		 * @param {String} value
		 * @param {Selector} selector the property originates from
		 * @param {Integer} priority 0 for normal properties, 2 for !important properties.
		 * @param {Array} additional array of integers representing more detailed priorities (sorting)
		 * @api public
		 */

		function Property(prop, value, selector, priority, additionalPriority) {
		  this.prop = prop;
		  this.value = value;
		  this.selector = selector;
		  this.priority = priority || 0;
		  this.additionalPriority = additionalPriority || [];
		}

		/**
		 * Compares with another Property based on Selector#specificity.
		 *
		 * @api public
		 */

		Property.prototype.compareFunc = function(property) {
		  var a = [];
		  a.push.apply(a, this.selector.specificity());
		  a.push.apply(a, this.additionalPriority);
		  a[0] += this.priority;
		  var b = [];
		  b.push.apply(b, property.selector.specificity());
		  b.push.apply(b, property.additionalPriority);
		  b[0] += property.priority;
		  return utils.compareFunc(a, b);
		};

		Property.prototype.compare = function(property) {
		  var winner = this.compareFunc(property);
		  if (winner === 1) {
		    return this;
		  }
		  return property;
		};


		/**
		 * Returns CSS property
		 *
		 * @api public
		 */

		Property.prototype.toString = function() {
		  return this.prop + ': ' + this.value.replace(/['"]+/g, '') + ';';
		}; 
	} (property));
	return property.exports;
}

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports$1) {

		/**
		 * Module dependencies.
		 */

		var mensch = requireMensch();
		var Selector = requireSelector();
		var Property = requireProperty();

		exports$1.Selector = Selector;
		exports$1.Property = Property;

		/**
		 * Returns an array of the selectors.
		 *
		 * @license Sizzle CSS Selector Engine - MIT
		 * @param {String} selectorText from mensch
		 * @api public
		 */

		exports$1.extract = function extract(selectorText) {
		  var attr = 0;
		  var sels = [];
		  var sel = '';

		  for (var i = 0, l = selectorText.length; i < l; i++) {
		    var c = selectorText.charAt(i);

		    if (attr) {
		      if (']' === c || ')' === c) { attr--; }
		      sel += c;
		    } else {
		      if (',' === c) {
		        sels.push(sel);
		        sel = '';
		      } else {
		        if ('[' === c || '(' === c) { attr++; }
		        if (sel.length || (c !== ',' && c !== '\n' && c !== ' ')) { sel += c; }
		      }
		    }
		  }

		  if (sel.length) {
		    sels.push(sel);
		  }
		  return sels;
		};

		/**
		 * Returns a parse tree for a CSS source.
		 * If it encounters multiple selectors separated by a comma, it splits the
		 * tree.
		 *
		 * @param {String} css source
		 * @api public
		 */

		exports$1.parseCSS = function(css) {
		  var parsed = mensch.parse(css, {position: true, comments: true});
		  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
		  var ret = [];

		  for (var i = 0, l = rules.length; i < l; i++) {
		    if (rules[i].type == 'rule') {
		      var rule = rules[i];
		      var selectors = rule.selectors;

		      for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
		        ret.push([selectors[ii], rule.declarations]);
		      }
		    }
		  }

		  return ret;
		};

		/**
		 * Returns preserved text for a CSS source.
		 *
		 * @param {String} css source
		 * @param {Object} options
		 * @api public
		 */

		exports$1.getPreservedText = function(css, options, ignoredPseudos) {
		  var parsed = mensch.parse(css, {position: true, comments: true});
		  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
		  var preserved = [];

		  for (var i = rules.length - 1; i >= 0; i--) {
		    if ((options.fontFaces && rules[i].type === 'font-face') ||
		        (options.mediaQueries && rules[i].type === 'media') ||
		        (options.keyFrames && rules[i].type === 'keyframes') ||
		        (options.pseudos && rules[i].selectors && this.matchesPseudo(rules[i].selectors[0], ignoredPseudos))) {
		      preserved.unshift(
		        mensch.stringify(
		          { stylesheet: { rules: [ rules[i] ] }},
		          { comments: false, indentation: '  ' }
		        )
		      );
		    }
		    rules[i].position.start;
		  }

		  if (preserved.length === 0) {
		    return false;
		  }
		  return '\n' + preserved.join('\n') + '\n';
		};

		exports$1.normalizeLineEndings = function(text) {
		  return text.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
		};

		exports$1.matchesPseudo = function(needle, haystack) {
		  return haystack.find(function (element) {
		    return needle.indexOf(element) > -1;
		  })
		};

		/**
		 * Compares two specificity vectors, returning the winning one.
		 *
		 * @param {Array} vector a
		 * @param {Array} vector b
		 * @return {Array}
		 * @api public
		 */

		exports$1.compareFunc = function(a, b) {
		  var min = Math.min(a.length, b.length);
		  for (var i = 0; i < min; i++) {
		    if (a[i] === b[i]) { continue; }
		    if (a[i] > b[i]) { return 1; }
		    return -1;
		  }

		  return a.length - b.length;
		};

		exports$1.compare = function(a, b) {
		  return exports$1.compareFunc(a, b) == 1 ? a : b;
		};

		exports$1.getDefaultOptions = function(options) {
		  var result = Object.assign({
		    extraCss: '',
		    insertPreservedExtraCss: true,
		    applyStyleTags: true,
		    removeStyleTags: true,
		    preserveMediaQueries: true,
		    preserveFontFaces: true,
		    preserveKeyFrames: true,
		    preservePseudos: true,
		    applyWidthAttributes: true,
		    applyHeightAttributes: true,
		    applyAttributesTableElements: true,
		    resolveCSSVariables: true,
		    url: ''
		  }, options);

		  result.webResources = result.webResources || {};

		  return result;
		}; 
	} (utils$1));
	return utils$1;
}

var hasRequiredCheerio;

function requireCheerio () {
	if (hasRequiredCheerio) return cheerio$1.exports;
	hasRequiredCheerio = 1;
	(function (module) {

		/**
		 * Module dependencies.
		 */
		var cheerio = requireLib$w();
		requireUtils$1();

		var cheerioLoad = function(html, options, encodeEntities) {
		  options = Object.assign({decodeEntities: false, _useHtmlParser2:true}, options);
		  html = encodeEntities(html);
		  return cheerio.load(html, options);
		};

		var createEntityConverters = function () {
		  var codeBlockLookup = [];

		  var encodeCodeBlocks = function(html) {
		    var blocks = module.exports.codeBlocks;
		    Object.keys(blocks).forEach(function(key) {
		      var re = new RegExp(blocks[key].start + '([\\S\\s]*?)' + blocks[key].end, 'g');
		      html = html.replace(re, function(match, subMatch) {
		        codeBlockLookup.push(match);
		        return 'JUICE_CODE_BLOCK_' + (codeBlockLookup.length - 1) + '_';
		      });
		    });
		    return html;
		  };

		  var decodeCodeBlocks = function(html) {
		    for(var index = 0; index < codeBlockLookup.length; index++) {
		      var re = new RegExp('JUICE_CODE_BLOCK_' + index + '_(="")?', 'gi');
		      html = html.replace(re, function() {
		        return codeBlockLookup[index];
		      });
		    }
		    return html;
		  };

		  return {
		    encodeEntities: encodeCodeBlocks,
		    decodeEntities: decodeCodeBlocks,
		  };
		};

		/**
		 * Parses the input, calls the callback on the parsed DOM, and generates the output
		 *
		 * @param {String} html input html to be processed
		 * @param {Object} options for the parser
		 * @param {Function} callback to be invoked on the DOM
		 * @param {Array} callbackExtraArguments to be passed to the callback
		 * @return {String} resulting html
		 */
		module.exports = function(html, options, callback, callbackExtraArguments) {
		  var entityConverters = createEntityConverters();

		  var $ = cheerioLoad(html, options, entityConverters.encodeEntities);
		  var args = [ $ ];
		  args.push.apply(args, callbackExtraArguments);
		  var doc = callback.apply(undefined, args) || $;

		  if (options && options.xmlMode) {
		    return entityConverters.decodeEntities(doc.xml());
		  }
		  return entityConverters.decodeEntities(doc.html());
		};

		module.exports.codeBlocks = {
		  EJS: { start: '<%', end: '%>' },
		  HBS: { start: '{{', end: '}}' }
		}; 
	} (cheerio$1));
	return cheerio$1.exports;
}

var numbers = {};

var hasRequiredNumbers;

function requireNumbers () {
	if (hasRequiredNumbers) return numbers;
	hasRequiredNumbers = 1;

	/**
	 * Converts a decimal number to roman numeral.
	 * https://stackoverflow.com/questions/9083037/convert-a-number-into-a-roman-numeral-in-javascript
	 *
	 * @param {Number} number
	 * @api private.
	 */
	numbers.romanize = function(num) {
	    if (isNaN(num))
	        return NaN;
	    var digits = String(+num).split(""),
	        key = ["","C","CC","CCC","CD","D","DC","DCC","DCCC","CM",
	               "","X","XX","XXX","XL","L","LX","LXX","LXXX","XC",
	               "","I","II","III","IV","V","VI","VII","VIII","IX"],
	        roman = "",
	        i = 3;
	    while (i--)
	        roman = (key[+digits.pop() + (i * 10)] || "") + roman;
	    return Array(+digits.join("") + 1).join("M") + roman;
	};

	/**
	 * Converts a decimal number to alphanumeric numeral.
	 * https://stackoverflow.com/questions/45787459/convert-number-to-alphabet-string-javascript
	 *
	 * @param {Number} number
	 * @api private.
	 */
	numbers.alphanumeric = function(num) {
	    var s = '', t;

	    while (num > 0) {
	      t = (num - 1) % 26;
	      s = String.fromCharCode(65 + t) + s;
	      num = (num - t)/26 | 0;
	    }
	    return s || undefined;
	};
	return numbers;
}

var variables;
var hasRequiredVariables;

function requireVariables () {
	if (hasRequiredVariables) return variables;
	hasRequiredVariables = 1;

	const uniqueString = (string) => {
	  let str = '';
	  do{
	    str = (Math.random() + 1).toString(36).substring(2);

	  }while(string.indexOf(str) !== -1);

	  return str;
	};

	/**
	 * Replace css variables with their value
	 */
	const replaceVariables = (el,value) => {

	  // find non-nested css function calls
	  // eg: rgb(...), drop-shadow(...)
		let funcReg = /([a-z\-]+)\s*\(\s*([^\(\)]*?)\s*(?:,\s*([^\(\)]*?)\s*)?\s*\)/i;
	  let replacements = [];
	  let match;
	  let uniq = uniqueString(value);

		while( (match = funcReg.exec(value)) !== null ){
	    let i = `${replacements.length}`;


	    // attempt to resolve variables
	    if( match[1].toLowerCase() == 'var' ){
	      const varValue = findVariableValue(el, match[2]);
	      
	      // found variable value
	      if( varValue ){
	        value = value.replace(match[0],varValue);
	        continue;
	      }

	      // use default value
	      // var(--name , default-value)
	      if( match[3] ){
	        value = value.replace(match[0],match[3]);
	        continue;
	      }
	    }
	    
	    let placeholder = `${uniq}${i.padStart(5,'-')}`;
	    value = value.replace(match[0],placeholder);
	    replacements.push({placeholder,replace:match[0]});
	  }

	  for( var i = replacements.length-1; i >=0; i--){
	    const replacement = replacements[i];
			value = value.replace(replacement.placeholder,replacement.replace);
	  }
	  
	  return value;
	};

	const findVariableValue = (el, variable) => {
	  while (el) {
	    if (el.styleProps && variable in el.styleProps) {
	      return el.styleProps[variable].value;
	    }

	    var el = el.pseudoElementParent || el.parent;
	  }
	};

	variables = { replaceVariables, findVariableValue };
	return variables;
}

var inline$1;
var hasRequiredInline$1;

function requireInline$1 () {
	if (hasRequiredInline$1) return inline$1;
	hasRequiredInline$1 = 1;

	var utils = requireUtils$1();
	var numbers = requireNumbers();
	var variables = requireVariables();

	inline$1 = function makeJuiceClient(juiceClient) {

	juiceClient.ignoredPseudos = ['hover', 'active', 'focus', 'visited', 'link'];
	juiceClient.widthElements = ['TABLE', 'TD', 'TH', 'IMG'];
	juiceClient.heightElements = ['TABLE', 'TD', 'TH', 'IMG'];
	juiceClient.tableElements = ['TABLE', 'TH', 'TR', 'TD', 'CAPTION', 'COLGROUP', 'COL', 'THEAD', 'TBODY', 'TFOOT'];
	juiceClient.nonVisualElements = [ 'HEAD', 'TITLE', 'BASE', 'LINK', 'STYLE', 'META', 'SCRIPT', 'NOSCRIPT' ];
	juiceClient.styleToAttribute = {
	  'background-color': 'bgcolor',
	  'background-image': 'background',
	  'text-align': 'align',
	  'vertical-align': 'valign'
	};
	juiceClient.excludedProperties = [];

	juiceClient.juiceDocument = juiceDocument;
	juiceClient.inlineDocument = inlineDocument;

	function inlineDocument($, css, options) {

	  options = options || {};
	  var rules = utils.parseCSS(css);
	  var editedElements = [];
	  var styleAttributeName = 'style';
	  var counters = {};

	  if (options.styleAttributeName) {
	    styleAttributeName = options.styleAttributeName;
	  }

	  rules.forEach(handleRule);
	  editedElements.forEach(setStyleAttrs);

	  if (options.inlinePseudoElements) {
	    editedElements.forEach(inlinePseudoElements);
	  }

	  if (options.applyWidthAttributes) {
	    editedElements.forEach(function(el) {
	      setDimensionAttrs(el, 'width');
	    });
	  }

	  if (options.applyHeightAttributes) {
	    editedElements.forEach(function(el) {
	      setDimensionAttrs(el, 'height');
	    });
	  }

	  if (options.applyAttributesTableElements) {
	    editedElements.forEach(setAttributesOnTableElements);
	  }

	  if (options.insertPreservedExtraCss && options.extraCss) {
	    var preservedText = utils.getPreservedText(options.extraCss, {
	      mediaQueries: options.preserveMediaQueries,
	      fontFaces: options.preserveFontFaces,
	      keyFrames: options.preserveKeyFrames
	    });
	    if (preservedText) {
	      var $appendTo = null;
	      if (options.insertPreservedExtraCss !== true) {
	        $appendTo = $(options.insertPreservedExtraCss);
	      } else {
	        $appendTo = $('head');
	        if (!$appendTo.length) { $appendTo = $('body'); }
	        if (!$appendTo.length) { $appendTo = $.root(); }
	      }

	      $appendTo.first().append('<style>' + preservedText + '</style>');
	    }
	  }

	  function handleRule(rule) {
	    var sel = rule[0];
	    var style = rule[1];
	    var selector = new utils.Selector(sel);
	    var parsedSelector = selector.parsed();

	    if (!parsedSelector) {
	      return;
	    }

	    var pseudoElementType = getPseudoElementType(parsedSelector);

	    // skip rule if the selector has any pseudos which are ignored
	    for (var i = 0; i < parsedSelector.length; ++i) {
	      var subSel = parsedSelector[i];
	      if (subSel.pseudos) {
	        for (var j = 0; j < subSel.pseudos.length; ++j) {
	          var subSelPseudo = subSel.pseudos[j];
	          if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
	            return;
	          }
	        }
	      }
	    }

	    if (pseudoElementType) {
	      var last = parsedSelector[parsedSelector.length - 1];
	      var pseudos = last.pseudos;
	      last.pseudos = filterElementPseudos(last.pseudos);
	      sel = parsedSelector.toString();
	      last.pseudos = pseudos;
	    }

	    var els;
	    try {
	      els = $(sel);
	    } catch (err) {
	      // skip invalid selector
	      return;
	    }

	    els.each(function() {
	      var el = this;

	      if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
	        return;
	      }

	      if (!el.counterProps) {
	        el.counterProps = el.parent && el.parent.counterProps
	          ? Object.create(el.parent.counterProps)
	          : {};
	      }

	      if (pseudoElementType) {
	        var pseudoElPropName = 'pseudo' + pseudoElementType;
	        var pseudoEl = el[pseudoElPropName];
	        if (!pseudoEl) {
	          pseudoEl = el[pseudoElPropName] = $('<span />').get(0);
	          pseudoEl.pseudoElementType = pseudoElementType;
	          pseudoEl.pseudoElementParent = el;
	          pseudoEl.counterProps = el.counterProps;
	          el[pseudoElPropName] = pseudoEl;
	        }
	        el = pseudoEl;
	      }

	      if (!el.styleProps) {
	        el.styleProps = {};

	        // if the element has inline styles, fake selector with topmost specificity
	        if ($(el).attr(styleAttributeName)) {
	          var cssText = '* { ' + $(el).attr(styleAttributeName) + ' } ';
	          addProps(utils.parseCSS(cssText)[0][1], new utils.Selector('<style>', true));
	        }

	        // store reference to an element we need to compile style="" attr for
	        editedElements.push(el);
	      }

	      function resetCounter(el, value) {
	        var tokens = value.split(/\s+/);

	        for (var j = 0; j < tokens.length; j++) {
	          var counter = tokens[j];
	          var resetval = parseInt(tokens[j+1], 10);

	          isNaN(resetval)
	            ? el.counterProps[counter] = counters[counter] = 0
	            : el.counterProps[counter] = counters[tokens[j++]] = resetval;
	        }
	      }

	      function incrementCounter(el, value) {
	        var tokens = value.split(/\s+/);

	        for (var j = 0; j < tokens.length; j++) {
	          var counter = tokens[j];

	          if (el.counterProps[counter] === undefined) {
	            continue;
	          }

	          var incrval = parseInt(tokens[j+1], 10);

	          isNaN(incrval)
	            ? el.counterProps[counter] = counters[counter] += 1
	            : el.counterProps[counter] = counters[tokens[j++]] += incrval;
	        }
	      }

	      // go through the properties
	      function addProps(style, selector) {
	        for (var i = 0, l = style.length; i < l; i++) {
	          if (style[i].type == 'property') {
	            var name = style[i].name;
	            var value = style[i].value;

	            if (name === 'counter-reset') {
	              resetCounter(el, value);
	            }

	            if (name === 'counter-increment') {
	              incrementCounter(el, value);
	            }

	            var important = value.match(/!important$/) !== null;
	            if (important && !options.preserveImportant) value = removeImportant(value);
	            // adds line number and column number for the properties as "additionalPriority" to the
	            // properties because in CSS the position directly affect the priority.
	            var additionalPriority = [style[i].position.start.line, style[i].position.start.col];
	            var prop = new utils.Property(name, value, selector, important ? 2 : 0, additionalPriority);
	            var existing = el.styleProps[name];

	            // if property name is not in the excluded properties array
	            if (juiceClient.excludedProperties.indexOf(name) < 0) {
	              if (existing && existing.compare(prop) === prop || !existing) {
	                // deleting a property let us change the order (move it to the end in the setStyleAttrs loop)
	                if (existing && existing.selector !== selector) {
	                  delete el.styleProps[name];
	                } else if (existing) {
	                  // make "prop" a special composed property.
	                  prop.nextProp = existing;
	                }

	                el.styleProps[name] = prop;
	              }
	            }
	          }
	        }
	      }

	      addProps(style, selector);
	    });
	  }

	  function setStyleAttrs(el) {
	    Object.keys(el.styleProps).length;
	    var props = [];
	    // Here we loop each property and make sure to "expand"
	    // linked "nextProp" properties happening when the same property
	    // is declared multiple times in the same selector.
	    Object.keys(el.styleProps).forEach(function(key) {
	      var np = el.styleProps[key];
	      while (typeof np !== 'undefined') {
	        props.push(np);
	        np = np.nextProp;
	      }
	    });
	    // sort properties by their originating selector's specificity so that
	    // props like "padding" and "padding-bottom" are resolved as expected.
	    props.sort(function(a, b) {
	      return a.compareFunc(b);
	    });
	    	
	    var string = props
	      .filter(function(prop) {

	        // don't add css variables if we're resolving their values
	        if (options.resolveCSSVariables && (prop.prop.indexOf('--') === 0) ) {
	          return false;
	        }
	        
	        // Content becomes the innerHTML of pseudo elements, not used as a
	        // style property
	        return (prop.prop !== 'content');
	      })
	      .map(function(prop) {
	        if (options.resolveCSSVariables) {
	          prop.value = variables.replaceVariables(el,prop.value);
	        }
	        return prop.prop + ': ' + prop.value.replace(/["]/g, '\'') + ';';
	      })
	      .join(' ');
	    if (string) {
	      $(el).attr(styleAttributeName, string);
	    }
	  }

	  function inlinePseudoElements(el) {
	    if (el.pseudoElementType && el.styleProps.content) {
	      var parsed = parseContent(el);
	      if (parsed.img) {
	        el.name = 'img';
	        $(el).attr('src', parsed.img);
	      } else {
	        $(el).text(parsed);
	      }
	      var parent = el.pseudoElementParent;
	      if (el.pseudoElementType === 'before') {
	        $(parent).prepend(el);
	      } else {
	        $(parent).append(el);
	      }
	    }
	  }

	  function setDimensionAttrs(el, dimension) {
	    if (!el.name) { return; }
	    var elName = el.name.toUpperCase();
	    if (juiceClient[dimension + 'Elements'].indexOf(elName) > -1) {
	      for (var i in el.styleProps) {
	        if (el.styleProps[i].prop === dimension) {
	          var value = el.styleProps[i].value;
	          if (options.preserveImportant) {
	            value = removeImportant(value);
	          }
	          if (value.match(/(px|auto)/)) {
	            var size = value.replace('px', '');
	            $(el).attr(dimension, size);
	            return;
	          }
	          if (juiceClient.tableElements.indexOf(elName) > -1 && value.match(/\%/)) {
	            $(el).attr(dimension, value);
	            return;
	          }
	        }
	      }
	    }
	  }

	  function extractBackgroundUrl(value) {
	    return value.indexOf('url(') !== 0
	      ? value
	      : value.replace(/^url\((["'])?([^"']+)\1\)$/, '$2');
	  }

	  function setAttributesOnTableElements(el) {
	    if (!el.name) { return; }
	    var elName = el.name.toUpperCase();
	    var styleProps = Object.keys(juiceClient.styleToAttribute);

	    if (juiceClient.tableElements.indexOf(elName) > -1) {
	      for (var i in el.styleProps) {
	        if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
	          var prop = juiceClient.styleToAttribute[el.styleProps[i].prop];
	          var value = el.styleProps[i].value;
	          if (options.preserveImportant) {
	            value = removeImportant(value);
	          }
	          if (prop === 'background') {
	            value = extractBackgroundUrl(value);
	          }
	          if (/(linear|radial)-gradient\(/i.test(value)) {
	            continue;
	          }
	          $(el).attr(prop, value);
	        }
	      }
	    }
	  }
	}

	function removeImportant(value) {
	  return value.replace(/\s*!important$/, '')
	}



	function applyCounterStyle(counter, style) {
	  switch (style) {
	    case 'lower-roman':
	      return numbers.romanize(counter).toLowerCase();
	    case 'upper-roman':
	      return numbers.romanize(counter);
	    case 'lower-latin':
	    case 'lower-alpha':
	      return numbers.alphanumeric(counter).toLowerCase();
	    case 'upper-latin':
	    case 'upper-alpha':
	      return numbers.alphanumeric(counter);
	    // TODO support more counter styles
	    default:
	      return counter.toString();
	  }
	}

	function parseContent(el) {
	  var content = el.styleProps.content.value;

	  if (content === 'none' || content === 'normal') {
	    return '';
	  }

	  var imageUrlMatch = content.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);
	  if (imageUrlMatch) {
	    var url = imageUrlMatch[1].replace(/^['"]|['"]$/g, '');
	    return { img: url };
	  }

	  var parsed = [];

	  var tokens = content.split(/['"]/);
	  for (var i = 0; i < tokens.length; i++) {
	    if (tokens[i] === '') continue;

	    var varMatch = tokens[i].match(/var\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
	    if (varMatch) {
	      var variable = variables.findVariableValue(el, varMatch[1]) || varMatch[2];
	      parsed.push(variable.replace(/^['"]|['"]$/g, ''));
	      continue;
	    }

	    var counterMatch = tokens[i].match(/counter\s*\(\s*(.*?)\s*(,\s*(.*?)\s*)?\s*\)/i);
	    if (counterMatch && counterMatch[1] in el.counterProps) {
	      var counter = el.counterProps[counterMatch[1]];
	      parsed.push(applyCounterStyle(counter, counterMatch[3]));
	      continue;
	    }

	    var attrMatch = tokens[i].match(/attr\s*\(\s*(.*?)\s*\)/i);
	    if (attrMatch) {
	      var attr = attrMatch[1];
	      parsed.push(el.pseudoElementParent
	        ? el.pseudoElementParent.attribs[attr]
	        : el.attribs[attr]
	      );
	      continue;
	    }

	    parsed.push(tokens[i]);
	  }

	  content = parsed.join('');
	  // Naive unescape, assume no unicode char codes
	  content = content.replace(/\\/g, '');
	  return content;
	}

	// Return "before" or "after" if the given selector is a pseudo element (e.g.,
	// a::after).
	function getPseudoElementType(selector) {
	  if (selector.length === 0) {
	    return;
	  }

	  var pseudos = selector[selector.length - 1].pseudos;
	  if (!pseudos) {
	    return;
	  }

	  for (var i = 0; i < pseudos.length; i++) {
	    if (isPseudoElementName(pseudos[i])) {
	      return pseudos[i].name;
	    }
	  }
	}

	function isPseudoElementName(pseudo) {
	  return pseudo.name === 'before' || pseudo.name === 'after';
	}

	function filterElementPseudos(pseudos) {
	  return pseudos.filter(function(pseudo) {
	    return !isPseudoElementName(pseudo);
	  });
	}

	function juiceDocument($, options) {
	  options = utils.getDefaultOptions(options);
	  var css = extractCssFromDocument($, options);
	  css += '\n' + options.extraCss;
	  inlineDocument($, css, options);
	  return $;
	}

	function getStylesData($, options) {
	  var results = [];
	  var stylesList = $('style');
	  var styleDataList, styleData, styleElement;
	  stylesList.each(function() {
	    styleElement = this;
	    // the API for Cheerio using parse5 (default) and htmlparser2 are slightly different
	    // detect this by checking if .childNodes exist (as opposed to .children)
	    var usingParse5 = !!styleElement.childNodes;
	    styleDataList = usingParse5 ? styleElement.childNodes : styleElement.children;
	    if (styleDataList.length !== 1) {
	      if (options.removeStyleTags) {
	        $(styleElement).remove();
	      }
	      return;
	    }
	    styleData = styleDataList[0].data;
	    if (options.applyStyleTags && $(styleElement).attr('data-embed') === undefined) {
	      results.push(styleData);
	    }
	    if (options.removeStyleTags && $(styleElement).attr('data-embed') === undefined) {
	      var text = usingParse5 ? styleElement.childNodes[0].nodeValue : styleElement.children[0].data;
	      var preservedText = utils.getPreservedText(text, {
	        mediaQueries: options.preserveMediaQueries,
	        fontFaces: options.preserveFontFaces,
	        keyFrames: options.preserveKeyFrames,
	        pseudos: options.preservePseudos
	      }, juiceClient.ignoredPseudos);
	      if (preservedText) {
	        if (usingParse5) {
	          styleElement.childNodes[0].nodeValue = preservedText;
	        } else {
	          styleElement.children[0].data = preservedText;
	        }
	      } else {
	        $(styleElement).remove();
	      }
	    }
	    $(styleElement).removeAttr('data-embed');
	  });
	  return results;
	}

	function extractCssFromDocument($, options) {
	  var results = getStylesData($, options);
	  var css = results.join('\n');
	  return css;
	}

	return juiceClient;

	};
	return inline$1;
}

var client;
var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;

	var cheerio = requireCheerio();
	var makeJuiceClient = requireInline$1();

	/**
	 * Note that makeJuiceClient will take a base object (in this case a function) and enhance it
	 * with a lot of useful properties and functions.
	 *
	 * This client adopts cheerio as a DOM parser and adds an "inlineContent" function that let
	 * users to specify the CSS to be inlined instead of extracting it from the html.
	 * 
	 * The weird "makeJuiceClient" behaviour is there in order to keep backward API compatibility.
	 */
	var juiceClient = makeJuiceClient(function(html,options) {
	  return cheerio(html, { xmlMode: options && options.xmlMode}, juiceDocument, [options]);
	});

	var juiceDocument = function(html, options) {
	  return juiceClient.juiceDocument(html, options);
	};

	juiceClient.inlineContent = function(html, css, options) {
	  return cheerio(html, { xmlMode: options && options.xmlMode}, juiceClient.inlineDocument, [css, options]);
	};

	juiceClient.codeBlocks = cheerio.codeBlocks;

	client = juiceClient;
	return client;
}

var js = {exports: {}};

var src = {};

var javascript = {exports: {}};

var beautifier$2 = {};

var output = {};

/*jshint node:true */

var hasRequiredOutput;

function requireOutput () {
	if (hasRequiredOutput) return output;
	hasRequiredOutput = 1;

	function OutputLine(parent) {
	  this.__parent = parent;
	  this.__character_count = 0;
	  // use indent_count as a marker for this.__lines that have preserved indentation
	  this.__indent_count = -1;
	  this.__alignment_count = 0;
	  this.__wrap_point_index = 0;
	  this.__wrap_point_character_count = 0;
	  this.__wrap_point_indent_count = -1;
	  this.__wrap_point_alignment_count = 0;

	  this.__items = [];
	}

	OutputLine.prototype.clone_empty = function() {
	  var line = new OutputLine(this.__parent);
	  line.set_indent(this.__indent_count, this.__alignment_count);
	  return line;
	};

	OutputLine.prototype.item = function(index) {
	  if (index < 0) {
	    return this.__items[this.__items.length + index];
	  } else {
	    return this.__items[index];
	  }
	};

	OutputLine.prototype.has_match = function(pattern) {
	  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
	    if (this.__items[lastCheckedOutput].match(pattern)) {
	      return true;
	    }
	  }
	  return false;
	};

	OutputLine.prototype.set_indent = function(indent, alignment) {
	  if (this.is_empty()) {
	    this.__indent_count = indent || 0;
	    this.__alignment_count = alignment || 0;
	    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
	  }
	};

	OutputLine.prototype._set_wrap_point = function() {
	  if (this.__parent.wrap_line_length) {
	    this.__wrap_point_index = this.__items.length;
	    this.__wrap_point_character_count = this.__character_count;
	    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
	    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
	  }
	};

	OutputLine.prototype._should_wrap = function() {
	  return this.__wrap_point_index &&
	    this.__character_count > this.__parent.wrap_line_length &&
	    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
	};

	OutputLine.prototype._allow_wrap = function() {
	  if (this._should_wrap()) {
	    this.__parent.add_new_line();
	    var next = this.__parent.current_line;
	    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
	    next.__items = this.__items.slice(this.__wrap_point_index);
	    this.__items = this.__items.slice(0, this.__wrap_point_index);

	    next.__character_count += this.__character_count - this.__wrap_point_character_count;
	    this.__character_count = this.__wrap_point_character_count;

	    if (next.__items[0] === " ") {
	      next.__items.splice(0, 1);
	      next.__character_count -= 1;
	    }
	    return true;
	  }
	  return false;
	};

	OutputLine.prototype.is_empty = function() {
	  return this.__items.length === 0;
	};

	OutputLine.prototype.last = function() {
	  if (!this.is_empty()) {
	    return this.__items[this.__items.length - 1];
	  } else {
	    return null;
	  }
	};

	OutputLine.prototype.push = function(item) {
	  this.__items.push(item);
	  var last_newline_index = item.lastIndexOf('\n');
	  if (last_newline_index !== -1) {
	    this.__character_count = item.length - last_newline_index;
	  } else {
	    this.__character_count += item.length;
	  }
	};

	OutputLine.prototype.pop = function() {
	  var item = null;
	  if (!this.is_empty()) {
	    item = this.__items.pop();
	    this.__character_count -= item.length;
	  }
	  return item;
	};


	OutputLine.prototype._remove_indent = function() {
	  if (this.__indent_count > 0) {
	    this.__indent_count -= 1;
	    this.__character_count -= this.__parent.indent_size;
	  }
	};

	OutputLine.prototype._remove_wrap_indent = function() {
	  if (this.__wrap_point_indent_count > 0) {
	    this.__wrap_point_indent_count -= 1;
	  }
	};
	OutputLine.prototype.trim = function() {
	  while (this.last() === ' ') {
	    this.__items.pop();
	    this.__character_count -= 1;
	  }
	};

	OutputLine.prototype.toString = function() {
	  var result = '';
	  if (this.is_empty()) {
	    if (this.__parent.indent_empty_lines) {
	      result = this.__parent.get_indent_string(this.__indent_count);
	    }
	  } else {
	    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
	    result += this.__items.join('');
	  }
	  return result;
	};

	function IndentStringCache(options, baseIndentString) {
	  this.__cache = [''];
	  this.__indent_size = options.indent_size;
	  this.__indent_string = options.indent_char;
	  if (!options.indent_with_tabs) {
	    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
	  }

	  // Set to null to continue support for auto detection of base indent
	  baseIndentString = baseIndentString || '';
	  if (options.indent_level > 0) {
	    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
	  }

	  this.__base_string = baseIndentString;
	  this.__base_string_length = baseIndentString.length;
	}

	IndentStringCache.prototype.get_indent_size = function(indent, column) {
	  var result = this.__base_string_length;
	  column = column || 0;
	  if (indent < 0) {
	    result = 0;
	  }
	  result += indent * this.__indent_size;
	  result += column;
	  return result;
	};

	IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
	  var result = this.__base_string;
	  column = column || 0;
	  if (indent_level < 0) {
	    indent_level = 0;
	    result = '';
	  }
	  column += indent_level * this.__indent_size;
	  this.__ensure_cache(column);
	  result += this.__cache[column];
	  return result;
	};

	IndentStringCache.prototype.__ensure_cache = function(column) {
	  while (column >= this.__cache.length) {
	    this.__add_column();
	  }
	};

	IndentStringCache.prototype.__add_column = function() {
	  var column = this.__cache.length;
	  var indent = 0;
	  var result = '';
	  if (this.__indent_size && column >= this.__indent_size) {
	    indent = Math.floor(column / this.__indent_size);
	    column -= indent * this.__indent_size;
	    result = new Array(indent + 1).join(this.__indent_string);
	  }
	  if (column) {
	    result += new Array(column + 1).join(' ');
	  }

	  this.__cache.push(result);
	};

	function Output(options, baseIndentString) {
	  this.__indent_cache = new IndentStringCache(options, baseIndentString);
	  this.raw = false;
	  this._end_with_newline = options.end_with_newline;
	  this.indent_size = options.indent_size;
	  this.wrap_line_length = options.wrap_line_length;
	  this.indent_empty_lines = options.indent_empty_lines;
	  this.__lines = [];
	  this.previous_line = null;
	  this.current_line = null;
	  this.next_line = new OutputLine(this);
	  this.space_before_token = false;
	  this.non_breaking_space = false;
	  this.previous_token_wrapped = false;
	  // initialize
	  this.__add_outputline();
	}

	Output.prototype.__add_outputline = function() {
	  this.previous_line = this.current_line;
	  this.current_line = this.next_line.clone_empty();
	  this.__lines.push(this.current_line);
	};

	Output.prototype.get_line_number = function() {
	  return this.__lines.length;
	};

	Output.prototype.get_indent_string = function(indent, column) {
	  return this.__indent_cache.get_indent_string(indent, column);
	};

	Output.prototype.get_indent_size = function(indent, column) {
	  return this.__indent_cache.get_indent_size(indent, column);
	};

	Output.prototype.is_empty = function() {
	  return !this.previous_line && this.current_line.is_empty();
	};

	Output.prototype.add_new_line = function(force_newline) {
	  // never newline at the start of file
	  // otherwise, newline only if we didn't just add one or we're forced
	  if (this.is_empty() ||
	    (!force_newline && this.just_added_newline())) {
	    return false;
	  }

	  // if raw output is enabled, don't print additional newlines,
	  // but still return True as though you had
	  if (!this.raw) {
	    this.__add_outputline();
	  }
	  return true;
	};

	Output.prototype.get_code = function(eol) {
	  this.trim(true);

	  // handle some edge cases where the last tokens
	  // has text that ends with newline(s)
	  var last_item = this.current_line.pop();
	  if (last_item) {
	    if (last_item[last_item.length - 1] === '\n') {
	      last_item = last_item.replace(/\n+$/g, '');
	    }
	    this.current_line.push(last_item);
	  }

	  if (this._end_with_newline) {
	    this.__add_outputline();
	  }

	  var sweet_code = this.__lines.join('\n');

	  if (eol !== '\n') {
	    sweet_code = sweet_code.replace(/[\n]/g, eol);
	  }
	  return sweet_code;
	};

	Output.prototype.set_wrap_point = function() {
	  this.current_line._set_wrap_point();
	};

	Output.prototype.set_indent = function(indent, alignment) {
	  indent = indent || 0;
	  alignment = alignment || 0;

	  // Next line stores alignment values
	  this.next_line.set_indent(indent, alignment);

	  // Never indent your first output indent at the start of the file
	  if (this.__lines.length > 1) {
	    this.current_line.set_indent(indent, alignment);
	    return true;
	  }

	  this.current_line.set_indent();
	  return false;
	};

	Output.prototype.add_raw_token = function(token) {
	  for (var x = 0; x < token.newlines; x++) {
	    this.__add_outputline();
	  }
	  this.current_line.set_indent(-1);
	  this.current_line.push(token.whitespace_before);
	  this.current_line.push(token.text);
	  this.space_before_token = false;
	  this.non_breaking_space = false;
	  this.previous_token_wrapped = false;
	};

	Output.prototype.add_token = function(printable_token) {
	  this.__add_space_before_token();
	  this.current_line.push(printable_token);
	  this.space_before_token = false;
	  this.non_breaking_space = false;
	  this.previous_token_wrapped = this.current_line._allow_wrap();
	};

	Output.prototype.__add_space_before_token = function() {
	  if (this.space_before_token && !this.just_added_newline()) {
	    if (!this.non_breaking_space) {
	      this.set_wrap_point();
	    }
	    this.current_line.push(' ');
	  }
	};

	Output.prototype.remove_indent = function(index) {
	  var output_length = this.__lines.length;
	  while (index < output_length) {
	    this.__lines[index]._remove_indent();
	    index++;
	  }
	  this.current_line._remove_wrap_indent();
	};

	Output.prototype.trim = function(eat_newlines) {
	  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

	  this.current_line.trim();

	  while (eat_newlines && this.__lines.length > 1 &&
	    this.current_line.is_empty()) {
	    this.__lines.pop();
	    this.current_line = this.__lines[this.__lines.length - 1];
	    this.current_line.trim();
	  }

	  this.previous_line = this.__lines.length > 1 ?
	    this.__lines[this.__lines.length - 2] : null;
	};

	Output.prototype.just_added_newline = function() {
	  return this.current_line.is_empty();
	};

	Output.prototype.just_added_blankline = function() {
	  return this.is_empty() ||
	    (this.current_line.is_empty() && this.previous_line.is_empty());
	};

	Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
	  var index = this.__lines.length - 2;
	  while (index >= 0) {
	    var potentialEmptyLine = this.__lines[index];
	    if (potentialEmptyLine.is_empty()) {
	      break;
	    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
	      potentialEmptyLine.item(-1) !== ends_with) {
	      this.__lines.splice(index + 1, 0, new OutputLine(this));
	      this.previous_line = this.__lines[this.__lines.length - 2];
	      break;
	    }
	    index--;
	  }
	};

	output.Output = Output;
	return output;
}

var token$1 = {};

/*jshint node:true */

var hasRequiredToken$1;

function requireToken$1 () {
	if (hasRequiredToken$1) return token$1;
	hasRequiredToken$1 = 1;

	function Token(type, text, newlines, whitespace_before) {
	  this.type = type;
	  this.text = text;

	  // comments_before are
	  // comments that have a new line before them
	  // and may or may not have a newline after
	  // this is a set of comments before
	  this.comments_before = null; /* inline comment*/


	  // this.comments_after =  new TokenStream(); // no new line before and newline after
	  this.newlines = newlines || 0;
	  this.whitespace_before = whitespace_before || '';
	  this.parent = null;
	  this.next = null;
	  this.previous = null;
	  this.opened = null;
	  this.closed = null;
	  this.directives = null;
	}


	token$1.Token = Token;
	return token$1;
}

var acorn = {};

/* jshint node: true, curly: false */

var hasRequiredAcorn;

function requireAcorn () {
	if (hasRequiredAcorn) return acorn;
	hasRequiredAcorn = 1;
	(function (exports$1) {

		// acorn used char codes to squeeze the last bit of performance out
		// Beautifier is okay without that, so we're using regex
		// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
		// 65 through 91 are uppercase letters.
		// permit _ (95).
		// 97 through 123 are lowercase letters.
		var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

		// inside an identifier @ is not allowed but 0-9 are.
		var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

		// Big ugly regular expressions that match characters in the
		// whitespace, identifier, and identifier-start categories. These
		// are only applied when a character is found to actually have a
		// code point above 128.
		var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
		var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
		//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
		//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

		var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
		var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
		var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

		exports$1.identifier = new RegExp(identifierStart + identifierChars, 'g');
		exports$1.identifierStart = new RegExp(identifierStart);
		exports$1.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

		// Whether a single character denotes a newline.

		exports$1.newline = /[\n\r\u2028\u2029]/;

		// Matches a whole line break (where CRLF is considered a single
		// line break). Used to count lines.

		// in javascript, these two differ
		// in python they are the same, different methods are called on them
		exports$1.lineBreak = new RegExp('\r\n|' + exports$1.newline.source);
		exports$1.allLineBreaks = new RegExp(exports$1.lineBreak.source, 'g'); 
	} (acorn));
	return acorn;
}

var options$4 = {};

var options$3 = {};

/*jshint node:true */

var hasRequiredOptions$4;

function requireOptions$4 () {
	if (hasRequiredOptions$4) return options$3;
	hasRequiredOptions$4 = 1;

	function Options(options, merge_child_field) {
	  this.raw_options = _mergeOpts(options, merge_child_field);

	  // Support passing the source text back with no change
	  this.disabled = this._get_boolean('disabled');

	  this.eol = this._get_characters('eol', 'auto');
	  this.end_with_newline = this._get_boolean('end_with_newline');
	  this.indent_size = this._get_number('indent_size', 4);
	  this.indent_char = this._get_characters('indent_char', ' ');
	  this.indent_level = this._get_number('indent_level');

	  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
	  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
	  if (!this.preserve_newlines) {
	    this.max_preserve_newlines = 0;
	  }

	  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
	  if (this.indent_with_tabs) {
	    this.indent_char = '\t';

	    // indent_size behavior changed after 1.8.6
	    // It used to be that indent_size would be
	    // set to 1 for indent_with_tabs. That is no longer needed and
	    // actually doesn't make sense - why not use spaces? Further,
	    // that might produce unexpected behavior - tabs being used
	    // for single-column alignment. So, when indent_with_tabs is true
	    // and indent_size is 1, reset indent_size to 4.
	    if (this.indent_size === 1) {
	      this.indent_size = 4;
	    }
	  }

	  // Backwards compat with 1.3.x
	  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

	  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

	  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']
	  // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).
	  // other values ignored
	  this.templating = this._get_selection_list('templating', ['auto', 'none', 'angular', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
	}

	Options.prototype._get_array = function(name, default_value) {
	  var option_value = this.raw_options[name];
	  var result = default_value || [];
	  if (typeof option_value === 'object') {
	    if (option_value !== null && typeof option_value.concat === 'function') {
	      result = option_value.concat();
	    }
	  } else if (typeof option_value === 'string') {
	    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
	  }
	  return result;
	};

	Options.prototype._get_boolean = function(name, default_value) {
	  var option_value = this.raw_options[name];
	  var result = option_value === undefined ? !!default_value : !!option_value;
	  return result;
	};

	Options.prototype._get_characters = function(name, default_value) {
	  var option_value = this.raw_options[name];
	  var result = default_value || '';
	  if (typeof option_value === 'string') {
	    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
	  }
	  return result;
	};

	Options.prototype._get_number = function(name, default_value) {
	  var option_value = this.raw_options[name];
	  default_value = parseInt(default_value, 10);
	  if (isNaN(default_value)) {
	    default_value = 0;
	  }
	  var result = parseInt(option_value, 10);
	  if (isNaN(result)) {
	    result = default_value;
	  }
	  return result;
	};

	Options.prototype._get_selection = function(name, selection_list, default_value) {
	  var result = this._get_selection_list(name, selection_list, default_value);
	  if (result.length !== 1) {
	    throw new Error(
	      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
	      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
	  }

	  return result[0];
	};


	Options.prototype._get_selection_list = function(name, selection_list, default_value) {
	  if (!selection_list || selection_list.length === 0) {
	    throw new Error("Selection list cannot be empty.");
	  }

	  default_value = default_value || [selection_list[0]];
	  if (!this._is_valid_selection(default_value, selection_list)) {
	    throw new Error("Invalid Default Value!");
	  }

	  var result = this._get_array(name, default_value);
	  if (!this._is_valid_selection(result, selection_list)) {
	    throw new Error(
	      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
	      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
	  }

	  return result;
	};

	Options.prototype._is_valid_selection = function(result, selection_list) {
	  return result.length && selection_list.length &&
	    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
	};


	// merges child options up with the parent options object
	// Example: obj = {a: 1, b: {a: 2}}
	//          mergeOpts(obj, 'b')
	//
	//          Returns: {a: 2}
	function _mergeOpts(allOptions, childFieldName) {
	  var finalOpts = {};
	  allOptions = _normalizeOpts(allOptions);
	  var name;

	  for (name in allOptions) {
	    if (name !== childFieldName) {
	      finalOpts[name] = allOptions[name];
	    }
	  }

	  //merge in the per type settings for the childFieldName
	  if (childFieldName && allOptions[childFieldName]) {
	    for (name in allOptions[childFieldName]) {
	      finalOpts[name] = allOptions[childFieldName][name];
	    }
	  }
	  return finalOpts;
	}

	function _normalizeOpts(options) {
	  var convertedOpts = {};
	  var key;

	  for (key in options) {
	    var newKey = key.replace(/-/g, "_");
	    convertedOpts[newKey] = options[key];
	  }
	  return convertedOpts;
	}

	options$3.Options = Options;
	options$3.normalizeOpts = _normalizeOpts;
	options$3.mergeOpts = _mergeOpts;
	return options$3;
}

/*jshint node:true */

var hasRequiredOptions$3;

function requireOptions$3 () {
	if (hasRequiredOptions$3) return options$4;
	hasRequiredOptions$3 = 1;

	var BaseOptions = requireOptions$4().Options;

	var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

	function Options(options) {
	  BaseOptions.call(this, options, 'js');

	  // compatibility, re
	  var raw_brace_style = this.raw_options.brace_style || null;
	  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
	    this.raw_options.brace_style = "expand";
	  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
	    this.raw_options.brace_style = "collapse,preserve-inline";
	  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
	    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
	    // } else if (!raw_brace_style) { //Nothing exists to set it
	    //   raw_brace_style = "collapse";
	  }

	  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
	  //else is considered a brace_style and the last one only will have an effect

	  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

	  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
	  this.brace_style = "collapse";

	  for (var bs = 0; bs < brace_style_split.length; bs++) {
	    if (brace_style_split[bs] === "preserve-inline") {
	      this.brace_preserve_inline = true;
	    } else {
	      this.brace_style = brace_style_split[bs];
	    }
	  }

	  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
	  this.break_chained_methods = this._get_boolean('break_chained_methods');
	  this.space_in_paren = this._get_boolean('space_in_paren');
	  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
	  this.jslint_happy = this._get_boolean('jslint_happy');
	  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
	  this.space_after_named_function = this._get_boolean('space_after_named_function');
	  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
	  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
	  this.unescape_strings = this._get_boolean('unescape_strings');
	  this.e4x = this._get_boolean('e4x');
	  this.comma_first = this._get_boolean('comma_first');
	  this.operator_position = this._get_selection('operator_position', validPositionValues);

	  // For testing of beautify preserve:start directive
	  this.test_output_raw = this._get_boolean('test_output_raw');

	  // force this._options.space_after_anon_function to true if this._options.jslint_happy
	  if (this.jslint_happy) {
	    this.space_after_anon_function = true;
	  }

	}
	Options.prototype = new BaseOptions();



	options$4.Options = Options;
	return options$4;
}

var tokenizer$2 = {};

var inputscanner = {};

/*jshint node:true */

var hasRequiredInputscanner;

function requireInputscanner () {
	if (hasRequiredInputscanner) return inputscanner;
	hasRequiredInputscanner = 1;

	var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

	function InputScanner(input_string) {
	  this.__input = input_string || '';
	  this.__input_length = this.__input.length;
	  this.__position = 0;
	}

	InputScanner.prototype.restart = function() {
	  this.__position = 0;
	};

	InputScanner.prototype.back = function() {
	  if (this.__position > 0) {
	    this.__position -= 1;
	  }
	};

	InputScanner.prototype.hasNext = function() {
	  return this.__position < this.__input_length;
	};

	InputScanner.prototype.next = function() {
	  var val = null;
	  if (this.hasNext()) {
	    val = this.__input.charAt(this.__position);
	    this.__position += 1;
	  }
	  return val;
	};

	InputScanner.prototype.peek = function(index) {
	  var val = null;
	  index = index || 0;
	  index += this.__position;
	  if (index >= 0 && index < this.__input_length) {
	    val = this.__input.charAt(index);
	  }
	  return val;
	};

	// This is a JavaScript only helper function (not in python)
	// Javascript doesn't have a match method
	// and not all implementation support "sticky" flag.
	// If they do not support sticky then both this.match() and this.test() method
	// must get the match and check the index of the match.
	// If sticky is supported and set, this method will use it.
	// Otherwise it will check that global is set, and fall back to the slower method.
	InputScanner.prototype.__match = function(pattern, index) {
	  pattern.lastIndex = index;
	  var pattern_match = pattern.exec(this.__input);

	  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
	    if (pattern_match.index !== index) {
	      pattern_match = null;
	    }
	  }

	  return pattern_match;
	};

	InputScanner.prototype.test = function(pattern, index) {
	  index = index || 0;
	  index += this.__position;

	  if (index >= 0 && index < this.__input_length) {
	    return !!this.__match(pattern, index);
	  } else {
	    return false;
	  }
	};

	InputScanner.prototype.testChar = function(pattern, index) {
	  // test one character regex match
	  var val = this.peek(index);
	  pattern.lastIndex = 0;
	  return val !== null && pattern.test(val);
	};

	InputScanner.prototype.match = function(pattern) {
	  var pattern_match = this.__match(pattern, this.__position);
	  if (pattern_match) {
	    this.__position += pattern_match[0].length;
	  } else {
	    pattern_match = null;
	  }
	  return pattern_match;
	};

	InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
	  var val = '';
	  var match;
	  if (starting_pattern) {
	    match = this.match(starting_pattern);
	    if (match) {
	      val += match[0];
	    }
	  }
	  if (until_pattern && (match || !starting_pattern)) {
	    val += this.readUntil(until_pattern, until_after);
	  }
	  return val;
	};

	InputScanner.prototype.readUntil = function(pattern, until_after) {
	  var val = '';
	  var match_index = this.__position;
	  pattern.lastIndex = this.__position;
	  var pattern_match = pattern.exec(this.__input);
	  if (pattern_match) {
	    match_index = pattern_match.index;
	    if (until_after) {
	      match_index += pattern_match[0].length;
	    }
	  } else {
	    match_index = this.__input_length;
	  }

	  val = this.__input.substring(this.__position, match_index);
	  this.__position = match_index;
	  return val;
	};

	InputScanner.prototype.readUntilAfter = function(pattern) {
	  return this.readUntil(pattern, true);
	};

	InputScanner.prototype.get_regexp = function(pattern, match_from) {
	  var result = null;
	  var flags = 'g';
	  if (match_from && regexp_has_sticky) {
	    flags = 'y';
	  }
	  // strings are converted to regexp
	  if (typeof pattern === "string" && pattern !== '') {
	    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
	    result = new RegExp(pattern, flags);
	  } else if (pattern) {
	    result = new RegExp(pattern.source, flags);
	  }
	  return result;
	};

	InputScanner.prototype.get_literal_regexp = function(literal_string) {
	  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
	};

	/* css beautifier legacy helpers */
	InputScanner.prototype.peekUntilAfter = function(pattern) {
	  var start = this.__position;
	  var val = this.readUntilAfter(pattern);
	  this.__position = start;
	  return val;
	};

	InputScanner.prototype.lookBack = function(testVal) {
	  var start = this.__position - 1;
	  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
	    .toLowerCase() === testVal;
	};

	inputscanner.InputScanner = InputScanner;
	return inputscanner;
}

var tokenizer$1 = {};

var tokenstream = {};

/*jshint node:true */

var hasRequiredTokenstream;

function requireTokenstream () {
	if (hasRequiredTokenstream) return tokenstream;
	hasRequiredTokenstream = 1;

	function TokenStream(parent_token) {
	  // private
	  this.__tokens = [];
	  this.__tokens_length = this.__tokens.length;
	  this.__position = 0;
	  this.__parent_token = parent_token;
	}

	TokenStream.prototype.restart = function() {
	  this.__position = 0;
	};

	TokenStream.prototype.isEmpty = function() {
	  return this.__tokens_length === 0;
	};

	TokenStream.prototype.hasNext = function() {
	  return this.__position < this.__tokens_length;
	};

	TokenStream.prototype.next = function() {
	  var val = null;
	  if (this.hasNext()) {
	    val = this.__tokens[this.__position];
	    this.__position += 1;
	  }
	  return val;
	};

	TokenStream.prototype.peek = function(index) {
	  var val = null;
	  index = index || 0;
	  index += this.__position;
	  if (index >= 0 && index < this.__tokens_length) {
	    val = this.__tokens[index];
	  }
	  return val;
	};

	TokenStream.prototype.add = function(token) {
	  if (this.__parent_token) {
	    token.parent = this.__parent_token;
	  }
	  this.__tokens.push(token);
	  this.__tokens_length += 1;
	};

	tokenstream.TokenStream = TokenStream;
	return tokenstream;
}

var whitespacepattern = {};

var pattern = {};

/*jshint node:true */

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;

	function Pattern(input_scanner, parent) {
	  this._input = input_scanner;
	  this._starting_pattern = null;
	  this._match_pattern = null;
	  this._until_pattern = null;
	  this._until_after = false;

	  if (parent) {
	    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
	    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
	    this._until_pattern = this._input.get_regexp(parent._until_pattern);
	    this._until_after = parent._until_after;
	  }
	}

	Pattern.prototype.read = function() {
	  var result = this._input.read(this._starting_pattern);
	  if (!this._starting_pattern || result) {
	    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
	  }
	  return result;
	};

	Pattern.prototype.read_match = function() {
	  return this._input.match(this._match_pattern);
	};

	Pattern.prototype.until_after = function(pattern) {
	  var result = this._create();
	  result._until_after = true;
	  result._until_pattern = this._input.get_regexp(pattern);
	  result._update();
	  return result;
	};

	Pattern.prototype.until = function(pattern) {
	  var result = this._create();
	  result._until_after = false;
	  result._until_pattern = this._input.get_regexp(pattern);
	  result._update();
	  return result;
	};

	Pattern.prototype.starting_with = function(pattern) {
	  var result = this._create();
	  result._starting_pattern = this._input.get_regexp(pattern, true);
	  result._update();
	  return result;
	};

	Pattern.prototype.matching = function(pattern) {
	  var result = this._create();
	  result._match_pattern = this._input.get_regexp(pattern, true);
	  result._update();
	  return result;
	};

	Pattern.prototype._create = function() {
	  return new Pattern(this._input, this);
	};

	Pattern.prototype._update = function() {};

	pattern.Pattern = Pattern;
	return pattern;
}

/*jshint node:true */

var hasRequiredWhitespacepattern;

function requireWhitespacepattern () {
	if (hasRequiredWhitespacepattern) return whitespacepattern;
	hasRequiredWhitespacepattern = 1;

	var Pattern = requirePattern().Pattern;

	function WhitespacePattern(input_scanner, parent) {
	  Pattern.call(this, input_scanner, parent);
	  if (parent) {
	    this._line_regexp = this._input.get_regexp(parent._line_regexp);
	  } else {
	    this.__set_whitespace_patterns('', '');
	  }

	  this.newline_count = 0;
	  this.whitespace_before_token = '';
	}
	WhitespacePattern.prototype = new Pattern();

	WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
	  whitespace_chars += '\\t ';
	  newline_chars += '\\n\\r';

	  this._match_pattern = this._input.get_regexp(
	    '[' + whitespace_chars + newline_chars + ']+', true);
	  this._newline_regexp = this._input.get_regexp(
	    '\\r\\n|[' + newline_chars + ']');
	};

	WhitespacePattern.prototype.read = function() {
	  this.newline_count = 0;
	  this.whitespace_before_token = '';

	  var resulting_string = this._input.read(this._match_pattern);
	  if (resulting_string === ' ') {
	    this.whitespace_before_token = ' ';
	  } else if (resulting_string) {
	    var matches = this.__split(this._newline_regexp, resulting_string);
	    this.newline_count = matches.length - 1;
	    this.whitespace_before_token = matches[this.newline_count];
	  }

	  return resulting_string;
	};

	WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
	  var result = this._create();
	  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
	  result._update();
	  return result;
	};

	WhitespacePattern.prototype._create = function() {
	  return new WhitespacePattern(this._input, this);
	};

	WhitespacePattern.prototype.__split = function(regexp, input_string) {
	  regexp.lastIndex = 0;
	  var start_index = 0;
	  var result = [];
	  var next_match = regexp.exec(input_string);
	  while (next_match) {
	    result.push(input_string.substring(start_index, next_match.index));
	    start_index = next_match.index + next_match[0].length;
	    next_match = regexp.exec(input_string);
	  }

	  if (start_index < input_string.length) {
	    result.push(input_string.substring(start_index, input_string.length));
	  } else {
	    result.push('');
	  }

	  return result;
	};



	whitespacepattern.WhitespacePattern = WhitespacePattern;
	return whitespacepattern;
}

/*jshint node:true */

var hasRequiredTokenizer$3;

function requireTokenizer$3 () {
	if (hasRequiredTokenizer$3) return tokenizer$1;
	hasRequiredTokenizer$3 = 1;

	var InputScanner = requireInputscanner().InputScanner;
	var Token = requireToken$1().Token;
	var TokenStream = requireTokenstream().TokenStream;
	var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;

	var TOKEN = {
	  START: 'TK_START',
	  RAW: 'TK_RAW',
	  EOF: 'TK_EOF'
	};

	var Tokenizer = function(input_string, options) {
	  this._input = new InputScanner(input_string);
	  this._options = options || {};
	  this.__tokens = null;

	  this._patterns = {};
	  this._patterns.whitespace = new WhitespacePattern(this._input);
	};

	Tokenizer.prototype.tokenize = function() {
	  this._input.restart();
	  this.__tokens = new TokenStream();

	  this._reset();

	  var current;
	  var previous = new Token(TOKEN.START, '');
	  var open_token = null;
	  var open_stack = [];
	  var comments = new TokenStream();

	  while (previous.type !== TOKEN.EOF) {
	    current = this._get_next_token(previous, open_token);
	    while (this._is_comment(current)) {
	      comments.add(current);
	      current = this._get_next_token(previous, open_token);
	    }

	    if (!comments.isEmpty()) {
	      current.comments_before = comments;
	      comments = new TokenStream();
	    }

	    current.parent = open_token;

	    if (this._is_opening(current)) {
	      open_stack.push(open_token);
	      open_token = current;
	    } else if (open_token && this._is_closing(current, open_token)) {
	      current.opened = open_token;
	      open_token.closed = current;
	      open_token = open_stack.pop();
	      current.parent = open_token;
	    }

	    current.previous = previous;
	    previous.next = current;

	    this.__tokens.add(current);
	    previous = current;
	  }

	  return this.__tokens;
	};


	Tokenizer.prototype._is_first_token = function() {
	  return this.__tokens.isEmpty();
	};

	Tokenizer.prototype._reset = function() {};

	Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
	  this._readWhitespace();
	  var resulting_string = this._input.read(/.+/g);
	  if (resulting_string) {
	    return this._create_token(TOKEN.RAW, resulting_string);
	  } else {
	    return this._create_token(TOKEN.EOF, '');
	  }
	};

	Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
	  return false;
	};

	Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
	  return false;
	};

	Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
	  return false;
	};

	Tokenizer.prototype._create_token = function(type, text) {
	  var token = new Token(type, text,
	    this._patterns.whitespace.newline_count,
	    this._patterns.whitespace.whitespace_before_token);
	  return token;
	};

	Tokenizer.prototype._readWhitespace = function() {
	  return this._patterns.whitespace.read();
	};



	tokenizer$1.Tokenizer = Tokenizer;
	tokenizer$1.TOKEN = TOKEN;
	return tokenizer$1;
}

var directives = {};

/*jshint node:true */

var hasRequiredDirectives;

function requireDirectives () {
	if (hasRequiredDirectives) return directives;
	hasRequiredDirectives = 1;

	function Directives(start_block_pattern, end_block_pattern) {
	  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
	  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
	  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
	  this.__directive_pattern = / (\w+)[:](\w+)/g;

	  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
	}

	Directives.prototype.get_directives = function(text) {
	  if (!text.match(this.__directives_block_pattern)) {
	    return null;
	  }

	  var directives = {};
	  this.__directive_pattern.lastIndex = 0;
	  var directive_match = this.__directive_pattern.exec(text);

	  while (directive_match) {
	    directives[directive_match[1]] = directive_match[2];
	    directive_match = this.__directive_pattern.exec(text);
	  }

	  return directives;
	};

	Directives.prototype.readIgnored = function(input) {
	  return input.readUntilAfter(this.__directives_end_ignore_pattern);
	};


	directives.Directives = Directives;
	return directives;
}

var templatablepattern = {};

/*jshint node:true */

var hasRequiredTemplatablepattern;

function requireTemplatablepattern () {
	if (hasRequiredTemplatablepattern) return templatablepattern;
	hasRequiredTemplatablepattern = 1;

	var Pattern = requirePattern().Pattern;


	var template_names = {
	  django: false,
	  erb: false,
	  handlebars: false,
	  php: false,
	  smarty: false,
	  angular: false
	};

	// This lets templates appear anywhere we would do a readUntil
	// The cost is higher but it is pay to play.
	function TemplatablePattern(input_scanner, parent) {
	  Pattern.call(this, input_scanner, parent);
	  this.__template_pattern = null;
	  this._disabled = Object.assign({}, template_names);
	  this._excluded = Object.assign({}, template_names);

	  if (parent) {
	    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
	    this._excluded = Object.assign(this._excluded, parent._excluded);
	    this._disabled = Object.assign(this._disabled, parent._disabled);
	  }
	  var pattern = new Pattern(input_scanner);
	  this.__patterns = {
	    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
	    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
	    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
	    php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
	    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
	    // django coflicts with handlebars a bit.
	    django: pattern.starting_with(/{%/).until_after(/%}/),
	    django_value: pattern.starting_with(/{{/).until_after(/}}/),
	    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
	    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
	    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
	    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
	  };
	}
	TemplatablePattern.prototype = new Pattern();

	TemplatablePattern.prototype._create = function() {
	  return new TemplatablePattern(this._input, this);
	};

	TemplatablePattern.prototype._update = function() {
	  this.__set_templated_pattern();
	};

	TemplatablePattern.prototype.disable = function(language) {
	  var result = this._create();
	  result._disabled[language] = true;
	  result._update();
	  return result;
	};

	TemplatablePattern.prototype.read_options = function(options) {
	  var result = this._create();
	  for (var language in template_names) {
	    result._disabled[language] = options.templating.indexOf(language) === -1;
	  }
	  result._update();
	  return result;
	};

	TemplatablePattern.prototype.exclude = function(language) {
	  var result = this._create();
	  result._excluded[language] = true;
	  result._update();
	  return result;
	};

	TemplatablePattern.prototype.read = function() {
	  var result = '';
	  if (this._match_pattern) {
	    result = this._input.read(this._starting_pattern);
	  } else {
	    result = this._input.read(this._starting_pattern, this.__template_pattern);
	  }
	  var next = this._read_template();
	  while (next) {
	    if (this._match_pattern) {
	      next += this._input.read(this._match_pattern);
	    } else {
	      next += this._input.readUntil(this.__template_pattern);
	    }
	    result += next;
	    next = this._read_template();
	  }

	  if (this._until_after) {
	    result += this._input.readUntilAfter(this._until_pattern);
	  }
	  return result;
	};

	TemplatablePattern.prototype.__set_templated_pattern = function() {
	  var items = [];

	  if (!this._disabled.php) {
	    items.push(this.__patterns.php._starting_pattern.source);
	  }
	  if (!this._disabled.handlebars) {
	    items.push(this.__patterns.handlebars._starting_pattern.source);
	  }
	  if (!this._disabled.angular) {
	    // Handlebars ('{{' and '}}') are also special tokens in Angular)
	    items.push(this.__patterns.handlebars._starting_pattern.source);
	  }
	  if (!this._disabled.erb) {
	    items.push(this.__patterns.erb._starting_pattern.source);
	  }
	  if (!this._disabled.django) {
	    items.push(this.__patterns.django._starting_pattern.source);
	    // The starting pattern for django is more complex because it has different
	    // patterns for value, comment, and other sections
	    items.push(this.__patterns.django_value._starting_pattern.source);
	    items.push(this.__patterns.django_comment._starting_pattern.source);
	  }
	  if (!this._disabled.smarty) {
	    items.push(this.__patterns.smarty._starting_pattern.source);
	  }

	  if (this._until_pattern) {
	    items.push(this._until_pattern.source);
	  }
	  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
	};

	TemplatablePattern.prototype._read_template = function() {
	  var resulting_string = '';
	  var c = this._input.peek();
	  if (c === '<') {
	    var peek1 = this._input.peek(1);
	    //if we're in a comment, do something special
	    // We treat all comments as literals, even more than preformatted tags
	    // we just look for the appropriate close tag
	    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
	      resulting_string = resulting_string ||
	        this.__patterns.php.read();
	    }
	    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
	      resulting_string = resulting_string ||
	        this.__patterns.erb.read();
	    }
	  } else if (c === '{') {
	    if (!this._disabled.handlebars && !this._excluded.handlebars) {
	      resulting_string = resulting_string ||
	        this.__patterns.handlebars_comment.read();
	      resulting_string = resulting_string ||
	        this.__patterns.handlebars_unescaped.read();
	      resulting_string = resulting_string ||
	        this.__patterns.handlebars.read();
	    }
	    if (!this._disabled.django) {
	      // django coflicts with handlebars a bit.
	      if (!this._excluded.django && !this._excluded.handlebars) {
	        resulting_string = resulting_string ||
	          this.__patterns.django_value.read();
	      }
	      if (!this._excluded.django) {
	        resulting_string = resulting_string ||
	          this.__patterns.django_comment.read();
	        resulting_string = resulting_string ||
	          this.__patterns.django.read();
	      }
	    }
	    if (!this._disabled.smarty) {
	      // smarty cannot be enabled with django or handlebars enabled
	      if (this._disabled.django && this._disabled.handlebars) {
	        resulting_string = resulting_string ||
	          this.__patterns.smarty_comment.read();
	        resulting_string = resulting_string ||
	          this.__patterns.smarty_literal.read();
	        resulting_string = resulting_string ||
	          this.__patterns.smarty.read();
	      }
	    }
	  }
	  return resulting_string;
	};


	templatablepattern.TemplatablePattern = TemplatablePattern;
	return templatablepattern;
}

/*jshint node:true */

var hasRequiredTokenizer$2;

function requireTokenizer$2 () {
	if (hasRequiredTokenizer$2) return tokenizer$2;
	hasRequiredTokenizer$2 = 1;

	var InputScanner = requireInputscanner().InputScanner;
	var BaseTokenizer = requireTokenizer$3().Tokenizer;
	var BASETOKEN = requireTokenizer$3().TOKEN;
	var Directives = requireDirectives().Directives;
	var acorn = requireAcorn();
	var Pattern = requirePattern().Pattern;
	var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;


	function in_array(what, arr) {
	  return arr.indexOf(what) !== -1;
	}


	var TOKEN = {
	  START_EXPR: 'TK_START_EXPR',
	  END_EXPR: 'TK_END_EXPR',
	  START_BLOCK: 'TK_START_BLOCK',
	  END_BLOCK: 'TK_END_BLOCK',
	  WORD: 'TK_WORD',
	  RESERVED: 'TK_RESERVED',
	  SEMICOLON: 'TK_SEMICOLON',
	  STRING: 'TK_STRING',
	  EQUALS: 'TK_EQUALS',
	  OPERATOR: 'TK_OPERATOR',
	  COMMA: 'TK_COMMA',
	  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
	  COMMENT: 'TK_COMMENT',
	  DOT: 'TK_DOT',
	  UNKNOWN: 'TK_UNKNOWN',
	  START: BASETOKEN.START,
	  RAW: BASETOKEN.RAW,
	  EOF: BASETOKEN.EOF
	};


	var directives_core = new Directives(/\/\*/, /\*\//);

	var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;

	var digit = /[0-9]/;

	// Dot "." must be distinguished from "..." and decimal
	var dot_pattern = /[^\d\.]/;

	var positionable_operators = (
	  ">>> === !== &&= ??= ||= " +
	  "<< && >= ** != == <= >> || ?? |> " +
	  "< / - + > : & % ? ^ | *").split(' ');

	// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
	// Also, you must update possitionable operators separately from punct
	var punct =
	  ">>>= " +
	  "... >>= <<= === >>> !== **= &&= ??= ||= " +
	  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
	  "= ! ? > < : / ^ - + * & % ~ |";

	punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
	// ?. but not if followed by a number 
	punct = '\\?\\.(?!\\d) ' + punct;
	punct = punct.replace(/ /g, '|');

	var punct_pattern = new RegExp(punct);

	// words which should always start on new line.
	var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
	var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as', 'class', 'extends']);
	var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

	// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

	var in_html_comment;

	var Tokenizer = function(input_string, options) {
	  BaseTokenizer.call(this, input_string, options);

	  this._patterns.whitespace = this._patterns.whitespace.matching(
	    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
	    /\u2028\u2029/.source);

	  var pattern_reader = new Pattern(this._input);
	  var templatable = new TemplatablePattern(this._input)
	    .read_options(this._options);

	  this.__patterns = {
	    template: templatable,
	    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
	    number: pattern_reader.matching(number_pattern),
	    punct: pattern_reader.matching(punct_pattern),
	    // comment ends just before nearest linefeed or end of file
	    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
	    //  /* ... */ comment ends with nearest */ or end of file
	    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
	    html_comment_start: pattern_reader.matching(/<!--/),
	    html_comment_end: pattern_reader.matching(/-->/),
	    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
	    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
	    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
	    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
	    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
	    template_text: templatable.until(/[`\\$]/),
	    template_expression: templatable.until(/[`}\\]/)
	  };

	};
	Tokenizer.prototype = new BaseTokenizer();

	Tokenizer.prototype._is_comment = function(current_token) {
	  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
	};

	Tokenizer.prototype._is_opening = function(current_token) {
	  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
	};

	Tokenizer.prototype._is_closing = function(current_token, open_token) {
	  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&
	    (open_token && (
	      (current_token.text === ']' && open_token.text === '[') ||
	      (current_token.text === ')' && open_token.text === '(') ||
	      (current_token.text === '}' && open_token.text === '{')));
	};

	Tokenizer.prototype._reset = function() {
	  in_html_comment = false;
	};

	Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
	  var token = null;
	  this._readWhitespace();
	  var c = this._input.peek();

	  if (c === null) {
	    return this._create_token(TOKEN.EOF, '');
	  }

	  token = token || this._read_non_javascript(c);
	  token = token || this._read_string(c);
	  token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'
	  token = token || this._read_word(previous_token);
	  token = token || this._read_singles(c);
	  token = token || this._read_comment(c);
	  token = token || this._read_regexp(c, previous_token);
	  token = token || this._read_xml(c, previous_token);
	  token = token || this._read_punctuation();
	  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

	  return token;
	};

	Tokenizer.prototype._read_word = function(previous_token) {
	  var resulting_string;
	  resulting_string = this.__patterns.identifier.read();
	  if (resulting_string !== '') {
	    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
	    if (!(previous_token.type === TOKEN.DOT ||
	        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
	      reserved_word_pattern.test(resulting_string)) {
	      if ((resulting_string === 'in' || resulting_string === 'of') &&
	        (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) { // hack for 'in' and 'of' operators
	        return this._create_token(TOKEN.OPERATOR, resulting_string);
	      }
	      return this._create_token(TOKEN.RESERVED, resulting_string);
	    }
	    return this._create_token(TOKEN.WORD, resulting_string);
	  }

	  resulting_string = this.__patterns.number.read();
	  if (resulting_string !== '') {
	    return this._create_token(TOKEN.WORD, resulting_string);
	  }
	};

	Tokenizer.prototype._read_singles = function(c) {
	  var token = null;
	  if (c === '(' || c === '[') {
	    token = this._create_token(TOKEN.START_EXPR, c);
	  } else if (c === ')' || c === ']') {
	    token = this._create_token(TOKEN.END_EXPR, c);
	  } else if (c === '{') {
	    token = this._create_token(TOKEN.START_BLOCK, c);
	  } else if (c === '}') {
	    token = this._create_token(TOKEN.END_BLOCK, c);
	  } else if (c === ';') {
	    token = this._create_token(TOKEN.SEMICOLON, c);
	  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
	    token = this._create_token(TOKEN.DOT, c);
	  } else if (c === ',') {
	    token = this._create_token(TOKEN.COMMA, c);
	  }

	  if (token) {
	    this._input.next();
	  }
	  return token;
	};

	Tokenizer.prototype._read_pair = function(c, d) {
	  var token = null;
	  if (c === '#' && d === '{') {
	    token = this._create_token(TOKEN.START_BLOCK, c + d);
	  }

	  if (token) {
	    this._input.next();
	    this._input.next();
	  }
	  return token;
	};

	Tokenizer.prototype._read_punctuation = function() {
	  var resulting_string = this.__patterns.punct.read();

	  if (resulting_string !== '') {
	    if (resulting_string === '=') {
	      return this._create_token(TOKEN.EQUALS, resulting_string);
	    } else if (resulting_string === '?.') {
	      return this._create_token(TOKEN.DOT, resulting_string);
	    } else {
	      return this._create_token(TOKEN.OPERATOR, resulting_string);
	    }
	  }
	};

	Tokenizer.prototype._read_non_javascript = function(c) {
	  var resulting_string = '';

	  if (c === '#') {
	    if (this._is_first_token()) {
	      resulting_string = this.__patterns.shebang.read();

	      if (resulting_string) {
	        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
	      }
	    }

	    // handles extendscript #includes
	    resulting_string = this.__patterns.include.read();

	    if (resulting_string) {
	      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
	    }

	    c = this._input.next();

	    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
	    var sharp = '#';
	    if (this._input.hasNext() && this._input.testChar(digit)) {
	      do {
	        c = this._input.next();
	        sharp += c;
	      } while (this._input.hasNext() && c !== '#' && c !== '=');
	      if (c === '#') ; else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
	        sharp += '[]';
	        this._input.next();
	        this._input.next();
	      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
	        sharp += '{}';
	        this._input.next();
	        this._input.next();
	      }
	      return this._create_token(TOKEN.WORD, sharp);
	    }

	    this._input.back();

	  } else if (c === '<' && this._is_first_token()) {
	    resulting_string = this.__patterns.html_comment_start.read();
	    if (resulting_string) {
	      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
	        resulting_string += this._input.next();
	      }
	      in_html_comment = true;
	      return this._create_token(TOKEN.COMMENT, resulting_string);
	    }
	  } else if (in_html_comment && c === '-') {
	    resulting_string = this.__patterns.html_comment_end.read();
	    if (resulting_string) {
	      in_html_comment = false;
	      return this._create_token(TOKEN.COMMENT, resulting_string);
	    }
	  }

	  return null;
	};

	Tokenizer.prototype._read_comment = function(c) {
	  var token = null;
	  if (c === '/') {
	    var comment = '';
	    if (this._input.peek(1) === '*') {
	      // peek for comment /* ... */
	      comment = this.__patterns.block_comment.read();
	      var directives = directives_core.get_directives(comment);
	      if (directives && directives.ignore === 'start') {
	        comment += directives_core.readIgnored(this._input);
	      }
	      comment = comment.replace(acorn.allLineBreaks, '\n');
	      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
	      token.directives = directives;
	    } else if (this._input.peek(1) === '/') {
	      // peek for comment // ...
	      comment = this.__patterns.comment.read();
	      token = this._create_token(TOKEN.COMMENT, comment);
	    }
	  }
	  return token;
	};

	Tokenizer.prototype._read_string = function(c) {
	  if (c === '`' || c === "'" || c === '"') {
	    var resulting_string = this._input.next();
	    this.has_char_escapes = false;

	    if (c === '`') {
	      resulting_string += this._read_string_recursive('`', true, '${');
	    } else {
	      resulting_string += this._read_string_recursive(c);
	    }

	    if (this.has_char_escapes && this._options.unescape_strings) {
	      resulting_string = unescape_string(resulting_string);
	    }

	    if (this._input.peek() === c) {
	      resulting_string += this._input.next();
	    }

	    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

	    return this._create_token(TOKEN.STRING, resulting_string);
	  }

	  return null;
	};

	Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
	  // regex and xml can only appear in specific locations during parsing
	  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
	    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&
	      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
	    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,
	      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA
	    ]));
	};

	Tokenizer.prototype._read_regexp = function(c, previous_token) {

	  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
	    // handle regexp
	    //
	    var resulting_string = this._input.next();
	    var esc = false;

	    var in_char_class = false;
	    while (this._input.hasNext() &&
	      ((esc || in_char_class || this._input.peek() !== c) &&
	        !this._input.testChar(acorn.newline))) {
	      resulting_string += this._input.peek();
	      if (!esc) {
	        esc = this._input.peek() === '\\';
	        if (this._input.peek() === '[') {
	          in_char_class = true;
	        } else if (this._input.peek() === ']') {
	          in_char_class = false;
	        }
	      } else {
	        esc = false;
	      }
	      this._input.next();
	    }

	    if (this._input.peek() === c) {
	      resulting_string += this._input.next();

	      // regexps may have modifiers /regexp/MOD , so fetch those, too
	      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
	      resulting_string += this._input.read(acorn.identifier);
	    }
	    return this._create_token(TOKEN.STRING, resulting_string);
	  }
	  return null;
	};

	Tokenizer.prototype._read_xml = function(c, previous_token) {

	  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
	    var xmlStr = '';
	    var match = this.__patterns.xml.read_match();
	    // handle e4x xml literals
	    //
	    if (match) {
	      // Trim root tag to attempt to
	      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
	      var isCurlyRoot = rootTag.indexOf('{') === 0;
	      var depth = 0;
	      while (match) {
	        var isEndTag = !!match[1];
	        var tagName = match[2];
	        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
	        if (!isSingletonTag &&
	          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
	          if (isEndTag) {
	            --depth;
	          } else {
	            ++depth;
	          }
	        }
	        xmlStr += match[0];
	        if (depth <= 0) {
	          break;
	        }
	        match = this.__patterns.xml.read_match();
	      }
	      // if we didn't close correctly, keep unformatted.
	      if (!match) {
	        xmlStr += this._input.match(/[\s\S]*/g)[0];
	      }
	      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
	      return this._create_token(TOKEN.STRING, xmlStr);
	    }
	  }

	  return null;
	};

	function unescape_string(s) {
	  // You think that a regex would work for this
	  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
	  //         return String.fromCharCode(parseInt(val, 16));
	  //     })
	  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
	  var out = '',
	    escaped = 0;

	  var input_scan = new InputScanner(s);
	  var matched = null;

	  while (input_scan.hasNext()) {
	    // Keep any whitespace, non-slash characters
	    // also keep slash pairs.
	    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

	    if (matched) {
	      out += matched[0];
	    }

	    if (input_scan.peek() === '\\') {
	      input_scan.next();
	      if (input_scan.peek() === 'x') {
	        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
	      } else if (input_scan.peek() === 'u') {
	        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
	        if (!matched) {
	          matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
	        }
	      } else {
	        out += '\\';
	        if (input_scan.hasNext()) {
	          out += input_scan.next();
	        }
	        continue;
	      }

	      // If there's some error decoding, return the original string
	      if (!matched) {
	        return s;
	      }

	      escaped = parseInt(matched[1], 16);

	      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
	        // we bail out on \x7f..\xff,
	        // leaving whole string escaped,
	        // as it's probably completely binary
	        return s;
	      } else if (escaped >= 0x00 && escaped < 0x20) {
	        // leave 0x00...0x1f escaped
	        out += '\\' + matched[0];
	      } else if (escaped > 0x10FFFF) {
	        // If the escape sequence is out of bounds, keep the original sequence and continue conversion
	        out += '\\' + matched[0];
	      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	        // single-quote, apostrophe, backslash - escape these
	        out += '\\' + String.fromCharCode(escaped);
	      } else {
	        out += String.fromCharCode(escaped);
	      }
	    }
	  }

	  return out;
	}

	// handle string
	//
	Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
	  var current_char;
	  var pattern;
	  if (delimiter === '\'') {
	    pattern = this.__patterns.single_quote;
	  } else if (delimiter === '"') {
	    pattern = this.__patterns.double_quote;
	  } else if (delimiter === '`') {
	    pattern = this.__patterns.template_text;
	  } else if (delimiter === '}') {
	    pattern = this.__patterns.template_expression;
	  }

	  var resulting_string = pattern.read();
	  var next = '';
	  while (this._input.hasNext()) {
	    next = this._input.next();
	    if (next === delimiter ||
	      (!allow_unescaped_newlines && acorn.newline.test(next))) {
	      this._input.back();
	      break;
	    } else if (next === '\\' && this._input.hasNext()) {
	      current_char = this._input.peek();

	      if (current_char === 'x' || current_char === 'u') {
	        this.has_char_escapes = true;
	      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
	        this._input.next();
	      }
	      next += this._input.next();
	    } else if (start_sub) {
	      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
	        next += this._input.next();
	      }

	      if (start_sub === next) {
	        if (delimiter === '`') {
	          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
	        } else {
	          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
	        }
	        if (this._input.hasNext()) {
	          next += this._input.next();
	        }
	      }
	    }
	    next += pattern.read();
	    resulting_string += next;
	  }

	  return resulting_string;
	};

	tokenizer$2.Tokenizer = Tokenizer;
	tokenizer$2.TOKEN = TOKEN;
	tokenizer$2.positionable_operators = positionable_operators.slice();
	tokenizer$2.line_starters = line_starters.slice();
	return tokenizer$2;
}

/*jshint node:true */

var hasRequiredBeautifier$2;

function requireBeautifier$2 () {
	if (hasRequiredBeautifier$2) return beautifier$2;
	hasRequiredBeautifier$2 = 1;

	var Output = requireOutput().Output;
	var Token = requireToken$1().Token;
	var acorn = requireAcorn();
	var Options = requireOptions$3().Options;
	var Tokenizer = requireTokenizer$2().Tokenizer;
	var line_starters = requireTokenizer$2().line_starters;
	var positionable_operators = requireTokenizer$2().positionable_operators;
	var TOKEN = requireTokenizer$2().TOKEN;


	function in_array(what, arr) {
	  return arr.indexOf(what) !== -1;
	}

	function ltrim(s) {
	  return s.replace(/^\s+/g, '');
	}

	function generateMapFromStrings(list) {
	  var result = {};
	  for (var x = 0; x < list.length; x++) {
	    // make the mapped names underscored instead of dash
	    result[list[x].replace(/-/g, '_')] = list[x];
	  }
	  return result;
	}

	function reserved_word(token, word) {
	  return token && token.type === TOKEN.RESERVED && token.text === word;
	}

	function reserved_array(token, words) {
	  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
	}
	// Unsure of what they mean, but they work. Worth cleaning up in future.
	var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

	var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

	// Generate map from array
	var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

	var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

	var MODE = {
	  BlockStatement: 'BlockStatement', // 'BLOCK'
	  Statement: 'Statement', // 'STATEMENT'
	  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	  Conditional: 'Conditional', //'(COND-EXPRESSION)',
	  Expression: 'Expression' //'(EXPRESSION)'
	};

	function remove_redundant_indentation(output, frame) {
	  // This implementation is effective but has some issues:
	  //     - can cause line wrap to happen too soon due to indent removal
	  //           after wrap points are calculated
	  // These issues are minor compared to ugly indentation.

	  if (frame.multiline_frame ||
	    frame.mode === MODE.ForInitializer ||
	    frame.mode === MODE.Conditional) {
	    return;
	  }

	  // remove one indent from each line inside this section
	  output.remove_indent(frame.start_line_index);
	}

	// we could use just string.split, but
	// IE doesn't like returning empty strings
	function split_linebreaks(s) {
	  //return s.split(/\x0d\x0a|\x0a/);

	  s = s.replace(acorn.allLineBreaks, '\n');
	  var out = [],
	    idx = s.indexOf("\n");
	  while (idx !== -1) {
	    out.push(s.substring(0, idx));
	    s = s.substring(idx + 1);
	    idx = s.indexOf("\n");
	  }
	  if (s.length) {
	    out.push(s);
	  }
	  return out;
	}

	function is_array(mode) {
	  return mode === MODE.ArrayLiteral;
	}

	function is_expression(mode) {
	  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	}

	function all_lines_start_with(lines, c) {
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i].trim();
	    if (line.charAt(0) !== c) {
	      return false;
	    }
	  }
	  return true;
	}

	function each_line_matches_indent(lines, indent) {
	  var i = 0,
	    len = lines.length,
	    line;
	  for (; i < len; i++) {
	    line = lines[i];
	    // allow empty lines to pass through
	    if (line && line.indexOf(indent) !== 0) {
	      return false;
	    }
	  }
	  return true;
	}


	function Beautifier(source_text, options) {
	  options = options || {};
	  this._source_text = source_text || '';

	  this._output = null;
	  this._tokens = null;
	  this._last_last_text = null;
	  this._flags = null;
	  this._previous_flags = null;

	  this._flag_store = null;
	  this._options = new Options(options);
	}

	Beautifier.prototype.create_flags = function(flags_base, mode) {
	  var next_indent_level = 0;
	  if (flags_base) {
	    next_indent_level = flags_base.indentation_level;
	    if (!this._output.just_added_newline() &&
	      flags_base.line_indent_level > next_indent_level) {
	      next_indent_level = flags_base.line_indent_level;
	    }
	  }

	  var next_flags = {
	    mode: mode,
	    parent: flags_base,
	    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text
	    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
	    declaration_statement: false,
	    declaration_assignment: false,
	    multiline_frame: false,
	    inline_frame: false,
	    if_block: false,
	    else_block: false,
	    class_start_block: false, // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
	    do_block: false,
	    do_while: false,
	    import_block: false,
	    in_case_statement: false, // switch(..){ INSIDE HERE }
	    in_case: false, // we're on the exact line with "case 0:"
	    case_body: false, // the indented case-action block
	    case_block: false, // the indented case-action block is wrapped with {}
	    indentation_level: next_indent_level,
	    alignment: 0,
	    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	    start_line_index: this._output.get_line_number(),
	    ternary_depth: 0
	  };
	  return next_flags;
	};

	Beautifier.prototype._reset = function(source_text) {
	  var baseIndentString = source_text.match(/^[\t ]*/)[0];

	  this._last_last_text = ''; // pre-last token text
	  this._output = new Output(this._options, baseIndentString);

	  // If testing the ignore directive, start with output disable set to true
	  this._output.raw = this._options.test_output_raw;


	  // Stack of parsing/formatting states, including MODE.
	  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	  // and formatted output.  This makes the beautifier less accurate than full parsers
	  // but also far more tolerant of syntax errors.
	  //
	  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	  // most full parsers would die, but the beautifier gracefully falls back to
	  // MODE.BlockStatement and continues on.
	  this._flag_store = [];
	  this.set_mode(MODE.BlockStatement);
	  var tokenizer = new Tokenizer(source_text, this._options);
	  this._tokens = tokenizer.tokenize();
	  return source_text;
	};

	Beautifier.prototype.beautify = function() {
	  // if disabled, return the input unchanged.
	  if (this._options.disabled) {
	    return this._source_text;
	  }

	  var sweet_code;
	  var source_text = this._reset(this._source_text);

	  var eol = this._options.eol;
	  if (this._options.eol === 'auto') {
	    eol = '\n';
	    if (source_text && acorn.lineBreak.test(source_text || '')) {
	      eol = source_text.match(acorn.lineBreak)[0];
	    }
	  }

	  var current_token = this._tokens.next();
	  while (current_token) {
	    this.handle_token(current_token);

	    this._last_last_text = this._flags.last_token.text;
	    this._flags.last_token = current_token;

	    current_token = this._tokens.next();
	  }

	  sweet_code = this._output.get_code(eol);

	  return sweet_code;
	};

	Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
	  if (current_token.type === TOKEN.START_EXPR) {
	    this.handle_start_expr(current_token);
	  } else if (current_token.type === TOKEN.END_EXPR) {
	    this.handle_end_expr(current_token);
	  } else if (current_token.type === TOKEN.START_BLOCK) {
	    this.handle_start_block(current_token);
	  } else if (current_token.type === TOKEN.END_BLOCK) {
	    this.handle_end_block(current_token);
	  } else if (current_token.type === TOKEN.WORD) {
	    this.handle_word(current_token);
	  } else if (current_token.type === TOKEN.RESERVED) {
	    this.handle_word(current_token);
	  } else if (current_token.type === TOKEN.SEMICOLON) {
	    this.handle_semicolon(current_token);
	  } else if (current_token.type === TOKEN.STRING) {
	    this.handle_string(current_token);
	  } else if (current_token.type === TOKEN.EQUALS) {
	    this.handle_equals(current_token);
	  } else if (current_token.type === TOKEN.OPERATOR) {
	    this.handle_operator(current_token);
	  } else if (current_token.type === TOKEN.COMMA) {
	    this.handle_comma(current_token);
	  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
	    this.handle_block_comment(current_token, preserve_statement_flags);
	  } else if (current_token.type === TOKEN.COMMENT) {
	    this.handle_comment(current_token, preserve_statement_flags);
	  } else if (current_token.type === TOKEN.DOT) {
	    this.handle_dot(current_token);
	  } else if (current_token.type === TOKEN.EOF) {
	    this.handle_eof(current_token);
	  } else if (current_token.type === TOKEN.UNKNOWN) {
	    this.handle_unknown(current_token, preserve_statement_flags);
	  } else {
	    this.handle_unknown(current_token, preserve_statement_flags);
	  }
	};

	Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
	  var newlines = current_token.newlines;
	  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

	  if (current_token.comments_before) {
	    var comment_token = current_token.comments_before.next();
	    while (comment_token) {
	      // The cleanest handling of inline comments is to treat them as though they aren't there.
	      // Just continue formatting and the behavior should be logical.
	      // Also ignore unknown tokens.  Again, this should result in better behavior.
	      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
	      this.handle_token(comment_token, preserve_statement_flags);
	      comment_token = current_token.comments_before.next();
	    }
	  }

	  if (keep_whitespace) {
	    for (var i = 0; i < newlines; i += 1) {
	      this.print_newline(i > 0, preserve_statement_flags);
	    }
	  } else {
	    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
	      newlines = this._options.max_preserve_newlines;
	    }

	    if (this._options.preserve_newlines) {
	      if (newlines > 1) {
	        this.print_newline(false, preserve_statement_flags);
	        for (var j = 1; j < newlines; j += 1) {
	          this.print_newline(true, preserve_statement_flags);
	        }
	      }
	    }
	  }

	};

	var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

	Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
	  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

	  // Never wrap the first token on a line
	  if (this._output.just_added_newline()) {
	    return;
	  }

	  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
	  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||
	    in_array(current_token.text, positionable_operators);

	  if (operatorLogicApplies) {
	    var shouldPrintOperatorNewline = (
	        in_array(this._flags.last_token.text, positionable_operators) &&
	        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
	      ) ||
	      in_array(current_token.text, positionable_operators);
	    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
	  }

	  if (shouldPreserveOrForce) {
	    this.print_newline(false, true);
	  } else if (this._options.wrap_line_length) {
	    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
	      // These tokens should never have a newline inserted
	      // between them and the following expression.
	      return;
	    }
	    this._output.set_wrap_point();
	  }
	};

	Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
	  if (!preserve_statement_flags) {
	    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
	      var next_token = this._tokens.peek();
	      while (this._flags.mode === MODE.Statement &&
	        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
	        !this._flags.do_block) {
	        this.restore_mode();
	      }
	    }
	  }

	  if (this._output.add_new_line(force_newline)) {
	    this._flags.multiline_frame = true;
	  }
	};

	Beautifier.prototype.print_token_line_indentation = function(current_token) {
	  if (this._output.just_added_newline()) {
	    if (this._options.keep_array_indentation &&
	      current_token.newlines &&
	      (current_token.text === '[' || is_array(this._flags.mode))) {
	      this._output.current_line.set_indent(-1);
	      this._output.current_line.push(current_token.whitespace_before);
	      this._output.space_before_token = false;
	    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
	      this._flags.line_indent_level = this._flags.indentation_level;
	    }
	  }
	};

	Beautifier.prototype.print_token = function(current_token) {
	  if (this._output.raw) {
	    this._output.add_raw_token(current_token);
	    return;
	  }

	  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&
	    this._output.just_added_newline()) {
	    if (this._output.previous_line.last() === ',') {
	      var popped = this._output.previous_line.pop();
	      // if the comma was already at the start of the line,
	      // pull back onto that line and reprint the indentation
	      if (this._output.previous_line.is_empty()) {
	        this._output.previous_line.push(popped);
	        this._output.trim(true);
	        this._output.current_line.pop();
	        this._output.trim();
	      }

	      // add the comma in front of the next token
	      this.print_token_line_indentation(current_token);
	      this._output.add_token(',');
	      this._output.space_before_token = true;
	    }
	  }

	  this.print_token_line_indentation(current_token);
	  this._output.non_breaking_space = true;
	  this._output.add_token(current_token.text);
	  if (this._output.previous_token_wrapped) {
	    this._flags.multiline_frame = true;
	  }
	};

	Beautifier.prototype.indent = function() {
	  this._flags.indentation_level += 1;
	  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
	};

	Beautifier.prototype.deindent = function() {
	  if (this._flags.indentation_level > 0 &&
	    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
	    this._flags.indentation_level -= 1;
	    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
	  }
	};

	Beautifier.prototype.set_mode = function(mode) {
	  if (this._flags) {
	    this._flag_store.push(this._flags);
	    this._previous_flags = this._flags;
	  } else {
	    this._previous_flags = this.create_flags(null, mode);
	  }

	  this._flags = this.create_flags(this._previous_flags, mode);
	  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
	};


	Beautifier.prototype.restore_mode = function() {
	  if (this._flag_store.length > 0) {
	    this._previous_flags = this._flags;
	    this._flags = this._flag_store.pop();
	    if (this._previous_flags.mode === MODE.Statement) {
	      remove_redundant_indentation(this._output, this._previous_flags);
	    }
	    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
	  }
	};

	Beautifier.prototype.start_of_object_property = function() {
	  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
	    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
	};

	Beautifier.prototype.start_of_statement = function(current_token) {
	  var start = false;
	  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;
	  start = start || reserved_word(this._flags.last_token, 'do');
	  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
	  start = start || reserved_word(this._flags.last_token, 'else') &&
	    !(reserved_word(current_token, 'if') && !current_token.comments_before);
	  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
	  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&
	    !this._flags.in_case &&
	    !(current_token.text === '--' || current_token.text === '++') &&
	    this._last_last_text !== 'function' &&
	    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);
	  start = start || (this._flags.mode === MODE.ObjectLiteral && (
	    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

	  if (start) {
	    this.set_mode(MODE.Statement);
	    this.indent();

	    this.handle_whitespace_and_comments(current_token, true);

	    // Issue #276:
	    // If starting a new statement with [if, for, while, do], push to a new line.
	    // if (a) if (b) if(c) d(); else e(); else f();
	    if (!this.start_of_object_property()) {
	      this.allow_wrap_or_preserved_newline(current_token,
	        reserved_array(current_token, ['do', 'for', 'if', 'while']));
	    }
	    return true;
	  }
	  return false;
	};

	Beautifier.prototype.handle_start_expr = function(current_token) {
	  // The conditional starts the statement if appropriate.
	  if (!this.start_of_statement(current_token)) {
	    this.handle_whitespace_and_comments(current_token);
	  }

	  var next_mode = MODE.Expression;
	  if (current_token.text === '[') {

	    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {
	      // this is array index specifier, break immediately
	      // a[x], fn()[x]
	      if (reserved_array(this._flags.last_token, line_starters)) {
	        this._output.space_before_token = true;
	      }
	      this.print_token(current_token);
	      this.set_mode(next_mode);
	      this.indent();
	      if (this._options.space_in_paren) {
	        this._output.space_before_token = true;
	      }
	      return;
	    }

	    next_mode = MODE.ArrayLiteral;
	    if (is_array(this._flags.mode)) {
	      if (this._flags.last_token.text === '[' ||
	        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
	        // ], [ goes to new line
	        // }, [ goes to new line
	        if (!this._options.keep_array_indentation) {
	          this.print_newline();
	        }
	      }
	    }

	    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
	      this._output.space_before_token = true;
	    }
	  } else {
	    if (this._flags.last_token.type === TOKEN.RESERVED) {
	      if (this._flags.last_token.text === 'for') {
	        this._output.space_before_token = this._options.space_before_conditional;
	        next_mode = MODE.ForInitializer;
	      } else if (in_array(this._flags.last_token.text, ['if', 'while', 'switch'])) {
	        this._output.space_before_token = this._options.space_before_conditional;
	        next_mode = MODE.Conditional;
	      } else if (in_array(this._flags.last_word, ['await', 'async'])) {
	        // Should be a space between await and an IIFE, or async and an arrow function
	        this._output.space_before_token = true;
	      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
	        this._output.space_before_token = false;
	      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {
	        this._output.space_before_token = true;
	      }
	    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
	      // Support of this kind of newline preservation.
	      // a = (b &&
	      //     (c || d));
	      if (!this.start_of_object_property()) {
	        this.allow_wrap_or_preserved_newline(current_token);
	      }
	    } else if (this._flags.last_token.type === TOKEN.WORD) {
	      this._output.space_before_token = false;

	      // function name() vs function name ()
	      // function* name() vs function* name ()
	      // async name() vs async name ()
	      // In ES6, you can also define the method properties of an object
	      // var obj = {a: function() {}}
	      // It can be abbreviated
	      // var obj = {a() {}}
	      // var obj = { a() {}} vs var obj = { a () {}}
	      // var obj = { * a() {}} vs var obj = { * a () {}}
	      var peek_back_two = this._tokens.peek(-3);
	      if (this._options.space_after_named_function && peek_back_two) {
	        // peek starts at next character so -1 is current token
	        var peek_back_three = this._tokens.peek(-4);
	        if (reserved_array(peek_back_two, ['async', 'function']) ||
	          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
	          this._output.space_before_token = true;
	        } else if (this._flags.mode === MODE.ObjectLiteral) {
	          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
	            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
	            this._output.space_before_token = true;
	          }
	        } else if (this._flags.parent && this._flags.parent.class_start_block) {
	          this._output.space_before_token = true;
	        }
	      }
	    } else {
	      // Support preserving wrapped arrow function expressions
	      // a.b('c',
	      //     () => d.e
	      // )
	      this.allow_wrap_or_preserved_newline(current_token);
	    }

	    // function() vs function ()
	    // yield*() vs yield* ()
	    // function*() vs function* ()
	    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
	      (this._flags.last_token.text === '*' &&
	        (in_array(this._last_last_text, ['function', 'yield']) ||
	          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
	      this._output.space_before_token = this._options.space_after_anon_function;
	    }
	  }

	  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {
	    this.print_newline();
	  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {
	    // do nothing on (( and )( and ][ and ]( and .(
	    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
	  }

	  this.print_token(current_token);
	  this.set_mode(next_mode);
	  if (this._options.space_in_paren) {
	    this._output.space_before_token = true;
	  }

	  // In all cases, if we newline while inside an expression it should be indented.
	  this.indent();
	};

	Beautifier.prototype.handle_end_expr = function(current_token) {
	  // statements inside expressions are not valid syntax, but...
	  // statements must all be closed when their container closes
	  while (this._flags.mode === MODE.Statement) {
	    this.restore_mode();
	  }

	  this.handle_whitespace_and_comments(current_token);

	  if (this._flags.multiline_frame) {
	    this.allow_wrap_or_preserved_newline(current_token,
	      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
	  }

	  if (this._options.space_in_paren) {
	    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
	      // () [] no inner space in empty parens like these, ever, ref #320
	      this._output.trim();
	      this._output.space_before_token = false;
	    } else {
	      this._output.space_before_token = true;
	    }
	  }
	  this.deindent();
	  this.print_token(current_token);
	  this.restore_mode();

	  remove_redundant_indentation(this._output, this._previous_flags);

	  // do {} while () // no statement required after
	  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
	    this._previous_flags.mode = MODE.Expression;
	    this._flags.do_block = false;
	    this._flags.do_while = false;

	  }
	};

	Beautifier.prototype.handle_start_block = function(current_token) {
	  this.handle_whitespace_and_comments(current_token);

	  // Check if this is should be treated as a ObjectLiteral
	  var next_token = this._tokens.peek();
	  var second_token = this._tokens.peek(1);
	  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {
	    this.set_mode(MODE.BlockStatement);
	    this._flags.in_case_statement = true;
	  } else if (this._flags.case_body) {
	    this.set_mode(MODE.BlockStatement);
	  } else if (second_token && (
	      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||
	      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))
	    )) {
	    // We don't support TypeScript,but we didn't break it for a very long time.
	    // We'll try to keep not breaking it.
	    if (in_array(this._last_last_text, ['class', 'interface']) && !in_array(second_token.text, [':', ','])) {
	      this.set_mode(MODE.BlockStatement);
	    } else {
	      this.set_mode(MODE.ObjectLiteral);
	    }
	  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {
	    // arrow function: (param1, paramN) => { statements }
	    this.set_mode(MODE.BlockStatement);
	  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||
	    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
	  ) {
	    // Detecting shorthand function syntax is difficult by scanning forward,
	    //     so check the surrounding context.
	    // If the block is being returned, imported, export default, passed as arg,
	    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
	    this.set_mode(MODE.ObjectLiteral);
	  } else {
	    this.set_mode(MODE.BlockStatement);
	  }

	  if (this._flags.last_token) {
	    if (reserved_array(this._flags.last_token.previous, ['class', 'extends'])) {
	      this._flags.class_start_block = true;
	    }
	  }

	  var empty_braces = !next_token.comments_before && next_token.text === '}';
	  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
	    this._flags.last_token.type === TOKEN.END_EXPR;

	  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
	  {
	    // search forward for a newline wanted inside this block
	    var index = 0;
	    var check_token = null;
	    this._flags.inline_frame = true;
	    do {
	      index += 1;
	      check_token = this._tokens.peek(index - 1);
	      if (check_token.newlines) {
	        this._flags.inline_frame = false;
	        break;
	      }
	    } while (check_token.type !== TOKEN.EOF &&
	      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
	  }

	  if ((this._options.brace_style === "expand" ||
	      (this._options.brace_style === "none" && current_token.newlines)) &&
	    !this._flags.inline_frame) {
	    if (this._flags.last_token.type !== TOKEN.OPERATOR &&
	      (empty_anonymous_function ||
	        this._flags.last_token.type === TOKEN.EQUALS ||
	        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
	      this._output.space_before_token = true;
	    } else {
	      this.print_newline(false, true);
	    }
	  } else { // collapse || inline_frame
	    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
	      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
	        this._output.space_before_token = true;
	      }

	      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {
	        this.allow_wrap_or_preserved_newline(current_token);
	        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
	        this._flags.multiline_frame = false;
	      }
	    }
	    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
	      if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
	        this.print_newline();
	      } else {
	        this._output.space_before_token = true;
	      }
	    }
	  }
	  this.print_token(current_token);
	  this.indent();

	  // Except for specific cases, open braces are followed by a new line.
	  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
	    this.print_newline();
	  }
	};

	Beautifier.prototype.handle_end_block = function(current_token) {
	  // statements must all be closed when their container closes
	  this.handle_whitespace_and_comments(current_token);

	  while (this._flags.mode === MODE.Statement) {
	    this.restore_mode();
	  }

	  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;

	  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
	    this._output.space_before_token = true;
	  } else if (this._options.brace_style === "expand") {
	    if (!empty_braces) {
	      this.print_newline();
	    }
	  } else {
	    // skip {}
	    if (!empty_braces) {
	      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
	        // we REALLY need a newline here, but newliner would skip that
	        this._options.keep_array_indentation = false;
	        this.print_newline();
	        this._options.keep_array_indentation = true;

	      } else {
	        this.print_newline();
	      }
	    }
	  }
	  this.restore_mode();
	  this.print_token(current_token);
	};

	Beautifier.prototype.handle_word = function(current_token) {
	  if (current_token.type === TOKEN.RESERVED) {
	    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
	      current_token.type = TOKEN.WORD;
	    } else if (current_token.text === 'import' && in_array(this._tokens.peek().text, ['(', '.'])) {
	      current_token.type = TOKEN.WORD;
	    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {
	      current_token.type = TOKEN.WORD;
	    } else if (this._flags.mode === MODE.ObjectLiteral) {
	      var next_token = this._tokens.peek();
	      if (next_token.text === ':') {
	        current_token.type = TOKEN.WORD;
	      }
	    }
	  }

	  if (this.start_of_statement(current_token)) {
	    // The conditional starts the statement if appropriate.
	    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {
	      this._flags.declaration_statement = true;
	    }
	  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
	    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
	    this._flags.last_token.type !== TOKEN.EQUALS &&
	    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
	    this.handle_whitespace_and_comments(current_token);
	    this.print_newline();
	  } else {
	    this.handle_whitespace_and_comments(current_token);
	  }

	  if (this._flags.do_block && !this._flags.do_while) {
	    if (reserved_word(current_token, 'while')) {
	      // do {} ## while ()
	      this._output.space_before_token = true;
	      this.print_token(current_token);
	      this._output.space_before_token = true;
	      this._flags.do_while = true;
	      return;
	    } else {
	      // do {} should always have while as the next word.
	      // if we don't see the expected while, recover
	      this.print_newline();
	      this._flags.do_block = false;
	    }
	  }

	  // if may be followed by else, or not
	  // Bare/inline ifs are tricky
	  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	  if (this._flags.if_block) {
	    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
	      this._flags.else_block = true;
	    } else {
	      while (this._flags.mode === MODE.Statement) {
	        this.restore_mode();
	      }
	      this._flags.if_block = false;
	      this._flags.else_block = false;
	    }
	  }

	  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
	    this.print_newline();
	    if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
	      // switch cases following one another
	      this.deindent();
	    }
	    this._flags.case_body = false;

	    this.print_token(current_token);
	    this._flags.in_case = true;
	    return;
	  }

	  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
	    if (!this.start_of_object_property() && !(
	        // start of object property is different for numeric values with +/- prefix operators
	        in_array(this._flags.last_token.text, ['+', '-']) && this._last_last_text === ':' && this._flags.parent.mode === MODE.ObjectLiteral)) {
	      this.allow_wrap_or_preserved_newline(current_token);
	    }
	  }

	  if (reserved_word(current_token, 'function')) {
	    if (in_array(this._flags.last_token.text, ['}', ';']) ||
	      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {
	      // make sure there is a nice clean space of at least one blank line
	      // before a new function definition
	      if (!this._output.just_added_blankline() && !current_token.comments_before) {
	        this.print_newline();
	        this.print_newline(true);
	      }
	    }
	    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
	      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
	        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
	        this._output.space_before_token = true;
	      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
	        this._output.space_before_token = true;
	      } else if (this._flags.last_token.text === 'declare') {
	        // accomodates Typescript declare function formatting
	        this._output.space_before_token = true;
	      } else {
	        this.print_newline();
	      }
	    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {
	      // foo = function
	      this._output.space_before_token = true;
	    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ; else {
	      this.print_newline();
	    }

	    this.print_token(current_token);
	    this._flags.last_word = current_token.text;
	    return;
	  }

	  var prefix = 'NONE';

	  if (this._flags.last_token.type === TOKEN.END_BLOCK) {

	    if (this._previous_flags.inline_frame) {
	      prefix = 'SPACE';
	    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
	      prefix = 'NEWLINE';
	    } else {
	      if (this._options.brace_style === "expand" ||
	        this._options.brace_style === "end-expand" ||
	        (this._options.brace_style === "none" && current_token.newlines)) {
	        prefix = 'NEWLINE';
	      } else {
	        prefix = 'SPACE';
	        this._output.space_before_token = true;
	      }
	    }
	  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
	    // TODO: Should this be for STATEMENT as well?
	    prefix = 'NEWLINE';
	  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
	    prefix = 'SPACE';
	  } else if (this._flags.last_token.type === TOKEN.STRING) {
	    prefix = 'NEWLINE';
	  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||
	    (this._flags.last_token.text === '*' &&
	      (in_array(this._last_last_text, ['function', 'yield']) ||
	        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
	    prefix = 'SPACE';
	  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
	    if (this._flags.inline_frame) {
	      prefix = 'SPACE';
	    } else {
	      prefix = 'NEWLINE';
	    }
	  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
	    this._output.space_before_token = true;
	    prefix = 'NEWLINE';
	  }

	  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
	    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
	      prefix = 'SPACE';
	    } else {
	      prefix = 'NEWLINE';
	    }

	  }

	  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
	    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
	        this._options.brace_style === "expand" ||
	        this._options.brace_style === "end-expand" ||
	        (this._options.brace_style === "none" && current_token.newlines)) &&
	      !this._flags.inline_frame) {
	      this.print_newline();
	    } else {
	      this._output.trim(true);
	      var line = this._output.current_line;
	      // If we trimmed and there's something other than a close block before us
	      // put a newline back in.  Handles '} // comment' scenario.
	      if (line.last() !== '}') {
	        this.print_newline();
	      }
	      this._output.space_before_token = true;
	    }
	  } else if (prefix === 'NEWLINE') {
	    if (reserved_array(this._flags.last_token, special_words)) {
	      // no newline between 'return nnn'
	      this._output.space_before_token = true;
	    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
	      // accomodates Typescript declare formatting
	      this._output.space_before_token = true;
	    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
	      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
	        // no need to force newline on 'var': for (var x = 0...)
	        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
	          // no newline for } else if {
	          this._output.space_before_token = true;
	        } else {
	          this.print_newline();
	        }
	      }
	    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
	      this.print_newline();
	    }
	  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
	    this.print_newline(); // }, in lists get a newline treatment
	  } else if (prefix === 'SPACE') {
	    this._output.space_before_token = true;
	  }
	  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
	    this._output.space_before_token = true;
	  }
	  this.print_token(current_token);
	  this._flags.last_word = current_token.text;

	  if (current_token.type === TOKEN.RESERVED) {
	    if (current_token.text === 'do') {
	      this._flags.do_block = true;
	    } else if (current_token.text === 'if') {
	      this._flags.if_block = true;
	    } else if (current_token.text === 'import') {
	      this._flags.import_block = true;
	    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
	      this._flags.import_block = false;
	    }
	  }
	};

	Beautifier.prototype.handle_semicolon = function(current_token) {
	  if (this.start_of_statement(current_token)) {
	    // The conditional starts the statement if appropriate.
	    // Semicolon can be the start (and end) of a statement
	    this._output.space_before_token = false;
	  } else {
	    this.handle_whitespace_and_comments(current_token);
	  }

	  var next_token = this._tokens.peek();
	  while (this._flags.mode === MODE.Statement &&
	    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
	    !this._flags.do_block) {
	    this.restore_mode();
	  }

	  // hacky but effective for the moment
	  if (this._flags.import_block) {
	    this._flags.import_block = false;
	  }
	  this.print_token(current_token);
	};

	Beautifier.prototype.handle_string = function(current_token) {
	  if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === '' && (current_token.previous.text === ')' || this._flags.last_token.type === TOKEN.WORD)) ; else if (this.start_of_statement(current_token)) {
	    // The conditional starts the statement if appropriate.
	    // One difference - strings want at least a space before
	    this._output.space_before_token = true;
	  } else {
	    this.handle_whitespace_and_comments(current_token);
	    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
	      this._output.space_before_token = true;
	    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
	      if (!this.start_of_object_property()) {
	        this.allow_wrap_or_preserved_newline(current_token);
	      }
	    } else if ((current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === ']' || current_token.previous.text === ')') && current_token.newlines === 0)) {
	      this._output.space_before_token = true;
	    } else {
	      this.print_newline();
	    }
	  }
	  this.print_token(current_token);
	};

	Beautifier.prototype.handle_equals = function(current_token) {
	  if (this.start_of_statement(current_token)) ; else {
	    this.handle_whitespace_and_comments(current_token);
	  }

	  if (this._flags.declaration_statement) {
	    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	    this._flags.declaration_assignment = true;
	  }
	  this._output.space_before_token = true;
	  this.print_token(current_token);
	  this._output.space_before_token = true;
	};

	Beautifier.prototype.handle_comma = function(current_token) {
	  this.handle_whitespace_and_comments(current_token, true);

	  this.print_token(current_token);
	  this._output.space_before_token = true;
	  if (this._flags.declaration_statement) {
	    if (is_expression(this._flags.parent.mode)) {
	      // do not break on comma, for(var a = 1, b = 2)
	      this._flags.declaration_assignment = false;
	    }

	    if (this._flags.declaration_assignment) {
	      this._flags.declaration_assignment = false;
	      this.print_newline(false, true);
	    } else if (this._options.comma_first) {
	      // for comma-first, we want to allow a newline before the comma
	      // to turn into a newline after the comma, which we will fixup later
	      this.allow_wrap_or_preserved_newline(current_token);
	    }
	  } else if (this._flags.mode === MODE.ObjectLiteral ||
	    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
	    if (this._flags.mode === MODE.Statement) {
	      this.restore_mode();
	    }

	    if (!this._flags.inline_frame) {
	      this.print_newline();
	    }
	  } else if (this._options.comma_first) {
	    // EXPR or DO_BLOCK
	    // for comma-first, we want to allow a newline before the comma
	    // to turn into a newline after the comma, which we will fixup later
	    this.allow_wrap_or_preserved_newline(current_token);
	  }
	};

	Beautifier.prototype.handle_operator = function(current_token) {
	  var isGeneratorAsterisk = current_token.text === '*' &&
	    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
	      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))
	    );
	  var isUnary = in_array(current_token.text, ['-', '+']) && (
	    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||
	    in_array(this._flags.last_token.text, line_starters) ||
	    this._flags.last_token.text === ','
	  );

	  if (this.start_of_statement(current_token)) ; else {
	    var preserve_statement_flags = !isGeneratorAsterisk;
	    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
	  }

	  // hack for actionscript's import .*;
	  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {
	    this.print_token(current_token);
	    return;
	  }

	  if (current_token.text === '::') {
	    // no spaces around exotic namespacing syntax operator
	    this.print_token(current_token);
	    return;
	  }

	  if (in_array(current_token.text, ['-', '+']) && this.start_of_object_property()) {
	    // numeric value with +/- symbol in front as a property
	    this.print_token(current_token);
	    return;
	  }

	  // Allow line wrapping between operators when operator_position is
	  //   set to before or preserve
	  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
	    this.allow_wrap_or_preserved_newline(current_token);
	  }

	  if (current_token.text === ':' && this._flags.in_case) {
	    this.print_token(current_token);

	    this._flags.in_case = false;
	    this._flags.case_body = true;
	    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
	      this.indent();
	      this.print_newline();
	      this._flags.case_block = false;
	    } else {
	      this._flags.case_block = true;
	      this._output.space_before_token = true;
	    }
	    return;
	  }

	  var space_before = true;
	  var space_after = true;
	  var in_ternary = false;
	  if (current_token.text === ':') {
	    if (this._flags.ternary_depth === 0) {
	      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
	      space_before = false;
	    } else {
	      this._flags.ternary_depth -= 1;
	      in_ternary = true;
	    }
	  } else if (current_token.text === '?') {
	    this._flags.ternary_depth += 1;
	  }

	  // let's handle the operator_position option prior to any conflicting logic
	  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
	    var isColon = current_token.text === ':';
	    var isTernaryColon = (isColon && in_ternary);
	    var isOtherColon = (isColon && !in_ternary);

	    switch (this._options.operator_position) {
	      case OPERATOR_POSITION.before_newline:
	        // if the current token is : and it's not a ternary statement then we set space_before to false
	        this._output.space_before_token = !isOtherColon;

	        this.print_token(current_token);

	        if (!isColon || isTernaryColon) {
	          this.allow_wrap_or_preserved_newline(current_token);
	        }

	        this._output.space_before_token = true;
	        return;

	      case OPERATOR_POSITION.after_newline:
	        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
	        //   then print a newline.

	        this._output.space_before_token = true;

	        if (!isColon || isTernaryColon) {
	          if (this._tokens.peek().newlines) {
	            this.print_newline(false, true);
	          } else {
	            this.allow_wrap_or_preserved_newline(current_token);
	          }
	        } else {
	          this._output.space_before_token = false;
	        }

	        this.print_token(current_token);

	        this._output.space_before_token = true;
	        return;

	      case OPERATOR_POSITION.preserve_newline:
	        if (!isOtherColon) {
	          this.allow_wrap_or_preserved_newline(current_token);
	        }

	        // if we just added a newline, or the current token is : and it's not a ternary statement,
	        //   then we set space_before to false
	        space_before = !(this._output.just_added_newline() || isOtherColon);

	        this._output.space_before_token = space_before;
	        this.print_token(current_token);
	        this._output.space_before_token = true;
	        return;
	    }
	  }

	  if (isGeneratorAsterisk) {
	    this.allow_wrap_or_preserved_newline(current_token);
	    space_before = false;
	    var next_token = this._tokens.peek();
	    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
	  } else if (current_token.text === '...') {
	    this.allow_wrap_or_preserved_newline(current_token);
	    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
	    space_after = false;
	  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
	    // unary operators (and binary +/- pretending to be unary) special cases
	    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
	      this.allow_wrap_or_preserved_newline(current_token);
	    }

	    space_before = false;
	    space_after = false;

	    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	    // if there is a newline between -- or ++ and anything else we should preserve it.
	    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++' || current_token.text === '~')) {
	      var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
	      if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
	        this.restore_mode();
	      }
	      this.print_newline(new_line_needed, true);
	    }

	    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
	      // for (;; ++i)
	      //        ^^^
	      space_before = true;
	    }

	    if (this._flags.last_token.type === TOKEN.RESERVED) {
	      space_before = true;
	    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
	      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
	    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
	      // a++ + ++b;
	      // a - -b
	      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);
	      // + and - are not unary when preceeded by -- or ++ operator
	      // a-- + b
	      // a * +b
	      // a - -b
	      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {
	        space_after = true;
	      }
	    }


	    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
	      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
	      // { foo; --i }
	      // foo(); --bar;
	      this.print_newline();
	    }
	  }

	  this._output.space_before_token = this._output.space_before_token || space_before;
	  this.print_token(current_token);
	  this._output.space_before_token = space_after;
	};

	Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
	  if (this._output.raw) {
	    this._output.add_raw_token(current_token);
	    if (current_token.directives && current_token.directives.preserve === 'end') {
	      // If we're testing the raw output behavior, do not allow a directive to turn it off.
	      this._output.raw = this._options.test_output_raw;
	    }
	    return;
	  }

	  if (current_token.directives) {
	    this.print_newline(false, preserve_statement_flags);
	    this.print_token(current_token);
	    if (current_token.directives.preserve === 'start') {
	      this._output.raw = true;
	    }
	    this.print_newline(false, true);
	    return;
	  }

	  // inline block
	  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
	    this._output.space_before_token = true;
	    this.print_token(current_token);
	    this._output.space_before_token = true;
	    return;
	  } else {
	    this.print_block_commment(current_token, preserve_statement_flags);
	  }
	};

	Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
	  var lines = split_linebreaks(current_token.text);
	  var j; // iterator for this case
	  var javadoc = false;
	  var starless = false;
	  var lastIndent = current_token.whitespace_before;
	  var lastIndentLength = lastIndent.length;

	  // block comment starts with a new line
	  this.print_newline(false, preserve_statement_flags);

	  // first line always indented
	  this.print_token_line_indentation(current_token);
	  this._output.add_token(lines[0]);
	  this.print_newline(false, preserve_statement_flags);


	  if (lines.length > 1) {
	    lines = lines.slice(1);
	    javadoc = all_lines_start_with(lines, '*');
	    starless = each_line_matches_indent(lines, lastIndent);

	    if (javadoc) {
	      this._flags.alignment = 1;
	    }

	    for (j = 0; j < lines.length; j++) {
	      if (javadoc) {
	        // javadoc: reformat and re-indent
	        this.print_token_line_indentation(current_token);
	        this._output.add_token(ltrim(lines[j]));
	      } else if (starless && lines[j]) {
	        // starless: re-indent non-empty content, avoiding trim
	        this.print_token_line_indentation(current_token);
	        this._output.add_token(lines[j].substring(lastIndentLength));
	      } else {
	        // normal comments output raw
	        this._output.current_line.set_indent(-1);
	        this._output.add_token(lines[j]);
	      }

	      // for comments on their own line or  more than one line, make sure there's a new line after
	      this.print_newline(false, preserve_statement_flags);
	    }

	    this._flags.alignment = 0;
	  }
	};


	Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
	  if (current_token.newlines) {
	    this.print_newline(false, preserve_statement_flags);
	  } else {
	    this._output.trim(true);
	  }

	  this._output.space_before_token = true;
	  this.print_token(current_token);
	  this.print_newline(false, preserve_statement_flags);
	};

	Beautifier.prototype.handle_dot = function(current_token) {
	  if (this.start_of_statement(current_token)) ; else {
	    this.handle_whitespace_and_comments(current_token, true);
	  }

	  if (this._flags.last_token.text.match('^[0-9]+$')) {
	    this._output.space_before_token = true;
	  }

	  if (reserved_array(this._flags.last_token, special_words)) {
	    this._output.space_before_token = false;
	  } else {
	    // allow preserved newlines before dots in general
	    // force newlines on dots after close paren when break_chained - for bar().baz()
	    this.allow_wrap_or_preserved_newline(current_token,
	      this._flags.last_token.text === ')' && this._options.break_chained_methods);
	  }

	  // Only unindent chained method dot if this dot starts a new line.
	  // Otherwise the automatic extra indentation removal will handle the over indent
	  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
	    this.deindent();
	  }

	  this.print_token(current_token);
	};

	Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
	  this.print_token(current_token);

	  if (current_token.text[current_token.text.length - 1] === '\n') {
	    this.print_newline(false, preserve_statement_flags);
	  }
	};

	Beautifier.prototype.handle_eof = function(current_token) {
	  // Unwind any open statements
	  while (this._flags.mode === MODE.Statement) {
	    this.restore_mode();
	  }
	  this.handle_whitespace_and_comments(current_token);
	};

	beautifier$2.Beautifier = Beautifier;
	return beautifier$2;
}

/*jshint node:true */

var hasRequiredJavascript;

function requireJavascript () {
	if (hasRequiredJavascript) return javascript.exports;
	hasRequiredJavascript = 1;

	var Beautifier = requireBeautifier$2().Beautifier,
	  Options = requireOptions$3().Options;

	function js_beautify(js_source_text, options) {
	  var beautifier = new Beautifier(js_source_text, options);
	  return beautifier.beautify();
	}

	javascript.exports = js_beautify;
	javascript.exports.defaultOptions = function() {
	  return new Options();
	};
	return javascript.exports;
}

var css = {exports: {}};

var beautifier$1 = {};

var options$2 = {};

/*jshint node:true */

var hasRequiredOptions$2;

function requireOptions$2 () {
	if (hasRequiredOptions$2) return options$2;
	hasRequiredOptions$2 = 1;

	var BaseOptions = requireOptions$4().Options;

	function Options(options) {
	  BaseOptions.call(this, options, 'css');

	  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
	  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
	  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
	  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

	  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
	  this.brace_style = 'collapse';
	  for (var bs = 0; bs < brace_style_split.length; bs++) {
	    if (brace_style_split[bs] !== 'expand') {
	      // default to collapse, as only collapse|expand is implemented for now
	      this.brace_style = 'collapse';
	    } else {
	      this.brace_style = brace_style_split[bs];
	    }
	  }
	}
	Options.prototype = new BaseOptions();



	options$2.Options = Options;
	return options$2;
}

/*jshint node:true */

var hasRequiredBeautifier$1;

function requireBeautifier$1 () {
	if (hasRequiredBeautifier$1) return beautifier$1;
	hasRequiredBeautifier$1 = 1;

	var Options = requireOptions$2().Options;
	var Output = requireOutput().Output;
	var InputScanner = requireInputscanner().InputScanner;
	var Directives = requireDirectives().Directives;

	var directives_core = new Directives(/\/\*/, /\*\//);

	var lineBreak = /\r\n|[\r\n]/;
	var allLineBreaks = /\r\n|[\r\n]/g;

	// tokenizer
	var whitespaceChar = /\s/;
	var whitespacePattern = /(?:\s|\n)+/g;
	var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
	var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

	function Beautifier(source_text, options) {
	  this._source_text = source_text || '';
	  // Allow the setting of language/file-type specific options
	  // with inheritance of overall settings
	  this._options = new Options(options);
	  this._ch = null;
	  this._input = null;

	  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	  this.NESTED_AT_RULE = {
	    "page": true,
	    "font-face": true,
	    "keyframes": true,
	    // also in CONDITIONAL_GROUP_RULE below
	    "media": true,
	    "supports": true,
	    "document": true
	  };
	  this.CONDITIONAL_GROUP_RULE = {
	    "media": true,
	    "supports": true,
	    "document": true
	  };
	  this.NON_SEMICOLON_NEWLINE_PROPERTY = [
	    "grid-template-areas",
	    "grid-template"
	  ];

	}

	Beautifier.prototype.eatString = function(endChars) {
	  var result = '';
	  this._ch = this._input.next();
	  while (this._ch) {
	    result += this._ch;
	    if (this._ch === "\\") {
	      result += this._input.next();
	    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
	      break;
	    }
	    this._ch = this._input.next();
	  }
	  return result;
	};

	// Skips any white space in the source text from the current position.
	// When allowAtLeastOneNewLine is true, will output new lines for each
	// newline character found; if the user has preserve_newlines off, only
	// the first newline will be output
	Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
	  var result = whitespaceChar.test(this._input.peek());
	  var newline_count = 0;
	  while (whitespaceChar.test(this._input.peek())) {
	    this._ch = this._input.next();
	    if (allowAtLeastOneNewLine && this._ch === '\n') {
	      if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
	        newline_count++;
	        this._output.add_new_line(true);
	      }
	    }
	  }
	  return result;
	};

	// Nested pseudo-class if we are insideRule
	// and the next special character found opens
	// a new block
	Beautifier.prototype.foundNestedPseudoClass = function() {
	  var openParen = 0;
	  var i = 1;
	  var ch = this._input.peek(i);
	  while (ch) {
	    if (ch === "{") {
	      return true;
	    } else if (ch === '(') {
	      // pseudoclasses can contain ()
	      openParen += 1;
	    } else if (ch === ')') {
	      if (openParen === 0) {
	        return false;
	      }
	      openParen -= 1;
	    } else if (ch === ";" || ch === "}") {
	      return false;
	    }
	    i++;
	    ch = this._input.peek(i);
	  }
	  return false;
	};

	Beautifier.prototype.print_string = function(output_string) {
	  this._output.set_indent(this._indentLevel);
	  this._output.non_breaking_space = true;
	  this._output.add_token(output_string);
	};

	Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
	  if (isAfterSpace) {
	    this._output.space_before_token = true;
	  }
	};

	Beautifier.prototype.indent = function() {
	  this._indentLevel++;
	};

	Beautifier.prototype.outdent = function() {
	  if (this._indentLevel > 0) {
	    this._indentLevel--;
	  }
	};

	/*_____________________--------------------_____________________*/

	Beautifier.prototype.beautify = function() {
	  if (this._options.disabled) {
	    return this._source_text;
	  }

	  var source_text = this._source_text;
	  var eol = this._options.eol;
	  if (eol === 'auto') {
	    eol = '\n';
	    if (source_text && lineBreak.test(source_text || '')) {
	      eol = source_text.match(lineBreak)[0];
	    }
	  }


	  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
	  source_text = source_text.replace(allLineBreaks, '\n');

	  // reset
	  var baseIndentString = source_text.match(/^[\t ]*/)[0];

	  this._output = new Output(this._options, baseIndentString);
	  this._input = new InputScanner(source_text);
	  this._indentLevel = 0;
	  this._nestedLevel = 0;

	  this._ch = null;
	  var parenLevel = 0;

	  var insideRule = false;
	  // This is the value side of a property value pair (blue in the following ex)
	  // label { content: blue }
	  var insidePropertyValue = false;
	  var enteringConditionalGroup = false;
	  var insideNonNestedAtRule = false;
	  var insideScssMap = false;
	  var topCharacter = this._ch;
	  var insideNonSemiColonValues = false;
	  var whitespace;
	  var isAfterSpace;
	  var previous_ch;

	  while (true) {
	    whitespace = this._input.read(whitespacePattern);
	    isAfterSpace = whitespace !== '';
	    previous_ch = topCharacter;
	    this._ch = this._input.next();
	    if (this._ch === '\\' && this._input.hasNext()) {
	      this._ch += this._input.next();
	    }
	    topCharacter = this._ch;

	    if (!this._ch) {
	      break;
	    } else if (this._ch === '/' && this._input.peek() === '*') {
	      // /* css comment */
	      // Always start block comments on a new line.
	      // This handles scenarios where a block comment immediately
	      // follows a property definition on the same line or where
	      // minified code is being beautified.
	      this._output.add_new_line();
	      this._input.back();

	      var comment = this._input.read(block_comment_pattern);

	      // Handle ignore directive
	      var directives = directives_core.get_directives(comment);
	      if (directives && directives.ignore === 'start') {
	        comment += directives_core.readIgnored(this._input);
	      }

	      this.print_string(comment);

	      // Ensures any new lines following the comment are preserved
	      this.eatWhitespace(true);

	      // Block comments are followed by a new line so they don't
	      // share a line with other properties
	      this._output.add_new_line();
	    } else if (this._ch === '/' && this._input.peek() === '/') {
	      // // single line comment
	      // Preserves the space before a comment
	      // on the same line as a rule
	      this._output.space_before_token = true;
	      this._input.back();
	      this.print_string(this._input.read(comment_pattern));

	      // Ensures any new lines following the comment are preserved
	      this.eatWhitespace(true);
	    } else if (this._ch === '$') {
	      this.preserveSingleSpace(isAfterSpace);

	      this.print_string(this._ch);

	      // strip trailing space, if present, for hash property checks
	      var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

	      if (variable.match(/[ :]$/)) {
	        // we have a variable or pseudo-class, add it and insert one space before continuing
	        variable = this.eatString(": ").replace(/\s+$/, '');
	        this.print_string(variable);
	        this._output.space_before_token = true;
	      }

	      // might be sass variable
	      if (parenLevel === 0 && variable.indexOf(':') !== -1) {
	        insidePropertyValue = true;
	        this.indent();
	      }
	    } else if (this._ch === '@') {
	      this.preserveSingleSpace(isAfterSpace);

	      // deal with less property mixins @{...}
	      if (this._input.peek() === '{') {
	        this.print_string(this._ch + this.eatString('}'));
	      } else {
	        this.print_string(this._ch);

	        // strip trailing space, if present, for hash property checks
	        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

	        if (variableOrRule.match(/[ :]$/)) {
	          // we have a variable or pseudo-class, add it and insert one space before continuing
	          variableOrRule = this.eatString(": ").replace(/\s+$/, '');
	          this.print_string(variableOrRule);
	          this._output.space_before_token = true;
	        }

	        // might be less variable
	        if (parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
	          insidePropertyValue = true;
	          this.indent();

	          // might be a nesting at-rule
	        } else if (variableOrRule in this.NESTED_AT_RULE) {
	          this._nestedLevel += 1;
	          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
	            enteringConditionalGroup = true;
	          }

	          // might be a non-nested at-rule
	        } else if (parenLevel === 0 && !insidePropertyValue) {
	          insideNonNestedAtRule = true;
	        }
	      }
	    } else if (this._ch === '#' && this._input.peek() === '{') {
	      this.preserveSingleSpace(isAfterSpace);
	      this.print_string(this._ch + this.eatString('}'));
	    } else if (this._ch === '{') {
	      if (insidePropertyValue) {
	        insidePropertyValue = false;
	        this.outdent();
	      }

	      // non nested at rule becomes nested
	      insideNonNestedAtRule = false;

	      // when entering conditional groups, only rulesets are allowed
	      if (enteringConditionalGroup) {
	        enteringConditionalGroup = false;
	        insideRule = (this._indentLevel >= this._nestedLevel);
	      } else {
	        // otherwise, declarations are also allowed
	        insideRule = (this._indentLevel >= this._nestedLevel - 1);
	      }
	      if (this._options.newline_between_rules && insideRule) {
	        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
	          this._output.ensure_empty_line_above('/', ',');
	        }
	      }

	      this._output.space_before_token = true;

	      // The difference in print_string and indent order is necessary to indent the '{' correctly
	      if (this._options.brace_style === 'expand') {
	        this._output.add_new_line();
	        this.print_string(this._ch);
	        this.indent();
	        this._output.set_indent(this._indentLevel);
	      } else {
	        // inside mixin and first param is object
	        if (previous_ch === '(') {
	          this._output.space_before_token = false;
	        } else if (previous_ch !== ',') {
	          this.indent();
	        }
	        this.print_string(this._ch);
	      }

	      this.eatWhitespace(true);
	      this._output.add_new_line();
	    } else if (this._ch === '}') {
	      this.outdent();
	      this._output.add_new_line();
	      if (previous_ch === '{') {
	        this._output.trim(true);
	      }

	      if (insidePropertyValue) {
	        this.outdent();
	        insidePropertyValue = false;
	      }
	      this.print_string(this._ch);
	      insideRule = false;
	      if (this._nestedLevel) {
	        this._nestedLevel--;
	      }

	      this.eatWhitespace(true);
	      this._output.add_new_line();

	      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
	        if (this._input.peek() !== '}') {
	          this._output.add_new_line(true);
	        }
	      }
	      if (this._input.peek() === ')') {
	        this._output.trim(true);
	        if (this._options.brace_style === "expand") {
	          this._output.add_new_line(true);
	        }
	      }
	    } else if (this._ch === ":") {

	      for (var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
	        if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
	          insideNonSemiColonValues = true;
	          break;
	        }
	      }

	      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
	        // 'property: value' delimiter
	        // which could be in a conditional group query

	        this.print_string(':');
	        if (!insidePropertyValue) {
	          insidePropertyValue = true;
	          this._output.space_before_token = true;
	          this.eatWhitespace(true);
	          this.indent();
	        }
	      } else {
	        // sass/less parent reference don't use a space
	        // sass nested pseudo-class don't use a space

	        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
	        if (this._input.lookBack(" ")) {
	          this._output.space_before_token = true;
	        }
	        if (this._input.peek() === ":") {
	          // pseudo-element
	          this._ch = this._input.next();
	          this.print_string("::");
	        } else {
	          // pseudo-class
	          this.print_string(':');
	        }
	      }
	    } else if (this._ch === '"' || this._ch === '\'') {
	      var preserveQuoteSpace = previous_ch === '"' || previous_ch === '\'';
	      this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
	      this.print_string(this._ch + this.eatString(this._ch));
	      this.eatWhitespace(true);
	    } else if (this._ch === ';') {
	      insideNonSemiColonValues = false;
	      if (parenLevel === 0) {
	        if (insidePropertyValue) {
	          this.outdent();
	          insidePropertyValue = false;
	        }
	        insideNonNestedAtRule = false;
	        this.print_string(this._ch);
	        this.eatWhitespace(true);

	        // This maintains single line comments on the same
	        // line. Block comments are also affected, but
	        // a new line is always output before one inside
	        // that section
	        if (this._input.peek() !== '/') {
	          this._output.add_new_line();
	        }
	      } else {
	        this.print_string(this._ch);
	        this.eatWhitespace(true);
	        this._output.space_before_token = true;
	      }
	    } else if (this._ch === '(') { // may be a url
	      if (this._input.lookBack("url")) {
	        this.print_string(this._ch);
	        this.eatWhitespace();
	        parenLevel++;
	        this.indent();
	        this._ch = this._input.next();
	        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
	          this._input.back();
	        } else if (this._ch) {
	          this.print_string(this._ch + this.eatString(')'));
	          if (parenLevel) {
	            parenLevel--;
	            this.outdent();
	          }
	        }
	      } else {
	        var space_needed = false;
	        if (this._input.lookBack("with")) {
	          // look back is not an accurate solution, we need tokens to confirm without whitespaces
	          space_needed = true;
	        }
	        this.preserveSingleSpace(isAfterSpace || space_needed);
	        this.print_string(this._ch);

	        // handle scss/sass map
	        if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
	          this._output.add_new_line();
	          insideScssMap = true;
	        } else {
	          this.eatWhitespace();
	          parenLevel++;
	          this.indent();
	        }
	      }
	    } else if (this._ch === ')') {
	      if (parenLevel) {
	        parenLevel--;
	        this.outdent();
	      }
	      if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
	        insideScssMap = false;
	        this.outdent();
	        this._output.add_new_line();
	      }
	      this.print_string(this._ch);
	    } else if (this._ch === ',') {
	      this.print_string(this._ch);
	      this.eatWhitespace(true);
	      if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
	        this._output.add_new_line();
	      } else {
	        this._output.space_before_token = true;
	      }
	    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
	      //handle combinator spacing
	      if (this._options.space_around_combinator) {
	        this._output.space_before_token = true;
	        this.print_string(this._ch);
	        this._output.space_before_token = true;
	      } else {
	        this.print_string(this._ch);
	        this.eatWhitespace();
	        // squash extra whitespace
	        if (this._ch && whitespaceChar.test(this._ch)) {
	          this._ch = '';
	        }
	      }
	    } else if (this._ch === ']') {
	      this.print_string(this._ch);
	    } else if (this._ch === '[') {
	      this.preserveSingleSpace(isAfterSpace);
	      this.print_string(this._ch);
	    } else if (this._ch === '=') { // no whitespace before or after
	      this.eatWhitespace();
	      this.print_string('=');
	      if (whitespaceChar.test(this._ch)) {
	        this._ch = '';
	      }
	    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
	      this._output.space_before_token = true;
	      this.print_string(this._ch);
	    } else {
	      var preserveAfterSpace = previous_ch === '"' || previous_ch === '\'';
	      this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
	      this.print_string(this._ch);

	      if (!this._output.just_added_newline() && this._input.peek() === '\n' && insideNonSemiColonValues) {
	        this._output.add_new_line();
	      }
	    }
	  }

	  var sweetCode = this._output.get_code(eol);

	  return sweetCode;
	};

	beautifier$1.Beautifier = Beautifier;
	return beautifier$1;
}

/*jshint node:true */

var hasRequiredCss;

function requireCss () {
	if (hasRequiredCss) return css.exports;
	hasRequiredCss = 1;

	var Beautifier = requireBeautifier$1().Beautifier,
	  Options = requireOptions$2().Options;

	function css_beautify(source_text, options) {
	  var beautifier = new Beautifier(source_text, options);
	  return beautifier.beautify();
	}

	css.exports = css_beautify;
	css.exports.defaultOptions = function() {
	  return new Options();
	};
	return css.exports;
}

var html = {exports: {}};

var beautifier = {};

var options$1 = {};

/*jshint node:true */

var hasRequiredOptions$1;

function requireOptions$1 () {
	if (hasRequiredOptions$1) return options$1;
	hasRequiredOptions$1 = 1;

	var BaseOptions = requireOptions$4().Options;

	function Options(options) {
	  BaseOptions.call(this, options, 'html');
	  if (this.templating.length === 1 && this.templating[0] === 'auto') {
	    this.templating = ['django', 'erb', 'handlebars', 'php'];
	  }

	  this.indent_inner_html = this._get_boolean('indent_inner_html');
	  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
	  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

	  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
	  this.wrap_attributes = this._get_selection('wrap_attributes',
	    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
	  this.wrap_attributes_min_attrs = this._get_number('wrap_attributes_min_attrs', 2);
	  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
	  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

	  // Block vs inline elements
	  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
	  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
	  // https://www.w3.org/TR/html5/dom.html#phrasing-content
	  this.inline = this._get_array('inline', [
	    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
	    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
	    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
	    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
	    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
	    'video', 'wbr', 'text',
	    // obsolete inline tags
	    'acronym', 'big', 'strike', 'tt'
	  ]);
	  this.inline_custom_elements = this._get_boolean('inline_custom_elements', true);
	  this.void_elements = this._get_array('void_elements', [
	    // HTLM void elements - aka self-closing tags - aka singletons
	    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
	    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
	    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
	    // NOTE: Optional tags are too complex for a simple list
	    // they are hard coded in _do_optional_end_element

	    // Doctype and xml elements
	    '!doctype', '?xml',

	    // obsolete tags
	    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
	    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
	    'basefont', 'isindex'
	  ]);
	  this.unformatted = this._get_array('unformatted', []);
	  this.content_unformatted = this._get_array('content_unformatted', [
	    'pre', 'textarea'
	  ]);
	  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
	  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

	}
	Options.prototype = new BaseOptions();



	options$1.Options = Options;
	return options$1;
}

var tokenizer = {};

/*jshint node:true */

var hasRequiredTokenizer$1;

function requireTokenizer$1 () {
	if (hasRequiredTokenizer$1) return tokenizer;
	hasRequiredTokenizer$1 = 1;

	var BaseTokenizer = requireTokenizer$3().Tokenizer;
	var BASETOKEN = requireTokenizer$3().TOKEN;
	var Directives = requireDirectives().Directives;
	var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
	var Pattern = requirePattern().Pattern;

	var TOKEN = {
	  TAG_OPEN: 'TK_TAG_OPEN',
	  TAG_CLOSE: 'TK_TAG_CLOSE',
	  CONTROL_FLOW_OPEN: 'TK_CONTROL_FLOW_OPEN',
	  CONTROL_FLOW_CLOSE: 'TK_CONTROL_FLOW_CLOSE',
	  ATTRIBUTE: 'TK_ATTRIBUTE',
	  EQUALS: 'TK_EQUALS',
	  VALUE: 'TK_VALUE',
	  COMMENT: 'TK_COMMENT',
	  TEXT: 'TK_TEXT',
	  UNKNOWN: 'TK_UNKNOWN',
	  START: BASETOKEN.START,
	  RAW: BASETOKEN.RAW,
	  EOF: BASETOKEN.EOF
	};

	var directives_core = new Directives(/<\!--/, /-->/);

	var Tokenizer = function(input_string, options) {
	  BaseTokenizer.call(this, input_string, options);
	  this._current_tag_name = '';

	  // Words end at whitespace or when a tag starts
	  // if we are indenting handlebars, they are considered tags
	  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
	  var pattern_reader = new Pattern(this._input);

	  this.__patterns = {
	    word: templatable_reader.until(/[\n\r\t <]/),
	    word_control_flow_close_excluded: templatable_reader.until(/[\n\r\t <}]/),
	    single_quote: templatable_reader.until_after(/'/),
	    double_quote: templatable_reader.until_after(/"/),
	    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
	    element_name: templatable_reader.until(/[\n\r\t >\/]/),

	    angular_control_flow_start: pattern_reader.matching(/\@[a-zA-Z]+[^({]*[({]/),
	    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
	    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
	    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
	    handlebars_raw_close: pattern_reader.until(/}}/),
	    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
	    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
	    // https://en.wikipedia.org/wiki/Conditional_comment
	    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
	    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
	  };

	  if (this._options.indent_handlebars) {
	    this.__patterns.word = this.__patterns.word.exclude('handlebars');
	    this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude('handlebars');
	  }

	  this._unformatted_content_delimiter = null;

	  if (this._options.unformatted_content_delimiter) {
	    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
	    this.__patterns.unformatted_content_delimiter =
	      pattern_reader.matching(literal_regexp)
	      .until_after(literal_regexp);
	  }
	};
	Tokenizer.prototype = new BaseTokenizer();

	Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
	  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
	};

	Tokenizer.prototype._is_opening = function(current_token) {
	  return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;
	};

	Tokenizer.prototype._is_closing = function(current_token, open_token) {
	  return (current_token.type === TOKEN.TAG_CLOSE &&
	    (open_token && (
	      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
	      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')))
	  ) || (current_token.type === TOKEN.CONTROL_FLOW_CLOSE &&
	    (current_token.text === '}' && open_token.text.endsWith('{')));
	};

	Tokenizer.prototype._reset = function() {
	  this._current_tag_name = '';
	};

	Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
	  var token = null;
	  this._readWhitespace();
	  var c = this._input.peek();

	  if (c === null) {
	    return this._create_token(TOKEN.EOF, '');
	  }

	  token = token || this._read_open_handlebars(c, open_token);
	  token = token || this._read_attribute(c, previous_token, open_token);
	  token = token || this._read_close(c, open_token);
	  token = token || this._read_script_and_style(c, previous_token);
	  token = token || this._read_control_flows(c, open_token);
	  token = token || this._read_raw_content(c, previous_token, open_token);
	  token = token || this._read_content_word(c, open_token);
	  token = token || this._read_comment_or_cdata(c);
	  token = token || this._read_processing(c);
	  token = token || this._read_open(c, open_token);
	  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

	  return token;
	};

	Tokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
	  var token = null;
	  var resulting_string = null;
	  var directives = null;

	  if (c === '<') {
	    var peek1 = this._input.peek(1);
	    // We treat all comments as literals, even more than preformatted tags
	    // we only look for the appropriate closing marker
	    if (peek1 === '!') {
	      resulting_string = this.__patterns.comment.read();

	      // only process directive on html comments
	      if (resulting_string) {
	        directives = directives_core.get_directives(resulting_string);
	        if (directives && directives.ignore === 'start') {
	          resulting_string += directives_core.readIgnored(this._input);
	        }
	      } else {
	        resulting_string = this.__patterns.cdata.read();
	      }
	    }

	    if (resulting_string) {
	      token = this._create_token(TOKEN.COMMENT, resulting_string);
	      token.directives = directives;
	    }
	  }

	  return token;
	};

	Tokenizer.prototype._read_processing = function(c) { // jshint unused:false
	  var token = null;
	  var resulting_string = null;
	  var directives = null;

	  if (c === '<') {
	    var peek1 = this._input.peek(1);
	    if (peek1 === '!' || peek1 === '?') {
	      resulting_string = this.__patterns.conditional_comment.read();
	      resulting_string = resulting_string || this.__patterns.processing.read();
	    }

	    if (resulting_string) {
	      token = this._create_token(TOKEN.COMMENT, resulting_string);
	      token.directives = directives;
	    }
	  }

	  return token;
	};

	Tokenizer.prototype._read_open = function(c, open_token) {
	  var resulting_string = null;
	  var token = null;
	  if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
	    if (c === '<') {

	      resulting_string = this._input.next();
	      if (this._input.peek() === '/') {
	        resulting_string += this._input.next();
	      }
	      resulting_string += this.__patterns.element_name.read();
	      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
	    }
	  }
	  return token;
	};

	Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
	  var resulting_string = null;
	  var token = null;
	  if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
	    if ((this._options.templating.includes('angular') || this._options.indent_handlebars) && c === '{' && this._input.peek(1) === '{') {
	      if (this._options.indent_handlebars && this._input.peek(2) === '!') {
	        resulting_string = this.__patterns.handlebars_comment.read();
	        resulting_string = resulting_string || this.__patterns.handlebars.read();
	        token = this._create_token(TOKEN.COMMENT, resulting_string);
	      } else {
	        resulting_string = this.__patterns.handlebars_open.read();
	        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
	      }
	    }
	  }
	  return token;
	};

	Tokenizer.prototype._read_control_flows = function(c, open_token) {
	  var resulting_string = '';
	  var token = null;
	  // Only check for control flows if angular templating is set
	  if (!this._options.templating.includes('angular')) {
	    return token;
	  }

	  if (c === '@') {
	    resulting_string = this.__patterns.angular_control_flow_start.read();
	    if (resulting_string === '') {
	      return token;
	    }

	    var opening_parentheses_count = resulting_string.endsWith('(') ? 1 : 0;
	    var closing_parentheses_count = 0;
	    // The opening brace of the control flow is where the number of opening and closing parentheses equal
	    // e.g. @if({value: true} !== null) { 
	    while (!(resulting_string.endsWith('{') && opening_parentheses_count === closing_parentheses_count)) {
	      var next_char = this._input.next();
	      if (next_char === null) {
	        break;
	      } else if (next_char === '(') {
	        opening_parentheses_count++;
	      } else if (next_char === ')') {
	        closing_parentheses_count++;
	      }
	      resulting_string += next_char;
	    }
	    token = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);
	  } else if (c === '}' && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
	    resulting_string = this._input.next();
	    token = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);
	  }
	  return token;
	};


	Tokenizer.prototype._read_close = function(c, open_token) {
	  var resulting_string = null;
	  var token = null;
	  if (open_token && open_token.type === TOKEN.TAG_OPEN) {
	    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
	      resulting_string = this._input.next();
	      if (c === '/') { //  for close tag "/>"
	        resulting_string += this._input.next();
	      }
	      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
	    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
	      this._input.next();
	      this._input.next();
	      token = this._create_token(TOKEN.TAG_CLOSE, '}}');
	    }
	  }

	  return token;
	};

	Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
	  var token = null;
	  var resulting_string = '';
	  if (open_token && open_token.text[0] === '<') {

	    if (c === '=') {
	      token = this._create_token(TOKEN.EQUALS, this._input.next());
	    } else if (c === '"' || c === "'") {
	      var content = this._input.next();
	      if (c === '"') {
	        content += this.__patterns.double_quote.read();
	      } else {
	        content += this.__patterns.single_quote.read();
	      }
	      token = this._create_token(TOKEN.VALUE, content);
	    } else {
	      resulting_string = this.__patterns.attribute.read();

	      if (resulting_string) {
	        if (previous_token.type === TOKEN.EQUALS) {
	          token = this._create_token(TOKEN.VALUE, resulting_string);
	        } else {
	          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
	        }
	      }
	    }
	  }
	  return token;
	};

	Tokenizer.prototype._is_content_unformatted = function(tag_name) {
	  // void_elements have no content and so cannot have unformatted content
	  // script and style tags should always be read as unformatted content
	  // finally content_unformatted and unformatted element contents are unformatted
	  return this._options.void_elements.indexOf(tag_name) === -1 &&
	    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
	      this._options.unformatted.indexOf(tag_name) !== -1);
	};

	Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
	  var resulting_string = '';
	  if (open_token && open_token.text[0] === '{') {
	    resulting_string = this.__patterns.handlebars_raw_close.read();
	  } else if (previous_token.type === TOKEN.TAG_CLOSE &&
	    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
	    // ^^ empty tag has no content 
	    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
	    if (this._is_content_unformatted(tag_name)) {

	      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
	    }
	  }

	  if (resulting_string) {
	    return this._create_token(TOKEN.TEXT, resulting_string);
	  }

	  return null;
	};

	Tokenizer.prototype._read_script_and_style = function(c, previous_token) { // jshint unused:false 
	  if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
	    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
	    if (tag_name === 'script' || tag_name === 'style') {
	      // Script and style tags are allowed to have comments wrapping their content
	      // or just have regular content.
	      var token = this._read_comment_or_cdata(c);
	      if (token) {
	        token.type = TOKEN.TEXT;
	        return token;
	      }
	      var resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
	      if (resulting_string) {
	        return this._create_token(TOKEN.TEXT, resulting_string);
	      }
	    }
	  }
	  return null;
	};

	Tokenizer.prototype._read_content_word = function(c, open_token) {
	  var resulting_string = '';
	  if (this._options.unformatted_content_delimiter) {
	    if (c === this._options.unformatted_content_delimiter[0]) {
	      resulting_string = this.__patterns.unformatted_content_delimiter.read();
	    }
	  }

	  if (!resulting_string) {
	    resulting_string = (open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();
	  }
	  if (resulting_string) {
	    return this._create_token(TOKEN.TEXT, resulting_string);
	  }
	  return null;
	};

	tokenizer.Tokenizer = Tokenizer;
	tokenizer.TOKEN = TOKEN;
	return tokenizer;
}

/*jshint node:true */

var hasRequiredBeautifier;

function requireBeautifier () {
	if (hasRequiredBeautifier) return beautifier;
	hasRequiredBeautifier = 1;

	var Options = requireOptions$1().Options;
	var Output = requireOutput().Output;
	var Tokenizer = requireTokenizer$1().Tokenizer;
	var TOKEN = requireTokenizer$1().TOKEN;

	var lineBreak = /\r\n|[\r\n]/;
	var allLineBreaks = /\r\n|[\r\n]/g;

	var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

	  this.indent_level = 0;
	  this.alignment_size = 0;
	  this.max_preserve_newlines = options.max_preserve_newlines;
	  this.preserve_newlines = options.preserve_newlines;

	  this._output = new Output(options, base_indent_string);

	};

	Printer.prototype.current_line_has_match = function(pattern) {
	  return this._output.current_line.has_match(pattern);
	};

	Printer.prototype.set_space_before_token = function(value, non_breaking) {
	  this._output.space_before_token = value;
	  this._output.non_breaking_space = non_breaking;
	};

	Printer.prototype.set_wrap_point = function() {
	  this._output.set_indent(this.indent_level, this.alignment_size);
	  this._output.set_wrap_point();
	};


	Printer.prototype.add_raw_token = function(token) {
	  this._output.add_raw_token(token);
	};

	Printer.prototype.print_preserved_newlines = function(raw_token) {
	  var newlines = 0;
	  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
	    newlines = raw_token.newlines ? 1 : 0;
	  }

	  if (this.preserve_newlines) {
	    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
	  }
	  for (var n = 0; n < newlines; n++) {
	    this.print_newline(n > 0);
	  }

	  return newlines !== 0;
	};

	Printer.prototype.traverse_whitespace = function(raw_token) {
	  if (raw_token.whitespace_before || raw_token.newlines) {
	    if (!this.print_preserved_newlines(raw_token)) {
	      this._output.space_before_token = true;
	    }
	    return true;
	  }
	  return false;
	};

	Printer.prototype.previous_token_wrapped = function() {
	  return this._output.previous_token_wrapped;
	};

	Printer.prototype.print_newline = function(force) {
	  this._output.add_new_line(force);
	};

	Printer.prototype.print_token = function(token) {
	  if (token.text) {
	    this._output.set_indent(this.indent_level, this.alignment_size);
	    this._output.add_token(token.text);
	  }
	};

	Printer.prototype.indent = function() {
	  this.indent_level++;
	};

	Printer.prototype.deindent = function() {
	  if (this.indent_level > 0) {
	    this.indent_level--;
	    this._output.set_indent(this.indent_level, this.alignment_size);
	  }
	};

	Printer.prototype.get_full_indent = function(level) {
	  level = this.indent_level + (level || 0);
	  if (level < 1) {
	    return '';
	  }

	  return this._output.get_indent_string(level);
	};

	var get_type_attribute = function(start_token) {
	  var result = null;
	  var raw_token = start_token.next;

	  // Search attributes for a type attribute
	  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
	    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {
	      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&
	        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
	        result = raw_token.next.next.text;
	      }
	      break;
	    }
	    raw_token = raw_token.next;
	  }

	  return result;
	};

	var get_custom_beautifier_name = function(tag_check, raw_token) {
	  var typeAttribute = null;
	  var result = null;

	  if (!raw_token.closed) {
	    return null;
	  }

	  if (tag_check === 'script') {
	    typeAttribute = 'text/javascript';
	  } else if (tag_check === 'style') {
	    typeAttribute = 'text/css';
	  }

	  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

	  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
	  // For those without a type attribute use default;
	  if (typeAttribute.search('text/css') > -1) {
	    result = 'css';
	  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
	    result = 'javascript';
	  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
	    result = 'html';
	  } else if (typeAttribute.search(/test\/null/) > -1) {
	    // Test only mime-type for testing the beautifier when null is passed as beautifing function
	    result = 'null';
	  }

	  return result;
	};

	function in_array(what, arr) {
	  return arr.indexOf(what) !== -1;
	}

	function TagFrame(parent, parser_token, indent_level) {
	  this.parent = parent || null;
	  this.tag = parser_token ? parser_token.tag_name : '';
	  this.indent_level = indent_level || 0;
	  this.parser_token = parser_token || null;
	}

	function TagStack(printer) {
	  this._printer = printer;
	  this._current_frame = null;
	}

	TagStack.prototype.get_parser_token = function() {
	  return this._current_frame ? this._current_frame.parser_token : null;
	};

	TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
	  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
	  this._current_frame = new_frame;
	};

	TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
	  var parser_token = null;

	  if (frame) {
	    parser_token = frame.parser_token;
	    this._printer.indent_level = frame.indent_level;
	    this._current_frame = frame.parent;
	  }

	  return parser_token;
	};

	TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
	  var frame = this._current_frame;

	  while (frame) { //till we reach '' (the initial value);
	    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
	      break;
	    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
	      frame = null;
	      break;
	    }
	    frame = frame.parent;
	  }

	  return frame;
	};

	TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
	  var frame = this._get_frame([tag], stop_list);
	  return this._try_pop_frame(frame);
	};

	TagStack.prototype.indent_to_tag = function(tag_list) {
	  var frame = this._get_frame(tag_list);
	  if (frame) {
	    this._printer.indent_level = frame.indent_level;
	  }
	};

	function Beautifier(source_text, options, js_beautify, css_beautify) {
	  //Wrapper function to invoke all the necessary constructors and deal with the output.
	  this._source_text = source_text || '';
	  options = options || {};
	  this._js_beautify = js_beautify;
	  this._css_beautify = css_beautify;
	  this._tag_stack = null;

	  // Allow the setting of language/file-type specific options
	  // with inheritance of overall settings
	  var optionHtml = new Options(options, 'html');

	  this._options = optionHtml;

	  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
	  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
	  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
	  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
	  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
	  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
	}

	Beautifier.prototype.beautify = function() {

	  // if disabled, return the input unchanged.
	  if (this._options.disabled) {
	    return this._source_text;
	  }

	  var source_text = this._source_text;
	  var eol = this._options.eol;
	  if (this._options.eol === 'auto') {
	    eol = '\n';
	    if (source_text && lineBreak.test(source_text)) {
	      eol = source_text.match(lineBreak)[0];
	    }
	  }

	  // HACK: newline parsing inconsistent. This brute force normalizes the input.
	  source_text = source_text.replace(allLineBreaks, '\n');

	  var baseIndentString = source_text.match(/^[\t ]*/)[0];

	  var last_token = {
	    text: '',
	    type: ''
	  };

	  var last_tag_token = new TagOpenParserToken(this._options);

	  var printer = new Printer(this._options, baseIndentString);
	  var tokens = new Tokenizer(source_text, this._options).tokenize();

	  this._tag_stack = new TagStack(printer);

	  var parser_token = null;
	  var raw_token = tokens.next();
	  while (raw_token.type !== TOKEN.EOF) {

	    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
	      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
	      last_tag_token = parser_token;
	    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||
	      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {
	      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
	    } else if (raw_token.type === TOKEN.TAG_CLOSE) {
	      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
	    } else if (raw_token.type === TOKEN.TEXT) {
	      parser_token = this._handle_text(printer, raw_token, last_tag_token);
	    } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {
	      parser_token = this._handle_control_flow_open(printer, raw_token);
	    } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {
	      parser_token = this._handle_control_flow_close(printer, raw_token);
	    } else {
	      // This should never happen, but if it does. Print the raw token
	      printer.add_raw_token(raw_token);
	    }

	    last_token = parser_token;

	    raw_token = tokens.next();
	  }
	  var sweet_code = printer._output.get_code(eol);

	  return sweet_code;
	};

	Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {
	  var parser_token = {
	    text: raw_token.text,
	    type: raw_token.type
	  };
	  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
	  if (raw_token.newlines) {
	    printer.print_preserved_newlines(raw_token);
	  } else {
	    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
	  }
	  printer.print_token(raw_token);
	  printer.indent();
	  return parser_token;
	};

	Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {
	  var parser_token = {
	    text: raw_token.text,
	    type: raw_token.type
	  };

	  printer.deindent();
	  if (raw_token.newlines) {
	    printer.print_preserved_newlines(raw_token);
	  } else {
	    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
	  }
	  printer.print_token(raw_token);
	  return parser_token;
	};

	Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
	  var parser_token = {
	    text: raw_token.text,
	    type: raw_token.type
	  };
	  printer.alignment_size = 0;
	  last_tag_token.tag_complete = true;

	  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
	  if (last_tag_token.is_unformatted) {
	    printer.add_raw_token(raw_token);
	  } else {
	    if (last_tag_token.tag_start_char === '<') {
	      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
	      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
	        printer.print_newline(false);
	      }
	    }
	    printer.print_token(raw_token);

	  }

	  if (last_tag_token.indent_content &&
	    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
	    printer.indent();

	    // only indent once per opened tag
	    last_tag_token.indent_content = false;
	  }

	  if (!last_tag_token.is_inline_element &&
	    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
	    printer.set_wrap_point();
	  }

	  return parser_token;
	};

	Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
	  var wrapped = last_tag_token.has_wrapped_attrs;
	  var parser_token = {
	    text: raw_token.text,
	    type: raw_token.type
	  };

	  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
	  if (last_tag_token.is_unformatted) {
	    printer.add_raw_token(raw_token);
	  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {
	    // For the insides of handlebars allow newlines or a single space between open and contents
	    if (printer.print_preserved_newlines(raw_token)) {
	      raw_token.newlines = 0;
	      printer.add_raw_token(raw_token);
	    } else {
	      printer.print_token(raw_token);
	    }
	  } else {
	    if (raw_token.type === TOKEN.ATTRIBUTE) {
	      printer.set_space_before_token(true);
	    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =
	      printer.set_space_before_token(false);
	    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value
	      printer.set_space_before_token(false);
	    }

	    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
	      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
	        printer.traverse_whitespace(raw_token);
	        wrapped = wrapped || raw_token.newlines !== 0;
	      }

	      // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':
	      // 1. always wrap the second and beyond attributes
	      // 2. wrap the first attribute only if 'force-expand-multiline' is specified
	      if (this._is_wrap_attributes_force &&
	        last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs &&
	        (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond
	          this._is_wrap_attributes_force_expand_multiline)) {
	        printer.print_newline(false);
	        wrapped = true;
	      }
	    }
	    printer.print_token(raw_token);
	    wrapped = wrapped || printer.previous_token_wrapped();
	    last_tag_token.has_wrapped_attrs = wrapped;
	  }
	  return parser_token;
	};

	Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
	  var parser_token = {
	    text: raw_token.text,
	    type: 'TK_CONTENT'
	  };
	  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
	    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
	  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
	    printer.add_raw_token(raw_token);
	  } else {
	    printer.traverse_whitespace(raw_token);
	    printer.print_token(raw_token);
	  }
	  return parser_token;
	};

	Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
	  var local = this;
	  if (raw_token.text !== '') {

	    var text = raw_token.text,
	      _beautifier,
	      script_indent_level = 1,
	      pre = '',
	      post = '';
	    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
	      _beautifier = this._js_beautify;
	    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
	      _beautifier = this._css_beautify;
	    } else if (last_tag_token.custom_beautifier_name === 'html') {
	      _beautifier = function(html_source, options) {
	        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
	        return beautifier.beautify();
	      };
	    }

	    if (this._options.indent_scripts === "keep") {
	      script_indent_level = 0;
	    } else if (this._options.indent_scripts === "separate") {
	      script_indent_level = -printer.indent_level;
	    }

	    var indentation = printer.get_full_indent(script_indent_level);

	    // if there is at least one empty line at the end of this text, strip it
	    // we'll be adding one back after the text but before the containing tag.
	    text = text.replace(/\n[ \t]*$/, '');

	    // Handle the case where content is wrapped in a comment or cdata.
	    if (last_tag_token.custom_beautifier_name !== 'html' &&
	      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
	      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

	      // if we start to wrap but don't finish, print raw
	      if (!matched) {
	        printer.add_raw_token(raw_token);
	        return;
	      }

	      pre = indentation + matched[1] + '\n';
	      text = matched[4];
	      if (matched[5]) {
	        post = indentation + matched[5];
	      }

	      // if there is at least one empty line at the end of this text, strip it
	      // we'll be adding one back after the text but before the containing tag.
	      text = text.replace(/\n[ \t]*$/, '');

	      if (matched[2] || matched[3].indexOf('\n') !== -1) {
	        // if the first line of the non-comment text has spaces
	        // use that as the basis for indenting in null case.
	        matched = matched[3].match(/[ \t]+$/);
	        if (matched) {
	          raw_token.whitespace_before = matched[0];
	        }
	      }
	    }

	    if (text) {
	      if (_beautifier) {

	        // call the Beautifier if avaliable
	        var Child_options = function() {
	          this.eol = '\n';
	        };
	        Child_options.prototype = this._options.raw_options;
	        var child_options = new Child_options();
	        text = _beautifier(indentation + text, child_options);
	      } else {
	        // simply indent the string otherwise
	        var white = raw_token.whitespace_before;
	        if (white) {
	          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
	        }

	        text = indentation + text.replace(/\n/g, '\n' + indentation);
	      }
	    }

	    if (pre) {
	      if (!text) {
	        text = pre + post;
	      } else {
	        text = pre + text + '\n' + post;
	      }
	    }

	    printer.print_newline(false);
	    if (text) {
	      raw_token.text = text;
	      raw_token.whitespace_before = '';
	      raw_token.newlines = 0;
	      printer.add_raw_token(raw_token);
	      printer.print_newline(true);
	    }
	  }
	};

	Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
	  var parser_token = this._get_tag_open_token(raw_token);

	  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
	    !last_tag_token.is_empty_element &&
	    raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
	    // End element tags for unformatted or content_unformatted elements
	    // are printed raw to keep any newlines inside them exactly the same.
	    printer.add_raw_token(raw_token);
	    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
	  } else {
	    printer.traverse_whitespace(raw_token);
	    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
	    if (!parser_token.is_inline_element) {
	      printer.set_wrap_point();
	    }
	    printer.print_token(raw_token);
	  }

	  // count the number of attributes
	  if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
	    var peek_index = 0;
	    var peek_token;
	    do {
	      peek_token = tokens.peek(peek_index);
	      if (peek_token.type === TOKEN.ATTRIBUTE) {
	        parser_token.attr_count += 1;
	      }
	      peek_index += 1;
	    } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
	  }

	  //indent attributes an auto, forced, aligned or forced-align line-wrap
	  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
	    parser_token.alignment_size = raw_token.text.length + 1;
	  }

	  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
	    printer.alignment_size = parser_token.alignment_size;
	  }

	  return parser_token;
	};

	var TagOpenParserToken = function(options, parent, raw_token) {
	  this.parent = parent || null;
	  this.text = '';
	  this.type = 'TK_TAG_OPEN';
	  this.tag_name = '';
	  this.is_inline_element = false;
	  this.is_unformatted = false;
	  this.is_content_unformatted = false;
	  this.is_empty_element = false;
	  this.is_start_tag = false;
	  this.is_end_tag = false;
	  this.indent_content = false;
	  this.multiline_content = false;
	  this.custom_beautifier_name = null;
	  this.start_tag_token = null;
	  this.attr_count = 0;
	  this.has_wrapped_attrs = false;
	  this.alignment_size = 0;
	  this.tag_complete = false;
	  this.tag_start_char = '';
	  this.tag_check = '';

	  if (!raw_token) {
	    this.tag_complete = true;
	  } else {
	    var tag_check_match;

	    this.tag_start_char = raw_token.text[0];
	    this.text = raw_token.text;

	    if (this.tag_start_char === '<') {
	      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
	      this.tag_check = tag_check_match ? tag_check_match[1] : '';
	    } else {
	      tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
	      this.tag_check = tag_check_match ? tag_check_match[1] : '';

	      // handle "{{#> myPartial}}" or "{{~#> myPartial}}"
	      if ((raw_token.text.startsWith('{{#>') || raw_token.text.startsWith('{{~#>')) && this.tag_check[0] === '>') {
	        if (this.tag_check === '>' && raw_token.next !== null) {
	          this.tag_check = raw_token.next.text.split(' ')[0];
	        } else {
	          this.tag_check = raw_token.text.split('>')[1];
	        }
	      }
	    }

	    this.tag_check = this.tag_check.toLowerCase();

	    if (raw_token.type === TOKEN.COMMENT) {
	      this.tag_complete = true;
	    }

	    this.is_start_tag = this.tag_check.charAt(0) !== '/';
	    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
	    this.is_end_tag = !this.is_start_tag ||
	      (raw_token.closed && raw_token.closed.text === '/>');

	    // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2
	    var handlebar_starts = 2;
	    if (this.tag_start_char === '{' && this.text.length >= 3) {
	      if (this.text.charAt(2) === '~') {
	        handlebar_starts = 3;
	      }
	    }

	    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
	    // if they start with # or ^, they are still considered single tags if indenting of handlebars is set to false
	    this.is_end_tag = this.is_end_tag ||
	      (this.tag_start_char === '{' && (!options.indent_handlebars || this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(handlebar_starts)))));
	  }
	};

	Beautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
	  var parser_token = new TagOpenParserToken(this._options, this._tag_stack.get_parser_token(), raw_token);

	  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

	  parser_token.is_end_tag = parser_token.is_end_tag ||
	    in_array(parser_token.tag_check, this._options.void_elements);

	  parser_token.is_empty_element = parser_token.tag_complete ||
	    (parser_token.is_start_tag && parser_token.is_end_tag);

	  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
	  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
	  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || (this._options.inline_custom_elements && parser_token.tag_name.includes("-")) || parser_token.tag_start_char === '{';

	  return parser_token;
	};

	Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

	  if (!parser_token.is_empty_element) {
	    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
	      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
	    } else { // it's a start-tag
	      // check if this tag is starting an element that has optional end element
	      // and do an ending needed
	      if (this._do_optional_end_element(parser_token)) {
	        if (!parser_token.is_inline_element) {
	          printer.print_newline(false);
	        }
	      }

	      this._tag_stack.record_tag(parser_token); //push it on the tag stack

	      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
	        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
	        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
	      }
	    }
	  }

	  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
	    printer.print_newline(false);
	    if (!printer._output.just_added_blankline()) {
	      printer.print_newline(true);
	    }
	  }

	  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

	    // if you hit an else case, reset the indent level if you are inside an:
	    // 'if', 'unless', or 'each' block.
	    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
	      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
	      parser_token.indent_content = true;
	      // Don't add a newline if opening {{#if}} tag is on the current line
	      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
	      if (!foundIfOnCurrentLine) {
	        printer.print_newline(false);
	      }
	    }

	    // Don't add a newline before elements that should remain where they are.
	    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&
	      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) ; else {
	      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
	        printer.print_newline(false);
	      }
	      this._calcluate_parent_multiline(printer, parser_token);
	    }
	  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
	    var do_end_expand = false;

	    // deciding whether a block is multiline should not be this hard
	    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
	    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
	      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
	      !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
	      last_token.type !== 'TK_CONTENT'
	    );

	    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
	      do_end_expand = false;
	    }

	    if (do_end_expand) {
	      printer.print_newline(false);
	    }
	  } else { // it's a start-tag
	    parser_token.indent_content = !parser_token.custom_beautifier_name;

	    if (parser_token.tag_start_char === '<') {
	      if (parser_token.tag_name === 'html') {
	        parser_token.indent_content = this._options.indent_inner_html;
	      } else if (parser_token.tag_name === 'head') {
	        parser_token.indent_content = this._options.indent_head_inner_html;
	      } else if (parser_token.tag_name === 'body') {
	        parser_token.indent_content = this._options.indent_body_inner_html;
	      }
	    }

	    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
	      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
	      printer.print_newline(false);
	    }

	    this._calcluate_parent_multiline(printer, parser_token);
	  }
	};

	Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
	  if (parser_token.parent && printer._output.just_added_newline() &&
	    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
	    parser_token.parent.multiline_content = true;
	  }
	};

	//To be used for <p> tag special case:
	var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
	var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

	Beautifier.prototype._do_optional_end_element = function(parser_token) {
	  var result = null;
	  // NOTE: cases of "if there is no more content in the parent element"
	  // are handled automatically by the beautifier.
	  // It assumes parent or ancestor close tag closes all children.
	  // https://www.w3.org/TR/html5/syntax.html#optional-tags
	  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
	    return;

	  }

	  if (parser_token.tag_name === 'body') {
	    // A head elements end tag may be omitted if the head element is not immediately followed by a space character or a comment.
	    result = result || this._tag_stack.try_pop('head');

	    //} else if (parser_token.tag_name === 'body') {
	    // DONE: A body elements end tag may be omitted if the body element is not immediately followed by a comment.

	  } else if (parser_token.tag_name === 'li') {
	    // An li elements end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
	    result = result || this._tag_stack.try_pop('li', ['ol', 'ul', 'menu']);

	  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
	    // A dd elements end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
	    // A dt elements end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
	    result = result || this._tag_stack.try_pop('dt', ['dl']);
	    result = result || this._tag_stack.try_pop('dd', ['dl']);


	  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
	    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
	    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
	    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
	    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
	    var p_parent = parser_token.parent.parent;
	    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
	      result = result || this._tag_stack.try_pop('p');
	    }
	  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
	    // An rt elements end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
	    // An rp elements end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
	    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
	    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

	  } else if (parser_token.tag_name === 'optgroup') {
	    // An optgroup elements end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
	    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
	    result = result || this._tag_stack.try_pop('optgroup', ['select']);
	    //result = result || this._tag_stack.try_pop('option', ['select']);

	  } else if (parser_token.tag_name === 'option') {
	    // An option elements end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
	    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

	  } else if (parser_token.tag_name === 'colgroup') {
	    // DONE: A colgroup elements end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
	    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
	    result = result || this._tag_stack.try_pop('caption', ['table']);

	  } else if (parser_token.tag_name === 'thead') {
	    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
	    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
	    result = result || this._tag_stack.try_pop('caption', ['table']);
	    result = result || this._tag_stack.try_pop('colgroup', ['table']);

	    //} else if (parser_token.tag_name === 'caption') {
	    // DONE: A caption elements end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

	  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
	    // A thead elements end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
	    // A tbody elements end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
	    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
	    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
	    result = result || this._tag_stack.try_pop('caption', ['table']);
	    result = result || this._tag_stack.try_pop('colgroup', ['table']);
	    result = result || this._tag_stack.try_pop('thead', ['table']);
	    result = result || this._tag_stack.try_pop('tbody', ['table']);

	    //} else if (parser_token.tag_name === 'tfoot') {
	    // DONE: A tfoot elements end tag may be omitted if there is no more content in the parent element.

	  } else if (parser_token.tag_name === 'tr') {
	    // A tr elements end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
	    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
	    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
	    result = result || this._tag_stack.try_pop('caption', ['table']);
	    result = result || this._tag_stack.try_pop('colgroup', ['table']);
	    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

	  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
	    // A td elements end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
	    // A th elements end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
	    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
	    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
	  }

	  // Start element omission not handled currently
	  // A head elements start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
	  // A tbody elements start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It cant be omitted if the element is empty.)
	  // A colgroup elements start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It cant be omitted if the element is empty.)

	  // Fix up the parent of the parser token
	  parser_token.parent = this._tag_stack.get_parser_token();

	  return result;
	};

	beautifier.Beautifier = Beautifier;
	return beautifier;
}

/*jshint node:true */

var hasRequiredHtml;

function requireHtml () {
	if (hasRequiredHtml) return html.exports;
	hasRequiredHtml = 1;

	var Beautifier = requireBeautifier().Beautifier,
	  Options = requireOptions$1().Options;

	function style_html(html_source, options, js_beautify, css_beautify) {
	  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
	  return beautifier.beautify();
	}

	html.exports = style_html;
	html.exports.defaultOptions = function() {
	  return new Options();
	};
	return html.exports;
}

/*jshint node:true */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;

	var js_beautify = requireJavascript();
	var css_beautify = requireCss();
	var html_beautify = requireHtml();

	function style_html(html_source, options, js, css) {
	  js = js || js_beautify;
	  css = css || css_beautify;
	  return html_beautify(html_source, options, js, css);
	}
	style_html.defaultOptions = html_beautify.defaultOptions;

	src.js = js_beautify;
	src.css = css_beautify;
	src.html = style_html;
	return src;
}

/*jshint node:true */

var hasRequiredJs;

function requireJs () {
	if (hasRequiredJs) return js.exports;
	hasRequiredJs = 1;
	(function (module) {

		/**
		The following batches are equivalent:

		var beautify_js = require('js-beautify');
		var beautify_js = require('js-beautify').js;
		var beautify_js = require('js-beautify').js_beautify;

		var beautify_css = require('js-beautify').css;
		var beautify_css = require('js-beautify').css_beautify;

		var beautify_html = require('js-beautify').html;
		var beautify_html = require('js-beautify').html_beautify;

		All methods returned accept two arguments, the source string and an options object.
		**/

		function get_beautify(js_beautify, css_beautify, html_beautify) {
		  // the default is js
		  var beautify = function(src, config) {
		    return js_beautify.js_beautify(src, config);
		  };

		  // short aliases
		  beautify.js = js_beautify.js_beautify;
		  beautify.css = css_beautify.css_beautify;
		  beautify.html = html_beautify.html_beautify;

		  // legacy aliases
		  beautify.js_beautify = js_beautify.js_beautify;
		  beautify.css_beautify = css_beautify.css_beautify;
		  beautify.html_beautify = html_beautify.html_beautify;

		  return beautify;
		}

		{
		  (function(mod) {
		    var beautifier = requireSrc();
		    beautifier.js_beautify = beautifier.js;
		    beautifier.css_beautify = beautifier.css;
		    beautifier.html_beautify = beautifier.html;

		    mod.exports = get_beautify(beautifier, beautifier, beautifier);

		  })(module);
		} 
	} (js));
	return js.exports;
}

var htmlminifier = {};

var clean = {exports: {}};

var optimize$3;
var hasRequiredOptimize$3;

function requireOptimize$3 () {
	if (hasRequiredOptimize$3) return optimize$3;
	hasRequiredOptimize$3 = 1;
	function level0Optimize(tokens) {
	  // noop as level 0 means no optimizations!
	  return tokens;
	}

	optimize$3 = level0Optimize;
	return optimize$3;
}

var shortenHex_1;
var hasRequiredShortenHex;

function requireShortenHex () {
	if (hasRequiredShortenHex) return shortenHex_1;
	hasRequiredShortenHex = 1;
	var COLORS = {
	  aliceblue: '#f0f8ff',
	  antiquewhite: '#faebd7',
	  aqua: '#0ff',
	  aquamarine: '#7fffd4',
	  azure: '#f0ffff',
	  beige: '#f5f5dc',
	  bisque: '#ffe4c4',
	  black: '#000',
	  blanchedalmond: '#ffebcd',
	  blue: '#00f',
	  blueviolet: '#8a2be2',
	  brown: '#a52a2a',
	  burlywood: '#deb887',
	  cadetblue: '#5f9ea0',
	  chartreuse: '#7fff00',
	  chocolate: '#d2691e',
	  coral: '#ff7f50',
	  cornflowerblue: '#6495ed',
	  cornsilk: '#fff8dc',
	  crimson: '#dc143c',
	  cyan: '#0ff',
	  darkblue: '#00008b',
	  darkcyan: '#008b8b',
	  darkgoldenrod: '#b8860b',
	  darkgray: '#a9a9a9',
	  darkgreen: '#006400',
	  darkgrey: '#a9a9a9',
	  darkkhaki: '#bdb76b',
	  darkmagenta: '#8b008b',
	  darkolivegreen: '#556b2f',
	  darkorange: '#ff8c00',
	  darkorchid: '#9932cc',
	  darkred: '#8b0000',
	  darksalmon: '#e9967a',
	  darkseagreen: '#8fbc8f',
	  darkslateblue: '#483d8b',
	  darkslategray: '#2f4f4f',
	  darkslategrey: '#2f4f4f',
	  darkturquoise: '#00ced1',
	  darkviolet: '#9400d3',
	  deeppink: '#ff1493',
	  deepskyblue: '#00bfff',
	  dimgray: '#696969',
	  dimgrey: '#696969',
	  dodgerblue: '#1e90ff',
	  firebrick: '#b22222',
	  floralwhite: '#fffaf0',
	  forestgreen: '#228b22',
	  fuchsia: '#f0f',
	  gainsboro: '#dcdcdc',
	  ghostwhite: '#f8f8ff',
	  gold: '#ffd700',
	  goldenrod: '#daa520',
	  gray: '#808080',
	  green: '#008000',
	  greenyellow: '#adff2f',
	  grey: '#808080',
	  honeydew: '#f0fff0',
	  hotpink: '#ff69b4',
	  indianred: '#cd5c5c',
	  indigo: '#4b0082',
	  ivory: '#fffff0',
	  khaki: '#f0e68c',
	  lavender: '#e6e6fa',
	  lavenderblush: '#fff0f5',
	  lawngreen: '#7cfc00',
	  lemonchiffon: '#fffacd',
	  lightblue: '#add8e6',
	  lightcoral: '#f08080',
	  lightcyan: '#e0ffff',
	  lightgoldenrodyellow: '#fafad2',
	  lightgray: '#d3d3d3',
	  lightgreen: '#90ee90',
	  lightgrey: '#d3d3d3',
	  lightpink: '#ffb6c1',
	  lightsalmon: '#ffa07a',
	  lightseagreen: '#20b2aa',
	  lightskyblue: '#87cefa',
	  lightslategray: '#778899',
	  lightslategrey: '#778899',
	  lightsteelblue: '#b0c4de',
	  lightyellow: '#ffffe0',
	  lime: '#0f0',
	  limegreen: '#32cd32',
	  linen: '#faf0e6',
	  magenta: '#ff00ff',
	  maroon: '#800000',
	  mediumaquamarine: '#66cdaa',
	  mediumblue: '#0000cd',
	  mediumorchid: '#ba55d3',
	  mediumpurple: '#9370db',
	  mediumseagreen: '#3cb371',
	  mediumslateblue: '#7b68ee',
	  mediumspringgreen: '#00fa9a',
	  mediumturquoise: '#48d1cc',
	  mediumvioletred: '#c71585',
	  midnightblue: '#191970',
	  mintcream: '#f5fffa',
	  mistyrose: '#ffe4e1',
	  moccasin: '#ffe4b5',
	  navajowhite: '#ffdead',
	  navy: '#000080',
	  oldlace: '#fdf5e6',
	  olive: '#808000',
	  olivedrab: '#6b8e23',
	  orange: '#ffa500',
	  orangered: '#ff4500',
	  orchid: '#da70d6',
	  palegoldenrod: '#eee8aa',
	  palegreen: '#98fb98',
	  paleturquoise: '#afeeee',
	  palevioletred: '#db7093',
	  papayawhip: '#ffefd5',
	  peachpuff: '#ffdab9',
	  peru: '#cd853f',
	  pink: '#ffc0cb',
	  plum: '#dda0dd',
	  powderblue: '#b0e0e6',
	  purple: '#800080',
	  rebeccapurple: '#663399',
	  red: '#f00',
	  rosybrown: '#bc8f8f',
	  royalblue: '#4169e1',
	  saddlebrown: '#8b4513',
	  salmon: '#fa8072',
	  sandybrown: '#f4a460',
	  seagreen: '#2e8b57',
	  seashell: '#fff5ee',
	  sienna: '#a0522d',
	  silver: '#c0c0c0',
	  skyblue: '#87ceeb',
	  slateblue: '#6a5acd',
	  slategray: '#708090',
	  slategrey: '#708090',
	  snow: '#fffafa',
	  springgreen: '#00ff7f',
	  steelblue: '#4682b4',
	  tan: '#d2b48c',
	  teal: '#008080',
	  thistle: '#d8bfd8',
	  tomato: '#ff6347',
	  turquoise: '#40e0d0',
	  violet: '#ee82ee',
	  wheat: '#f5deb3',
	  white: '#fff',
	  whitesmoke: '#f5f5f5',
	  yellow: '#ff0',
	  yellowgreen: '#9acd32'
	};

	var toHex = {};
	var toName = {};

	for (var name in COLORS) {
	  var hex = COLORS[name];

	  if (name.length < hex.length) {
	    toName[hex] = name;
	  } else {
	    toHex[name] = hex;
	  }
	}

	var toHexPattern = new RegExp('(^| |,|\\))(' + Object.keys(toHex).join('|') + ')( |,|\\)|$)', 'ig');
	var toNamePattern = new RegExp('(' + Object.keys(toName).join('|') + ')([^a-f0-9]|$)', 'ig');

	function hexConverter(match, prefix, colorValue, suffix) {
	  return prefix + toHex[colorValue.toLowerCase()] + suffix;
	}

	function nameConverter(match, colorValue, suffix) {
	  return toName[colorValue.toLowerCase()] + suffix;
	}

	function shortenHex(value) {
	  var hasHex = value.indexOf('#') > -1;
	  var shortened = value.replace(toHexPattern, hexConverter);

	  if (shortened != value) {
	    shortened = shortened.replace(toHexPattern, hexConverter);
	  }

	  return hasHex ?
	    shortened.replace(toNamePattern, nameConverter) :
	    shortened;
	}

	shortenHex_1 = shortenHex;
	return shortenHex_1;
}

var shortenHsl_1;
var hasRequiredShortenHsl;

function requireShortenHsl () {
	if (hasRequiredShortenHsl) return shortenHsl_1;
	hasRequiredShortenHsl = 1;
	// HSL to RGB converter. Both methods adapted from:
	// http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript

	function hslToRgb(h, s, l) {
	  var r, g, b;

	  // normalize hue orientation b/w 0 and 360 degrees
	  h = h % 360;
	  if (h < 0)
	    h += 360;
	  h = ~~h / 360;

	  if (s < 0)
	    s = 0;
	  else if (s > 100)
	    s = 100;
	  s = ~~s / 100;

	  if (l < 0)
	    l = 0;
	  else if (l > 100)
	    l = 100;
	  l = ~~l / 100;

	  if (s === 0) {
	    r = g = b = l; // achromatic
	  } else {
	    var q = l < 0.5 ?
	      l * (1 + s) :
	      l + s - l * s;
	    var p = 2 * l - q;
	    r = hueToRgb(p, q, h + 1/3);
	    g = hueToRgb(p, q, h);
	    b = hueToRgb(p, q, h - 1/3);
	  }

	  return [~~(r * 255), ~~(g * 255), ~~(b * 255)];
	}

	function hueToRgb(p, q, t) {
	  if (t < 0) t += 1;
	  if (t > 1) t -= 1;
	  if (t < 1/6) return p + (q - p) * 6 * t;
	  if (t < 1/2) return q;
	  if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	  return p;
	}

	function shortenHsl(hue, saturation, lightness) {
	  var asRgb = hslToRgb(hue, saturation, lightness);
	  var redAsHex = asRgb[0].toString(16);
	  var greenAsHex = asRgb[1].toString(16);
	  var blueAsHex = asRgb[2].toString(16);

	  return '#' +
	    ((redAsHex.length == 1 ? '0' : '') + redAsHex) +
	    ((greenAsHex.length == 1 ? '0' : '') + greenAsHex) +
	    ((blueAsHex.length == 1 ? '0' : '') + blueAsHex);
	}

	shortenHsl_1 = shortenHsl;
	return shortenHsl_1;
}

var shortenRgb_1;
var hasRequiredShortenRgb;

function requireShortenRgb () {
	if (hasRequiredShortenRgb) return shortenRgb_1;
	hasRequiredShortenRgb = 1;
	function shortenRgb(red, green, blue) {
	  var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));
	  var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));
	  var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));

	  // Credit: Asen  http://jsbin.com/UPUmaGOc/2/edit?js,console
	  return '#' + ('00000' + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);
	}

	shortenRgb_1 = shortenRgb;
	return shortenRgb_1;
}

var naturalCompare_1;
var hasRequiredNaturalCompare;

function requireNaturalCompare () {
	if (hasRequiredNaturalCompare) return naturalCompare_1;
	hasRequiredNaturalCompare = 1;
	// adapted from http://nedbatchelder.com/blog/200712.html#e20071211T054956

	var NUMBER_PATTERN = /([0-9]+)/;

	function naturalCompare(value1, value2) {
	  var keys1 = ('' + value1).split(NUMBER_PATTERN).map(tryParseInt);
	  var keys2 = ('' + value2).split(NUMBER_PATTERN).map(tryParseInt);
	  var key1;
	  var key2;
	  var compareFirst = Math.min(keys1.length, keys2.length);
	  var i, l;

	  for (i = 0, l = compareFirst; i < l; i++) {
	    key1 = keys1[i];
	    key2 = keys2[i];

	    if (key1 != key2) {
	      return key1 > key2 ? 1 : -1;
	    }
	  }

	  return keys1.length > keys2.length ? 1 : (keys1.length == keys2.length ? 0 : -1);
	}

	function tryParseInt(value) {
	  return ('' + parseInt(value)) == value ?
	    parseInt(value) :
	    value;
	}

	naturalCompare_1 = naturalCompare;
	return naturalCompare_1;
}

var sortSelectors_1;
var hasRequiredSortSelectors;

function requireSortSelectors () {
	if (hasRequiredSortSelectors) return sortSelectors_1;
	hasRequiredSortSelectors = 1;
	var naturalCompare = requireNaturalCompare();

	function naturalSorter(scope1, scope2) {
	  return naturalCompare(scope1[1], scope2[1]);
	}

	function standardSorter(scope1, scope2) {
	  return scope1[1] > scope2[1] ? 1 : -1;
	}

	function sortSelectors(selectors, method) {
	  switch (method) {
	    case 'natural':
	      return selectors.sort(naturalSorter);
	    case 'standard':
	      return selectors.sort(standardSorter);
	    case 'none':
	    case false:
	      return selectors;
	  }
	}

	sortSelectors_1 = sortSelectors;
	return sortSelectors_1;
}

var override_1;
var hasRequiredOverride;

function requireOverride () {
	if (hasRequiredOverride) return override_1;
	hasRequiredOverride = 1;
	function override(source1, source2) {
	  var target = {};
	  var key1;
	  var key2;
	  var item;

	  for (key1 in source1) {
	    item = source1[key1];

	    if (Array.isArray(item)) {
	      target[key1] = item.slice(0);
	    } else if (typeof item == 'object' && item !== null) {
	      target[key1] = override(item, {});
	    } else {
	      target[key1] = item;
	    }
	  }

	  for (key2 in source2) {
	    item = source2[key2];

	    if (key2 in target && Array.isArray(item)) {
	      target[key2] = item.slice(0);
	    } else if (key2 in target && typeof item == 'object' && item !== null) {
	      target[key2] = override(target[key2], item);
	    } else {
	      target[key2] = item;
	    }
	  }

	  return target;
	}

	override_1 = override;
	return override_1;
}

var format$1;
var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format$1;
	hasRequiredFormat$1 = 1;
	var systemLineBreak = require$$0$1.EOL;

	var override = requireOverride();

	var Breaks = {
	  AfterAtRule: 'afterAtRule',
	  AfterBlockBegins: 'afterBlockBegins',
	  AfterBlockEnds: 'afterBlockEnds',
	  AfterComment: 'afterComment',
	  AfterProperty: 'afterProperty',
	  AfterRuleBegins: 'afterRuleBegins',
	  AfterRuleEnds: 'afterRuleEnds',
	  BeforeBlockEnds: 'beforeBlockEnds',
	  BetweenSelectors: 'betweenSelectors'
	};

	var BreakWith = {
	  CarriageReturnLineFeed: '\r\n',
	  LineFeed: '\n',
	  System: systemLineBreak
	};

	var IndentWith = {
	  Space: ' ',
	  Tab: '\t'
	};

	var Spaces = {
	  AroundSelectorRelation: 'aroundSelectorRelation',
	  BeforeBlockBegins: 'beforeBlockBegins',
	  BeforeValue: 'beforeValue'
	};

	var DEFAULTS = {
	  breaks: breaks(false),
	  breakWith: BreakWith.System,
	  indentBy: 0,
	  indentWith: IndentWith.Space,
	  spaces: spaces(false),
	  wrapAt: false,
	  semicolonAfterLastProperty: false
	};

	var BEAUTIFY_ALIAS = 'beautify';
	var KEEP_BREAKS_ALIAS = 'keep-breaks';

	var OPTION_SEPARATOR = ';';
	var OPTION_NAME_VALUE_SEPARATOR = ':';
	var HASH_VALUES_OPTION_SEPARATOR = ',';
	var HASH_VALUES_NAME_VALUE_SEPARATOR = '=';

	var FALSE_KEYWORD_1 = 'false';
	var FALSE_KEYWORD_2 = 'off';
	var TRUE_KEYWORD_1 = 'true';
	var TRUE_KEYWORD_2 = 'on';

	function breaks(value) {
	  var breakOptions = {};

	  breakOptions[Breaks.AfterAtRule] = value;
	  breakOptions[Breaks.AfterBlockBegins] = value;
	  breakOptions[Breaks.AfterBlockEnds] = value;
	  breakOptions[Breaks.AfterComment] = value;
	  breakOptions[Breaks.AfterProperty] = value;
	  breakOptions[Breaks.AfterRuleBegins] = value;
	  breakOptions[Breaks.AfterRuleEnds] = value;
	  breakOptions[Breaks.BeforeBlockEnds] = value;
	  breakOptions[Breaks.BetweenSelectors] = value;

	  return breakOptions;
	}

	function spaces(value) {
	  var spaceOptions = {};

	  spaceOptions[Spaces.AroundSelectorRelation] = value;
	  spaceOptions[Spaces.BeforeBlockBegins] = value;
	  spaceOptions[Spaces.BeforeValue] = value;

	  return spaceOptions;
	}

	function formatFrom(source) {
	  if (source === undefined || source === false) {
	    return false;
	  }

	  if (typeof source == 'object' && 'breakWith' in source) {
	    source = override(source, { breakWith: mapBreakWith(source.breakWith) });
	  }

	  if (typeof source == 'object' && 'indentBy' in source) {
	    source = override(source, { indentBy: parseInt(source.indentBy) });
	  }

	  if (typeof source == 'object' && 'indentWith' in source) {
	    source = override(source, { indentWith: mapIndentWith(source.indentWith) });
	  }

	  if (typeof source == 'object') {
	    return override(DEFAULTS, source);
	  }

	  if (typeof source == 'object') {
	    return override(DEFAULTS, source);
	  }

	  if (typeof source == 'string' && source == BEAUTIFY_ALIAS) {
	    return override(DEFAULTS, {
	      breaks: breaks(true),
	      indentBy: 2,
	      spaces: spaces(true)
	    });
	  }

	  if (typeof source == 'string' && source == KEEP_BREAKS_ALIAS) {
	    return override(DEFAULTS, {
	      breaks: {
	        afterAtRule: true,
	        afterBlockBegins: true,
	        afterBlockEnds: true,
	        afterComment: true,
	        afterRuleEnds: true,
	        beforeBlockEnds: true
	      }
	    });
	  }

	  if (typeof source == 'string') {
	    return override(DEFAULTS, toHash(source));
	  }

	  return DEFAULTS;
	}

	function toHash(string) {
	  return string
	    .split(OPTION_SEPARATOR)
	    .reduce(function (accumulator, directive) {
	      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];

	      if (name == 'breaks' || name == 'spaces') {
	        accumulator[name] = hashValuesToHash(value);
	      } else if (name == 'indentBy' || name == 'wrapAt') {
	        accumulator[name] = parseInt(value);
	      } else if (name == 'indentWith') {
	        accumulator[name] = mapIndentWith(value);
	      } else if (name == 'breakWith') {
	        accumulator[name] = mapBreakWith(value);
	      }

	      return accumulator;
	    }, {});
	}

	function hashValuesToHash(string) {
	  return string
	    .split(HASH_VALUES_OPTION_SEPARATOR)
	    .reduce(function (accumulator, directive) {
	      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];

	      accumulator[name] = normalizeValue(value);

	      return accumulator;
	    }, {});
	}


	function normalizeValue(value) {
	  switch (value) {
	    case FALSE_KEYWORD_1:
	    case FALSE_KEYWORD_2:
	      return false;
	    case TRUE_KEYWORD_1:
	    case TRUE_KEYWORD_2:
	      return true;
	    default:
	      return value;
	  }
	}

	function mapBreakWith(value) {
	  switch (value) {
	    case 'windows':
	    case 'crlf':
	    case BreakWith.CarriageReturnLineFeed:
	      return BreakWith.CarriageReturnLineFeed;
	    case 'unix':
	    case 'lf':
	    case BreakWith.LineFeed:
	      return BreakWith.LineFeed;
	    default:
	      return systemLineBreak;
	  }
	}

	function mapIndentWith(value) {
	  switch (value) {
	    case 'space':
	      return IndentWith.Space;
	    case 'tab':
	      return IndentWith.Tab;
	    default:
	      return value;
	  }
	}

	format$1 = {
	  Breaks: Breaks,
	  Spaces: Spaces,
	  formatFrom: formatFrom
	};
	return format$1;
}

var marker;
var hasRequiredMarker;

function requireMarker () {
	if (hasRequiredMarker) return marker;
	hasRequiredMarker = 1;
	var Marker = {
	  ASTERISK: '*',
	  AT: '@',
	  BACK_SLASH: '\\',
	  CARRIAGE_RETURN: '\r',
	  CLOSE_CURLY_BRACKET: '}',
	  CLOSE_ROUND_BRACKET: ')',
	  CLOSE_SQUARE_BRACKET: ']',
	  COLON: ':',
	  COMMA: ',',
	  DOUBLE_QUOTE: '"',
	  EXCLAMATION: '!',
	  FORWARD_SLASH: '/',
	  INTERNAL: '-clean-css-',
	  NEW_LINE_NIX: '\n',
	  OPEN_CURLY_BRACKET: '{',
	  OPEN_ROUND_BRACKET: '(',
	  OPEN_SQUARE_BRACKET: '[',
	  SEMICOLON: ';',
	  SINGLE_QUOTE: '\'',
	  SPACE: ' ',
	  TAB: '\t',
	  UNDERSCORE: '_'
	};

	marker = Marker;
	return marker;
}

var formatPosition_1;
var hasRequiredFormatPosition;

function requireFormatPosition () {
	if (hasRequiredFormatPosition) return formatPosition_1;
	hasRequiredFormatPosition = 1;
	function formatPosition(metadata) {
	  var line = metadata[0];
	  var column = metadata[1];
	  var source = metadata[2];

	  return source ?
	    source + ':' + line + ':' + column :
	    line + ':' + column;
	}

	formatPosition_1 = formatPosition;
	return formatPosition_1;
}

var tidyRules_1;
var hasRequiredTidyRules;

function requireTidyRules () {
	if (hasRequiredTidyRules) return tidyRules_1;
	hasRequiredTidyRules = 1;
	var Spaces = requireFormat$1().Spaces;
	var Marker = requireMarker();
	var formatPosition = requireFormatPosition();

	var CASE_ATTRIBUTE_PATTERN = /[\s"'][iI]\s*\]/;
	var CASE_RESTORE_PATTERN = /([\d\w])([iI])\]/g;
	var DOUBLE_QUOTE_CASE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g;
	var DOUBLE_QUOTE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g;
	var HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\s*)+/;
	var SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g;
	var SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g;
	var RELATION_PATTERN = /[>\+~]/;
	var WHITESPACE_PATTERN = /\s/;

	var ASTERISK_PLUS_HTML_HACK = '*+html ';
	var ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = '*:first-child+html ';
	var LESS_THAN = '<';

	function hasInvalidCharacters(value) {
	  var isEscaped;
	  var isInvalid = false;
	  var character;
	  var isQuote = false;
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {
	      isQuote = !isQuote;
	    } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {
	      isInvalid = true;
	      break;
	    } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {
	      isInvalid = true;
	      break;
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	  }

	  return isInvalid;
	}

	function removeWhitespace(value, format) {
	  var stripped = [];
	  var character;
	  var isNewLineNix;
	  var isNewLineWin;
	  var isEscaped;
	  var wasEscaped;
	  var isQuoted;
	  var isSingleQuoted;
	  var isDoubleQuoted;
	  var isAttribute;
	  var isRelation;
	  var isWhitespace;
	  var roundBracketLevel = 0;
	  var wasRelation = false;
	  var wasWhitespace = false;
	  var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);
	  var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    isNewLineNix = character == Marker.NEW_LINE_NIX;
	    isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;
	    isQuoted = isSingleQuoted || isDoubleQuoted;
	    isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);
	    isWhitespace = WHITESPACE_PATTERN.test(character);

	    if (wasEscaped && isQuoted && isNewLineWin) {
	      // swallow escaped new windows lines in comments
	      stripped.pop();
	      stripped.pop();
	    } else if (isEscaped && isQuoted && isNewLineNix) {
	      // swallow escaped new *nix lines in comments
	      stripped.pop();
	    } else if (isEscaped) {
	      stripped.push(character);
	    } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {
	      stripped.push(character);
	      isAttribute = true;
	    } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {
	      stripped.push(character);
	      isAttribute = false;
	    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {
	      stripped.push(character);
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {
	      stripped.push(character);
	      roundBracketLevel--;
	    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
	      stripped.push(character);
	      isSingleQuoted = true;
	    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
	      stripped.push(character);
	      isDoubleQuoted = true;
	    } else if (character == Marker.SINGLE_QUOTE && isQuoted) {
	      stripped.push(character);
	      isSingleQuoted = false;
	    } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {
	      stripped.push(character);
	      isDoubleQuoted = false;
	    } else if (isWhitespace && wasRelation && !spaceAroundRelation) {
	      continue;
	    } else if (!isWhitespace && wasRelation && spaceAroundRelation) {
	      stripped.push(Marker.SPACE);
	      stripped.push(character);
	    } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) ; else if (isWhitespace && wasWhitespace && !isQuoted) ; else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) ; else if (isRelation && wasWhitespace && !spaceAroundRelation) {
	      stripped.pop();
	      stripped.push(character);
	    } else if (isRelation && !wasWhitespace && spaceAroundRelation) {
	      stripped.push(Marker.SPACE);
	      stripped.push(character);
	    } else if (isWhitespace) {
	      stripped.push(Marker.SPACE);
	    } else {
	      stripped.push(character);
	    }

	    wasEscaped = isEscaped;
	    isEscaped = character == Marker.BACK_SLASH;
	    wasRelation = isRelation;
	    wasWhitespace = isWhitespace;
	  }

	  return withCaseAttribute ?
	    stripped.join('').replace(CASE_RESTORE_PATTERN, '$1 $2]') :
	    stripped.join('');
	}

	function removeQuotes(value) {
	  if (value.indexOf('\'') == -1 && value.indexOf('"') == -1) {
	    return value;
	  }

	  return value
	    .replace(SINGLE_QUOTE_CASE_PATTERN, '=$1 $2')
	    .replace(SINGLE_QUOTE_PATTERN, '=$1$2')
	    .replace(DOUBLE_QUOTE_CASE_PATTERN, '=$1 $2')
	    .replace(DOUBLE_QUOTE_PATTERN, '=$1$2');
	}

	function tidyRules(rules, removeUnsupported, adjacentSpace, format, warnings) {
	  var list = [];
	  var repeated = [];

	  function removeHTMLComment(rule, match) {
	    warnings.push('HTML comment \'' + match + '\' at ' + formatPosition(rule[2][0]) + '. Removing.');
	    return '';
	  }

	  for (var i = 0, l = rules.length; i < l; i++) {
	    var rule = rules[i];
	    var reduced = rule[1];

	    reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));

	    if (hasInvalidCharacters(reduced)) {
	      warnings.push('Invalid selector \'' + rule[1] + '\' at ' + formatPosition(rule[2][0]) + '. Ignoring.');
	      continue;
	    }

	    reduced = removeWhitespace(reduced, format);
	    reduced = removeQuotes(reduced);

	    if (adjacentSpace && reduced.indexOf('nav') > 0) {
	      reduced = reduced.replace(/\+nav(\S|$)/, '+ nav$1');
	    }

	    if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {
	      continue;
	    }

	    if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {
	      continue;
	    }

	    if (reduced.indexOf('*') > -1) {
	      reduced = reduced
	        .replace(/\*([:#\.\[])/g, '$1')
	        .replace(/^(\:first\-child)?\+html/, '*$1+html');
	    }

	    if (repeated.indexOf(reduced) > -1) {
	      continue;
	    }

	    rule[1] = reduced;
	    repeated.push(reduced);
	    list.push(rule);
	  }

	  if (list.length == 1 && list[0][1].length === 0) {
	    warnings.push('Empty selector \'' + list[0][1] + '\' at ' + formatPosition(list[0][2][0]) + '. Ignoring.');
	    list = [];
	  }

	  return list;
	}

	tidyRules_1 = tidyRules;
	return tidyRules_1;
}

var tidyBlock_1;
var hasRequiredTidyBlock;

function requireTidyBlock () {
	if (hasRequiredTidyBlock) return tidyBlock_1;
	hasRequiredTidyBlock = 1;
	var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\W/;

	function tidyBlock(values, spaceAfterClosingBrace) {
	  var withoutSpaceAfterClosingBrace;
	  var i;

	  for (i = values.length - 1; i >= 0; i--) {
	    withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);

	    values[i][1] = values[i][1]
	      .replace(/\n|\r\n/g, ' ')
	      .replace(/\s+/g, ' ')
	      .replace(/(,|:|\() /g, '$1')
	      .replace(/ \)/g, ')')
	      .replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, '$1')
	      .replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, '$1')
	      .replace(withoutSpaceAfterClosingBrace ? /\) /g : null, ')');
	  }

	  return values;
	}

	tidyBlock_1 = tidyBlock;
	return tidyBlock_1;
}

var tidyAtRule_1;
var hasRequiredTidyAtRule;

function requireTidyAtRule () {
	if (hasRequiredTidyAtRule) return tidyAtRule_1;
	hasRequiredTidyAtRule = 1;
	function tidyAtRule(value) {
	  return value
	    .replace(/\s+/g, ' ')
	    .replace(/url\(\s+/g, 'url(')
	    .replace(/\s+\)/g, ')')
	    .trim();
	}

	tidyAtRule_1 = tidyAtRule;
	return tidyAtRule_1;
}

var hack;
var hasRequiredHack;

function requireHack () {
	if (hasRequiredHack) return hack;
	hasRequiredHack = 1;
	var Hack = {
	  ASTERISK: 'asterisk',
	  BANG: 'bang',
	  BACKSLASH: 'backslash',
	  UNDERSCORE: 'underscore'
	};

	hack = Hack;
	return hack;
}

var removeUnused_1;
var hasRequiredRemoveUnused;

function requireRemoveUnused () {
	if (hasRequiredRemoveUnused) return removeUnused_1;
	hasRequiredRemoveUnused = 1;
	function removeUnused(properties) {
	  for (var i = properties.length - 1; i >= 0; i--) {
	    var property = properties[i];

	    if (property.unused) {
	      property.all.splice(property.position, 1);
	    }
	  }
	}

	removeUnused_1 = removeUnused;
	return removeUnused_1;
}

var restoreFromOptimizing_1;
var hasRequiredRestoreFromOptimizing;

function requireRestoreFromOptimizing () {
	if (hasRequiredRestoreFromOptimizing) return restoreFromOptimizing_1;
	hasRequiredRestoreFromOptimizing = 1;
	var Hack = requireHack();

	var Marker = requireMarker();

	var ASTERISK_HACK = '*';
	var BACKSLASH_HACK = '\\';
	var IMPORTANT_TOKEN = '!important';
	var UNDERSCORE_HACK = '_';
	var BANG_HACK = '!ie';

	function restoreFromOptimizing(properties, restoreCallback) {
	  var property;
	  var restored;
	  var current;
	  var i;

	  for (i = properties.length - 1; i >= 0; i--) {
	    property = properties[i];

	    if (property.unused) {
	      continue;
	    }

	    if (!property.dirty && !property.important && !property.hack) {
	      continue;
	    }

	    if (restoreCallback) {
	      restored = restoreCallback(property);
	      property.value = restored;
	    } else {
	      restored = property.value;
	    }

	    if (property.important) {
	      restoreImportant(property);
	    }

	    if (property.hack) {
	      restoreHack(property);
	    }

	    if ('all' in property) {
	      current = property.all[property.position];
	      current[1][1] = property.name;

	      current.splice(2, current.length - 1);
	      Array.prototype.push.apply(current, restored);
	    }
	  }
	}

	function restoreImportant(property) {
	  property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;
	}

	function restoreHack(property) {
	  if (property.hack[0] == Hack.UNDERSCORE) {
	    property.name = UNDERSCORE_HACK + property.name;
	  } else if (property.hack[0] == Hack.ASTERISK) {
	    property.name = ASTERISK_HACK + property.name;
	  } else if (property.hack[0] == Hack.BACKSLASH) {
	    property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];
	  } else if (property.hack[0] == Hack.BANG) {
	    property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;
	  }
	}

	restoreFromOptimizing_1 = restoreFromOptimizing;
	return restoreFromOptimizing_1;
}

var token;
var hasRequiredToken;

function requireToken () {
	if (hasRequiredToken) return token;
	hasRequiredToken = 1;
	var Token = {
	  AT_RULE: 'at-rule', // e.g. `@import`, `@charset`
	  AT_RULE_BLOCK: 'at-rule-block', // e.g. `@font-face{...}`
	  AT_RULE_BLOCK_SCOPE: 'at-rule-block-scope', // e.g. `@font-face`
	  COMMENT: 'comment', // e.g. `/* comment */`
	  NESTED_BLOCK: 'nested-block', // e.g. `@media screen{...}`, `@keyframes animation {...}`
	  NESTED_BLOCK_SCOPE: 'nested-block-scope', // e.g. `@media`, `@keyframes`
	  PROPERTY: 'property', // e.g. `color:red`
	  PROPERTY_BLOCK: 'property-block', // e.g. `--var:{color:red}`
	  PROPERTY_NAME: 'property-name', // e.g. `color`
	  PROPERTY_VALUE: 'property-value', // e.g. `red`
	  RAW: 'raw', // e.g. anything between /* clean-css ignore:start */ and /* clean-css ignore:end */ comments
	  RULE: 'rule', // e.g `div > a{...}`
	  RULE_SCOPE: 'rule-scope' // e.g `div > a`
	};

	token = Token;
	return token;
}

var wrapForOptimizing;
var hasRequiredWrapForOptimizing;

function requireWrapForOptimizing () {
	if (hasRequiredWrapForOptimizing) return wrapForOptimizing;
	hasRequiredWrapForOptimizing = 1;
	var Hack = requireHack();

	var Marker = requireMarker();
	var Token = requireToken();

	var Match = {
	  ASTERISK: '*',
	  BACKSLASH: '\\',
	  BANG: '!',
	  BANG_SUFFIX_PATTERN: /!\w+$/,
	  IMPORTANT_TOKEN_PATTERN: new RegExp('!important$', 'i'),
	  IMPORTANT_WORD_PATTERN: new RegExp('important$', 'i'),
	  SUFFIX_BANG_PATTERN: /!$/,
	  UNDERSCORE: '_',
	  VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
	};

	function wrapAll(properties, includeVariable, skipProperties) {
	  var wrapped = [];
	  var single;
	  var property;
	  var i;

	  for (i = properties.length - 1; i >= 0; i--) {
	    property = properties[i];

	    if (property[0] != Token.PROPERTY) {
	      continue;
	    }

	    if (!includeVariable && someVariableReferences(property)) {
	      continue;
	    }

	    if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {
	      continue;
	    }

	    single = wrapSingle(property);
	    single.all = properties;
	    single.position = i;
	    wrapped.unshift(single);
	  }

	  return wrapped;
	}

	function someVariableReferences(property) {
	  var i, l;
	  var value;

	  // skipping `property` and property name tokens
	  for (i = 2, l = property.length; i < l; i++) {
	    value = property[i];

	    if (value[0] != Token.PROPERTY_VALUE) {
	      continue;
	    }

	    if (isVariableReference(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function isVariableReference(value) {
	  return Match.VARIABLE_REFERENCE_PATTERN.test(value);
	}

	function isMultiplex(property) {
	  var value;
	  var i, l;

	  for (i = 3, l = property.length; i < l; i++) {
	    value = property[i];

	    if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {
	      return true;
	    }
	  }

	  return false;
	}

	function hackFrom(property) {
	  var match = false;
	  var name = property[1][1];
	  var lastValue = property[property.length - 1];

	  if (name[0] == Match.UNDERSCORE) {
	    match = [Hack.UNDERSCORE];
	  } else if (name[0] == Match.ASTERISK) {
	    match = [Hack.ASTERISK];
	  } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {
	    match = [Hack.BANG];
	  } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {
	    match = [Hack.BANG];
	  } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {
	    match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];
	  } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {
	    match = [Hack.BACKSLASH, lastValue[1].substring(1)];
	  }

	  return match;
	}

	function isImportant(property) {
	  if (property.length < 3)
	    return false;

	  var lastValue = property[property.length - 1];
	  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
	    return true;
	  } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {
	    return true;
	  }

	  return false;
	}

	function stripImportant(property) {
	  var lastValue = property[property.length - 1];
	  var oneButLastValue = property[property.length - 2];

	  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
	    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, '');
	  } else {
	    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, '');
	    oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, '');
	  }

	  if (lastValue[1].length === 0) {
	    property.pop();
	  }

	  if (oneButLastValue[1].length === 0) {
	    property.pop();
	  }
	}

	function stripPrefixHack(property) {
	  property[1][1] = property[1][1].substring(1);
	}

	function stripSuffixHack(property, hackFrom) {
	  var lastValue = property[property.length - 1];
	  lastValue[1] = lastValue[1]
	    .substring(0, lastValue[1].indexOf(hackFrom[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG))
	    .trim();

	  if (lastValue[1].length === 0) {
	    property.pop();
	  }
	}

	function wrapSingle(property) {
	  var importantProperty = isImportant(property);
	  if (importantProperty) {
	    stripImportant(property);
	  }

	  var whichHack = hackFrom(property);
	  if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {
	    stripPrefixHack(property);
	  } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {
	    stripSuffixHack(property, whichHack);
	  }

	  return {
	    block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,
	    components: [],
	    dirty: false,
	    hack: whichHack,
	    important: importantProperty,
	    name: property[1][1],
	    multiplex: property.length > 3 ? isMultiplex(property) : false,
	    position: 0,
	    shorthand: false,
	    unused: false,
	    value: property.slice(2)
	  };
	}

	wrapForOptimizing = {
	  all: wrapAll,
	  single: wrapSingle
	};
	return wrapForOptimizing;
}

var roundingPrecision;
var hasRequiredRoundingPrecision;

function requireRoundingPrecision () {
	if (hasRequiredRoundingPrecision) return roundingPrecision;
	hasRequiredRoundingPrecision = 1;
	var override = requireOverride();

	var INTEGER_PATTERN = /^\d+$/;

	var ALL_UNITS = ['*', 'all'];
	var DEFAULT_PRECISION = 'off'; // all precision changes are disabled
	var DIRECTIVES_SEPARATOR = ','; // e.g. *=5,px=3
	var DIRECTIVE_VALUE_SEPARATOR = '='; // e.g. *=5

	function roundingPrecisionFrom(source) {
	  return override(defaults(DEFAULT_PRECISION), buildPrecisionFrom(source));
	}

	function defaults(value) {
	  return {
	    'ch': value,
	    'cm': value,
	    'em': value,
	    'ex': value,
	    'in': value,
	    'mm': value,
	    'pc': value,
	    'pt': value,
	    'px': value,
	    'q': value,
	    'rem': value,
	    'vh': value,
	    'vmax': value,
	    'vmin': value,
	    'vw': value,
	    '%': value
	  };
	}

	function buildPrecisionFrom(source) {
	  if (source === null || source === undefined) {
	    return {};
	  }

	  if (typeof source == 'boolean') {
	    return {};
	  }

	  if (typeof source == 'number' && source == -1) {
	    return defaults(DEFAULT_PRECISION);
	  }

	  if (typeof source == 'number') {
	    return defaults(source);
	  }

	  if (typeof source == 'string' && INTEGER_PATTERN.test(source)) {
	    return defaults(parseInt(source));
	  }

	  if (typeof source == 'string' && source == DEFAULT_PRECISION) {
	    return defaults(DEFAULT_PRECISION);
	  }

	  if (typeof source == 'object') {
	    return source;
	  }

	  return source
	    .split(DIRECTIVES_SEPARATOR)
	    .reduce(function (accumulator, directive) {
	      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);
	      var name = directiveParts[0];
	      var value = parseInt(directiveParts[1]);

	      if (isNaN(value) || value == -1) {
	        value = DEFAULT_PRECISION;
	      }

	      if (ALL_UNITS.indexOf(name) > -1) {
	        accumulator = override(accumulator, defaults(value));
	      } else {
	        accumulator[name] = value;
	      }

	      return accumulator;
	    }, {});
	}

	roundingPrecision = {
	  DEFAULT: DEFAULT_PRECISION,
	  roundingPrecisionFrom: roundingPrecisionFrom
	};
	return roundingPrecision;
}

var optimizationLevel;
var hasRequiredOptimizationLevel;

function requireOptimizationLevel () {
	if (hasRequiredOptimizationLevel) return optimizationLevel;
	hasRequiredOptimizationLevel = 1;
	var roundingPrecisionFrom = requireRoundingPrecision().roundingPrecisionFrom;

	var override = requireOverride();

	var OptimizationLevel = {
	  Zero: '0',
	  One: '1',
	  Two: '2'
	};

	var DEFAULTS = {};

	DEFAULTS[OptimizationLevel.Zero] = {};
	DEFAULTS[OptimizationLevel.One] = {
	  cleanupCharsets: true,
	  normalizeUrls: true,
	  optimizeBackground: true,
	  optimizeBorderRadius: true,
	  optimizeFilter: true,
	  optimizeFontWeight: true,
	  optimizeOutline: true,
	  removeEmpty: true,
	  removeNegativePaddings: true,
	  removeQuotes: true,
	  removeWhitespace: true,
	  replaceMultipleZeros: true,
	  replaceTimeUnits: true,
	  replaceZeroUnits: true,
	  roundingPrecision: roundingPrecisionFrom(undefined),
	  selectorsSortingMethod: 'standard',
	  specialComments: 'all',
	  tidyAtRules: true,
	  tidyBlockScopes: true,
	  tidySelectors: true,
	  transform: noop
	};
	DEFAULTS[OptimizationLevel.Two] = {
	  mergeAdjacentRules: true,
	  mergeIntoShorthands: true,
	  mergeMedia: true,
	  mergeNonAdjacentRules: true,
	  mergeSemantically: false,
	  overrideProperties: true,
	  removeEmpty: true,
	  reduceNonAdjacentRules: true,
	  removeDuplicateFontRules: true,
	  removeDuplicateMediaBlocks: true,
	  removeDuplicateRules: true,
	  removeUnusedAtRules: false,
	  restructureRules: false,
	  skipProperties: []
	};

	var ALL_KEYWORD_1 = '*';
	var ALL_KEYWORD_2 = 'all';
	var FALSE_KEYWORD_1 = 'false';
	var FALSE_KEYWORD_2 = 'off';
	var TRUE_KEYWORD_1 = 'true';
	var TRUE_KEYWORD_2 = 'on';

	var LIST_VALUE_SEPARATOR = ',';
	var OPTION_SEPARATOR = ';';
	var OPTION_VALUE_SEPARATOR = ':';

	function noop() {}

	function optimizationLevelFrom(source) {
	  var level = override(DEFAULTS, {});
	  var Zero = OptimizationLevel.Zero;
	  var One = OptimizationLevel.One;
	  var Two = OptimizationLevel.Two;


	  if (undefined === source) {
	    delete level[Two];
	    return level;
	  }

	  if (typeof source == 'string') {
	    source = parseInt(source);
	  }

	  if (typeof source == 'number' && source === parseInt(Two)) {
	    return level;
	  }

	  if (typeof source == 'number' && source === parseInt(One)) {
	    delete level[Two];
	    return level;
	  }

	  if (typeof source == 'number' && source === parseInt(Zero)) {
	    delete level[Two];
	    delete level[One];
	    return level;
	  }

	  if (typeof source == 'object') {
	    source = covertValuesToHashes(source);
	  }

	  if (One in source && 'roundingPrecision' in source[One]) {
	    source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);
	  }

	  if (Two in source && 'skipProperties' in source[Two] && typeof(source[Two].skipProperties) == 'string') {
	    source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);
	  }

	  if (Zero in source || One in source || Two in source) {
	    level[Zero] = override(level[Zero], source[Zero]);
	  }

	  if (One in source && ALL_KEYWORD_1 in source[One]) {
	    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_1])));
	    delete source[One][ALL_KEYWORD_1];
	  }

	  if (One in source && ALL_KEYWORD_2 in source[One]) {
	    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_2])));
	    delete source[One][ALL_KEYWORD_2];
	  }

	  if (One in source || Two in source) {
	    level[One] = override(level[One], source[One]);
	  } else {
	    delete level[One];
	  }

	  if (Two in source && ALL_KEYWORD_1 in source[Two]) {
	    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));
	    delete source[Two][ALL_KEYWORD_1];
	  }

	  if (Two in source && ALL_KEYWORD_2 in source[Two]) {
	    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));
	    delete source[Two][ALL_KEYWORD_2];
	  }

	  if (Two in source) {
	    level[Two] = override(level[Two], source[Two]);
	  } else {
	    delete level[Two];
	  }

	  return level;
	}

	function defaults(level, value) {
	  var options = override(DEFAULTS[level], {});
	  var key;

	  for (key in options) {
	    if (typeof options[key] == 'boolean') {
	      options[key] = value;
	    }
	  }

	  return options;
	}

	function normalizeValue(value) {
	  switch (value) {
	    case FALSE_KEYWORD_1:
	    case FALSE_KEYWORD_2:
	      return false;
	    case TRUE_KEYWORD_1:
	    case TRUE_KEYWORD_2:
	      return true;
	    default:
	      return value;
	  }
	}

	function covertValuesToHashes(source) {
	  var clonedSource = override(source, {});
	  var level;
	  var i;

	  for (i = 0; i <= 2; i++) {
	    level = '' + i;

	    if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {
	      delete clonedSource[level];
	    }

	    if (level in clonedSource && clonedSource[level] === true) {
	      clonedSource[level] = {};
	    }

	    if (level in clonedSource && typeof clonedSource[level] == 'string') {
	      clonedSource[level] = covertToHash(clonedSource[level], level);
	    }
	  }

	  return clonedSource;
	}

	function covertToHash(asString, level) {
	  return asString
	    .split(OPTION_SEPARATOR)
	    .reduce(function (accumulator, directive) {
	      var parts = directive.split(OPTION_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];
	      var normalizedValue = normalizeValue(value);

	      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {
	        accumulator = override(accumulator, defaults(level, normalizedValue));
	      } else {
	        accumulator[name] = normalizedValue;
	      }

	      return accumulator;
	    }, {});
	}

	optimizationLevel = {
	  OptimizationLevel: OptimizationLevel,
	  optimizationLevelFrom: optimizationLevelFrom,
	};
	return optimizationLevel;
}

var split_1;
var hasRequiredSplit;

function requireSplit () {
	if (hasRequiredSplit) return split_1;
	hasRequiredSplit = 1;
	var Marker = requireMarker();

	function split(value, separator) {
	  var openLevel = Marker.OPEN_ROUND_BRACKET;
	  var closeLevel = Marker.CLOSE_ROUND_BRACKET;
	  var level = 0;
	  var cursor = 0;
	  var lastStart = 0;
	  var lastValue;
	  var lastCharacter;
	  var len = value.length;
	  var parts = [];

	  if (value.indexOf(separator) == -1) {
	    return [value];
	  }

	  if (value.indexOf(openLevel) == -1) {
	    return value.split(separator);
	  }

	  while (cursor < len) {
	    if (value[cursor] == openLevel) {
	      level++;
	    } else if (value[cursor] == closeLevel) {
	      level--;
	    }

	    if (level === 0 && cursor > 0 && cursor + 1 < len && value[cursor] == separator) {
	      parts.push(value.substring(lastStart, cursor));
	      lastStart = cursor + 1;
	    }

	    cursor++;
	  }

	  if (lastStart < cursor + 1) {
	    lastValue = value.substring(lastStart);
	    lastCharacter = lastValue[lastValue.length - 1];
	    if (lastCharacter == separator) {
	      lastValue = lastValue.substring(0, lastValue.length - 1);
	    }

	    parts.push(lastValue);
	  }

	  return parts;
	}

	split_1 = split;
	return split_1;
}

var helpers;
var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	var emptyCharacter = '';

	var Breaks = requireFormat$1().Breaks;
	var Spaces = requireFormat$1().Spaces;

	var Marker = requireMarker();
	var Token = requireToken();

	function supportsAfterClosingBrace(token) {
	  return token[1][1] == 'background' || token[1][1] == 'transform' || token[1][1] == 'src';
	}

	function afterClosingBrace(token, valueIndex) {
	  return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;
	}

	function afterComma(token, valueIndex) {
	  return token[valueIndex][1] == Marker.COMMA;
	}

	function afterSlash(token, valueIndex) {
	  return token[valueIndex][1] == Marker.FORWARD_SLASH;
	}

	function beforeComma(token, valueIndex) {
	  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;
	}

	function beforeSlash(token, valueIndex) {
	  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;
	}

	function inFilter(token) {
	  return token[1][1] == 'filter' || token[1][1] == '-ms-filter';
	}

	function disallowsSpace(context, token, valueIndex) {
	  return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) ||
	    beforeSlash(token, valueIndex) ||
	    afterSlash(token, valueIndex) ||
	    beforeComma(token, valueIndex) ||
	    afterComma(token, valueIndex);
	}

	function rules(context, tokens) {
	  var store = context.store;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    store(context, tokens[i]);

	    if (i < l - 1) {
	      store(context, comma(context));
	    }
	  }
	}

	function body(context, tokens) {
	  var lastPropertyAt = lastPropertyIndex(tokens);

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    property(context, tokens, i, lastPropertyAt);
	  }
	}

	function lastPropertyIndex(tokens) {
	  var index = tokens.length - 1;

	  for (; index >= 0; index--) {
	    if (tokens[index][0] != Token.COMMENT) {
	      break;
	    }
	  }

	  return index;
	}

	function property(context, tokens, position, lastPropertyAt) {
	  var store = context.store;
	  var token = tokens[position];

	  var propertyValue = token[2];
	  var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;

	  var needsSemicolon;
	  if ( context.format ) {
	    if ( context.format.semicolonAfterLastProperty || isPropertyBlock ) {
	      needsSemicolon = true;
	    } else if ( position < lastPropertyAt ) {
	      needsSemicolon = true;
	    } else {
	      needsSemicolon = false;
	    }
	  } else {
	    needsSemicolon = position < lastPropertyAt || isPropertyBlock;
	  }

	  var isLast = position === lastPropertyAt;

	  switch (token[0]) {
	    case Token.AT_RULE:
	      store(context, token);
	      store(context, semicolon(context, Breaks.AfterProperty, false));
	      break;
	    case Token.AT_RULE_BLOCK:
	      rules(context, token[1]);
	      store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	      body(context, token[2]);
	      store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	      break;
	    case Token.COMMENT:
	      store(context, token);
	      break;
	    case Token.PROPERTY:
	      store(context, token[1]);
	      store(context, colon(context));
	      if (propertyValue) {
	        value(context, token);
	      }
	      store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);
	      break;
	    case Token.RAW:
	      store(context, token);
	  }
	}

	function value(context, token) {
	  var store = context.store;
	  var j, m;

	  if (token[2][0] == Token.PROPERTY_BLOCK) {
	    store(context, openBrace(context, Breaks.AfterBlockBegins, false));
	    body(context, token[2][1]);
	    store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));
	  } else {
	    for (j = 2, m = token.length; j < m; j++) {
	      store(context, token[j]);

	      if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {
	        store(context, Marker.SPACE);
	      }
	    }
	  }
	}

	function allowsBreak(context, where) {
	  return context.format && context.format.breaks[where];
	}

	function allowsSpace(context, where) {
	  return context.format && context.format.spaces[where];
	}

	function openBrace(context, where, needsPrefixSpace) {
	  if (context.format) {
	    context.indentBy += context.format.indentBy;
	    context.indentWith = context.format.indentWith.repeat(context.indentBy);
	    return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) +
	      Marker.OPEN_CURLY_BRACKET +
	      (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) +
	      context.indentWith;
	  } else {
	    return Marker.OPEN_CURLY_BRACKET;
	  }
	}

	function closeBrace(context, where, beforeBlockEnd, isLast) {
	  if (context.format) {
	    context.indentBy -= context.format.indentBy;
	    context.indentWith = context.format.indentWith.repeat(context.indentBy);
	    return (allowsBreak(context, Breaks.AfterProperty) || beforeBlockEnd && allowsBreak(context, Breaks.BeforeBlockEnds) ? context.format.breakWith : emptyCharacter) +
	      context.indentWith +
	      Marker.CLOSE_CURLY_BRACKET +
	      (isLast ? emptyCharacter : (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith);
	  } else {
	    return Marker.CLOSE_CURLY_BRACKET;
	  }
	}

	function colon(context) {
	  return context.format ?
	    Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) :
	    Marker.COLON;
	}

	function semicolon(context, where, isLast) {
	  return context.format ?
	    Marker.SEMICOLON + (isLast || !allowsBreak(context, where) ? emptyCharacter : context.format.breakWith + context.indentWith) :
	    Marker.SEMICOLON;
	}

	function comma(context) {
	  return context.format ?
	    Marker.COMMA + (allowsBreak(context, Breaks.BetweenSelectors) ? context.format.breakWith : emptyCharacter) + context.indentWith :
	    Marker.COMMA;
	}

	function all(context, tokens) {
	  var store = context.store;
	  var token;
	  var isLast;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    isLast = i == l - 1;

	    switch (token[0]) {
	      case Token.AT_RULE:
	        store(context, token);
	        store(context, semicolon(context, Breaks.AfterAtRule, isLast));
	        break;
	      case Token.AT_RULE_BLOCK:
	        rules(context, token[1]);
	        store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	        body(context, token[2]);
	        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	        break;
	      case Token.NESTED_BLOCK:
	        rules(context, token[1]);
	        store(context, openBrace(context, Breaks.AfterBlockBegins, true));
	        all(context, token[2]);
	        store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));
	        break;
	      case Token.COMMENT:
	        store(context, token);
	        store(context, allowsBreak(context, Breaks.AfterComment) ? context.format.breakWith : emptyCharacter);
	        break;
	      case Token.RAW:
	        store(context, token);
	        break;
	      case Token.RULE:
	        rules(context, token[1]);
	        store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	        body(context, token[2]);
	        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	        break;
	    }
	  }
	}

	helpers = {
	  all: all,
	  body: body,
	  property: property,
	  rules: rules,
	  value: value
	};
	return helpers;
}

var oneTime;
var hasRequiredOneTime;

function requireOneTime () {
	if (hasRequiredOneTime) return oneTime;
	hasRequiredOneTime = 1;
	var helpers = requireHelpers();

	function store(serializeContext, token) {
	  serializeContext.output.push(typeof token == 'string' ? token : token[1]);
	}

	function context() {
	  var newContext = {
	    output: [],
	    store: store
	  };

	  return newContext;
	}

	function all(tokens) {
	  var oneTimeContext = context();
	  helpers.all(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function body(tokens) {
	  var oneTimeContext = context();
	  helpers.body(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function property(tokens, position) {
	  var oneTimeContext = context();
	  helpers.property(oneTimeContext, tokens, position, true);
	  return oneTimeContext.output.join('');
	}

	function rules(tokens) {
	  var oneTimeContext = context();
	  helpers.rules(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function value(tokens) {
	  var oneTimeContext = context();
	  helpers.value(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	oneTime = {
	  all: all,
	  body: body,
	  property: property,
	  rules: rules,
	  value: value
	};
	return oneTime;
}

var optimize$2;
var hasRequiredOptimize$2;

function requireOptimize$2 () {
	if (hasRequiredOptimize$2) return optimize$2;
	hasRequiredOptimize$2 = 1;
	var shortenHex = requireShortenHex();
	var shortenHsl = requireShortenHsl();
	var shortenRgb = requireShortenRgb();
	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();
	var tidyBlock = requireTidyBlock();
	var tidyAtRule = requireTidyAtRule();

	var Hack = requireHack();
	var removeUnused = requireRemoveUnused();
	var restoreFromOptimizing = requireRestoreFromOptimizing();
	var wrapForOptimizing = requireWrapForOptimizing().all;

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var Token = requireToken();
	var Marker = requireMarker();

	var formatPosition = requireFormatPosition();
	var split = requireSplit();

	var serializeRules = requireOneTime().rules;

	var IgnoreProperty = 'ignore-property';

	var CHARSET_TOKEN = '@charset';
	var CHARSET_REGEXP = new RegExp('^' + CHARSET_TOKEN, 'i');

	var DEFAULT_ROUNDING_PRECISION = requireRoundingPrecision().DEFAULT;

	var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
	var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;

	var HEX_VALUE_PATTERN = /[0-9a-f]/i;
	var PROPERTY_NAME_PATTERN = /^(?:\-chrome\-|\-[\w\-]+\w|\w[\w\-]+\w|\-\-\S+)$/;
	var IMPORT_PREFIX_PATTERN = /^@import/i;
	var QUOTED_PATTERN = /^('.*'|".*")$/;
	var QUOTED_BUT_SAFE_PATTERN = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/;
	var URL_PREFIX_PATTERN = /^url\(/i;
	var LOCAL_PREFIX_PATTERN = /^local\(/i;
	var VARIABLE_NAME_PATTERN = /^--\S+$/;

	function isLocal(value){
	  return LOCAL_PREFIX_PATTERN.test(value);
	}

	function isNegative(value) {
	  return value && value[1][0] == '-' && parseFloat(value[1]) < 0;
	}

	function isQuoted(value) {
	  return QUOTED_PATTERN.test(value);
	}

	function isUrl(value) {
	  return URL_PREFIX_PATTERN.test(value);
	}

	function normalizeUrl(value) {
	  return value
	    .replace(URL_PREFIX_PATTERN, 'url(')
	    .replace(/\\?\n|\\?\r\n/g, '');
	}

	function optimizeBackground(property) {
	  var values = property.value;

	  if (values.length == 1 && values[0][1] == 'none') {
	    values[0][1] = '0 0';
	  }

	  if (values.length == 1 && values[0][1] == 'transparent') {
	    values[0][1] = '0 0';
	  }
	}

	function optimizeBorderRadius(property) {
	  var values = property.value;
	  var spliceAt;

	  if (values.length == 3 && values[1][1] == '/' && values[0][1] == values[2][1]) {
	    spliceAt = 1;
	  } else if (values.length == 5 && values[2][1] == '/' && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {
	    spliceAt = 2;
	  } else if (values.length == 7 && values[3][1] == '/' && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {
	    spliceAt = 3;
	  } else if (values.length == 9 && values[4][1] == '/' && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {
	    spliceAt = 4;
	  }

	  if (spliceAt) {
	    property.value.splice(spliceAt);
	    property.dirty = true;
	  }
	}

	/**
	 * @param {string} name
	 * @param {string} value
	 * @param {Object} compatibility
	 * @return {string}
	 */
	function optimizeColors(name, value, compatibility) {
	  if (!value.match(/#|rgb|hsl/gi)) {
	    return shortenHex(value);
	  }

	  value = value
	    .replace(/(rgb|hsl)a?\((\-?\d+),(\-?\d+\%?),(\-?\d+\%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi, function (match, colorFn, p1, p2, p3, alpha) {
	      return (parseInt(alpha, 10) >= 1 ? colorFn + '(' + [p1,p2,p3].join(',') + ')' : match);
	    })
	    .replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/gi, function (match, red, green, blue) {
	      return shortenRgb(red, green, blue);
	    })
	    .replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi, function (match, hue, saturation, lightness) {
	      return shortenHsl(hue, saturation, lightness);
	    })
	    .replace(/(^|[^='"])#([0-9a-f]{6})/gi, function (match, prefix, color, at, inputValue) {
	      var suffix = inputValue[at + match.length];

	      if (suffix && HEX_VALUE_PATTERN.test(suffix)) {
	        return match;
	      } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {
	        return (prefix + '#' + color[0] + color[2] + color[4]).toLowerCase();
	      } else {
	        return (prefix + '#' + color).toLowerCase();
	      }
	    })
	    .replace(/(^|[^='"])#([0-9a-f]{3})/gi, function (match, prefix, color) {
	      return prefix + '#' + color.toLowerCase();
	    })
	    .replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/gi, function (match, colorFunction, colorDef) {
	      var tokens = colorDef.split(',');
	      var colorFnLowercase = colorFunction && colorFunction.toLowerCase();
	      var applies = (colorFnLowercase == 'hsl' && tokens.length == 3) ||
	        (colorFnLowercase == 'hsla' && tokens.length == 4) ||
	        (colorFnLowercase == 'rgb' && tokens.length === 3 && colorDef.indexOf('%') > 0) ||
	        (colorFnLowercase == 'rgba' && tokens.length == 4 && colorDef.indexOf('%') > 0);

	      if (!applies) {
	        return match;
	      }

	      if (tokens[1].indexOf('%') == -1) {
	        tokens[1] += '%';
	      }

	      if (tokens[2].indexOf('%') == -1) {
	        tokens[2] += '%';
	      }

	      return colorFunction + '(' + tokens.join(',') + ')';
	    });

	  if (compatibility.colors.opacity && name.indexOf('background') == -1) {
	    value = value.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, function (match) {
	      if (split(value, ',').pop().indexOf('gradient(') > -1) {
	        return match;
	      }

	      return 'transparent';
	    });
	  }

	  return shortenHex(value);
	}

	function optimizeFilter(property) {
	  if (property.value.length == 1) {
	    property.value[0][1] = property.value[0][1].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, function (match, filter, suffix) {
	      return filter.toLowerCase() + suffix;
	    });
	  }

	  property.value[0][1] = property.value[0][1]
	    .replace(/,(\S)/g, ', $1')
	    .replace(/ ?= ?/g, '=');
	}

	function optimizeFontWeight(property, atIndex) {
	  var value = property.value[atIndex][1];

	  if (value == 'normal') {
	    value = '400';
	  } else if (value == 'bold') {
	    value = '700';
	  }

	  property.value[atIndex][1] = value;
	}

	function optimizeMultipleZeros(property) {
	  var values = property.value;
	  var spliceAt;

	  if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {
	    if (property.name.indexOf('box-shadow') > -1) {
	      spliceAt = 2;
	    } else {
	      spliceAt = 1;
	    }
	  }

	  if (spliceAt) {
	    property.value.splice(spliceAt);
	    property.dirty = true;
	  }
	}

	function optimizeOutline(property) {
	  var values = property.value;

	  if (values.length == 1 && values[0][1] == 'none') {
	    values[0][1] = '0';
	  }
	}

	function optimizePixelLengths(_, value, compatibility) {
	  if (!WHOLE_PIXEL_VALUE.test(value)) {
	    return value;
	  }

	  return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {
	    var newValue;
	    var intVal = parseInt(val);

	    if (intVal === 0) {
	      return match;
	    }

	    if (compatibility.properties.shorterLengthUnits && compatibility.units.pt && intVal * 3 % 4 === 0) {
	      newValue = intVal * 3 / 4 + 'pt';
	    }

	    if (compatibility.properties.shorterLengthUnits && compatibility.units.pc && intVal % 16 === 0) {
	      newValue = intVal / 16 + 'pc';
	    }

	    if (compatibility.properties.shorterLengthUnits && compatibility.units.in && intVal % 96 === 0) {
	      newValue = intVal / 96 + 'in';
	    }

	    if (newValue) {
	      newValue = match.substring(0, match.indexOf(val)) + newValue;
	    }

	    return newValue && newValue.length < match.length ? newValue : match;
	  });
	}

	function optimizePrecision(_, value, precisionOptions) {
	  if (!precisionOptions.enabled || value.indexOf('.') === -1) {
	    return value;
	  }

	  return value
	    .replace(precisionOptions.decimalPointMatcher, '$1$2$3')
	    .replace(precisionOptions.zeroMatcher, function (match, integerPart, fractionPart, unit) {
	      var multiplier = precisionOptions.units[unit].multiplier;
	      var parsedInteger = parseInt(integerPart);
	      var integer = isNaN(parsedInteger) ? 0 : parsedInteger;
	      var fraction = parseFloat(fractionPart);

	      return Math.round((integer + fraction) * multiplier) / multiplier + unit;
	    });
	}

	function optimizeTimeUnits(_, value) {
	  if (!TIME_VALUE.test(value))
	    return value;

	  return value.replace(TIME_VALUE, function (match, val, unit) {
	    var newValue;

	    if (unit == 'ms') {
	      newValue = parseInt(val) / 1000 + 's';
	    } else if (unit == 's') {
	      newValue = parseFloat(val) * 1000 + 'ms';
	    }

	    return newValue.length < match.length ? newValue : match;
	  });
	}

	function optimizeUnits(name, value, unitsRegexp) {
	  if (/^(?:\-moz\-calc|\-webkit\-calc|calc|rgb|hsl|rgba|hsla)\(/.test(value)) {
	    return value;
	  }

	  if (name == 'flex' || name == '-ms-flex' || name == '-webkit-flex' || name == 'flex-basis' || name == '-webkit-flex-basis') {
	    return value;
	  }

	  if (value.indexOf('%') > 0 && (name == 'height' || name == 'max-height' || name == 'width' || name == 'max-width')) {
	    return value;
	  }

	  return value
	    .replace(unitsRegexp, '$1' + '0' + '$2')
	    .replace(unitsRegexp, '$1' + '0' + '$2');
	}

	function optimizeWhitespace(name, value) {
	  if (name.indexOf('filter') > -1 || value.indexOf(' ') == -1 || value.indexOf('expression') === 0) {
	    return value;
	  }

	  if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {
	    return value;
	  }

	  value = value.replace(/\s+/g, ' ');

	  if (value.indexOf('calc') > -1) {
	    value = value.replace(/\) ?\/ ?/g, ')/ ');
	  }

	  return value
	    .replace(/(\(;?)\s+/g, '$1')
	    .replace(/\s+(;?\))/g, '$1')
	    .replace(/, /g, ',');
	}

	function optimizeZeroDegUnit(_, value) {
	  if (value.indexOf('0deg') == -1) {
	    return value;
	  }

	  return value.replace(/\(0deg\)/g, '(0)');
	}

	function optimizeZeroUnits(name, value) {
	  if (value.indexOf('0') == -1) {
	    return value;
	  }

	  if (value.indexOf('-') > -1) {
	    value = value
	      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2')
	      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2');
	  }

	  return value
	    .replace(/(^|\s)0+([1-9])/g, '$1$2')
	    .replace(/(^|\D)\.0+(\D|$)/g, '$10$2')
	    .replace(/(^|\D)\.0+(\D|$)/g, '$10$2')
	    .replace(/\.([1-9]*)0+(\D|$)/g, function (match, nonZeroPart, suffix) {
	      return (nonZeroPart.length > 0 ? '.' : '') + nonZeroPart + suffix;
	    })
	    .replace(/(^|\D)0\.(\d)/g, '$1.$2');
	}

	function removeQuotes(name, value) {
	  if (name == 'content' || name.indexOf('font-variation-settings') > -1 || name.indexOf('font-feature-settings') > -1 || name == 'grid' || name.indexOf('grid-') > -1) {
	    return value;
	  }

	  return QUOTED_BUT_SAFE_PATTERN.test(value) ?
	    value.substring(1, value.length - 1) :
	    value;
	}

	function removeUrlQuotes(value) {
	  return /^url\(['"].+['"]\)$/.test(value) && !/^url\(['"].*[\*\s\(\)'"].*['"]\)$/.test(value) && !/^url\(['"]data:[^;]+;charset/.test(value) ?
	    value.replace(/["']/g, '') :
	    value;
	}

	function transformValue(propertyName, propertyValue, rule, transformCallback) {
	  var selector = serializeRules(rule);
	  var transformedValue = transformCallback(propertyName, propertyValue, selector);

	  if (transformedValue === undefined) {
	    return propertyValue;
	  } else if (transformedValue === false) {
	    return IgnoreProperty;
	  } else {
	    return transformedValue;
	  }
	}

	//

	function optimizeBody(rule, properties, context) {
	  var options = context.options;
	  var levelOptions = options.level[OptimizationLevel.One];
	  var property, name, type, value;
	  var valueIsUrl;
	  var propertyToken;
	  var _properties = wrapForOptimizing(properties, true);

	  propertyLoop:
	  for (var i = 0, l = _properties.length; i < l; i++) {
	    property = _properties[i];
	    name = property.name;

	    if (!PROPERTY_NAME_PATTERN.test(name)) {
	      propertyToken = property.all[property.position];
	      context.warnings.push('Invalid property name \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
	      property.unused = true;
	    }

	    if (property.value.length === 0) {
	      propertyToken = property.all[property.position];
	      context.warnings.push('Empty property \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
	      property.unused = true;
	    }

	    if (property.hack && (
	        (property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack ||
	        property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack ||
	        property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {
	      property.unused = true;
	    }

	    if (levelOptions.removeNegativePaddings && name.indexOf('padding') === 0 && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {
	      property.unused = true;
	    }

	    if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {
	      property.unused = true;
	    }

	    if (property.unused) {
	      continue;
	    }

	    if (property.block) {
	      optimizeBody(rule, property.value[0][1], context);
	      continue;
	    }

	    if (VARIABLE_NAME_PATTERN.test(name)) {
	      continue;
	    }

	    for (var j = 0, m = property.value.length; j < m; j++) {
	      type = property.value[j][0];
	      value = property.value[j][1];
	      valueIsUrl = isUrl(value);

	      if (type == Token.PROPERTY_BLOCK) {
	        property.unused = true;
	        context.warnings.push('Invalid value token at ' + formatPosition(value[0][1][2][0]) + '. Ignoring.');
	        break;
	      }

	      if (valueIsUrl && !context.validator.isUrl(value)) {
	        property.unused = true;
	        context.warnings.push('Broken URL \'' + value + '\' at ' + formatPosition(property.value[j][2][0]) + '. Ignoring.');
	        break;
	      }

	      if (valueIsUrl) {
	        value = levelOptions.normalizeUrls ?
	          normalizeUrl(value) :
	          value;
	        value = !options.compatibility.properties.urlQuotes ?
	          removeUrlQuotes(value) :
	          value;
	      } else if (isQuoted(value) || isLocal(value)) {
	        value = levelOptions.removeQuotes ?
	          removeQuotes(name, value) :
	          value;
	      } else {
	        value = levelOptions.removeWhitespace ?
	          optimizeWhitespace(name, value) :
	          value;
	        value = optimizePrecision(name, value, options.precision);
	        value = optimizePixelLengths(name, value, options.compatibility);
	        value = levelOptions.replaceTimeUnits ?
	          optimizeTimeUnits(name, value) :
	          value;
	        value = levelOptions.replaceZeroUnits ?
	          optimizeZeroUnits(name, value) :
	          value;

	        if (options.compatibility.properties.zeroUnits) {
	          value = optimizeZeroDegUnit(name, value);
	          value = optimizeUnits(name, value, options.unitsRegexp);
	        }

	        if (options.compatibility.properties.colors) {
	          value = optimizeColors(name, value, options.compatibility);
	        }
	      }

	      value = transformValue(name, value, rule, levelOptions.transform);

	      if (value === IgnoreProperty) {
	        property.unused = true;
	        continue propertyLoop;
	      }

	      property.value[j][1] = value;
	    }

	    if (levelOptions.replaceMultipleZeros) {
	      optimizeMultipleZeros(property);
	    }

	    if (name == 'background' && levelOptions.optimizeBackground) {
	      optimizeBackground(property);
	    } else if (name.indexOf('border') === 0 && name.indexOf('radius') > 0 && levelOptions.optimizeBorderRadius) {
	      optimizeBorderRadius(property);
	    } else if (name == 'filter'&& levelOptions.optimizeFilter && options.compatibility.properties.ieFilters) {
	      optimizeFilter(property);
	    } else if (name == 'font-weight' && levelOptions.optimizeFontWeight) {
	      optimizeFontWeight(property, 0);
	    } else if (name == 'outline' && levelOptions.optimizeOutline) {
	      optimizeOutline(property);
	    }
	  }

	  restoreFromOptimizing(_properties);
	  removeUnused(_properties);
	  removeComments(properties, options);
	}

	function removeComments(tokens, options) {
	  var token;
	  var i;

	  for (i = 0; i < tokens.length; i++) {
	    token = tokens[i];

	    if (token[0] != Token.COMMENT) {
	      continue;
	    }

	    optimizeComment(token, options);

	    if (token[1].length === 0) {
	      tokens.splice(i, 1);
	      i--;
	    }
	  }
	}

	function optimizeComment(token, options) {
	  if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == 'all' || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {
	    options.commentsKept++;
	    return;
	  }

	  token[1] = [];
	}

	function cleanupCharsets(tokens) {
	  var hasCharset = false;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] != Token.AT_RULE)
	      continue;

	    if (!CHARSET_REGEXP.test(token[1]))
	      continue;

	    if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    } else {
	      hasCharset = true;
	      tokens.splice(i, 1);
	      tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
	    }
	  }
	}

	function buildUnitRegexp(options) {
	  var units = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%'];
	  var otherUnits = ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];

	  otherUnits.forEach(function (unit) {
	    if (options.compatibility.units[unit]) {
	      units.push(unit);
	    }
	  });

	  return new RegExp('(^|\\s|\\(|,)0(?:' + units.join('|') + ')(\\W|$)', 'g');
	}

	function buildPrecisionOptions(roundingPrecision) {
	  var precisionOptions = {
	    matcher: null,
	    units: {},
	  };
	  var optimizable = [];
	  var unit;
	  var value;

	  for (unit in roundingPrecision) {
	    value = roundingPrecision[unit];

	    if (value != DEFAULT_ROUNDING_PRECISION) {
	      precisionOptions.units[unit] = {};
	      precisionOptions.units[unit].value = value;
	      precisionOptions.units[unit].multiplier = Math.pow(10, value);

	      optimizable.push(unit);
	    }
	  }

	  if (optimizable.length > 0) {
	    precisionOptions.enabled = true;
	    precisionOptions.decimalPointMatcher = new RegExp('(\\d)\\.($|' + optimizable.join('|') + ')($|\\W)', 'g');
	    precisionOptions.zeroMatcher = new RegExp('(\\d*)(\\.\\d+)(' + optimizable.join('|') + ')', 'g');
	  }

	  return precisionOptions;
	}

	function isImport(token) {
	  return IMPORT_PREFIX_PATTERN.test(token[1]);
	}

	function isLegacyFilter(property) {
	  var value;

	  if (property.name == 'filter' || property.name == '-ms-filter') {
	    value = property.value[0][1];

	    return value.indexOf('progid') > -1 ||
	      value.indexOf('alpha') === 0 ||
	      value.indexOf('chroma') === 0;
	  } else {
	    return false;
	  }
	}

	function level1Optimize(tokens, context) {
	  var options = context.options;
	  var levelOptions = options.level[OptimizationLevel.One];
	  var ie7Hack = options.compatibility.selectors.ie7Hack;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
	  var format = options.format;
	  var mayHaveCharset = false;
	  var afterRules = false;

	  options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
	  options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
	  options.commentsKept = options.commentsKept || 0;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    switch (token[0]) {
	      case Token.AT_RULE:
	        token[1] = isImport(token) && afterRules ? '' : token[1];
	        token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
	        mayHaveCharset = true;
	        break;
	      case Token.AT_RULE_BLOCK:
	        optimizeBody(token[1], token[2], context);
	        afterRules = true;
	        break;
	      case Token.NESTED_BLOCK:
	        token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
	        level1Optimize(token[2], context);
	        afterRules = true;
	        break;
	      case Token.COMMENT:
	        optimizeComment(token, options);
	        break;
	      case Token.RULE:
	        token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];
	        token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
	        optimizeBody(token[1], token[2], context);
	        afterRules = true;
	        break;
	    }

	    if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || (token[2] && token[2].length === 0))) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    }
	  }

	  if (levelOptions.cleanupCharsets && mayHaveCharset) {
	    cleanupCharsets(tokens);
	  }

	  return tokens;
	}

	optimize$2 = level1Optimize;
	return optimize$2;
}

var isMergeable_1;
var hasRequiredIsMergeable;

function requireIsMergeable () {
	if (hasRequiredIsMergeable) return isMergeable_1;
	hasRequiredIsMergeable = 1;
	var Marker = requireMarker();
	var split = requireSplit();

	var DEEP_SELECTOR_PATTERN = /\/deep\//;
	var DOUBLE_COLON_PATTERN = /^::/;
	var NOT_PSEUDO = ':not';
	var PSEUDO_CLASSES_WITH_ARGUMENTS = [
	  ':dir',
	  ':lang',
	  ':not',
	  ':nth-child',
	  ':nth-last-child',
	  ':nth-last-of-type',
	  ':nth-of-type'
	];
	var RELATION_PATTERN = /[>\+~]/;
	var UNMIXABLE_PSEUDO_CLASSES = [
	  ':after',
	  ':before',
	  ':first-letter',
	  ':first-line',
	  ':lang'
	];
	var UNMIXABLE_PSEUDO_ELEMENTS = [
	  '::after',
	  '::before',
	  '::first-letter',
	  '::first-line'
	];

	var Level = {
	  DOUBLE_QUOTE: 'double-quote',
	  SINGLE_QUOTE: 'single-quote',
	  ROOT: 'root'
	};

	function isMergeable(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
	  var singleSelectors = split(selector, Marker.COMMA);
	  var singleSelector;
	  var i, l;

	  for (i = 0, l = singleSelectors.length; i < l; i++) {
	    singleSelector = singleSelectors[i];

	    if (singleSelector.length === 0 ||
	        isDeepSelector(singleSelector) ||
	        (singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging))) {
	      return false;
	    }
	  }

	  return true;
	}

	function isDeepSelector(selector) {
	  return DEEP_SELECTOR_PATTERN.test(selector);
	}

	function extractPseudoFrom(selector) {
	  var list = [];
	  var character;
	  var buffer = [];
	  var level = Level.ROOT;
	  var roundBracketLevel = 0;
	  var isQuoted;
	  var isEscaped;
	  var isPseudo = false;
	  var isRelation;
	  var wasColon = false;
	  var index;
	  var len;

	  for (index = 0, len = selector.length; index < len; index++) {
	    character = selector[index];

	    isRelation = !isEscaped && RELATION_PATTERN.test(character);
	    isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;

	    if (isEscaped) {
	      buffer.push(character);
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {
	      buffer.push(character);
	      level = Level.DOUBLE_QUOTE;
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
	      buffer.push(character);
	      level = Level.ROOT;
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {
	      buffer.push(character);
	      level = Level.SINGLE_QUOTE;
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
	      buffer.push(character);
	      level = Level.ROOT;
	    } else if (isQuoted) {
	      buffer.push(character);
	    } else if (character == Marker.OPEN_ROUND_BRACKET) {
	      buffer.push(character);
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {
	      buffer.push(character);
	      list.push(buffer.join(''));
	      roundBracketLevel--;
	      buffer = [];
	      isPseudo = false;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET) {
	      buffer.push(character);
	      roundBracketLevel--;
	    } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {
	      list.push(buffer.join(''));
	      buffer = [];
	      buffer.push(character);
	    } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {
	      buffer = [];
	      buffer.push(character);
	      isPseudo = true;
	    } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {
	      list.push(buffer.join(''));
	      buffer = [];
	      isPseudo = false;
	    } else if (isRelation && roundBracketLevel === 0 && isPseudo) {
	      list.push(buffer.join(''));
	      buffer = [];
	      isPseudo = false;
	    } else {
	      buffer.push(character);
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	    wasColon = character == Marker.COLON;
	  }

	  if (buffer.length > 0 && isPseudo) {
	    list.push(buffer.join(''));
	  }

	  return list;
	}

	function areMergeable(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
	  return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) &&
	    needArguments(matches) &&
	    (matches.length < 2 || !someIncorrectlyChained(selector, matches)) &&
	    (matches.length < 2 || multiplePseudoMerging && allMixable(matches));
	}

	function areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) {
	  var match;
	  var name;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];
	    name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?
	      match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) :
	      match;

	    if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {
	      return false;
	    }
	  }

	  return true;
	}

	function needArguments(matches) {
	  var match;
	  var name;
	  var bracketOpensAt;
	  var hasArguments;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];

	    bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);
	    hasArguments = bracketOpensAt > -1;
	    name = hasArguments ?
	      match.substring(0, bracketOpensAt) :
	      match;

	    if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {
	      return false;
	    }

	    if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {
	      return false;
	    }
	  }

	  return true;
	}

	function someIncorrectlyChained(selector, matches) {
	  var positionInSelector = 0;
	  var match;
	  var matchAt;
	  var nextMatch;
	  var nextMatchAt;
	  var name;
	  var nextName;
	  var areChained;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];
	    nextMatch = matches[i + 1];

	    if (!nextMatch) {
	      break;
	    }

	    matchAt = selector.indexOf(match, positionInSelector);
	    nextMatchAt = selector.indexOf(match, matchAt + 1);
	    positionInSelector = nextMatchAt;
	    areChained = matchAt + match.length == nextMatchAt;

	    if (areChained) {
	      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?
	        match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) :
	        match;
	      nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?
	        nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) :
	        nextMatch;

	      if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function allMixable(matches) {
	  var unmixableMatches = 0;
	  var match;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];

	    if (isPseudoElement(match)) {
	      unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;
	    } else {
	      unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;
	    }

	    if (unmixableMatches > 1) {
	      return false;
	    }
	  }

	  return true;
	}

	function isPseudoElement(pseudo) {
	  return DOUBLE_COLON_PATTERN.test(pseudo);
	}

	isMergeable_1 = isMergeable;
	return isMergeable_1;
}

var everyValuesPair_1;
var hasRequiredEveryValuesPair;

function requireEveryValuesPair () {
	if (hasRequiredEveryValuesPair) return everyValuesPair_1;
	hasRequiredEveryValuesPair = 1;
	var Marker = requireMarker();

	function everyValuesPair(fn, left, right) {
	  var leftSize = left.value.length;
	  var rightSize = right.value.length;
	  var total = Math.max(leftSize, rightSize);
	  var lowerBound = Math.min(leftSize, rightSize) - 1;
	  var leftValue;
	  var rightValue;
	  var position;

	  for (position = 0; position < total; position++) {
	    leftValue = left.value[position] && left.value[position][1] || leftValue;
	    rightValue = right.value[position] && right.value[position][1] || rightValue;

	    if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {
	      continue;
	    }

	    if (!fn(leftValue, rightValue, position, position <= lowerBound)) {
	      return false;
	    }
	  }

	  return true;
	}

	everyValuesPair_1 = everyValuesPair;
	return everyValuesPair_1;
}

var hasInherit_1;
var hasRequiredHasInherit;

function requireHasInherit () {
	if (hasRequiredHasInherit) return hasInherit_1;
	hasRequiredHasInherit = 1;
	function hasInherit(property) {
	  for (var i = property.value.length - 1; i >= 0; i--) {
	    if (property.value[i][1] == 'inherit')
	      return true;
	  }

	  return false;
	}

	hasInherit_1 = hasInherit;
	return hasInherit_1;
}

var invalidPropertyError;
var hasRequiredInvalidPropertyError;

function requireInvalidPropertyError () {
	if (hasRequiredInvalidPropertyError) return invalidPropertyError;
	hasRequiredInvalidPropertyError = 1;
	function InvalidPropertyError(message) {
	  this.name = 'InvalidPropertyError';
	  this.message = message;
	  this.stack = (new Error()).stack;
	}

	InvalidPropertyError.prototype = Object.create(Error.prototype);
	InvalidPropertyError.prototype.constructor = InvalidPropertyError;

	invalidPropertyError = InvalidPropertyError;
	return invalidPropertyError;
}

var breakUp;
var hasRequiredBreakUp;

function requireBreakUp () {
	if (hasRequiredBreakUp) return breakUp;
	hasRequiredBreakUp = 1;
	var InvalidPropertyError = requireInvalidPropertyError();

	var wrapSingle = requireWrapForOptimizing().single;

	var Token = requireToken();
	var Marker = requireMarker();

	var formatPosition = requireFormatPosition();

	function _anyIsInherit(values) {
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    if (values[i][1] == 'inherit') {
	      return true;
	    }
	  }

	  return false;
	}

	function _colorFilter(validator) {
	  return function (value) {
	    return value[1] == 'invert' || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
	  };
	}

	function _styleFilter(validator) {
	  return function (value) {
	    return value[1] != 'inherit' && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
	  };
	}

	function _wrapDefault(name, property, compactable) {
	  var descriptor = compactable[name];
	  if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {
	    return wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, name],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]
	    ]);
	  } else if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
	    return wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, name],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]
	    ]);
	  } else {
	    return wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, name],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue]
	    ]);
	  }
	}

	function _widthFilter(validator) {
	  return function (value) {
	    return value[1] != 'inherit' &&
	      (validator.isWidth(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1])) &&
	      !validator.isStyleKeyword(value[1]) &&
	      !validator.isColorFunction(value[1]);
	  };
	}

	function animation(property, compactable, validator) {
	  var duration = _wrapDefault(property.name + '-duration', property, compactable);
	  var timing = _wrapDefault(property.name + '-timing-function', property, compactable);
	  var delay = _wrapDefault(property.name + '-delay', property, compactable);
	  var iteration = _wrapDefault(property.name + '-iteration-count', property, compactable);
	  var direction = _wrapDefault(property.name + '-direction', property, compactable);
	  var fill = _wrapDefault(property.name + '-fill-mode', property, compactable);
	  var play = _wrapDefault(property.name + '-play-state', property, compactable);
	  var name = _wrapDefault(property.name + '-name', property, compactable);
	  var components = [duration, timing, delay, iteration, direction, fill, play, name];
	  var values = property.value;
	  var value;
	  var durationSet = false;
	  var timingSet = false;
	  var delaySet = false;
	  var iterationSet = false;
	  var directionSet = false;
	  var fillSet = false;
	  var playSet = false;
	  var nameSet = false;
	  var i;
	  var l;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
	    return components;
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isTime(value[1]) && !durationSet) {
	      duration.value = [value];
	      durationSet = true;
	    } else if (validator.isTime(value[1]) && !delaySet) {
	      delay.value = [value];
	      delaySet = true;
	    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
	      timing.value = [value];
	      timingSet = true;
	    } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) && !iterationSet) {
	      iteration.value = [value];
	      iterationSet = true;
	    } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {
	      direction.value = [value];
	      directionSet = true;
	    } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {
	      fill.value = [value];
	      fillSet = true;
	    } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {
	      play.value = [value];
	      playSet = true;
	    } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {
	      name.value = [value];
	      nameSet = true;
	    } else {
	      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
	    }
	  }

	  return components;
	}

	function background(property, compactable, validator) {
	  var image = _wrapDefault('background-image', property, compactable);
	  var position = _wrapDefault('background-position', property, compactable);
	  var size = _wrapDefault('background-size', property, compactable);
	  var repeat = _wrapDefault('background-repeat', property, compactable);
	  var attachment = _wrapDefault('background-attachment', property, compactable);
	  var origin = _wrapDefault('background-origin', property, compactable);
	  var clip = _wrapDefault('background-clip', property, compactable);
	  var color = _wrapDefault('background-color', property, compactable);
	  var components = [image, position, size, repeat, attachment, origin, clip, color];
	  var values = property.value;

	  var positionSet = false;
	  var clipSet = false;
	  var originSet = false;
	  var repeatSet = false;

	  var anyValueSet = false;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    // NOTE: 'inherit' is not a valid value for background-attachment
	    color.value = image.value =  repeat.value = position.value = size.value = origin.value = clip.value = property.value;
	    return components;
	  }

	  if (property.value.length == 1 && property.value[0][1] == '0 0') {
	    return components;
	  }

	  for (var i = values.length - 1; i >= 0; i--) {
	    var value = values[i];

	    if (validator.isBackgroundAttachmentKeyword(value[1])) {
	      attachment.value = [value];
	      anyValueSet = true;
	    } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
	      if (clipSet) {
	        origin.value = [value];
	        originSet = true;
	      } else {
	        clip.value = [value];
	        clipSet = true;
	      }
	      anyValueSet = true;
	    } else if (validator.isBackgroundRepeatKeyword(value[1])) {
	      if (repeatSet) {
	        repeat.value.unshift(value);
	      } else {
	        repeat.value = [value];
	        repeatSet = true;
	      }
	      anyValueSet = true;
	    } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {
	      if (i > 0) {
	        var previousValue = values[i - 1];

	        if (previousValue[1] == Marker.FORWARD_SLASH) {
	          size.value = [value];
	        } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {
	          size.value = [previousValue, value];
	          i -= 2;
	        } else {
	          if (!positionSet)
	            position.value = [];

	          position.value.unshift(value);
	          positionSet = true;
	        }
	      } else {
	        if (!positionSet)
	          position.value = [];

	        position.value.unshift(value);
	        positionSet = true;
	      }
	      anyValueSet = true;
	    } else if ((color.value[0][1] == compactable[color.name].defaultValue || color.value[0][1] == 'none') && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
	      color.value = [value];
	      anyValueSet = true;
	    } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
	      image.value = [value];
	      anyValueSet = true;
	    }
	  }

	  if (clipSet && !originSet)
	    origin.value = clip.value.slice(0);

	  if (!anyValueSet) {
	    throw new InvalidPropertyError('Invalid background value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  return components;
	}

	function borderRadius(property, compactable) {
	  var values = property.value;
	  var splitAt = -1;

	  for (var i = 0, l = values.length; i < l; i++) {
	    if (values[i][1] == Marker.FORWARD_SLASH) {
	      splitAt = i;
	      break;
	    }
	  }

	  if (splitAt === 0 || splitAt === values.length - 1) {
	    throw new InvalidPropertyError('Invalid border-radius value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  var target = _wrapDefault(property.name, property, compactable);
	  target.value = splitAt > -1 ?
	    values.slice(0, splitAt) :
	    values.slice(0);
	  target.components = fourValues(target, compactable);

	  var remainder = _wrapDefault(property.name, property, compactable);
	  remainder.value = splitAt > -1 ?
	    values.slice(splitAt + 1) :
	    values.slice(0);
	  remainder.components = fourValues(remainder, compactable);

	  for (var j = 0; j < 4; j++) {
	    target.components[j].multiplex = true;
	    target.components[j].value = target.components[j].value.concat(remainder.components[j].value);
	  }

	  return target.components;
	}

	function font(property, compactable, validator) {
	  var style = _wrapDefault('font-style', property, compactable);
	  var variant = _wrapDefault('font-variant', property, compactable);
	  var weight = _wrapDefault('font-weight', property, compactable);
	  var stretch = _wrapDefault('font-stretch', property, compactable);
	  var size = _wrapDefault('font-size', property, compactable);
	  var height = _wrapDefault('line-height', property, compactable);
	  var family = _wrapDefault('font-family', property, compactable);
	  var components = [style, variant, weight, stretch, size, height, family];
	  var values = property.value;
	  var fuzzyMatched = 4; // style, variant, weight, and stretch
	  var index = 0;
	  var isStretchSet = false;
	  var isStretchValid;
	  var isStyleSet = false;
	  var isStyleValid;
	  var isVariantSet = false;
	  var isVariantValid;
	  var isWeightSet = false;
	  var isWeightValid;
	  var isSizeSet = false;
	  var appendableFamilyName = false;

	  if (!values[index]) {
	    throw new InvalidPropertyError('Missing font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
	  }

	  if (values.length == 1 && values[0][1] == 'inherit') {
	    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
	    return components;
	  }

	  if (values.length == 1 && (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {
	    values[0][1] = Marker.INTERNAL + values[0][1];
	    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
	    return components;
	  }

	  if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
	    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  // fuzzy match style, variant, weight, and stretch on first elements
	  while (index < fuzzyMatched) {
	    isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);

	    if (isStyleValid && !isStyleSet) {
	      style.value = [values[index]];
	      isStyleSet = true;
	    } else if (isVariantValid && !isVariantSet) {
	      variant.value = [values[index]];
	      isVariantSet = true;
	    } else if (isWeightValid && !isWeightSet) {
	      weight.value = [values[index]];
	      isWeightSet = true;
	    } else if (isStretchValid && !isStretchSet) {
	      stretch.value = [values[index]];
	      isStretchSet = true;
	    } else if (isStyleValid && isStyleSet || isVariantValid && isVariantSet || isWeightValid && isWeightSet || isStretchValid && isStretchSet) {
	      throw new InvalidPropertyError('Invalid font style / variant / weight / stretch value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	    } else {
	      break;
	    }

	    index++;
	  }

	  // now comes font-size ...
	  if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) && !validator.isDynamicUnit(values[index][1])) {
	    size.value = [values[index]];
	    isSizeSet = true;
	    index++;
	  } else {
	    throw new InvalidPropertyError('Missing font size at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  if (!values[index]) {
	    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  // ... and perhaps line-height
	  if (isSizeSet && values[index] && values[index][1] == Marker.FORWARD_SLASH && values[index + 1] && (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {
	    height.value = [values[index + 1]];
	    index++;
	    index++;
	  }

	  // ... and whatever comes next is font-family
	  family.value = [];

	  while (values[index]) {
	    if (values[index][1] == Marker.COMMA) {
	      appendableFamilyName = false;
	    } else {
	      if (appendableFamilyName) {
	        family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
	      } else {
	        family.value.push(values[index]);
	      }

	      appendableFamilyName = true;
	    }

	    index++;
	  }

	  if (family.value.length === 0) {
	    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  return components;
	}

	function _anyIsFontSize(values, validator) {
	  var value;
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function _anyIsFontFamily(values, validator) {
	  var value;
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isIdentifier(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function fourValues(property, compactable) {
	  var componentNames = compactable[property.name].components;
	  var components = [];
	  var value = property.value;

	  if (value.length < 1)
	    return [];

	  if (value.length < 2)
	    value[1] = value[0].slice(0);
	  if (value.length < 3)
	    value[2] = value[0].slice(0);
	  if (value.length < 4)
	    value[3] = value[1].slice(0);

	  for (var i = componentNames.length - 1; i >= 0; i--) {
	    var component = wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, componentNames[i]]
	    ]);
	    component.value = [value[i]];
	    components.unshift(component);
	  }

	  return components;
	}

	function multiplex(splitWith) {
	  return function (property, compactable, validator) {
	    var splitsAt = [];
	    var values = property.value;
	    var i, j, l, m;

	    // find split commas
	    for (i = 0, l = values.length; i < l; i++) {
	      if (values[i][1] == ',')
	        splitsAt.push(i);
	    }

	    if (splitsAt.length === 0)
	      return splitWith(property, compactable, validator);

	    var splitComponents = [];

	    // split over commas, and into components
	    for (i = 0, l = splitsAt.length; i <= l; i++) {
	      var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
	      var to = i < l ? splitsAt[i] : values.length;

	      var _property = _wrapDefault(property.name, property, compactable);
	      _property.value = values.slice(from, to);

	      splitComponents.push(splitWith(_property, compactable, validator));
	    }

	    var components = splitComponents[0];

	    // group component values from each split
	    for (i = 0, l = components.length; i < l; i++) {
	      components[i].multiplex = true;

	      for (j = 1, m = splitComponents.length; j < m; j++) {
	        components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
	        Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);
	      }
	    }

	    return components;
	  };
	}

	function listStyle(property, compactable, validator) {
	  var type = _wrapDefault('list-style-type', property, compactable);
	  var position = _wrapDefault('list-style-position', property, compactable);
	  var image = _wrapDefault('list-style-image', property, compactable);
	  var components = [type, position, image];

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    type.value = position.value = image.value = [property.value[0]];
	    return components;
	  }

	  var values = property.value.slice(0);
	  var total = values.length;
	  var index = 0;

	  // `image` first...
	  for (index = 0, total = values.length; index < total; index++) {
	    if (validator.isUrl(values[index][1]) || values[index][1] == '0') {
	      image.value = [values[index]];
	      values.splice(index, 1);
	      break;
	    }
	  }

	  // ... then `position`
	  for (index = 0, total = values.length; index < total; index++) {
	    if (validator.isListStylePositionKeyword(values[index][1])) {
	      position.value = [values[index]];
	      values.splice(index, 1);
	      break;
	    }
	  }

	  // ... and what's left is a `type`
	  if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
	    type.value = [values[0]];
	  }

	  return components;
	}

	function transition(property, compactable, validator) {
	  var prop = _wrapDefault(property.name + '-property', property, compactable);
	  var duration = _wrapDefault(property.name + '-duration', property, compactable);
	  var timing = _wrapDefault(property.name + '-timing-function', property, compactable);
	  var delay = _wrapDefault(property.name + '-delay', property, compactable);
	  var components = [prop, duration, timing, delay];
	  var values = property.value;
	  var value;
	  var durationSet = false;
	  var delaySet = false;
	  var propSet = false;
	  var timingSet = false;
	  var i;
	  var l;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    prop.value = duration.value = timing.value = delay.value = property.value;
	    return components;
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isTime(value[1]) && !durationSet) {
	      duration.value = [value];
	      durationSet = true;
	    } else if (validator.isTime(value[1]) && !delaySet) {
	      delay.value = [value];
	      delaySet = true;
	    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
	      timing.value = [value];
	      timingSet = true;
	    } else if (validator.isIdentifier(value[1]) && !propSet) {
	      prop.value = [value];
	      propSet = true;
	    } else {
	      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
	    }
	  }

	  return components;
	}

	function widthStyleColor(property, compactable, validator) {
	  var descriptor = compactable[property.name];
	  var components = [
	    _wrapDefault(descriptor.components[0], property, compactable),
	    _wrapDefault(descriptor.components[1], property, compactable),
	    _wrapDefault(descriptor.components[2], property, compactable)
	  ];
	  var color, style, width;

	  for (var i = 0; i < 3; i++) {
	    var component = components[i];

	    if (component.name.indexOf('color') > 0)
	      color = component;
	    else if (component.name.indexOf('style') > 0)
	      style = component;
	    else
	      width = component;
	  }

	  if ((property.value.length == 1 && property.value[0][1] == 'inherit') ||
	      (property.value.length == 3 && property.value[0][1] == 'inherit' && property.value[1][1] == 'inherit' && property.value[2][1] == 'inherit')) {
	    color.value = style.value = width.value = [property.value[0]];
	    return components;
	  }

	  var values = property.value.slice(0);
	  var match, matches;

	  // NOTE: usually users don't follow the required order of parts in this shorthand,
	  // so we'll try to parse it caring as little about order as possible

	  if (values.length > 0) {
	    matches = values.filter(_widthFilter(validator));
	    match = matches.length > 1 && (matches[0][1] == 'none' || matches[0][1] == 'auto') ? matches[1] : matches[0];
	    if (match) {
	      width.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  if (values.length > 0) {
	    match = values.filter(_styleFilter(validator))[0];
	    if (match) {
	      style.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  if (values.length > 0) {
	    match = values.filter(_colorFilter(validator))[0];
	    if (match) {
	      color.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  return components;
	}

	breakUp = {
	  animation: animation,
	  background: background,
	  border: widthStyleColor,
	  borderRadius: borderRadius,
	  font: font,
	  fourValues: fourValues,
	  listStyle: listStyle,
	  multiplex: multiplex,
	  outline: widthStyleColor,
	  transition: transition
	};
	return breakUp;
}

var vendorPrefixes;
var hasRequiredVendorPrefixes;

function requireVendorPrefixes () {
	if (hasRequiredVendorPrefixes) return vendorPrefixes;
	hasRequiredVendorPrefixes = 1;
	var VENDOR_PREFIX_PATTERN = /(?:^|\W)(\-\w+\-)/g;

	function unique(value) {
	  var prefixes = [];
	  var match;

	  while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {
	    if (prefixes.indexOf(match[0]) == -1) {
	      prefixes.push(match[0]);
	    }
	  }

	  return prefixes;
	}

	function same(value1, value2) {
	  return unique(value1).sort().join(',') == unique(value2).sort().join(',');
	}

	vendorPrefixes = {
	  unique: unique,
	  same: same
	};
	return vendorPrefixes;
}

var understandable_1;
var hasRequiredUnderstandable;

function requireUnderstandable () {
	if (hasRequiredUnderstandable) return understandable_1;
	hasRequiredUnderstandable = 1;
	var sameVendorPrefixes = requireVendorPrefixes().same;

	function understandable(validator, value1, value2, _position, isPaired) {
	  if (!sameVendorPrefixes(value1, value2)) {
	    return false;
	  }

	  if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {
	    return false;
	  }

	  return true;
	}

	understandable_1 = understandable;
	return understandable_1;
}

var canOverride;
var hasRequiredCanOverride;

function requireCanOverride () {
	if (hasRequiredCanOverride) return canOverride;
	hasRequiredCanOverride = 1;
	var understandable = requireUnderstandable();

	function animationIterationCount(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);
	}

	function animationName(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);
	}

	function areSameFunction(validator, value1, value2) {
	  if (!validator.isFunction(value1) || !validator.isFunction(value2)) {
	    return false;
	  }

	  var function1Name = value1.substring(0, value1.indexOf('('));
	  var function2Name = value2.substring(0, value2.indexOf('('));

	  return function1Name === function2Name;
	}

	function backgroundPosition(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {
	    return true;
	  }

	  return unit(validator, value1, value2);
	}

	function backgroundSize(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {
	    return true;
	  }

	  return unit(validator, value1, value2);
	}

	function color(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {
	    return false;
	  } else if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {
	    return false;
	  } else if (validator.isColor(value1) && validator.isColor(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function components(overrideCheckers) {
	  return function (validator, value1, value2, position) {
	    return overrideCheckers[position](validator, value1, value2);
	  };
	}

	function fontFamily(validator, value1, value2) {
	  return understandable(validator, value1, value2, 0, true);
	}

	function image(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (validator.isImage(value2)) {
	    return true;
	  } else if (validator.isImage(value1)) {
	    return false;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function keyword(propertyName) {
	  return function(validator, value1, value2) {
	    if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName)(value2)) {
	      return false;
	    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	      return true;
	    }

	    return validator.isKeyword(propertyName)(value2);
	  };
	}

	function keywordWithGlobal(propertyName) {
	  return function(validator, value1, value2) {
	    if (!understandable(validator, value1, value2, 0, true) && !(validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2))) {
	      return false;
	    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	      return true;
	    }

	    return validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2);
	  };
	}

	function propertyName(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isIdentifier(value2);
	}

	function sameFunctionOrValue(validator, value1, value2) {
	  return areSameFunction(validator, value1, value2) ?
	    true :
	    value1 === value2;
	}

	function textShadow(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);
	}

	function time(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (validator.isTime(value1) && !validator.isTime(value2)) {
	    return false;
	  } else if (validator.isTime(value2)) {
	    return true;
	  } else if (validator.isTime(value1)) {
	    return false;
	  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function timingFunction(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isTimingFunction(value2) || validator.isGlobal(value2);
	}

	function unit(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if (validator.isUnit(value1) && !validator.isUnit(value2)) {
	    return false;
	  } else if (validator.isUnit(value2)) {
	    return true;
	  } else if (validator.isUnit(value1)) {
	    return false;
	  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function unitOrKeywordWithGlobal(propertyName) {
	  var byKeyword = keywordWithGlobal(propertyName);

	  return function(validator, value1, value2) {
	    return unit(validator, value1, value2) || byKeyword(validator, value1, value2);
	  };
	}

	function unitOrNumber(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } else if ((validator.isUnit(value1) || validator.isNumber(value1)) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
	    return false;
	  } else if (validator.isUnit(value2) || validator.isNumber(value2)) {
	    return true;
	  } else if (validator.isUnit(value1) || validator.isNumber(value1)) {
	    return false;
	  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function zIndex(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {
	    return false;
	  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isZIndex(value2);
	}

	canOverride = {
	  generic: {
	    color: color,
	    components: components,
	    image: image,
	    propertyName: propertyName,
	    time: time,
	    timingFunction: timingFunction,
	    unit: unit,
	    unitOrNumber: unitOrNumber
	  },
	  property: {
	    animationDirection: keywordWithGlobal('animation-direction'),
	    animationFillMode: keyword('animation-fill-mode'),
	    animationIterationCount: animationIterationCount,
	    animationName: animationName,
	    animationPlayState: keywordWithGlobal('animation-play-state'),
	    backgroundAttachment: keyword('background-attachment'),
	    backgroundClip: keywordWithGlobal('background-clip'),
	    backgroundOrigin: keyword('background-origin'),
	    backgroundPosition: backgroundPosition,
	    backgroundRepeat: keyword('background-repeat'),
	    backgroundSize: backgroundSize,
	    bottom: unitOrKeywordWithGlobal('bottom'),
	    borderCollapse: keyword('border-collapse'),
	    borderStyle: keywordWithGlobal('*-style'),
	    clear: keywordWithGlobal('clear'),
	    cursor: keywordWithGlobal('cursor'),
	    display: keywordWithGlobal('display'),
	    float: keywordWithGlobal('float'),
	    left: unitOrKeywordWithGlobal('left'),
	    fontFamily: fontFamily,
	    fontStretch: keywordWithGlobal('font-stretch'),
	    fontStyle: keywordWithGlobal('font-style'),
	    fontVariant: keywordWithGlobal('font-variant'),
	    fontWeight: keywordWithGlobal('font-weight'),
	    listStyleType: keywordWithGlobal('list-style-type'),
	    listStylePosition: keywordWithGlobal('list-style-position'),
	    outlineStyle: keywordWithGlobal('*-style'),
	    overflow: keywordWithGlobal('overflow'),
	    position: keywordWithGlobal('position'),
	    right: unitOrKeywordWithGlobal('right'),
	    textAlign: keywordWithGlobal('text-align'),
	    textDecoration: keywordWithGlobal('text-decoration'),
	    textOverflow: keywordWithGlobal('text-overflow'),
	    textShadow: textShadow,
	    top: unitOrKeywordWithGlobal('top'),
	    transform: sameFunctionOrValue,
	    verticalAlign: unitOrKeywordWithGlobal('vertical-align'),
	    visibility: keywordWithGlobal('visibility'),
	    whiteSpace: keywordWithGlobal('white-space'),
	    zIndex: zIndex
	  }
	};
	return canOverride;
}

var clone;
var hasRequiredClone$1;

function requireClone$1 () {
	if (hasRequiredClone$1) return clone;
	hasRequiredClone$1 = 1;
	var wrapSingle = requireWrapForOptimizing().single;

	var Token = requireToken();

	function deep(property) {
	  var cloned = shallow(property);
	  for (var i = property.components.length - 1; i >= 0; i--) {
	    var component = shallow(property.components[i]);
	    component.value = property.components[i].value.slice(0);
	    cloned.components.unshift(component);
	  }

	  cloned.dirty = true;
	  cloned.value = property.value.slice(0);

	  return cloned;
	}

	function shallow(property) {
	  var cloned = wrapSingle([
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, property.name]
	  ]);
	  cloned.important = property.important;
	  cloned.hack = property.hack;
	  cloned.unused = false;
	  return cloned;
	}

	clone = {
	  deep: deep,
	  shallow: shallow
	};
	return clone;
}

var restore;
var hasRequiredRestore;

function requireRestore () {
	if (hasRequiredRestore) return restore;
	hasRequiredRestore = 1;
	var shallowClone = requireClone$1().shallow;

	var Token = requireToken();
	var Marker = requireMarker();

	function isInheritOnly(values) {
	  for (var i = 0, l = values.length; i < l; i++) {
	    var value = values[i][1];

	    if (value != 'inherit' && value != Marker.COMMA && value != Marker.FORWARD_SLASH)
	      return false;
	  }

	  return true;
	}

	function background(property, compactable, lastInMultiplex) {
	  var components = property.components;
	  var restored = [];
	  var needsOne, needsBoth;

	  function restoreValue(component) {
	    Array.prototype.unshift.apply(restored, component.value);
	  }

	  function isDefaultValue(component) {
	    var descriptor = compactable[component.name];

	    if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
	      return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] == descriptor.defaultValue[0] : true);
	    } else if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {
	      return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] : component.value[0][1]) == descriptor.defaultValue[1];
	    } else {
	      return component.value[0][1] == descriptor.defaultValue;
	    }
	  }

	  for (var i = components.length - 1; i >= 0; i--) {
	    var component = components[i];
	    var isDefault = isDefaultValue(component);

	    if (component.name == 'background-clip') {
	      var originComponent = components[i - 1];
	      var isOriginDefault = isDefaultValue(originComponent);

	      needsOne = component.value[0][1] == originComponent.value[0][1];

	      needsBoth = !needsOne && (
	        (isOriginDefault && !isDefault) ||
	        (!isOriginDefault && !isDefault) ||
	        (!isOriginDefault && isDefault && component.value[0][1] != originComponent.value[0][1]));

	      if (needsOne) {
	        restoreValue(originComponent);
	      } else if (needsBoth) {
	        restoreValue(component);
	        restoreValue(originComponent);
	      }

	      i--;
	    } else if (component.name == 'background-size') {
	      var positionComponent = components[i - 1];
	      var isPositionDefault = isDefaultValue(positionComponent);

	      needsOne = !isPositionDefault && isDefault;

	      needsBoth = !needsOne &&
	        (isPositionDefault && !isDefault || !isPositionDefault && !isDefault);

	      if (needsOne) {
	        restoreValue(positionComponent);
	      } else if (needsBoth) {
	        restoreValue(component);
	        restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);
	        restoreValue(positionComponent);
	      } else if (positionComponent.value.length == 1) {
	        restoreValue(positionComponent);
	      }

	      i--;
	    } else {
	      if (isDefault || compactable[component.name].multiplexLastOnly && !lastInMultiplex)
	        continue;

	      restoreValue(component);
	    }
	  }

	  if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == '0')
	    restored.push(property.value[0]);

	  if (restored.length === 0)
	    restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);

	  if (isInheritOnly(restored))
	    return [restored[0]];

	  return restored;
	}

	function borderRadius(property, compactable) {
	  if (property.multiplex) {
	    var horizontal = shallowClone(property);
	    var vertical = shallowClone(property);

	    for (var i = 0; i < 4; i++) {
	      var component = property.components[i];

	      var horizontalComponent = shallowClone(property);
	      horizontalComponent.value = [component.value[0]];
	      horizontal.components.push(horizontalComponent);

	      var verticalComponent = shallowClone(property);
	      // FIXME: only shorthand compactor (see breakup#borderRadius) knows that border radius
	      // longhands have two values, whereas tokenizer does not care about populating 2nd value
	      // if it's missing, hence this fallback
	      verticalComponent.value = [component.value[1] || component.value[0]];
	      vertical.components.push(verticalComponent);
	    }

	    var horizontalValues = fourValues(horizontal);
	    var verticalValues = fourValues(vertical);

	    if (horizontalValues.length == verticalValues.length &&
	        horizontalValues[0][1] == verticalValues[0][1] &&
	        (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true) &&
	        (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true) &&
	        (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {
	      return horizontalValues;
	    } else {
	      return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);
	    }
	  } else {
	    return fourValues(property);
	  }
	}

	function font(property, compactable) {
	  var components = property.components;
	  var restored = [];
	  var component;
	  var componentIndex = 0;
	  var fontFamilyIndex = 0;

	  if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {
	    property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);
	    return property.value;
	  }

	  // first four components are optional
	  while (componentIndex < 4) {
	    component = components[componentIndex];

	    if (component.value[0][1] != compactable[component.name].defaultValue) {
	      Array.prototype.push.apply(restored, component.value);
	    }

	    componentIndex++;
	  }

	  // then comes font-size
	  Array.prototype.push.apply(restored, components[componentIndex].value);
	  componentIndex++;

	  // then may come line-height
	  if (components[componentIndex].value[0][1] != compactable[components[componentIndex].name].defaultValue) {
	    Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);
	    Array.prototype.push.apply(restored, components[componentIndex].value);
	  }

	  componentIndex++;

	  // then comes font-family
	  while (components[componentIndex].value[fontFamilyIndex]) {
	    restored.push(components[componentIndex].value[fontFamilyIndex]);

	    if (components[componentIndex].value[fontFamilyIndex + 1]) {
	      restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
	    }

	    fontFamilyIndex++;
	  }

	  if (isInheritOnly(restored)) {
	    return [restored[0]];
	  }

	  return restored;
	}

	function fourValues(property) {
	  var components = property.components;
	  var value1 = components[0].value[0];
	  var value2 = components[1].value[0];
	  var value3 = components[2].value[0];
	  var value4 = components[3].value[0];

	  if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {
	    return [value1];
	  } else if (value1[1] == value3[1] && value2[1] == value4[1]) {
	    return [value1, value2];
	  } else if (value2[1] == value4[1]) {
	    return [value1, value2, value3];
	  } else {
	    return [value1, value2, value3, value4];
	  }
	}

	function multiplex(restoreWith) {
	  return function (property, compactable) {
	    if (!property.multiplex)
	      return restoreWith(property, compactable, true);

	    var multiplexSize = 0;
	    var restored = [];
	    var componentMultiplexSoFar = {};
	    var i, l;

	    // At this point we don't know what's the multiplex size, e.g. how many background layers are there
	    for (i = 0, l = property.components[0].value.length; i < l; i++) {
	      if (property.components[0].value[i][1] == Marker.COMMA)
	        multiplexSize++;
	    }

	    for (i = 0; i <= multiplexSize; i++) {
	      var _property = shallowClone(property);

	      // We split multiplex into parts and restore them one by one
	      for (var j = 0, m = property.components.length; j < m; j++) {
	        var componentToClone = property.components[j];
	        var _component = shallowClone(componentToClone);
	        _property.components.push(_component);

	        // The trick is some properties has more than one value, so we iterate over values looking for
	        // a multiplex separator - a comma
	        for (var k = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length; k < n; k++) {
	          if (componentToClone.value[k][1] == Marker.COMMA) {
	            componentMultiplexSoFar[_component.name] = k + 1;
	            break;
	          }

	          _component.value.push(componentToClone.value[k]);
	        }
	      }

	      // No we can restore shorthand value
	      var lastInMultiplex = i == multiplexSize;
	      var _restored = restoreWith(_property, compactable, lastInMultiplex);
	      Array.prototype.push.apply(restored, _restored);

	      if (i < multiplexSize)
	        restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
	    }

	    return restored;
	  };
	}

	function withoutDefaults(property, compactable) {
	  var components = property.components;
	  var restored = [];

	  for (var i = components.length - 1; i >= 0; i--) {
	    var component = components[i];
	    var descriptor = compactable[component.name];

	    if (component.value[0][1] != descriptor.defaultValue || ('keepUnlessDefault' in descriptor) && !isDefault(components, compactable, descriptor.keepUnlessDefault)) {
	      restored.unshift(component.value[0]);
	    }
	  }

	  if (restored.length === 0)
	    restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);

	  if (isInheritOnly(restored))
	    return [restored[0]];

	  return restored;
	}

	function isDefault(components, compactable, propertyName) {
	  var component;
	  var i, l;

	  for (i = 0, l = components.length; i < l; i++) {
	    component = components[i];

	    if (component.name == propertyName && component.value[0][1] == compactable[propertyName].defaultValue) {
	      return true;
	    }
	  }

	  return false;
	}

	restore = {
	  background: background,
	  borderRadius: borderRadius,
	  font: font,
	  fourValues: fourValues,
	  multiplex: multiplex,
	  withoutDefaults: withoutDefaults
	};
	return restore;
}

var compactable_1;
var hasRequiredCompactable;

function requireCompactable () {
	if (hasRequiredCompactable) return compactable_1;
	hasRequiredCompactable = 1;
	// Contains the interpretation of CSS properties, as used by the property optimizer

	var breakUp = requireBreakUp();
	var canOverride = requireCanOverride();
	var restore = requireRestore();

	var override = requireOverride();

	// Properties to process
	// Extend this object in order to add support for more properties in the optimizer.
	//
	// Each key in this object represents a CSS property and should be an object.
	// Such an object contains properties that describe how the represented CSS property should be handled.
	// Possible options:
	//
	// * components: array (Only specify for shorthand properties.)
	//   Contains the names of the granular properties this shorthand compacts.
	//
	// * canOverride: function
	//   Returns whether two tokens of this property can be merged with each other.
	//   This property has no meaning for shorthands.
	//
	// * defaultValue: string
	//   Specifies the default value of the property according to the CSS standard.
	//   For shorthand, this is used when every component is set to its default value, therefore it should be the shortest possible default value of all the components.
	//
	// * shortestValue: string
	//   Specifies the shortest possible value the property can possibly have.
	//   (Falls back to defaultValue if unspecified.)
	//
	// * breakUp: function (Only specify for shorthand properties.)
	//   Breaks the shorthand up to its components.
	//
	// * restore: function (Only specify for shorthand properties.)
	//   Puts the shorthand together from its components.
	//
	var compactable = {
	  'animation': {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.time,
	      canOverride.generic.timingFunction,
	      canOverride.generic.time,
	      canOverride.property.animationIterationCount,
	      canOverride.property.animationDirection,
	      canOverride.property.animationFillMode,
	      canOverride.property.animationPlayState,
	      canOverride.property.animationName
	    ]),
	    components: [
	      'animation-duration',
	      'animation-timing-function',
	      'animation-delay',
	      'animation-iteration-count',
	      'animation-direction',
	      'animation-fill-mode',
	      'animation-play-state',
	      'animation-name'
	    ],
	    breakUp: breakUp.multiplex(breakUp.animation),
	    defaultValue: 'none',
	    restore: restore.multiplex(restore.withoutDefaults),
	    shorthand: true,
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-delay': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-direction': {
	    canOverride: canOverride.property.animationDirection,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'normal',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-duration': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    keepUnlessDefault: 'animation-delay',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-fill-mode': {
	    canOverride: canOverride.property.animationFillMode,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-iteration-count': {
	    canOverride: canOverride.property.animationIterationCount,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '1',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-name': {
	    canOverride: canOverride.property.animationName,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-play-state': {
	    canOverride: canOverride.property.animationPlayState,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'running',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-timing-function': {
	    canOverride: canOverride.generic.timingFunction,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'ease',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'background': {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.image,
	      canOverride.property.backgroundPosition,
	      canOverride.property.backgroundSize,
	      canOverride.property.backgroundRepeat,
	      canOverride.property.backgroundAttachment,
	      canOverride.property.backgroundOrigin,
	      canOverride.property.backgroundClip,
	      canOverride.generic.color
	    ]),
	    components: [
	      'background-image',
	      'background-position',
	      'background-size',
	      'background-repeat',
	      'background-attachment',
	      'background-origin',
	      'background-clip',
	      'background-color'
	    ],
	    breakUp: breakUp.multiplex(breakUp.background),
	    defaultValue: '0 0',
	    restore: restore.multiplex(restore.background),
	    shortestValue: '0',
	    shorthand: true
	  },
	  'background-attachment': {
	    canOverride: canOverride.property.backgroundAttachment,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'scroll',
	    intoMultiplexMode: 'real'
	  },
	  'background-clip': {
	    canOverride: canOverride.property.backgroundClip,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'border-box',
	    intoMultiplexMode: 'real',
	    shortestValue: 'border-box'
	  },
	  'background-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'transparent',
	    intoMultiplexMode: 'real', // otherwise real color will turn into default since color appears in last multiplex only
	    multiplexLastOnly: true,
	    nonMergeableValue: 'none',
	    shortestValue: 'red'
	  },
	  'background-image': {
	    canOverride: canOverride.generic.image,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'default'
	  },
	  'background-origin': {
	    canOverride: canOverride.property.backgroundOrigin,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'padding-box',
	    intoMultiplexMode: 'real',
	    shortestValue: 'border-box'
	  },
	  'background-position': {
	    canOverride: canOverride.property.backgroundPosition,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['0', '0'],
	    doubleValues: true,
	    intoMultiplexMode: 'real',
	    shortestValue: '0'
	  },
	  'background-repeat': {
	    canOverride: canOverride.property.backgroundRepeat,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['repeat'],
	    doubleValues: true,
	    intoMultiplexMode: 'real'
	  },
	  'background-size': {
	    canOverride: canOverride.property.backgroundSize,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['auto'],
	    doubleValues: true,
	    intoMultiplexMode: 'real',
	    shortestValue: '0 0'
	  },
	  'bottom': {
	    canOverride: canOverride.property.bottom,
	    defaultValue: 'auto'
	  },
	  'border': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-width',
	      'border-style',
	      'border-color'
	    ],
	    defaultValue: 'none',
	    overridesShorthands: [
	      'border-bottom',
	      'border-left',
	      'border-right',
	      'border-top'
	    ],
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    shorthandComponents: true
	  },
	  'border-bottom': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-bottom-width',
	      'border-bottom-style',
	      'border-bottom-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true
	  },
	  'border-bottom-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-bottom',
	      'border-color'
	    ],
	    defaultValue: 'none'
	  },
	  'border-bottom-left-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-bottom-right-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-bottom-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-bottom',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-bottom-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-bottom',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-top-width',
	    shortestValue: '0'
	  },
	  'border-collapse': {
	    canOverride: canOverride.property.borderCollapse,
	    defaultValue: 'separate'
	  },
	  'border-color': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.color,
	      canOverride.generic.color,
	      canOverride.generic.color,
	      canOverride.generic.color
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-color',
	      'border-right-color',
	      'border-bottom-color',
	      'border-left-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.fourValues,
	    shortestValue: 'red',
	    shorthand: true
	  },
	  'border-left': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-left-width',
	      'border-left-style',
	      'border-left-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true
	  },
	  'border-left-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-left'
	    ],
	    defaultValue: 'none'
	  },
	  'border-left-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-left',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-left-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-left',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-right-width',
	    shortestValue: '0'
	  },
	  'border-radius': {
	    breakUp: breakUp.borderRadius,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'border-top-left-radius',
	      'border-top-right-radius',
	      'border-bottom-right-radius',
	      'border-bottom-left-radius'
	    ],
	    defaultValue: '0',
	    restore: restore.borderRadius,
	    shorthand: true,
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-right': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-right-width',
	      'border-right-style',
	      'border-right-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true
	  },
	  'border-right-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-right'
	    ],
	    defaultValue: 'none'
	  },
	  'border-right-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-right',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-right-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-right',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-left-width',
	    shortestValue: '0'
	  },
	  'border-style': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-style',
	      'border-right-style',
	      'border-bottom-style',
	      'border-left-style'
	    ],
	    defaultValue: 'none',
	    restore: restore.fourValues,
	    shorthand: true
	  },
	  'border-top': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-top-width',
	      'border-top-style',
	      'border-top-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true
	  },
	  'border-top-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-top'
	    ],
	    defaultValue: 'none'
	  },
	  'border-top-left-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-top-right-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-top-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-style',
	      'border-top'
	    ],
	    defaultValue: 'none'
	  },
	  'border-top-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-top',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-bottom-width',
	    shortestValue: '0'
	  },
	  'border-width': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-width',
	      'border-right-width',
	      'border-bottom-width',
	      'border-left-width'
	    ],
	    defaultValue: 'medium',
	    restore: restore.fourValues,
	    shortestValue: '0',
	    shorthand: true
	  },
	  'clear': {
	    canOverride: canOverride.property.clear,
	    defaultValue: 'none'
	  },
	  'color': {
	    canOverride: canOverride.generic.color,
	    defaultValue: 'transparent',
	    shortestValue: 'red'
	  },
	  'cursor': {
	    canOverride: canOverride.property.cursor,
	    defaultValue: 'auto'
	  },
	  'display': {
	    canOverride: canOverride.property.display,
	  },
	  'float': {
	    canOverride: canOverride.property.float,
	    defaultValue: 'none'
	  },
	  'font': {
	    breakUp: breakUp.font,
	    canOverride: canOverride.generic.components([
	      canOverride.property.fontStyle,
	      canOverride.property.fontVariant,
	      canOverride.property.fontWeight,
	      canOverride.property.fontStretch,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.property.fontFamily
	    ]),
	    components: [
	      'font-style',
	      'font-variant',
	      'font-weight',
	      'font-stretch',
	      'font-size',
	      'line-height',
	      'font-family'
	    ],
	    restore: restore.font,
	    shorthand: true
	  },
	  'font-family': {
	    canOverride: canOverride.property.fontFamily,
	    defaultValue: 'user|agent|specific'
	  },
	  'font-size': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'medium',
	    shortestValue: '0'
	  },
	  'font-stretch': {
	    canOverride: canOverride.property.fontStretch,
	    defaultValue: 'normal'
	  },
	  'font-style': {
	    canOverride: canOverride.property.fontStyle,
	    defaultValue: 'normal'
	  },
	  'font-variant': {
	    canOverride: canOverride.property.fontVariant,
	    defaultValue: 'normal'
	  },
	  'font-weight': {
	    canOverride: canOverride.property.fontWeight,
	    defaultValue: 'normal',
	    shortestValue: '400'
	  },
	  'height': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'auto',
	    shortestValue: '0'
	  },
	  'left': {
	    canOverride: canOverride.property.left,
	    defaultValue: 'auto'
	  },
	  'line-height': {
	    canOverride: canOverride.generic.unitOrNumber,
	    defaultValue: 'normal',
	    shortestValue: '0'
	  },
	  'list-style': {
	    canOverride: canOverride.generic.components([
	      canOverride.property.listStyleType,
	      canOverride.property.listStylePosition,
	      canOverride.property.listStyleImage
	    ]),
	    components: [
	      'list-style-type',
	      'list-style-position',
	      'list-style-image'
	    ],
	    breakUp: breakUp.listStyle,
	    restore: restore.withoutDefaults,
	    defaultValue: 'outside', // can't use 'disc' because that'd override default 'decimal' for <ol>
	    shortestValue: 'none',
	    shorthand: true
	  },
	  'list-style-image' : {
	    canOverride: canOverride.generic.image,
	    componentOf: [
	      'list-style'
	    ],
	    defaultValue: 'none'
	  },
	  'list-style-position' : {
	    canOverride: canOverride.property.listStylePosition,
	    componentOf: [
	      'list-style'
	    ],
	    defaultValue: 'outside',
	    shortestValue: 'inside'
	  },
	  'list-style-type' : {
	    canOverride: canOverride.property.listStyleType,
	    componentOf: [
	      'list-style'
	    ],
	    // NOTE: we can't tell the real default value here, it's 'disc' for <ul> and 'decimal' for <ol>
	    // this is a hack, but it doesn't matter because this value will be either overridden or
	    // it will disappear at the final step anyway
	    defaultValue: 'decimal|disc',
	    shortestValue: 'none'
	  },
	  'margin': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'margin-top',
	      'margin-right',
	      'margin-bottom',
	      'margin-left'
	    ],
	    defaultValue: '0',
	    restore: restore.fourValues,
	    shorthand: true
	  },
	  'margin-bottom': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-top'
	  },
	  'margin-left': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-right'
	  },
	  'margin-right': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-left'
	  },
	  'margin-top': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-bottom'
	  },
	  'outline': {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.color,
	      canOverride.property.outlineStyle,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'outline-color',
	      'outline-style',
	      'outline-width'
	    ],
	    breakUp: breakUp.outline,
	    restore: restore.withoutDefaults,
	    defaultValue: '0',
	    shorthand: true
	  },
	  'outline-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'invert',
	    shortestValue: 'red'
	  },
	  'outline-style': {
	    canOverride: canOverride.property.outlineStyle,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'none'
	  },
	  'outline-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'medium',
	    shortestValue: '0'
	  },
	  'overflow': {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  'overflow-x': {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  'overflow-y': {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  'padding': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'padding-top',
	      'padding-right',
	      'padding-bottom',
	      'padding-left'
	    ],
	    defaultValue: '0',
	    restore: restore.fourValues,
	    shorthand: true
	  },
	  'padding-bottom': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-top'
	  },
	  'padding-left': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-right'
	  },
	  'padding-right': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-left'
	  },
	  'padding-top': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-bottom'
	  },
	  'position': {
	    canOverride: canOverride.property.position,
	    defaultValue: 'static'
	  },
	  'right': {
	    canOverride: canOverride.property.right,
	    defaultValue: 'auto'
	  },
	  'text-align': {
	    canOverride: canOverride.property.textAlign,
	    // NOTE: we can't tell the real default value here, as it depends on default text direction
	    // this is a hack, but it doesn't matter because this value will be either overridden or
	    // it will disappear anyway
	    defaultValue: 'left|right'
	  },
	  'text-decoration': {
	    canOverride: canOverride.property.textDecoration,
	    defaultValue: 'none'
	  },
	  'text-overflow': {
	    canOverride: canOverride.property.textOverflow,
	    defaultValue: 'none'
	  },
	  'text-shadow': {
	    canOverride: canOverride.property.textShadow,
	    defaultValue: 'none'
	  },
	  'top': {
	    canOverride: canOverride.property.top,
	    defaultValue: 'auto'
	  },
	  'transform': {
	    canOverride: canOverride.property.transform,
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-webkit-'
	    ]
	  },
	  'transition': {
	    breakUp: breakUp.multiplex(breakUp.transition),
	    canOverride: canOverride.generic.components([
	      canOverride.property.transitionProperty,
	      canOverride.generic.time,
	      canOverride.generic.timingFunction,
	      canOverride.generic.time
	    ]),
	    components: [
	      'transition-property',
	      'transition-duration',
	      'transition-timing-function',
	      'transition-delay'
	    ],
	    defaultValue: 'none',
	    restore: restore.multiplex(restore.withoutDefaults),
	    shorthand: true,
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-delay': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-duration': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-property': {
	    canOverride: canOverride.generic.propertyName,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: 'all',
	    intoMultiplexMode: 'placeholder',
	    placeholderValue: '_', // it's a short value that won't match any property and still be a valid `transition-property`
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-timing-function': {
	    canOverride: canOverride.generic.timingFunction,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: 'ease',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'vertical-align': {
	    canOverride: canOverride.property.verticalAlign,
	    defaultValue: 'baseline'
	  },
	  'visibility': {
	    canOverride: canOverride.property.visibility,
	    defaultValue: 'visible'
	  },
	  'white-space': {
	    canOverride: canOverride.property.whiteSpace,
	    defaultValue: 'normal'
	  },
	  'width': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'auto',
	    shortestValue: '0'
	  },
	  'z-index': {
	    canOverride: canOverride.property.zIndex,
	    defaultValue: 'auto'
	  }
	};

	function cloneDescriptor(propertyName, prefix) {
	  var clonedDescriptor = override(compactable[propertyName], {});

	  if ('componentOf' in clonedDescriptor) {
	    clonedDescriptor.componentOf = clonedDescriptor.componentOf.map(function (shorthandName) {
	      return prefix + shorthandName;
	    });
	  }

	  if ('components' in clonedDescriptor) {
	    clonedDescriptor.components = clonedDescriptor.components.map(function (longhandName) {
	      return prefix + longhandName;
	    });
	  }

	  if ('keepUnlessDefault' in clonedDescriptor) {
	    clonedDescriptor.keepUnlessDefault = prefix + clonedDescriptor.keepUnlessDefault;
	  }

	  return clonedDescriptor;
	}

	// generate vendor-prefixed properties
	var vendorPrefixedCompactable = {};

	for (var propertyName in compactable) {
	  var descriptor = compactable[propertyName];

	  if (!('vendorPrefixes' in descriptor)) {
	    continue;
	  }

	  for (var i = 0; i < descriptor.vendorPrefixes.length; i++) {
	    var prefix = descriptor.vendorPrefixes[i];
	    var clonedDescriptor = cloneDescriptor(propertyName, prefix);
	    delete clonedDescriptor.vendorPrefixes;

	    vendorPrefixedCompactable[prefix + propertyName] = clonedDescriptor;
	  }

	  delete descriptor.vendorPrefixes;
	}

	compactable_1 = override(compactable, vendorPrefixedCompactable);
	return compactable_1;
}

var populateComponents_1;
var hasRequiredPopulateComponents;

function requirePopulateComponents () {
	if (hasRequiredPopulateComponents) return populateComponents_1;
	hasRequiredPopulateComponents = 1;
	var compactable = requireCompactable();
	var InvalidPropertyError = requireInvalidPropertyError();

	function populateComponents(properties, validator, warnings) {
	  var component;
	  var j, m;

	  for (var i = properties.length - 1; i >= 0; i--) {
	    var property = properties[i];
	    var descriptor = compactable[property.name];

	    if (descriptor && descriptor.shorthand) {
	      property.shorthand = true;
	      property.dirty = true;

	      try {
	        property.components = descriptor.breakUp(property, compactable, validator);

	        if (descriptor.shorthandComponents) {
	          for (j = 0, m = property.components.length; j < m; j++) {
	            component = property.components[j];
	            component.components = compactable[component.name].breakUp(component, compactable, validator);
	          }
	        }
	      } catch (e) {
	        if (e instanceof InvalidPropertyError) {
	          property.components = []; // this will set property.unused to true below
	          warnings.push(e.message);
	        } else {
	          throw e;
	        }
	      }

	      if (property.components.length > 0)
	        property.multiplex = property.components[0].multiplex;
	      else
	        property.unused = true;
	    }
	  }
	}

	populateComponents_1 = populateComponents;
	return populateComponents_1;
}

var restoreWithComponents_1;
var hasRequiredRestoreWithComponents;

function requireRestoreWithComponents () {
	if (hasRequiredRestoreWithComponents) return restoreWithComponents_1;
	hasRequiredRestoreWithComponents = 1;
	var compactable = requireCompactable();

	function restoreWithComponents(property) {
	  var descriptor = compactable[property.name];

	  if (descriptor && descriptor.shorthand) {
	    return descriptor.restore(property, compactable);
	  } else {
	    return property.value;
	  }
	}

	restoreWithComponents_1 = restoreWithComponents;
	return restoreWithComponents_1;
}

var mergeIntoShorthands_1;
var hasRequiredMergeIntoShorthands;

function requireMergeIntoShorthands () {
	if (hasRequiredMergeIntoShorthands) return mergeIntoShorthands_1;
	hasRequiredMergeIntoShorthands = 1;
	var everyValuesPair = requireEveryValuesPair();
	var hasInherit = requireHasInherit();
	var populateComponents = requirePopulateComponents();

	var compactable = requireCompactable();
	var deepClone = requireClone$1().deep;
	var restoreWithComponents = requireRestoreWithComponents();

	var restoreFromOptimizing = requireRestoreFromOptimizing();
	var wrapSingle = requireWrapForOptimizing().single;

	var serializeBody = requireOneTime().body;
	var Token = requireToken();

	function mergeIntoShorthands(properties, validator) {
	  var candidates = {};
	  var descriptor;
	  var componentOf;
	  var property;
	  var i, l;
	  var j, m;

	  // there is no shorthand property made up of less than 3 longhands
	  if (properties.length < 3) {
	    return;
	  }

	  for (i = 0, l = properties.length; i < l; i++) {
	    property = properties[i];
	    descriptor = compactable[property.name];

	    if (property.unused) {
	      continue;
	    }

	    if (property.hack) {
	      continue;
	    }

	    if (property.block) {
	      continue;
	    }

	    invalidateOrCompact(properties, i, candidates, validator);

	    if (descriptor && descriptor.componentOf) {
	      for (j = 0, m = descriptor.componentOf.length; j < m; j++) {
	        componentOf = descriptor.componentOf[j];

	        candidates[componentOf] = candidates[componentOf] || {};
	        candidates[componentOf][property.name] = property;
	      }
	    }
	  }

	  invalidateOrCompact(properties, i, candidates, validator);
	}

	function invalidateOrCompact(properties, position, candidates, validator) {
	  var invalidatedBy = properties[position];
	  var shorthandName;
	  var shorthandDescriptor;
	  var candidateComponents;

	  for (shorthandName in candidates) {
	    if (undefined !== invalidatedBy && shorthandName == invalidatedBy.name) {
	      continue;
	    }

	    shorthandDescriptor = compactable[shorthandName];
	    candidateComponents = candidates[shorthandName];
	    if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {
	      delete candidates[shorthandName];
	      continue;
	    }

	    if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {
	      continue;
	    }

	    if (mixedImportance(candidateComponents)) {
	      continue;
	    }

	    if (!overridable(candidateComponents, shorthandName, validator)) {
	      continue;
	    }

	    if (!mergeable(candidateComponents)) {
	      continue;
	    }

	    if (mixedInherit(candidateComponents)) {
	      replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);
	    } else {
	      replaceWithShorthand(properties, candidateComponents, shorthandName, validator);
	    }
	  }
	}

	function invalidates(candidates, shorthandName, invalidatedBy) {
	  var shorthandDescriptor = compactable[shorthandName];
	  var invalidatedByDescriptor = compactable[invalidatedBy.name];
	  var componentName;

	  if ('overridesShorthands' in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {
	    return true;
	  }

	  if (invalidatedByDescriptor && 'componentOf' in invalidatedByDescriptor) {
	    for (componentName in candidates[shorthandName]) {
	      if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function mixedImportance(components) {
	  var important;
	  var componentName;

	  for (componentName in components) {
	    if (undefined !== important && components[componentName].important != important) {
	      return true;
	    }

	    important = components[componentName].important;
	  }

	  return false;
	}

	function overridable(components, shorthandName, validator) {
	  var descriptor = compactable[shorthandName];
	  var newValuePlaceholder = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var newProperty = wrapSingle(newValuePlaceholder);
	  var component;
	  var mayOverride;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];
	    mayOverride = compactable[component.name].canOverride;

	    if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {
	      return false;
	    }
	  }

	  return true;
	}

	function mergeable(components) {
	  var lastCount = null;
	  var currentCount;
	  var componentName;
	  var component;
	  var descriptor;
	  var values;

	  for (componentName in components) {
	    component = components[componentName];
	    descriptor = compactable[componentName];

	    if (!('restore' in descriptor)) {
	      continue;
	    }

	    restoreFromOptimizing([component.all[component.position]], restoreWithComponents);
	    values = descriptor.restore(component, compactable);

	    currentCount = values.length;

	    if (lastCount !== null && currentCount !== lastCount) {
	      return false;
	    }

	    lastCount = currentCount;
	  }

	  return true;
	}

	function mixedInherit(components) {
	  var componentName;
	  var lastValue = null;
	  var currentValue;

	  for (componentName in components) {
	    currentValue = hasInherit(components[componentName]);

	    if (lastValue !== null && lastValue !== currentValue) {
	      return true;
	    }

	    lastValue = currentValue;
	  }

	  return false;
	}

	function replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator) {
	  var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);
	  var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);
	  var longhandTokensSequence = viaLonghands[0];
	  var shorthandTokensSequence = viaShorthand[0];
	  var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;
	  var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;
	  var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];
	  var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];
	  var all = candidateComponents[Object.keys(candidateComponents)[0]].all;
	  var componentName;
	  var oldComponent;
	  var newComponent;
	  var newToken;

	  newProperty.position = all.length;
	  newProperty.shorthand = true;
	  newProperty.dirty = true;
	  newProperty.all = all;
	  newProperty.all.push(newTokensSequence[0]);

	  properties.push(newProperty);

	  for (componentName in candidateComponents) {
	    oldComponent = candidateComponents[componentName];
	    oldComponent.unused = true;

	    if (oldComponent.name in newComponents) {
	      newComponent = newComponents[oldComponent.name];
	      newToken = findTokenIn(newTokensSequence, componentName);

	      newComponent.position = all.length;
	      newComponent.all = all;
	      newComponent.all.push(newToken);

	      properties.push(newComponent);
	    }
	  }
	}

	function buildSequenceWithInheritLonghands(components, shorthandName, validator) {
	  var tokensSequence = [];
	  var inheritComponents = {};
	  var nonInheritComponents = {};
	  var descriptor = compactable[shorthandName];
	  var shorthandToken = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var newProperty = wrapSingle(shorthandToken);
	  var component;
	  var longhandToken;
	  var newComponent;
	  var nameMetadata;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];

	    if (hasInherit(component)) {
	      longhandToken = component.all[component.position].slice(0, 2);
	      Array.prototype.push.apply(longhandToken, component.value);
	      tokensSequence.push(longhandToken);

	      newComponent = deepClone(component);
	      newComponent.value = inferComponentValue(components, newComponent.name);

	      newProperty.components[i] = newComponent;
	      inheritComponents[component.name] = deepClone(component);
	    } else {
	      newComponent = deepClone(component);
	      newComponent.all = component.all;
	      newProperty.components[i] = newComponent;

	      nonInheritComponents[component.name] = component;
	    }
	  }

	  nameMetadata = joinMetadata(nonInheritComponents, 1);
	  shorthandToken[1].push(nameMetadata);

	  restoreFromOptimizing([newProperty], restoreWithComponents);

	  shorthandToken = shorthandToken.slice(0, 2);
	  Array.prototype.push.apply(shorthandToken, newProperty.value);

	  tokensSequence.unshift(shorthandToken);

	  return [tokensSequence, newProperty, inheritComponents];
	}

	function inferComponentValue(components, propertyName) {
	  var descriptor = compactable[propertyName];

	  if ('oppositeTo' in descriptor) {
	    return components[descriptor.oppositeTo].value;
	  } else {
	    return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
	  }
	}

	function joinMetadata(components, at) {
	  var metadata = [];
	  var component;
	  var originalValue;
	  var componentMetadata;
	  var componentName;

	  for (componentName in components) {
	    component = components[componentName];
	    originalValue = component.all[component.position];
	    componentMetadata = originalValue[at][originalValue[at].length - 1];

	    Array.prototype.push.apply(metadata, componentMetadata);
	  }

	  return metadata.sort(metadataSorter);
	}

	function metadataSorter(metadata1, metadata2) {
	  var line1 = metadata1[0];
	  var line2 = metadata2[0];
	  var column1 = metadata1[1];
	  var column2 = metadata2[1];

	  if (line1 < line2) {
	    return -1;
	  } else if (line1 === line2) {
	    return column1 < column2 ? -1 : 1;
	  } else {
	    return 1;
	  }
	}

	function buildSequenceWithInheritShorthand(components, shorthandName, validator) {
	  var tokensSequence = [];
	  var inheritComponents = {};
	  var nonInheritComponents = {};
	  var descriptor = compactable[shorthandName];
	  var shorthandToken = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, 'inherit']
	  ];
	  var newProperty = wrapSingle(shorthandToken);
	  var component;
	  var longhandToken;
	  var nameMetadata;
	  var valueMetadata;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];

	    if (hasInherit(component)) {
	      inheritComponents[component.name] = component;
	    } else {
	      longhandToken = component.all[component.position].slice(0, 2);
	      Array.prototype.push.apply(longhandToken, component.value);
	      tokensSequence.push(longhandToken);

	      nonInheritComponents[component.name] = deepClone(component);
	    }
	  }

	  nameMetadata = joinMetadata(inheritComponents, 1);
	  shorthandToken[1].push(nameMetadata);

	  valueMetadata = joinMetadata(inheritComponents, 2);
	  shorthandToken[2].push(valueMetadata);

	  tokensSequence.unshift(shorthandToken);

	  return [tokensSequence, newProperty, nonInheritComponents];
	}

	function findTokenIn(tokens, componentName) {
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    if (tokens[i][1][1] == componentName) {
	      return tokens[i];
	    }
	  }
	}

	function replaceWithShorthand(properties, candidateComponents, shorthandName, validator) {
	  var descriptor = compactable[shorthandName];
	  var nameMetadata;
	  var valueMetadata;
	  var newValuePlaceholder = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var all;

	  var newProperty = wrapSingle(newValuePlaceholder);
	  newProperty.shorthand = true;
	  newProperty.dirty = true;

	  populateComponents([newProperty], validator, []);

	  for (var i = 0, l = descriptor.components.length; i < l; i++) {
	    var component = candidateComponents[descriptor.components[i]];

	    newProperty.components[i] = deepClone(component);
	    newProperty.important = component.important;

	    all = component.all;
	  }

	  for (var componentName in candidateComponents) {
	    candidateComponents[componentName].unused = true;
	  }

	  nameMetadata = joinMetadata(candidateComponents, 1);
	  newValuePlaceholder[1].push(nameMetadata);

	  valueMetadata = joinMetadata(candidateComponents, 2);
	  newValuePlaceholder[2].push(valueMetadata);

	  newProperty.position = all.length;
	  newProperty.all = all;
	  newProperty.all.push(newValuePlaceholder);

	  properties.push(newProperty);
	}

	mergeIntoShorthands_1 = mergeIntoShorthands;
	return mergeIntoShorthands_1;
}

var findComponentIn_1;
var hasRequiredFindComponentIn;

function requireFindComponentIn () {
	if (hasRequiredFindComponentIn) return findComponentIn_1;
	hasRequiredFindComponentIn = 1;
	var compactable = requireCompactable();

	function findComponentIn(shorthand, longhand) {
	  var comparator = nameComparator(longhand);

	  return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);
	}

	function nameComparator(to) {
	  return function (property) {
	    return to.name === property.name;
	  };
	}

	function findInDirectComponents(shorthand, comparator) {
	  return shorthand.components.filter(comparator)[0];
	}

	function findInSubComponents(shorthand, comparator) {
	  var shorthandComponent;
	  var longhandMatch;
	  var i, l;

	  if (!compactable[shorthand.name].shorthandComponents) {
	    return;
	  }

	  for (i = 0, l = shorthand.components.length; i < l; i++) {
	    shorthandComponent = shorthand.components[i];
	    longhandMatch = findInDirectComponents(shorthandComponent, comparator);

	    if (longhandMatch) {
	      return longhandMatch;
	    }
	  }

	  return;
	}

	findComponentIn_1 = findComponentIn;
	return findComponentIn_1;
}

var isComponentOf_1;
var hasRequiredIsComponentOf;

function requireIsComponentOf () {
	if (hasRequiredIsComponentOf) return isComponentOf_1;
	hasRequiredIsComponentOf = 1;
	var compactable = requireCompactable();

	function isComponentOf(property1, property2, shallow) {
	  return isDirectComponentOf(property1, property2) ||
	    !shallow && !!compactable[property1.name].shorthandComponents && isSubComponentOf(property1, property2);
	}

	function isDirectComponentOf(property1, property2) {
	  var descriptor = compactable[property1.name];

	  return 'components' in descriptor && descriptor.components.indexOf(property2.name) > -1;
	}

	function isSubComponentOf(property1, property2) {
	  return property1
	    .components
	    .some(function (component) {
	      return isDirectComponentOf(component, property2);
	    });
	}

	isComponentOf_1 = isComponentOf;
	return isComponentOf_1;
}

var isMergeableShorthand_1;
var hasRequiredIsMergeableShorthand;

function requireIsMergeableShorthand () {
	if (hasRequiredIsMergeableShorthand) return isMergeableShorthand_1;
	hasRequiredIsMergeableShorthand = 1;
	var Marker = requireMarker();

	function isMergeableShorthand(shorthand) {
	  if (shorthand.name != 'font') {
	    return true;
	  }

	  return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;
	}

	isMergeableShorthand_1 = isMergeableShorthand;
	return isMergeableShorthand_1;
}

var overridesNonComponentShorthand_1;
var hasRequiredOverridesNonComponentShorthand;

function requireOverridesNonComponentShorthand () {
	if (hasRequiredOverridesNonComponentShorthand) return overridesNonComponentShorthand_1;
	hasRequiredOverridesNonComponentShorthand = 1;
	var compactable = requireCompactable();

	function overridesNonComponentShorthand(property1, property2) {
	  return property1.name in compactable &&
	    'overridesShorthands' in compactable[property1.name] &&
	    compactable[property1.name].overridesShorthands.indexOf(property2.name) > -1;
	}

	overridesNonComponentShorthand_1 = overridesNonComponentShorthand;
	return overridesNonComponentShorthand_1;
}

var overrideProperties_1;
var hasRequiredOverrideProperties;

function requireOverrideProperties () {
	if (hasRequiredOverrideProperties) return overrideProperties_1;
	hasRequiredOverrideProperties = 1;
	var hasInherit = requireHasInherit();
	var everyValuesPair = requireEveryValuesPair();
	var findComponentIn = requireFindComponentIn();
	var isComponentOf = requireIsComponentOf();
	var isMergeableShorthand = requireIsMergeableShorthand();
	var overridesNonComponentShorthand = requireOverridesNonComponentShorthand();
	var sameVendorPrefixesIn = requireVendorPrefixes().same;

	var compactable = requireCompactable();
	var deepClone = requireClone$1().deep;
	var restoreWithComponents = requireRestoreWithComponents();
	var shallowClone = requireClone$1().shallow;

	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var Token = requireToken();
	var Marker = requireMarker();

	var serializeProperty = requireOneTime().property;

	function wouldBreakCompatibility(property, validator) {
	  for (var i = 0; i < property.components.length; i++) {
	    var component = property.components[i];
	    var descriptor = compactable[component.name];
	    var canOverride = descriptor && descriptor.canOverride || canOverride.sameValue;

	    var _component = shallowClone(component);
	    _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];

	    if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {
	      return true;
	    }
	  }

	  return false;
	}

	function overrideIntoMultiplex(property, by) {
	  by.unused = true;

	  turnIntoMultiplex(by, multiplexSize(property));
	  property.value = by.value;
	}

	function overrideByMultiplex(property, by) {
	  by.unused = true;
	  property.multiplex = true;
	  property.value = by.value;
	}

	function overrideSimple(property, by) {
	  by.unused = true;
	  property.value = by.value;
	}

	function override(property, by) {
	  if (by.multiplex)
	    overrideByMultiplex(property, by);
	  else if (property.multiplex)
	    overrideIntoMultiplex(property, by);
	  else
	    overrideSimple(property, by);
	}

	function overrideShorthand(property, by) {
	  by.unused = true;

	  for (var i = 0, l = property.components.length; i < l; i++) {
	    override(property.components[i], by.components[i], property.multiplex);
	  }
	}

	function turnIntoMultiplex(property, size) {
	  property.multiplex = true;

	  if (compactable[property.name].shorthand) {
	    turnShorthandValueIntoMultiplex(property, size);
	  } else {
	    turnLonghandValueIntoMultiplex(property, size);
	  }
	}

	function turnShorthandValueIntoMultiplex(property, size) {
	  var component;
	  var i, l;

	  for (i = 0, l = property.components.length; i < l; i++) {
	    component = property.components[i];

	    if (!component.multiplex) {
	      turnLonghandValueIntoMultiplex(component, size);
	    }
	  }
	}

	function turnLonghandValueIntoMultiplex(property, size) {
	  var descriptor = compactable[property.name];
	  var withRealValue = descriptor.intoMultiplexMode == 'real';
	  var withValue = descriptor.intoMultiplexMode == 'real' ?
	    property.value.slice(0) :
	    (descriptor.intoMultiplexMode == 'placeholder' ? descriptor.placeholderValue : descriptor.defaultValue);
	  var i = multiplexSize(property);
	  var j;
	  var m = withValue.length;

	  for (; i < size; i++) {
	    property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);

	    if (Array.isArray(withValue)) {
	      for (j = 0; j < m; j++) {
	        property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);
	      }
	    } else {
	      property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);
	    }
	  }
	}

	function multiplexSize(component) {
	  var size = 0;

	  for (var i = 0, l = component.value.length; i < l; i++) {
	    if (component.value[i][1] == Marker.COMMA)
	      size++;
	  }

	  return size + 1;
	}

	function lengthOf(property) {
	  var fakeAsArray = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, property.name]
	  ].concat(property.value);
	  return serializeProperty([fakeAsArray], 0).length;
	}

	function moreSameShorthands(properties, startAt, name) {
	  // Since we run the main loop in `compactOverrides` backwards, at this point some
	  // properties may not be marked as unused.
	  // We should consider reverting the order if possible
	  var count = 0;

	  for (var i = startAt; i >= 0; i--) {
	    if (properties[i].name == name && !properties[i].unused)
	      count++;
	    if (count > 1)
	      break;
	  }

	  return count > 1;
	}

	function overridingFunction(shorthand, validator) {
	  for (var i = 0, l = shorthand.components.length; i < l; i++) {
	    if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {
	      return true;
	    }
	  }

	  return false;
	}

	function anyValue(fn, property) {
	  for (var i = 0, l = property.value.length; i < l; i++) {
	    if (property.value[i][1] == Marker.COMMA)
	      continue;

	    if (fn(property.value[i][1]))
	      return true;
	  }

	  return false;
	}

	function wouldResultInLongerValue(left, right) {
	  if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex)
	    return false;

	  var multiplex = left.multiplex ? left : right;
	  var simple = left.multiplex ? right : left;
	  var component;

	  var multiplexClone = deepClone(multiplex);
	  restoreFromOptimizing([multiplexClone], restoreWithComponents);

	  var simpleClone = deepClone(simple);
	  restoreFromOptimizing([simpleClone], restoreWithComponents);

	  var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);

	  if (left.multiplex) {
	    component = findComponentIn(multiplexClone, simpleClone);
	    overrideIntoMultiplex(component, simpleClone);
	  } else {
	    component = findComponentIn(simpleClone, multiplexClone);
	    turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));
	    overrideByMultiplex(component, multiplexClone);
	  }

	  restoreFromOptimizing([simpleClone], restoreWithComponents);

	  var lengthAfter = lengthOf(simpleClone);

	  return lengthBefore <= lengthAfter;
	}

	function isCompactable(property) {
	  return property.name in compactable;
	}

	function noneOverrideHack(left, right) {
	  return !left.multiplex &&
	    (left.name == 'background' || left.name == 'background-image') &&
	    right.multiplex &&
	    (right.name == 'background' || right.name == 'background-image') &&
	    anyLayerIsNone(right.value);
	}

	function anyLayerIsNone(values) {
	  var layers = intoLayers(values);

	  for (var i = 0, l = layers.length; i < l; i++) {
	    if (layers[i].length == 1 && layers[i][0][1] == 'none')
	      return true;
	  }

	  return false;
	}

	function intoLayers(values) {
	  var layers = [];

	  for (var i = 0, layer = [], l = values.length; i < l; i++) {
	    var value = values[i];
	    if (value[1] == Marker.COMMA) {
	      layers.push(layer);
	      layer = [];
	    } else {
	      layer.push(value);
	    }
	  }

	  layers.push(layer);
	  return layers;
	}

	function overrideProperties(properties, withMerging, compatibility, validator) {
	  var mayOverride, right, left, component;
	  var overriddenComponents;
	  var overriddenComponent;
	  var overridingComponent;
	  var overridable;
	  var i, j, k;

	  propertyLoop:
	  for (i = properties.length - 1; i >= 0; i--) {
	    right = properties[i];

	    if (!isCompactable(right))
	      continue;

	    if (right.block)
	      continue;

	    mayOverride = compactable[right.name].canOverride;

	    traverseLoop:
	    for (j = i - 1; j >= 0; j--) {
	      left = properties[j];

	      if (!isCompactable(left))
	        continue;

	      if (left.block)
	        continue;

	      if (left.unused || right.unused)
	        continue;

	      if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack)
	        continue;

	      if (left.important == right.important && left.hack[0] != right.hack[0])
	        continue;

	      if (left.important == right.important && (left.hack[0] != right.hack[0] || (left.hack[1] && left.hack[1] != right.hack[1])))
	        continue;

	      if (hasInherit(right))
	        continue;

	      if (noneOverrideHack(left, right))
	        continue;

	      if (right.shorthand && isComponentOf(right, left)) {
	        // maybe `left` can be overridden by `right` which is a shorthand?
	        if (!right.important && left.important)
	          continue;

	        if (!sameVendorPrefixesIn([left], right.components))
	          continue;

	        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator))
	          continue;

	        if (!isMergeableShorthand(right)) {
	          left.unused = true;
	          continue;
	        }

	        component = findComponentIn(right, left);
	        mayOverride = compactable[left.name].canOverride;
	        if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {
	          left.unused = true;
	        }
	      } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {
	        // `right` is a shorthand while `left` can be overriden by it, think `border` and `border-top`
	        if (!right.important && left.important) {
	          continue;
	        }

	        if (!sameVendorPrefixesIn([left], right.components)) {
	          continue;
	        }

	        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {
	          continue;
	        }

	        overriddenComponents = left.shorthand ?
	          left.components:
	          [left];

	        for (k = overriddenComponents.length - 1; k >= 0; k--) {
	          overriddenComponent = overriddenComponents[k];
	          overridingComponent = findComponentIn(right, overriddenComponent);
	          mayOverride = compactable[overriddenComponent.name].canOverride;

	          if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {
	            continue traverseLoop;
	          }
	        }

	        left.unused = true;
	      } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {
	        // maybe `right` can be pulled into `left` which is a shorthand?
	        if (right.important && !left.important)
	          continue;

	        if (!right.important && left.important) {
	          right.unused = true;
	          continue;
	        }

	        // Pending more clever algorithm in #527
	        if (moreSameShorthands(properties, i - 1, left.name))
	          continue;

	        if (overridingFunction(left, validator))
	          continue;

	        if (!isMergeableShorthand(left))
	          continue;

	        component = findComponentIn(left, right);
	        if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {
	          var disabledBackgroundMerging =
	            !compatibility.properties.backgroundClipMerging && component.name.indexOf('background-clip') > -1 ||
	            !compatibility.properties.backgroundOriginMerging && component.name.indexOf('background-origin') > -1 ||
	            !compatibility.properties.backgroundSizeMerging && component.name.indexOf('background-size') > -1;
	          var nonMergeableValue = compactable[right.name].nonMergeableValue === right.value[0][1];

	          if (disabledBackgroundMerging || nonMergeableValue)
	            continue;

	          if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator))
	            continue;

	          if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right)))
	            continue;

	          if (wouldResultInLongerValue(left, right))
	            continue;

	          if (!left.multiplex && right.multiplex)
	            turnIntoMultiplex(left, multiplexSize(right));

	          override(component, right);
	          left.dirty = true;
	        }
	      } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {
	        // merge if all components can be merged

	        if (!left.multiplex && right.multiplex)
	          continue;

	        if (!right.important && left.important) {
	          right.unused = true;
	          continue propertyLoop;
	        }

	        if (right.important && !left.important) {
	          left.unused = true;
	          continue;
	        }

	        if (!isMergeableShorthand(right)) {
	          left.unused = true;
	          continue;
	        }

	        for (k = left.components.length - 1; k >= 0; k--) {
	          var leftComponent = left.components[k];
	          var rightComponent = right.components[k];

	          mayOverride = compactable[leftComponent.name].canOverride;
	          if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent))
	            continue propertyLoop;
	        }

	        overrideShorthand(left, right);
	        left.dirty = true;
	      } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {
	        // border is a shorthand but any of its components is a shorthand too

	        if (!left.important && right.important)
	          continue;

	        component = findComponentIn(left, right);
	        mayOverride = compactable[right.name].canOverride;
	        if (!everyValuesPair(mayOverride.bind(null, validator), component, right))
	          continue;

	        if (left.important && !right.important) {
	          right.unused = true;
	          continue;
	        }

	        var rightRestored = compactable[right.name].restore(right, compactable);
	        if (rightRestored.length > 1)
	          continue;

	        component = findComponentIn(left, right);
	        override(component, right);
	        right.dirty = true;
	      } else if (left.name == right.name) {
	        // two non-shorthands should be merged based on understandability
	        overridable = true;

	        if (right.shorthand) {
	          for (k = right.components.length - 1; k >= 0 && overridable; k--) {
	            overriddenComponent = left.components[k];
	            overridingComponent = right.components[k];
	            mayOverride = compactable[overridingComponent.name].canOverride;

	            overridable = overridable && everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);
	          }
	        } else {
	          mayOverride = compactable[right.name].canOverride;
	          overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);
	        }

	        if (left.important && !right.important && overridable) {
	          right.unused = true;
	          continue;
	        }

	        if (!left.important && right.important && overridable) {
	          left.unused = true;
	          continue;
	        }

	        if (!overridable) {
	          continue;
	        }

	        left.unused = true;
	      }
	    }
	  }
	}

	overrideProperties_1 = overrideProperties;
	return overrideProperties_1;
}

var optimize$1;
var hasRequiredOptimize$1;

function requireOptimize$1 () {
	if (hasRequiredOptimize$1) return optimize$1;
	hasRequiredOptimize$1 = 1;
	var mergeIntoShorthands = requireMergeIntoShorthands();
	var overrideProperties = requireOverrideProperties();
	var populateComponents = requirePopulateComponents();

	var restoreWithComponents = requireRestoreWithComponents();

	var wrapForOptimizing = requireWrapForOptimizing().all;
	var removeUnused = requireRemoveUnused();
	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	function optimizeProperties(properties, withOverriding, withMerging, context) {
	  var levelOptions = context.options.level[OptimizationLevel.Two];
	  var _properties = wrapForOptimizing(properties, false, levelOptions.skipProperties);
	  var _property;
	  var i, l;

	  populateComponents(_properties, context.validator, context.warnings);

	  for (i = 0, l = _properties.length; i < l; i++) {
	    _property = _properties[i];
	    if (_property.block) {
	      optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);
	    }
	  }

	  if (withMerging && levelOptions.mergeIntoShorthands) {
	    mergeIntoShorthands(_properties, context.validator);
	  }

	  if (withOverriding && levelOptions.overrideProperties) {
	    overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);
	  }

	  restoreFromOptimizing(_properties, restoreWithComponents);
	  removeUnused(_properties);
	}

	optimize$1 = optimizeProperties;
	return optimize$1;
}

var mergeAdjacent_1;
var hasRequiredMergeAdjacent;

function requireMergeAdjacent () {
	if (hasRequiredMergeAdjacent) return mergeAdjacent_1;
	hasRequiredMergeAdjacent = 1;
	var isMergeable = requireIsMergeable();

	var optimizeProperties = requireOptimize$1();

	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function mergeAdjacent(tokens, context) {
	  var lastToken = [null, [], []];
	  var options = context.options;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var mergeLimit = options.compatibility.selectors.mergeLimit;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] != Token.RULE) {
	      lastToken = [null, [], []];
	      continue;
	    }

	    if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {
	      Array.prototype.push.apply(lastToken[2], token[2]);
	      optimizeProperties(lastToken[2], true, true, context);
	      token[2] = [];
	    } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2]) &&
	        isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&
	        isMergeable(serializeRules(lastToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&
	        lastToken[1].length < mergeLimit) {
	      lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
	      lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];
	      token[2] = [];
	    } else {
	      lastToken = token;
	    }
	  }
	}

	mergeAdjacent_1 = mergeAdjacent;
	return mergeAdjacent_1;
}

var rulesOverlap_1;
var hasRequiredRulesOverlap;

function requireRulesOverlap () {
	if (hasRequiredRulesOverlap) return rulesOverlap_1;
	hasRequiredRulesOverlap = 1;
	var MODIFIER_PATTERN = /\-\-.+$/;

	function rulesOverlap(rule1, rule2, bemMode) {
	  var scope1;
	  var scope2;
	  var i, l;
	  var j, m;

	  for (i = 0, l = rule1.length; i < l; i++) {
	    scope1 = rule1[i][1];

	    for (j = 0, m = rule2.length; j < m; j++) {
	      scope2 = rule2[j][1];

	      if (scope1 == scope2) {
	        return true;
	      }

	      if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function withoutModifiers(scope) {
	  return scope.replace(MODIFIER_PATTERN, '');
	}

	rulesOverlap_1 = rulesOverlap;
	return rulesOverlap_1;
}

var specificity_1;
var hasRequiredSpecificity;

function requireSpecificity () {
	if (hasRequiredSpecificity) return specificity_1;
	hasRequiredSpecificity = 1;
	var Marker = requireMarker();

	var Selector = {
	  DOT: '.',
	  HASH: '#',
	  PSEUDO: ':'
	};

	var LETTER_PATTERN = /[a-zA-Z]/;
	var NOT_PREFIX = ':not(';
	var SEPARATOR_PATTERN = /[\s,\(>~\+]/;

	function specificity(selector) {
	  var result = [0, 0, 0];
	  var character;
	  var isEscaped;
	  var isSingleQuoted;
	  var isDoubleQuoted;
	  var roundBracketLevel = 0;
	  var couldIntroduceNewTypeSelector;
	  var withinNotPseudoClass = false;
	  var wasPseudoClass = false;
	  var i, l;

	  for (i = 0, l = selector.length; i < l; i++) {
	    character = selector[i];

	    if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
	      isSingleQuoted = true;
	    } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {
	      isSingleQuoted = false;
	    } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
	      isDoubleQuoted = true;
	    } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {
	      isDoubleQuoted = false;
	    } else if (isSingleQuoted || isDoubleQuoted) {
	      continue;
	    } else if (roundBracketLevel > 0 && !withinNotPseudoClass) ; else if (character == Marker.OPEN_ROUND_BRACKET) {
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {
	      roundBracketLevel--;
	      withinNotPseudoClass = false;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET) {
	      roundBracketLevel--;
	    } else if (character == Selector.HASH) {
	      result[0]++;
	    } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {
	      result[1]++;
	    } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {
	      result[1]++;
	      withinNotPseudoClass = false;
	    } else if (character == Selector.PSEUDO) {
	      withinNotPseudoClass = true;
	    } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {
	      result[2]++;
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	    wasPseudoClass = character == Selector.PSEUDO;
	    couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);
	  }

	  return result;
	}

	function isNotPseudoClass(selector, index) {
	  return selector.indexOf(NOT_PREFIX, index) === index;
	}

	specificity_1 = specificity;
	return specificity_1;
}

var specificitiesOverlap_1;
var hasRequiredSpecificitiesOverlap;

function requireSpecificitiesOverlap () {
	if (hasRequiredSpecificitiesOverlap) return specificitiesOverlap_1;
	hasRequiredSpecificitiesOverlap = 1;
	var specificity = requireSpecificity();

	function specificitiesOverlap(selector1, selector2, cache) {
	  var specificity1;
	  var specificity2;
	  var i, l;
	  var j, m;

	  for (i = 0, l = selector1.length; i < l; i++) {
	    specificity1 = findSpecificity(selector1[i][1], cache);

	    for (j = 0, m = selector2.length; j < m; j++) {
	      specificity2 = findSpecificity(selector2[j][1], cache);

	      if (specificity1[0] === specificity2[0] && specificity1[1] === specificity2[1] && specificity1[2] === specificity2[2]) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function findSpecificity(selector, cache) {
	  var value;

	  if (!(selector in cache)) {
	    cache[selector] = value = specificity(selector);
	  }

	  return value || cache[selector];
	}

	specificitiesOverlap_1 = specificitiesOverlap;
	return specificitiesOverlap_1;
}

var reorderable;
var hasRequiredReorderable;

function requireReorderable () {
	if (hasRequiredReorderable) return reorderable;
	hasRequiredReorderable = 1;
	// TODO: it'd be great to merge it with the other canReorder functionality

	var rulesOverlap = requireRulesOverlap();
	var specificitiesOverlap = requireSpecificitiesOverlap();

	var FLEX_PROPERTIES = /align\-items|box\-align|box\-pack|flex|justify/;
	var BORDER_PROPERTIES = /^border\-(top|right|bottom|left|color|style|width|radius)/;

	function canReorder(left, right, cache) {
	  for (var i = right.length - 1; i >= 0; i--) {
	    for (var j = left.length - 1; j >= 0; j--) {
	      if (!canReorderSingle(left[j], right[i], cache))
	        return false;
	    }
	  }

	  return true;
	}

	function canReorderSingle(left, right, cache) {
	  var leftName = left[0];
	  var leftValue = left[1];
	  var leftNameRoot = left[2];
	  var leftSelector = left[5];
	  var leftInSpecificSelector = left[6];
	  var rightName = right[0];
	  var rightValue = right[1];
	  var rightNameRoot = right[2];
	  var rightSelector = right[5];
	  var rightInSpecificSelector = right[6];

	  if (leftName == 'font' && rightName == 'line-height' || rightName == 'font' && leftName == 'line-height')
	    return false;
	  if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName))
	    return false;
	  if (leftNameRoot == rightNameRoot && unprefixed(leftName) == unprefixed(rightName) && (vendorPrefixed(leftName) ^ vendorPrefixed(rightName)))
	    return false;
	  if (leftNameRoot == 'border' && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == 'border' || leftName == rightNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName))))
	    return false;
	  if (rightNameRoot == 'border' && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == 'border' || rightName == leftNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName))))
	    return false;
	  if (leftNameRoot == 'border' && rightNameRoot == 'border' && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName)))
	    return false;
	  if (leftNameRoot != rightNameRoot)
	    return true;
	  if (leftName == rightName && leftNameRoot == rightNameRoot && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue)))
	    return true;
	  if (leftName != rightName && leftNameRoot == rightNameRoot && leftName != leftNameRoot && rightName != rightNameRoot)
	    return true;
	  if (leftName != rightName && leftNameRoot == rightNameRoot && leftValue == rightValue)
	    return true;
	  if (rightInSpecificSelector && leftInSpecificSelector && !inheritable(leftNameRoot) && !inheritable(rightNameRoot) && !rulesOverlap(rightSelector, leftSelector, false))
	    return true;
	  if (!specificitiesOverlap(leftSelector, rightSelector, cache))
	    return true;

	  return false;
	}

	function vendorPrefixed(name) {
	  return /^\-(?:moz|webkit|ms|o)\-/.test(name);
	}

	function unprefixed(name) {
	  return name.replace(/^\-(?:moz|webkit|ms|o)\-/, '');
	}

	function sameBorderComponent(name1, name2) {
	  return name1.split('-').pop() == name2.split('-').pop();
	}

	function isSideBorder(name) {
	  return name == 'border-top' || name == 'border-right' || name == 'border-bottom' || name == 'border-left';
	}

	function isStyleBorder(name) {
	  return name == 'border-color' || name == 'border-style' || name == 'border-width';
	}

	function withDifferentVendorPrefix(value1, value2) {
	  return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split('-')[1] != value2.split('-')[2];
	}

	function inheritable(name) {
	  // According to http://www.w3.org/TR/CSS21/propidx.html
	  // Others will be catched by other, preceeding rules
	  return name == 'font' || name == 'line-height' || name == 'list-style';
	}

	reorderable = {
	  canReorder: canReorder,
	  canReorderSingle: canReorderSingle
	};
	return reorderable;
}

var extractProperties_1;
var hasRequiredExtractProperties;

function requireExtractProperties () {
	if (hasRequiredExtractProperties) return extractProperties_1;
	hasRequiredExtractProperties = 1;
	// This extractor is used in level 2 optimizations
	// IMPORTANT: Mind Token class and this code is not related!
	// Properties will be tokenized in one step, see #429

	var Token = requireToken();
	var serializeRules = requireOneTime().rules;
	var serializeValue = requireOneTime().value;

	function extractProperties(token) {
	  var properties = [];
	  var inSpecificSelector;
	  var property;
	  var name;
	  var value;
	  var i, l;

	  if (token[0] == Token.RULE) {
	    inSpecificSelector = !/[\.\+>~]/.test(serializeRules(token[1]));

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[0] != Token.PROPERTY)
	        continue;

	      name = property[1][1];
	      if (name.length === 0)
	        continue;

	      if (name.indexOf('--') === 0)
	        continue;

	      value = serializeValue(property, i);

	      properties.push([
	        name,
	        value,
	        findNameRoot(name),
	        token[2][i],
	        name + ':' + value,
	        token[1],
	        inSpecificSelector
	      ]);
	    }
	  } else if (token[0] == Token.NESTED_BLOCK) {
	    for (i = 0, l = token[2].length; i < l; i++) {
	      properties = properties.concat(extractProperties(token[2][i]));
	    }
	  }

	  return properties;
	}

	function findNameRoot(name) {
	  if (name == 'list-style')
	    return name;
	  if (name.indexOf('-radius') > 0)
	    return 'border-radius';
	  if (name == 'border-collapse' || name == 'border-spacing' || name == 'border-image')
	    return name;
	  if (name.indexOf('border-') === 0 && /^border\-\w+\-\w+$/.test(name))
	    return name.match(/border\-\w+/)[0];
	  if (name.indexOf('border-') === 0 && /^border\-\w+$/.test(name))
	    return 'border';
	  if (name.indexOf('text-') === 0)
	    return name;
	  if (name == '-chrome-')
	    return name;

	  return name.replace(/^\-\w+\-/, '').match(/([a-zA-Z]+)/)[0].toLowerCase();
	}

	extractProperties_1 = extractProperties;
	return extractProperties_1;
}

var mergeMediaQueries_1;
var hasRequiredMergeMediaQueries;

function requireMergeMediaQueries () {
	if (hasRequiredMergeMediaQueries) return mergeMediaQueries_1;
	hasRequiredMergeMediaQueries = 1;
	var canReorder = requireReorderable().canReorder;
	var canReorderSingle = requireReorderable().canReorderSingle;
	var extractProperties = requireExtractProperties();
	var rulesOverlap = requireRulesOverlap();

	var serializeRules = requireOneTime().rules;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
	var Token = requireToken();

	function mergeMediaQueries(tokens, context) {
	  var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;
	  var specificityCache = context.cache.specificity;
	  var candidates = {};
	  var reduced = [];

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    if (token[0] != Token.NESTED_BLOCK) {
	      continue;
	    }

	    var key = serializeRules(token[1]);
	    var candidate = candidates[key];
	    if (!candidate) {
	      candidate = [];
	      candidates[key] = candidate;
	    }

	    candidate.push(i);
	  }

	  for (var name in candidates) {
	    var positions = candidates[name];

	    positionLoop:
	    for (var j = positions.length - 1; j > 0; j--) {
	      var positionOne = positions[j];
	      var tokenOne = tokens[positionOne];
	      var positionTwo = positions[j - 1];
	      var tokenTwo = tokens[positionTwo];

	      directionLoop:
	      for (var direction = 1; direction >= -1; direction -= 2) {
	        var topToBottom = direction == 1;
	        var from = topToBottom ? positionOne + 1 : positionTwo - 1;
	        var to = topToBottom ? positionTwo : positionOne;
	        var delta = topToBottom ? 1 : -1;
	        var source = topToBottom ? tokenOne : tokenTwo;
	        var target = topToBottom ? tokenTwo : tokenOne;
	        var movedProperties = extractProperties(source);

	        while (from != to) {
	          var traversedProperties = extractProperties(tokens[from]);
	          from += delta;

	          if (mergeSemantically && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)) {
	            continue;
	          }

	          if (!canReorder(movedProperties, traversedProperties, specificityCache))
	            continue directionLoop;
	        }

	        target[2] = topToBottom ?
	          source[2].concat(target[2]) :
	          target[2].concat(source[2]);
	        source[2] = [];

	        reduced.push(target);
	        continue positionLoop;
	      }
	    }
	  }

	  return reduced;
	}

	function allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache) {
	  var movedProperty;
	  var movedRule;
	  var traversedProperty;
	  var traversedRule;
	  var i, l;
	  var j, m;

	  for (i = 0, l = movedProperties.length; i < l; i++) {
	    movedProperty = movedProperties[i];
	    movedRule = movedProperty[5];

	    for (j = 0, m = traversedProperties.length; j < m; j++) {
	      traversedProperty = traversedProperties[j];
	      traversedRule = traversedProperty[5];

	      if (rulesOverlap(movedRule, traversedRule, true) && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {
	        return false;
	      }
	    }
	  }

	  return true;
	}

	mergeMediaQueries_1 = mergeMediaQueries;
	return mergeMediaQueries_1;
}

var mergeNonAdjacentByBody_1;
var hasRequiredMergeNonAdjacentByBody;

function requireMergeNonAdjacentByBody () {
	if (hasRequiredMergeNonAdjacentByBody) return mergeNonAdjacentByBody_1;
	hasRequiredMergeNonAdjacentByBody = 1;
	var isMergeable = requireIsMergeable();

	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function unsafeSelector(value) {
	  return /\.|\*| :/.test(value);
	}

	function isBemElement(token) {
	  var asString = serializeRules(token[1]);
	  return asString.indexOf('__') > -1 || asString.indexOf('--') > -1;
	}

	function withoutModifier(selector) {
	  return selector.replace(/--[^ ,>\+~:]+/g, '');
	}

	function removeAnyUnsafeElements(left, candidates) {
	  var leftSelector = withoutModifier(serializeRules(left[1]));

	  for (var body in candidates) {
	    var right = candidates[body];
	    var rightSelector = withoutModifier(serializeRules(right[1]));

	    if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1)
	      delete candidates[body];
	  }
	}

	function mergeNonAdjacentByBody(tokens, context) {
	  var options = context.options;
	  var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var candidates = {};

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    if (token[0] != Token.RULE)
	      continue;

	    if (token[2].length > 0 && (!mergeSemantically && unsafeSelector(serializeRules(token[1]))))
	      candidates = {};

	    if (token[2].length > 0 && mergeSemantically && isBemElement(token))
	      removeAnyUnsafeElements(token, candidates);

	    var candidateBody = serializeBody(token[2]);
	    var oldToken = candidates[candidateBody];
	    if (oldToken &&
	        isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&
	        isMergeable(serializeRules(oldToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {

	      if (token[2].length > 0) {
	        token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
	        token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];
	      } else {
	        token[1] = oldToken[1].concat(token[1]);
	      }

	      oldToken[2] = [];
	      candidates[candidateBody] = null;
	    }

	    candidates[serializeBody(token[2])] = token;
	  }
	}

	mergeNonAdjacentByBody_1 = mergeNonAdjacentByBody;
	return mergeNonAdjacentByBody_1;
}

var mergeNonAdjacentBySelector_1;
var hasRequiredMergeNonAdjacentBySelector;

function requireMergeNonAdjacentBySelector () {
	if (hasRequiredMergeNonAdjacentBySelector) return mergeNonAdjacentBySelector_1;
	hasRequiredMergeNonAdjacentBySelector = 1;
	var canReorder = requireReorderable().canReorder;
	var extractProperties = requireExtractProperties();

	var optimizeProperties = requireOptimize$1();

	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function mergeNonAdjacentBySelector(tokens, context) {
	  var specificityCache = context.cache.specificity;
	  var allSelectors = {};
	  var repeatedSelectors = [];
	  var i;

	  for (i = tokens.length - 1; i >= 0; i--) {
	    if (tokens[i][0] != Token.RULE)
	      continue;
	    if (tokens[i][2].length === 0)
	      continue;

	    var selector = serializeRules(tokens[i][1]);
	    allSelectors[selector] = [i].concat(allSelectors[selector] || []);

	    if (allSelectors[selector].length == 2)
	      repeatedSelectors.push(selector);
	  }

	  for (i = repeatedSelectors.length - 1; i >= 0; i--) {
	    var positions = allSelectors[repeatedSelectors[i]];

	    selectorIterator:
	    for (var j = positions.length - 1; j > 0; j--) {
	      var positionOne = positions[j - 1];
	      var tokenOne = tokens[positionOne];
	      var positionTwo = positions[j];
	      var tokenTwo = tokens[positionTwo];

	      directionIterator:
	      for (var direction = 1; direction >= -1; direction -= 2) {
	        var topToBottom = direction == 1;
	        var from = topToBottom ? positionOne + 1 : positionTwo - 1;
	        var to = topToBottom ? positionTwo : positionOne;
	        var delta = topToBottom ? 1 : -1;
	        var moved = topToBottom ? tokenOne : tokenTwo;
	        var target = topToBottom ? tokenTwo : tokenOne;
	        var movedProperties = extractProperties(moved);

	        while (from != to) {
	          var traversedProperties = extractProperties(tokens[from]);
	          from += delta;

	          // traversed then moved as we move selectors towards the start
	          var reorderable = topToBottom ?
	            canReorder(movedProperties, traversedProperties, specificityCache) :
	            canReorder(traversedProperties, movedProperties, specificityCache);

	          if (!reorderable && !topToBottom)
	            continue selectorIterator;
	          if (!reorderable && topToBottom)
	            continue directionIterator;
	        }

	        if (topToBottom) {
	          Array.prototype.push.apply(moved[2], target[2]);
	          target[2] = moved[2];
	        } else {
	          Array.prototype.push.apply(target[2], moved[2]);
	        }

	        optimizeProperties(target[2], true, true, context);
	        moved[2] = [];
	      }
	    }
	  }
	}

	mergeNonAdjacentBySelector_1 = mergeNonAdjacentBySelector;
	return mergeNonAdjacentBySelector_1;
}

var cloneArray_1;
var hasRequiredCloneArray;

function requireCloneArray () {
	if (hasRequiredCloneArray) return cloneArray_1;
	hasRequiredCloneArray = 1;
	function cloneArray(array) {
	  var cloned = array.slice(0);

	  for (var i = 0, l = cloned.length; i < l; i++) {
	    if (Array.isArray(cloned[i]))
	      cloned[i] = cloneArray(cloned[i]);
	  }

	  return cloned;
	}

	cloneArray_1 = cloneArray;
	return cloneArray_1;
}

var reduceNonAdjacent_1;
var hasRequiredReduceNonAdjacent;

function requireReduceNonAdjacent () {
	if (hasRequiredReduceNonAdjacent) return reduceNonAdjacent_1;
	hasRequiredReduceNonAdjacent = 1;
	var isMergeable = requireIsMergeable();

	var optimizeProperties = requireOptimize$1();

	var cloneArray = requireCloneArray();

	var Token = requireToken();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function reduceNonAdjacent(tokens, context) {
	  var options = context.options;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var candidates = {};
	  var repeated = [];

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];

	    if (token[0] != Token.RULE) {
	      continue;
	    } else if (token[2].length === 0) {
	      continue;
	    }

	    var selectorAsString = serializeRules(token[1]);
	    var isComplexAndNotSpecial = token[1].length > 1 &&
	      isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);
	    var wrappedSelectors = wrappedSelectorsFrom(token[1]);
	    var selectors = isComplexAndNotSpecial ?
	      [selectorAsString].concat(wrappedSelectors) :
	      [selectorAsString];

	    for (var j = 0, m = selectors.length; j < m; j++) {
	      var selector = selectors[j];

	      if (!candidates[selector])
	        candidates[selector] = [];
	      else
	        repeated.push(selector);

	      candidates[selector].push({
	        where: i,
	        list: wrappedSelectors,
	        isPartial: isComplexAndNotSpecial && j > 0,
	        isComplex: isComplexAndNotSpecial && j === 0
	      });
	    }
	  }

	  reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);
	  reduceComplexNonAdjacentCases(tokens, candidates, options, context);
	}

	function wrappedSelectorsFrom(list) {
	  var wrapped = [];

	  for (var i = 0; i < list.length; i++) {
	    wrapped.push([list[i][1]]);
	  }

	  return wrapped;
	}

	function reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context) {
	  function filterOut(idx, bodies) {
	    return data[idx].isPartial && bodies.length === 0;
	  }

	  function reduceBody(token, newBody, processedCount, tokenIdx) {
	    if (!data[processedCount - tokenIdx - 1].isPartial)
	      token[2] = newBody;
	  }

	  for (var i = 0, l = repeated.length; i < l; i++) {
	    var selector = repeated[i];
	    var data = candidates[selector];

	    reduceSelector(tokens, data, {
	      filterOut: filterOut,
	      callback: reduceBody
	    }, options, context);
	  }
	}

	function reduceComplexNonAdjacentCases(tokens, candidates, options, context) {
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var localContext = {};

	  function filterOut(idx) {
	    return localContext.data[idx].where < localContext.intoPosition;
	  }

	  function collectReducedBodies(token, newBody, processedCount, tokenIdx) {
	    if (tokenIdx === 0)
	      localContext.reducedBodies.push(newBody);
	  }

	  allSelectors:
	  for (var complexSelector in candidates) {
	    var into = candidates[complexSelector];
	    if (!into[0].isComplex)
	      continue;

	    var intoPosition = into[into.length - 1].where;
	    var intoToken = tokens[intoPosition];
	    var reducedBodies = [];

	    var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) ?
	      into[0].list :
	      [complexSelector];

	    localContext.intoPosition = intoPosition;
	    localContext.reducedBodies = reducedBodies;

	    for (var j = 0, m = selectors.length; j < m; j++) {
	      var selector = selectors[j];
	      var data = candidates[selector];

	      if (data.length < 2)
	        continue allSelectors;

	      localContext.data = data;

	      reduceSelector(tokens, data, {
	        filterOut: filterOut,
	        callback: collectReducedBodies
	      }, options, context);

	      if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0]))
	        continue allSelectors;
	    }

	    intoToken[2] = reducedBodies[0];
	  }
	}

	function reduceSelector(tokens, data, context, options, outerContext) {
	  var bodies = [];
	  var bodiesAsList = [];
	  var processedTokens = [];

	  for (var j = data.length - 1; j >= 0; j--) {
	    if (context.filterOut(j, bodies))
	      continue;

	    var where = data[j].where;
	    var token = tokens[where];
	    var clonedBody = cloneArray(token[2]);

	    bodies = bodies.concat(clonedBody);
	    bodiesAsList.push(clonedBody);
	    processedTokens.push(where);
	  }

	  optimizeProperties(bodies, true, false, outerContext);

	  var processedCount = processedTokens.length;
	  var propertyIdx = bodies.length - 1;
	  var tokenIdx = processedCount - 1;

	  while (tokenIdx >= 0) {
	     if ((tokenIdx === 0 || (bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1)) && propertyIdx > -1) {
	      propertyIdx--;
	      continue;
	    }

	    var newBody = bodies.splice(propertyIdx + 1);
	    context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);

	    tokenIdx--;
	  }
	}

	reduceNonAdjacent_1 = reduceNonAdjacent;
	return reduceNonAdjacent_1;
}

var removeDuplicateFontAtRules_1;
var hasRequiredRemoveDuplicateFontAtRules;

function requireRemoveDuplicateFontAtRules () {
	if (hasRequiredRemoveDuplicateFontAtRules) return removeDuplicateFontAtRules_1;
	hasRequiredRemoveDuplicateFontAtRules = 1;
	var Token = requireToken();

	var serializeAll = requireOneTime().all;

	var FONT_FACE_SCOPE = '@font-face';

	function removeDuplicateFontAtRules(tokens) {
	  var fontAtRules = [];
	  var token;
	  var key;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {
	      continue;
	    }

	    key = serializeAll([token]);

	    if (fontAtRules.indexOf(key) > -1) {
	      token[2] = [];
	    } else {
	      fontAtRules.push(key);
	    }
	  }
	}

	removeDuplicateFontAtRules_1 = removeDuplicateFontAtRules;
	return removeDuplicateFontAtRules_1;
}

var removeDuplicateMediaQueries_1;
var hasRequiredRemoveDuplicateMediaQueries;

function requireRemoveDuplicateMediaQueries () {
	if (hasRequiredRemoveDuplicateMediaQueries) return removeDuplicateMediaQueries_1;
	hasRequiredRemoveDuplicateMediaQueries = 1;
	var Token = requireToken();

	var serializeAll = requireOneTime().all;
	var serializeRules = requireOneTime().rules;

	function removeDuplicateMediaQueries(tokens) {
	  var candidates = {};
	  var candidate;
	  var token;
	  var key;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    if (token[0] != Token.NESTED_BLOCK) {
	      continue;
	    }

	    key = serializeRules(token[1]) + '%' + serializeAll(token[2]);
	    candidate = candidates[key];

	    if (candidate) {
	      candidate[2] = [];
	    }

	    candidates[key] = token;
	  }
	}

	removeDuplicateMediaQueries_1 = removeDuplicateMediaQueries;
	return removeDuplicateMediaQueries_1;
}

var removeDuplicates_1;
var hasRequiredRemoveDuplicates;

function requireRemoveDuplicates () {
	if (hasRequiredRemoveDuplicates) return removeDuplicates_1;
	hasRequiredRemoveDuplicates = 1;
	var Token = requireToken();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function removeDuplicates(tokens) {
	  var matched = {};
	  var moreThanOnce = [];
	  var id, token;
	  var body, bodies;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    if (token[0] != Token.RULE)
	      continue;

	    id = serializeRules(token[1]);

	    if (matched[id] && matched[id].length == 1)
	      moreThanOnce.push(id);
	    else
	      matched[id] = matched[id] || [];

	    matched[id].push(i);
	  }

	  for (i = 0, l = moreThanOnce.length; i < l; i++) {
	    id = moreThanOnce[i];
	    bodies = [];

	    for (var j = matched[id].length - 1; j >= 0; j--) {
	      token = tokens[matched[id][j]];
	      body = serializeBody(token[2]);

	      if (bodies.indexOf(body) > -1)
	        token[2] = [];
	      else
	        bodies.push(body);
	    }
	  }
	}

	removeDuplicates_1 = removeDuplicates;
	return removeDuplicates_1;
}

var removeUnusedAtRules_1;
var hasRequiredRemoveUnusedAtRules;

function requireRemoveUnusedAtRules () {
	if (hasRequiredRemoveUnusedAtRules) return removeUnusedAtRules_1;
	hasRequiredRemoveUnusedAtRules = 1;
	var populateComponents = requirePopulateComponents();

	var wrapForOptimizing = requireWrapForOptimizing().single;
	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var Token = requireToken();

	var animationNameRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation-name$/;
	var animationRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation$/;
	var keyframeRegex = /^@(\-moz\-|\-o\-|\-webkit\-)?keyframes /;
	var importantRegex = /\s{0,31}!important$/;
	var optionalMatchingQuotesRegex = /^(['"]?)(.*)\1$/;

	function normalize(value) {
	  return value
	    .replace(optionalMatchingQuotesRegex, '$2')
	    .replace(importantRegex, '');
	}

	function removeUnusedAtRules(tokens, context) {
	  removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);
	  removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);
	  removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);
	  removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);
	}

	function removeUnusedAtRule(tokens, matchCallback, markCallback, context) {
	  var atRules = {};
	  var atRule;
	  var atRuleTokens;
	  var atRuleToken;
	  var zeroAt;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    matchCallback(tokens[i], atRules);
	  }

	  if (Object.keys(atRules).length === 0) {
	    return;
	  }

	  markUsedAtRules(tokens, markCallback, atRules, context);

	  for (atRule in atRules) {
	    atRuleTokens = atRules[atRule];

	    for (i = 0, l = atRuleTokens.length; i < l; i++) {
	      atRuleToken = atRuleTokens[i];
	      zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;
	      atRuleToken[zeroAt] = [];
	    }
	  }
	}

	function markUsedAtRules(tokens, markCallback, atRules, context) {
	  var boundMarkCallback = markCallback(atRules);
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    switch (tokens[i][0]) {
	      case Token.RULE:
	        boundMarkCallback(tokens[i], context);
	        break;
	      case Token.NESTED_BLOCK:
	        markUsedAtRules(tokens[i][2], markCallback, atRules, context);
	    }
	  }
	}

	function matchCounterStyle(token, atRules) {
	  var match;

	  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf('@counter-style') === 0) {
	    match = token[1][0][1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markCounterStylesAsUsed(atRules) {
	  return function (token, context) {
	    var property;
	    var wrappedProperty;
	    var i, l;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'list-style') {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);

	        if (wrappedProperty.components[0].value[0][1] in atRules) {
	          delete atRules[property[2][1]];
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (property[1][1] == 'list-style-type' && property[2][1] in atRules) {
	        delete atRules[property[2][1]];
	      }
	    }
	  };
	}

	function matchFontFace(token, atRules) {
	  var property;
	  var match;
	  var i, l;

	  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == '@font-face') {
	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'font-family') {
	        match = normalize(property[2][1].toLowerCase());
	        atRules[match] = atRules[match] || [];
	        atRules[match].push(token);
	        break;
	      }
	    }
	  }
	}

	function markFontFacesAsUsed(atRules) {
	  return function (token, context) {
	    var property;
	    var wrappedProperty;
	    var component;
	    var normalizedMatch;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'font') {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);
	        component = wrappedProperty.components[6];

	        for (j = 0, m = component.value.length; j < m; j++) {
	          normalizedMatch = normalize(component.value[j][1].toLowerCase());

	          if (normalizedMatch in atRules) {
	            delete atRules[normalizedMatch];
	          }
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (property[1][1] == 'font-family') {
	        for (j = 2, m = property.length; j < m; j++) {
	          normalizedMatch = normalize(property[j][1].toLowerCase());

	          if (normalizedMatch in atRules) {
	            delete atRules[normalizedMatch];
	          }
	        }
	      }
	    }
	  };
	}

	function matchKeyframe(token, atRules) {
	  var match;

	  if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {
	    match = token[1][0][1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markKeyframesAsUsed(atRules) {
	  return function (token, context) {
	    var property;
	    var wrappedProperty;
	    var component;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (animationRegex.test(property[1][1])) {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);
	        component = wrappedProperty.components[7];

	        for (j = 0, m = component.value.length; j < m; j++) {
	          if (component.value[j][1] in atRules) {
	            delete atRules[component.value[j][1]];
	          }
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (animationNameRegex.test(property[1][1])) {
	        for (j = 2, m = property.length; j < m; j++) {
	          if (property[j][1] in atRules) {
	            delete atRules[property[j][1]];
	          }
	        }
	      }
	    }
	  };
	}

	function matchNamespace(token, atRules) {
	  var match;

	  if (token[0] == Token.AT_RULE && token[1].indexOf('@namespace') === 0) {
	    match = token[1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markNamespacesAsUsed(atRules) {
	  var namespaceRegex = new RegExp(Object.keys(atRules).join('\\\||') + '\\\|', 'g');

	  return function (token) {
	    var match;
	    var scope;
	    var normalizedMatch;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[1].length; i < l; i++) {
	      scope = token[1][i];
	      match = scope[1].match(namespaceRegex);

	      for (j = 0, m = match.length; j < m; j++) {
	        normalizedMatch = match[j].substring(0, match[j].length - 1);

	        if (normalizedMatch in atRules) {
	          delete atRules[normalizedMatch];
	        }
	      }
	    }
	  };
	}

	removeUnusedAtRules_1 = removeUnusedAtRules;
	return removeUnusedAtRules_1;
}

var tidyRuleDuplicates_1;
var hasRequiredTidyRuleDuplicates;

function requireTidyRuleDuplicates () {
	if (hasRequiredTidyRuleDuplicates) return tidyRuleDuplicates_1;
	hasRequiredTidyRuleDuplicates = 1;
	function ruleSorter(s1, s2) {
	  return s1[1] > s2[1] ? 1 : -1;
	}

	function tidyRuleDuplicates(rules) {
	  var list = [];
	  var repeated = [];

	  for (var i = 0, l = rules.length; i < l; i++) {
	    var rule = rules[i];

	    if (repeated.indexOf(rule[1]) == -1) {
	      repeated.push(rule[1]);
	      list.push(rule);
	    }
	  }

	  return list.sort(ruleSorter);
	}

	tidyRuleDuplicates_1 = tidyRuleDuplicates;
	return tidyRuleDuplicates_1;
}

var restructure_1;
var hasRequiredRestructure;

function requireRestructure () {
	if (hasRequiredRestructure) return restructure_1;
	hasRequiredRestructure = 1;
	var canReorderSingle = requireReorderable().canReorderSingle;
	var extractProperties = requireExtractProperties();
	var isMergeable = requireIsMergeable();
	var tidyRuleDuplicates = requireTidyRuleDuplicates();

	var Token = requireToken();

	var cloneArray = requireCloneArray();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function naturalSorter(a, b) {
	  return a > b ? 1 : -1;
	}

	function cloneAndMergeSelectors(propertyA, propertyB) {
	  var cloned = cloneArray(propertyA);
	  cloned[5] = cloned[5].concat(propertyB[5]);

	  return cloned;
	}

	function restructure(tokens, context) {
	  var options = context.options;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var mergeLimit = options.compatibility.selectors.mergeLimit;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var specificityCache = context.cache.specificity;
	  var movableTokens = {};
	  var movedProperties = [];
	  var multiPropertyMoveCache = {};
	  var movedToBeDropped = [];
	  var maxCombinationsLevel = 2;
	  var ID_JOIN_CHARACTER = '%';

	  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {
	    for (var i = allFits.length - 1; i >= 0; i--) {
	      var fit = allFits[i][0];
	      var id = addToCache(movedProperty, fit);

	      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {
	        removeAllMatchingFromCache(id);
	        break;
	      }
	    }
	  }

	  function addToCache(movedProperty, fit) {
	    var id = cacheId(fit);
	    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];
	    multiPropertyMoveCache[id].push([movedProperty, fit]);
	    return id;
	  }

	  function removeAllMatchingFromCache(matchId) {
	    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);
	    var forRemoval = [];
	    var i;

	    for (var id in multiPropertyMoveCache) {
	      var selectors = id.split(ID_JOIN_CHARACTER);
	      for (i = selectors.length - 1; i >= 0; i--) {
	        if (matchSelectors.indexOf(selectors[i]) > -1) {
	          forRemoval.push(id);
	          break;
	        }
	      }
	    }

	    for (i = forRemoval.length - 1; i >= 0; i--) {
	      delete multiPropertyMoveCache[forRemoval[i]];
	    }
	  }

	  function cacheId(cachedTokens) {
	    var id = [];
	    for (var i = 0, l = cachedTokens.length; i < l; i++) {
	      id.push(serializeRules(cachedTokens[i][1]));
	    }
	    return id.join(ID_JOIN_CHARACTER);
	  }

	  function tokensToMerge(sourceTokens) {
	    var uniqueTokensWithBody = [];
	    var mergeableTokens = [];

	    for (var i = sourceTokens.length - 1; i >= 0; i--) {
	      if (!isMergeable(serializeRules(sourceTokens[i][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
	        continue;
	      }

	      mergeableTokens.unshift(sourceTokens[i]);
	      if (sourceTokens[i][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1)
	        uniqueTokensWithBody.push(sourceTokens[i]);
	    }

	    return uniqueTokensWithBody.length > 1 ?
	      mergeableTokens :
	      [];
	  }

	  function shortenIfPossible(position, movedProperty) {
	    var name = movedProperty[0];
	    var value = movedProperty[1];
	    var key = movedProperty[4];
	    var valueSize = name.length + value.length + 1;
	    var allSelectors = [];
	    var qualifiedTokens = [];

	    var mergeableTokens = tokensToMerge(movableTokens[key]);
	    if (mergeableTokens.length < 2)
	      return;

	    var allFits = findAllFits(mergeableTokens, valueSize, 1);
	    var bestFit = allFits[0];
	    if (bestFit[1] > 0)
	      return sendToMultiPropertyMoveCache(position, movedProperty, allFits);

	    for (var i = bestFit[0].length - 1; i >=0; i--) {
	      allSelectors = bestFit[0][i][1].concat(allSelectors);
	      qualifiedTokens.unshift(bestFit[0][i]);
	    }

	    allSelectors = tidyRuleDuplicates(allSelectors);
	    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);
	  }

	  function fitSorter(fit1, fit2) {
	    return fit1[1] > fit2[1] ? 1 : (fit1[1] == fit2[1] ? 0 : -1);
	  }

	  function findAllFits(mergeableTokens, propertySize, propertiesCount) {
	    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);
	    return combinations.sort(fitSorter);
	  }

	  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {
	    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];
	    if (tokensVariant.length > 2 && level > 0) {
	      for (var i = tokensVariant.length - 1; i >= 0; i--) {
	        var subVariant = Array.prototype.slice.call(tokensVariant, 0);
	        subVariant.splice(i, 1);
	        differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));
	      }
	    }

	    return differenceVariants;
	  }

	  function sizeDifference(tokensVariant, propertySize, propertiesCount) {
	    var allSelectorsSize = 0;
	    for (var i = tokensVariant.length - 1; i >= 0; i--) {
	      allSelectorsSize += tokensVariant[i][2].length > propertiesCount ? serializeRules(tokensVariant[i][1]).length : -1;
	    }
	    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;
	  }

	  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {
	    var i, j, k, m;
	    var allProperties = [];

	    for (i = mergeableTokens.length - 1; i >= 0; i--) {
	      var mergeableToken = mergeableTokens[i];

	      for (j = mergeableToken[2].length - 1; j >= 0; j--) {
	        var mergeableProperty = mergeableToken[2][j];

	        for (k = 0, m = properties.length; k < m; k++) {
	          var property = properties[k];

	          var mergeablePropertyName = mergeableProperty[1][1];
	          var propertyName = property[0];
	          var propertyBody = property[4];
	          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {
	            mergeableToken[2].splice(j, 1);
	            break;
	          }
	        }
	      }
	    }

	    for (i = properties.length - 1; i >= 0; i--) {
	      allProperties.unshift(properties[i][3]);
	    }

	    var newToken = [Token.RULE, allSelectors, allProperties];
	    tokens.splice(position, 0, newToken);
	  }

	  function dropPropertiesAt(position, movedProperty) {
	    var key = movedProperty[4];
	    var toMove = movableTokens[key];

	    if (toMove && toMove.length > 1) {
	      if (!shortenMultiMovesIfPossible(position, movedProperty))
	        shortenIfPossible(position, movedProperty);
	    }
	  }

	  function shortenMultiMovesIfPossible(position, movedProperty) {
	    var candidates = [];
	    var propertiesAndMergableTokens = [];
	    var key = movedProperty[4];
	    var j, k;

	    var mergeableTokens = tokensToMerge(movableTokens[key]);
	    if (mergeableTokens.length < 2)
	      return;

	    movableLoop:
	    for (var value in movableTokens) {
	      var tokensList = movableTokens[value];

	      for (j = mergeableTokens.length - 1; j >= 0; j--) {
	        if (tokensList.indexOf(mergeableTokens[j]) == -1)
	          continue movableLoop;
	      }

	      candidates.push(value);
	    }

	    if (candidates.length < 2)
	      return false;

	    for (j = candidates.length - 1; j >= 0; j--) {
	      for (k = movedProperties.length - 1; k >= 0; k--) {
	        if (movedProperties[k][4] == candidates[j]) {
	          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);
	          break;
	        }
	      }
	    }

	    return processMultiPropertyMove(position, propertiesAndMergableTokens);
	  }

	  function processMultiPropertyMove(position, propertiesAndMergableTokens) {
	    var valueSize = 0;
	    var properties = [];
	    var property;

	    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {
	      property = propertiesAndMergableTokens[i][0];
	      var fullValue = property[4];
	      valueSize += fullValue.length + (i > 0 ? 1 : 0);

	      properties.push(property);
	    }

	    var mergeableTokens = propertiesAndMergableTokens[0][1];
	    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];
	    if (bestFit[1] > 0)
	      return false;

	    var allSelectors = [];
	    var qualifiedTokens = [];
	    for (i = bestFit[0].length - 1; i >= 0; i--) {
	      allSelectors = bestFit[0][i][1].concat(allSelectors);
	      qualifiedTokens.unshift(bestFit[0][i]);
	    }

	    allSelectors = tidyRuleDuplicates(allSelectors);
	    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);

	    for (i = properties.length - 1; i >= 0; i--) {
	      property = properties[i];
	      var index = movedProperties.indexOf(property);

	      delete movableTokens[property[4]];

	      if (index > -1 && movedToBeDropped.indexOf(index) == -1)
	        movedToBeDropped.push(index);
	    }

	    return true;
	  }

	  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {
	    var propertyName = property[0];
	    var movedPropertyName = movedProperty[0];
	    if (propertyName != movedPropertyName)
	      return false;

	    var key = movedProperty[4];
	    var toMove = movableTokens[key];
	    return toMove && toMove.indexOf(token) > -1;
	  }

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    var isRule;
	    var j, k, m;
	    var samePropertyAt;

	    if (token[0] == Token.RULE) {
	      isRule = true;
	    } else if (token[0] == Token.NESTED_BLOCK) {
	      isRule = false;
	    } else {
	      continue;
	    }

	    // We cache movedProperties.length as it may change in the loop
	    var movedCount = movedProperties.length;

	    var properties = extractProperties(token);
	    movedToBeDropped = [];

	    var unmovableInCurrentToken = [];
	    for (j = properties.length - 1; j >= 0; j--) {
	      for (k = j - 1; k >= 0; k--) {
	        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {
	          unmovableInCurrentToken.push(j);
	          break;
	        }
	      }
	    }

	    for (j = properties.length - 1; j >= 0; j--) {
	      var property = properties[j];
	      var movedSameProperty = false;

	      for (k = 0; k < movedCount; k++) {
	        var movedProperty = movedProperties[k];

	        if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) ||
	            movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {
	          dropPropertiesAt(i + 1, movedProperty);

	          if (movedToBeDropped.indexOf(k) == -1) {
	            movedToBeDropped.push(k);
	            delete movableTokens[movedProperty[4]];
	          }
	        }

	        if (!movedSameProperty) {
	          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];

	          if (movedSameProperty) {
	            samePropertyAt = k;
	          }
	        }
	      }

	      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1)
	        continue;

	      var key = property[4];

	      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {
	        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);
	        movedProperties.splice(samePropertyAt, 1);
	        movableTokens[key] = [token];
	        movedSameProperty = false;
	      } else {
	        movableTokens[key] = movableTokens[key] || [];
	        movableTokens[key].push(token);
	      }

	      if (movedSameProperty) {
	        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);
	      } else {
	        movedProperties.push(property);
	      }
	    }

	    movedToBeDropped = movedToBeDropped.sort(naturalSorter);
	    for (j = 0, m = movedToBeDropped.length; j < m; j++) {
	      var dropAt = movedToBeDropped[j] - j;
	      movedProperties.splice(dropAt, 1);
	    }
	  }

	  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;
	  for (; position < tokens.length - 1; position++) {
	    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;
	    var isComment = tokens[position][0] === Token.COMMENT;
	    if (!(isImportRule || isComment))
	      break;
	  }

	  for (i = 0; i < movedProperties.length; i++) {
	    dropPropertiesAt(position, movedProperties[i]);
	  }
	}

	restructure_1 = restructure;
	return restructure_1;
}

var optimize;
var hasRequiredOptimize;

function requireOptimize () {
	if (hasRequiredOptimize) return optimize;
	hasRequiredOptimize = 1;
	var mergeAdjacent = requireMergeAdjacent();
	var mergeMediaQueries = requireMergeMediaQueries();
	var mergeNonAdjacentByBody = requireMergeNonAdjacentByBody();
	var mergeNonAdjacentBySelector = requireMergeNonAdjacentBySelector();
	var reduceNonAdjacent = requireReduceNonAdjacent();
	var removeDuplicateFontAtRules = requireRemoveDuplicateFontAtRules();
	var removeDuplicateMediaQueries = requireRemoveDuplicateMediaQueries();
	var removeDuplicates = requireRemoveDuplicates();
	var removeUnusedAtRules = requireRemoveUnusedAtRules();
	var restructure = requireRestructure();

	var optimizeProperties = requireOptimize$1();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var Token = requireToken();

	function removeEmpty(tokens) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];
	    var isEmpty = false;

	    switch (token[0]) {
	      case Token.RULE:
	        isEmpty = token[1].length === 0 || token[2].length === 0;
	        break;
	      case Token.NESTED_BLOCK:
	        removeEmpty(token[2]);
	        isEmpty = token[2].length === 0;
	        break;
	      case Token.AT_RULE:
	        isEmpty = token[1].length === 0;
	        break;
	      case Token.AT_RULE_BLOCK:
	        isEmpty = token[2].length === 0;
	    }

	    if (isEmpty) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    }
	  }
	}

	function recursivelyOptimizeBlocks(tokens, context) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] == Token.NESTED_BLOCK) {
	      var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);
	      level2Optimize(token[2], context, !isKeyframes);
	    }
	  }
	}

	function recursivelyOptimizeProperties(tokens, context) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    switch (token[0]) {
	      case Token.RULE:
	        optimizeProperties(token[2], true, true, context);
	        break;
	      case Token.NESTED_BLOCK:
	        recursivelyOptimizeProperties(token[2], context);
	    }
	  }
	}

	function level2Optimize(tokens, context, withRestructuring) {
	  var levelOptions = context.options.level[OptimizationLevel.Two];
	  var reduced;
	  var i;

	  recursivelyOptimizeBlocks(tokens, context);
	  recursivelyOptimizeProperties(tokens, context);

	  if (levelOptions.removeDuplicateRules) {
	    removeDuplicates(tokens, context);
	  }

	  if (levelOptions.mergeAdjacentRules) {
	    mergeAdjacent(tokens, context);
	  }

	  if (levelOptions.reduceNonAdjacentRules) {
	    reduceNonAdjacent(tokens, context);
	  }

	  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'body') {
	    mergeNonAdjacentBySelector(tokens, context);
	  }

	  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'selector') {
	    mergeNonAdjacentByBody(tokens, context);
	  }

	  if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {
	    restructure(tokens, context);
	    mergeAdjacent(tokens, context);
	  }

	  if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {
	    restructure(tokens, context);
	  }

	  if (levelOptions.removeDuplicateFontRules) {
	    removeDuplicateFontAtRules(tokens, context);
	  }

	  if (levelOptions.removeDuplicateMediaBlocks) {
	    removeDuplicateMediaQueries(tokens, context);
	  }

	  if (levelOptions.removeUnusedAtRules) {
	    removeUnusedAtRules(tokens, context);
	  }

	  if (levelOptions.mergeMedia) {
	    reduced = mergeMediaQueries(tokens, context);
	    for (i = reduced.length - 1; i >= 0; i--) {
	      level2Optimize(reduced[i][2], context, false);
	    }
	  }

	  if (levelOptions.removeEmpty) {
	    removeEmpty(tokens);
	  }

	  return tokens;
	}

	optimize = level2Optimize;
	return optimize;
}

var validator_1;
var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator_1;
	hasRequiredValidator = 1;
	var functionNoVendorRegexStr = '[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)';
	var functionVendorRegexStr = '\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)';
	var variableRegexStr = 'var\\(\\-\\-[^\\)]+\\)';
	var functionAnyRegexStr = '(' + variableRegexStr + '|' + functionNoVendorRegexStr + '|' + functionVendorRegexStr + ')';

	var calcRegex = new RegExp('^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$', 'i');
	var decimalRegex = /[0-9]/;
	var functionAnyRegex = new RegExp('^' + functionAnyRegexStr + '$', 'i');
	var hslColorRegex = /^hsl\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/i;
	var identifierRegex = /^(\-[a-z0-9_][a-z0-9\-_]*|[a-z][a-z0-9\-_]*)$/i;
	var namedEntityRegex = /^[a-z]+$/i;
	var prefixRegex = /^-([a-z0-9]|-)*$/i;
	var rgbColorRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\.\d]+\s{0,31}\)$/i;
	var timingFunctionRegex = /^(cubic\-bezier|steps)\([^\)]+\)$/;
	var validTimeUnits = ['ms', 's'];
	var urlRegex = /^url\([\s\S]+\)$/i;
	var variableRegex = new RegExp('^' + variableRegexStr + '$', 'i');

	var eightValueColorRegex = /^#[0-9a-f]{8}$/i;
	var fourValueColorRegex = /^#[0-9a-f]{4}$/i;
	var sixValueColorRegex = /^#[0-9a-f]{6}$/i;
	var threeValueColorRegex = /^#[0-9a-f]{3}$/i;

	var DECIMAL_DOT = '.';
	var MINUS_SIGN = '-';
	var PLUS_SIGN = '+';

	var Keywords = {
	  '^': [
	    'inherit',
	    'initial',
	    'unset'
	  ],
	  '*-style': [
	    'auto',
	    'dashed',
	    'dotted',
	    'double',
	    'groove',
	    'hidden',
	    'inset',
	    'none',
	    'outset',
	    'ridge',
	    'solid'
	  ],
	  '*-timing-function': [
	    'ease',
	    'ease-in',
	    'ease-in-out',
	    'ease-out',
	    'linear',
	    'step-end',
	    'step-start'
	  ],
	  'animation-direction': [
	    'alternate',
	    'alternate-reverse',
	    'normal',
	    'reverse'
	  ],
	  'animation-fill-mode': [
	    'backwards',
	    'both',
	    'forwards',
	    'none'
	  ],
	  'animation-iteration-count': [
	    'infinite'
	  ],
	  'animation-name': [
	    'none'
	  ],
	  'animation-play-state': [
	    'paused',
	    'running'
	  ],
	  'background-attachment': [
	    'fixed',
	    'inherit',
	    'local',
	    'scroll'
	  ],
	  'background-clip': [
	    'border-box',
	    'content-box',
	    'inherit',
	    'padding-box',
	    'text'
	  ],
	  'background-origin': [
	    'border-box',
	    'content-box',
	    'inherit',
	    'padding-box'
	  ],
	  'background-position': [
	    'bottom',
	    'center',
	    'left',
	    'right',
	    'top'
	  ],
	  'background-repeat': [
	    'no-repeat',
	    'inherit',
	    'repeat',
	    'repeat-x',
	    'repeat-y',
	    'round',
	    'space'
	  ],
	  'background-size': [
	    'auto',
	    'cover',
	    'contain'
	  ],
	  'border-collapse': [
	    'collapse',
	    'inherit',
	    'separate'
	  ],
	  'bottom': [
	    'auto'
	  ],
	  'clear': [
	    'both',
	    'left',
	    'none',
	    'right'
	  ],
	  'color': [
	    'transparent'
	  ],
	  'cursor': [
	    'all-scroll',
	    'auto',
	    'col-resize',
	    'crosshair',
	    'default',
	    'e-resize',
	    'help',
	    'move',
	    'n-resize',
	    'ne-resize',
	    'no-drop',
	    'not-allowed',
	    'nw-resize',
	    'pointer',
	    'progress',
	    'row-resize',
	    's-resize',
	    'se-resize',
	    'sw-resize',
	    'text',
	    'vertical-text',
	    'w-resize',
	    'wait'
	  ],
	  'display': [
	    'block',
	    'inline',
	    'inline-block',
	    'inline-table',
	    'list-item',
	    'none',
	    'table',
	    'table-caption',
	    'table-cell',
	    'table-column',
	    'table-column-group',
	    'table-footer-group',
	    'table-header-group',
	    'table-row',
	    'table-row-group'
	  ],
	  'float': [
	    'left',
	    'none',
	    'right'
	  ],
	  'left': [
	    'auto'
	  ],
	  'font': [
	    'caption',
	    'icon',
	    'menu',
	    'message-box',
	    'small-caption',
	    'status-bar',
	    'unset'
	  ],
	  'font-size': [
	    'large',
	    'larger',
	    'medium',
	    'small',
	    'smaller',
	    'x-large',
	    'x-small',
	    'xx-large',
	    'xx-small'
	  ],
	  'font-stretch': [
	    'condensed',
	    'expanded',
	    'extra-condensed',
	    'extra-expanded',
	    'normal',
	    'semi-condensed',
	    'semi-expanded',
	    'ultra-condensed',
	    'ultra-expanded'
	  ],
	  'font-style': [
	    'italic',
	    'normal',
	    'oblique'
	  ],
	  'font-variant': [
	    'normal',
	    'small-caps'
	  ],
	  'font-weight': [
	    '100',
	    '200',
	    '300',
	    '400',
	    '500',
	    '600',
	    '700',
	    '800',
	    '900',
	    'bold',
	    'bolder',
	    'lighter',
	    'normal'
	  ],
	  'line-height': [
	    'normal'
	  ],
	  'list-style-position': [
	    'inside',
	    'outside'
	  ],
	  'list-style-type': [
	    'armenian',
	    'circle',
	    'decimal',
	    'decimal-leading-zero',
	    'disc',
	    'decimal|disc', // this is the default value of list-style-type, see comment in compactable.js
	    'georgian',
	    'lower-alpha',
	    'lower-greek',
	    'lower-latin',
	    'lower-roman',
	    'none',
	    'square',
	    'upper-alpha',
	    'upper-latin',
	    'upper-roman'
	  ],
	  'overflow': [
	    'auto',
	    'hidden',
	    'scroll',
	    'visible'
	  ],
	  'position': [
	    'absolute',
	    'fixed',
	    'relative',
	    'static'
	  ],
	  'right': [
	    'auto'
	  ],
	  'text-align': [
	    'center',
	    'justify',
	    'left',
	    'left|right', // this is the default value of list-style-type, see comment in compactable.js
	    'right'
	  ],
	  'text-decoration': [
	    'line-through',
	    'none',
	    'overline',
	    'underline'
	  ],
	  'text-overflow': [
	    'clip',
	    'ellipsis'
	  ],
	  'top': [
	    'auto'
	  ],
	  'vertical-align': [
	    'baseline',
	    'bottom',
	    'middle',
	    'sub',
	    'super',
	    'text-bottom',
	    'text-top',
	    'top'
	  ],
	  'visibility': [
	    'collapse',
	    'hidden',
	    'visible'
	  ],
	  'white-space': [
	    'normal',
	    'nowrap',
	    'pre'
	  ],
	  'width': [
	    'inherit',
	    'initial',
	    'medium',
	    'thick',
	    'thin'
	  ]
	};

	var Units = [
	  '%',
	  'ch',
	  'cm',
	  'em',
	  'ex',
	  'in',
	  'mm',
	  'pc',
	  'pt',
	  'px',
	  'rem',
	  'vh',
	  'vm',
	  'vmax',
	  'vmin',
	  'vw'
	];

	function isColor(value) {
	  return value != 'auto' &&
	    (
	      isKeyword('color')(value) ||
	      isHexColor(value) ||
	      isColorFunction(value) ||
	      isNamedEntity(value)
	    );
	}

	function isColorFunction(value) {
	  return isRgbColor(value) || isHslColor(value);
	}

	function isDynamicUnit(value) {
	  return calcRegex.test(value);
	}

	function isFunction(value) {
	  return functionAnyRegex.test(value);
	}

	function isHexColor(value) {
	  return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);
	}

	function isHslColor(value) {
	  return hslColorRegex.test(value);
	}

	function isIdentifier(value) {
	  return identifierRegex.test(value);
	}

	function isImage(value) {
	  return value == 'none' || value == 'inherit' || isUrl(value);
	}

	function isKeyword(propertyName) {
	  return function(value) {
	    return Keywords[propertyName].indexOf(value) > -1;
	  };
	}

	function isNamedEntity(value) {
	  return namedEntityRegex.test(value);
	}

	function isNumber(value) {
	  return scanForNumber(value) == value.length;
	}

	function isRgbColor(value) {
	  return rgbColorRegex.test(value);
	}

	function isPrefixed(value) {
	  return prefixRegex.test(value);
	}

	function isPositiveNumber(value) {
	  return isNumber(value) &&
	    parseFloat(value) >= 0;
	}

	function isVariable(value) {
	  return variableRegex.test(value);
	}

	function isTime(value) {
	  var numberUpTo = scanForNumber(value);

	  return numberUpTo == value.length && parseInt(value) === 0 ||
	    numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1;
	}

	function isTimingFunction() {
	  var isTimingFunctionKeyword = isKeyword('*-timing-function');

	  return function (value) {
	    return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);
	  };
	}

	function isUnit(validUnits, value) {
	  var numberUpTo = scanForNumber(value);

	  return numberUpTo == value.length && parseInt(value) === 0 ||
	    numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1)) > -1 ||
	    value == 'auto' ||
	    value == 'inherit';
	}

	function isUrl(value) {
	  return urlRegex.test(value);
	}

	function isZIndex(value) {
	  return value == 'auto' ||
	    isNumber(value) ||
	    isKeyword('^')(value);
	}

	function scanForNumber(value) {
	  var hasDot = false;
	  var hasSign = false;
	  var character;
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {
	      hasSign = true;
	    } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {
	      return i - 1;
	    } else if (character == DECIMAL_DOT && !hasDot) {
	      hasDot = true;
	    } else if (character == DECIMAL_DOT && hasDot) {
	      return i - 1;
	    } else if (decimalRegex.test(character)) {
	      continue;
	    } else {
	      return i - 1;
	    }
	  }

	  return i;
	}

	function validator(compatibility) {
	  var validUnits = Units.slice(0).filter(function (value) {
	    return !(value in compatibility.units) || compatibility.units[value] === true;
	  });

	  return {
	    colorOpacity: compatibility.colors.opacity,
	    isAnimationDirectionKeyword: isKeyword('animation-direction'),
	    isAnimationFillModeKeyword: isKeyword('animation-fill-mode'),
	    isAnimationIterationCountKeyword: isKeyword('animation-iteration-count'),
	    isAnimationNameKeyword: isKeyword('animation-name'),
	    isAnimationPlayStateKeyword: isKeyword('animation-play-state'),
	    isTimingFunction: isTimingFunction(),
	    isBackgroundAttachmentKeyword: isKeyword('background-attachment'),
	    isBackgroundClipKeyword: isKeyword('background-clip'),
	    isBackgroundOriginKeyword: isKeyword('background-origin'),
	    isBackgroundPositionKeyword: isKeyword('background-position'),
	    isBackgroundRepeatKeyword: isKeyword('background-repeat'),
	    isBackgroundSizeKeyword: isKeyword('background-size'),
	    isColor: isColor,
	    isColorFunction: isColorFunction,
	    isDynamicUnit: isDynamicUnit,
	    isFontKeyword: isKeyword('font'),
	    isFontSizeKeyword: isKeyword('font-size'),
	    isFontStretchKeyword: isKeyword('font-stretch'),
	    isFontStyleKeyword: isKeyword('font-style'),
	    isFontVariantKeyword: isKeyword('font-variant'),
	    isFontWeightKeyword: isKeyword('font-weight'),
	    isFunction: isFunction,
	    isGlobal: isKeyword('^'),
	    isHslColor: isHslColor,
	    isIdentifier: isIdentifier,
	    isImage: isImage,
	    isKeyword: isKeyword,
	    isLineHeightKeyword: isKeyword('line-height'),
	    isListStylePositionKeyword: isKeyword('list-style-position'),
	    isListStyleTypeKeyword: isKeyword('list-style-type'),
	    isNumber: isNumber,
	    isPrefixed: isPrefixed,
	    isPositiveNumber: isPositiveNumber,
	    isRgbColor: isRgbColor,
	    isStyleKeyword: isKeyword('*-style'),
	    isTime: isTime,
	    isUnit: isUnit.bind(null, validUnits),
	    isUrl: isUrl,
	    isVariable: isVariable,
	    isWidth: isKeyword('width'),
	    isZIndex: isZIndex
	  };
	}

	validator_1 = validator;
	return validator_1;
}

var compatibility;
var hasRequiredCompatibility;

function requireCompatibility () {
	if (hasRequiredCompatibility) return compatibility;
	hasRequiredCompatibility = 1;
	var DEFAULTS = {
	  '*': {
	    colors: {
	      opacity: true // rgba / hsla
	    },
	    properties: {
	      backgroundClipMerging: true, // background-clip to shorthand
	      backgroundOriginMerging: true, // background-origin to shorthand
	      backgroundSizeMerging: true, // background-size to shorthand
	      colors: true, // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`
	      ieBangHack: false, // !ie suffix hacks on IE<8
	      ieFilters: false, // whether to preserve `filter` and `-ms-filter` properties
	      iePrefixHack: false, // underscore / asterisk prefix hacks on IE
	      ieSuffixHack: false, // \9 suffix hacks on IE6-9
	      merging: true, // merging properties into one
	      shorterLengthUnits: false, // optimize pixel units into `pt`, `pc` or `in` units
	      spaceAfterClosingBrace: true, // 'url() no-repeat' to 'url()no-repeat'
	      urlQuotes: false, // whether to wrap content of `url()` into quotes or not
	      zeroUnits: true // 0[unit] -> 0
	    },
	    selectors: {
	      adjacentSpace: false, // div+ nav Android stock browser hack
	      ie7Hack: false, // *+html hack
	      mergeablePseudoClasses: [
	        ':active',
	        ':after',
	        ':before',
	        ':empty',
	        ':checked',
	        ':disabled',
	        ':empty',
	        ':enabled',
	        ':first-child',
	        ':first-letter',
	        ':first-line',
	        ':first-of-type',
	        ':focus',
	        ':hover',
	        ':lang',
	        ':last-child',
	        ':last-of-type',
	        ':link',
	        ':not',
	        ':nth-child',
	        ':nth-last-child',
	        ':nth-last-of-type',
	        ':nth-of-type',
	        ':only-child',
	        ':only-of-type',
	        ':root',
	        ':target',
	        ':visited'
	      ], // selectors with these pseudo-classes can be merged as these are universally supported
	      mergeablePseudoElements: [
	        '::after',
	        '::before',
	        '::first-letter',
	        '::first-line'
	      ], // selectors with these pseudo-elements can be merged as these are universally supported
	      mergeLimit: 8191, // number of rules that can be safely merged together
	      multiplePseudoMerging: true
	    },
	    units: {
	      ch: true,
	      in: true,
	      pc: true,
	      pt: true,
	      rem: true,
	      vh: true,
	      vm: true, // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length
	      vmax: true,
	      vmin: true,
	      vw: true
	    }
	  }
	};

	DEFAULTS.ie11 = DEFAULTS['*'];

	DEFAULTS.ie10 = DEFAULTS['*'];

	DEFAULTS.ie9 = merge(DEFAULTS['*'], {
	  properties: {
	    ieFilters: true,
	    ieSuffixHack: true
	  }
	});

	DEFAULTS.ie8 = merge(DEFAULTS.ie9, {
	  colors: {
	    opacity: false
	  },
	  properties: {
	    backgroundClipMerging: false,
	    backgroundOriginMerging: false,
	    backgroundSizeMerging: false,
	    iePrefixHack: true,
	    merging: false
	  },
	  selectors: {
	    mergeablePseudoClasses: [
	      ':after',
	      ':before',
	      ':first-child',
	      ':first-letter',
	      ':focus',
	      ':hover',
	      ':visited'
	    ],
	    mergeablePseudoElements: []
	  },
	  units: {
	    ch: false,
	    rem: false,
	    vh: false,
	    vm: false,
	    vmax: false,
	    vmin: false,
	    vw: false
	  }
	});

	DEFAULTS.ie7 = merge(DEFAULTS.ie8, {
	  properties: {
	    ieBangHack: true
	  },
	  selectors: {
	    ie7Hack: true,
	    mergeablePseudoClasses: [
	      ':first-child',
	      ':first-letter',
	      ':hover',
	      ':visited'
	    ]
	  },
	});

	function compatibilityFrom(source) {
	  return merge(DEFAULTS['*'], calculateSource(source));
	}

	function merge(source, target) {
	  for (var key in source) {
	    if (Object.prototype.hasOwnProperty.call(source, key)) {
	      var value = source[key];

	      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {
	        target[key] = merge(value, target[key] || {});
	      } else {
	        target[key] = key in target ? target[key] : value;
	      }
	    }
	  }

	  return target;
	}

	function calculateSource(source) {
	  if (typeof source == 'object')
	    return source;

	  if (!/[,\+\-]/.test(source))
	    return DEFAULTS[source] || DEFAULTS['*'];

	  var parts = source.split(',');
	  var template = parts[0] in DEFAULTS ?
	    DEFAULTS[parts.shift()] :
	    DEFAULTS['*'];

	  source = {};

	  parts.forEach(function (part) {
	    var isAdd = part[0] == '+';
	    var key = part.substring(1).split('.');
	    var group = key[0];
	    var option = key[1];

	    source[group] = source[group] || {};
	    source[group][option] = isAdd;
	  });

	  return merge(template, source);
	}

	compatibility = compatibilityFrom;
	return compatibility;
}

var isHttpResource_1;
var hasRequiredIsHttpResource;

function requireIsHttpResource () {
	if (hasRequiredIsHttpResource) return isHttpResource_1;
	hasRequiredIsHttpResource = 1;
	var HTTP_RESOURCE_PATTERN = /^http:\/\//;

	function isHttpResource(uri) {
	  return HTTP_RESOURCE_PATTERN.test(uri);
	}

	isHttpResource_1 = isHttpResource;
	return isHttpResource_1;
}

var isHttpsResource_1;
var hasRequiredIsHttpsResource;

function requireIsHttpsResource () {
	if (hasRequiredIsHttpsResource) return isHttpsResource_1;
	hasRequiredIsHttpsResource = 1;
	var HTTPS_RESOURCE_PATTERN = /^https:\/\//;

	function isHttpsResource(uri) {
	  return HTTPS_RESOURCE_PATTERN.test(uri);
	}

	isHttpsResource_1 = isHttpsResource;
	return isHttpsResource_1;
}

var loadRemoteResource_1;
var hasRequiredLoadRemoteResource;

function requireLoadRemoteResource () {
	if (hasRequiredLoadRemoteResource) return loadRemoteResource_1;
	hasRequiredLoadRemoteResource = 1;
	var http = require$$0$2;
	var https = require$$1$2;
	var url = require$$1$1;

	var isHttpResource = requireIsHttpResource();
	var isHttpsResource = requireIsHttpsResource();
	var override = requireOverride();

	var HTTP_PROTOCOL = 'http:';

	function loadRemoteResource(uri, inlineRequest, inlineTimeout, callback) {
	  var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;
	  var errorHandled = false;
	  var requestOptions;
	  var fetch;

	  requestOptions = override(
	    url.parse(uri),
	    inlineRequest || {}
	  );

	  if (inlineRequest.hostname !== undefined) {
	    // overwrite as we always expect a http proxy currently
	    requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;
	    requestOptions.path = requestOptions.href;
	  }

	  fetch = (proxyProtocol && !isHttpsResource(proxyProtocol)) || isHttpResource(uri) ?
	    http.get :
	    https.get;

	  fetch(requestOptions, function (res) {
	    var chunks = [];
	    var movedUri;

	    if (errorHandled) {
	      return;
	    }

	    if (res.statusCode < 200 || res.statusCode > 399) {
	      return callback(res.statusCode, null);
	    } else if (res.statusCode > 299) {
	      movedUri = url.resolve(uri, res.headers.location);
	      return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);
	    }

	    res.on('data', function (chunk) {
	      chunks.push(chunk.toString());
	    });
	    res.on('end', function () {
	      var body = chunks.join('');
	      callback(null, body);
	    });
	  })
	  .on('error', function (res) {
	    if (errorHandled) {
	      return;
	    }

	    errorHandled = true;
	    callback(res.message, null);
	  })
	  .on('timeout', function () {
	    if (errorHandled) {
	      return;
	    }

	    errorHandled = true;
	    callback('timeout', null);
	  })
	  .setTimeout(inlineTimeout);
	}

	loadRemoteResource_1 = loadRemoteResource;
	return loadRemoteResource_1;
}

var fetch;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch;
	hasRequiredFetch = 1;
	var loadRemoteResource = requireLoadRemoteResource();

	function fetchFrom(callback) {
	  return callback || loadRemoteResource;
	}

	fetch = fetchFrom;
	return fetch;
}

var inline;
var hasRequiredInline;

function requireInline () {
	if (hasRequiredInline) return inline;
	hasRequiredInline = 1;
	function inlineOptionsFrom(rules) {
	  if (Array.isArray(rules)) {
	    return rules;
	  }

	  if (rules === false) {
	    return ['none'];
	  }

	  return undefined === rules ?
	    ['local'] :
	    rules.split(',');
	}

	inline = inlineOptionsFrom;
	return inline;
}

var inlineRequest;
var hasRequiredInlineRequest;

function requireInlineRequest () {
	if (hasRequiredInlineRequest) return inlineRequest;
	hasRequiredInlineRequest = 1;
	var url = require$$1$1;
	var override = requireOverride();
	function inlineRequestFrom(option) {
	  return override(
	    /* jshint camelcase: false */
	    proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy),
	    option || {}
	  );
	}
	function proxyOptionsFrom(httpProxy) {
	  return httpProxy ? {
	    hostname: url.parse(httpProxy).hostname,
	    port: parseInt(url.parse(httpProxy).port)
	  } : {};
	}
	inlineRequest = inlineRequestFrom;
	return inlineRequest;
}

var inlineTimeout;
var hasRequiredInlineTimeout;

function requireInlineTimeout () {
	if (hasRequiredInlineTimeout) return inlineTimeout;
	hasRequiredInlineTimeout = 1;
	var DEFAULT_TIMEOUT = 5000;

	function inlineTimeoutFrom(option) {
	  return option || DEFAULT_TIMEOUT;
	}

	inlineTimeout = inlineTimeoutFrom;
	return inlineTimeout;
}

var rebase;
var hasRequiredRebase$1;

function requireRebase$1 () {
	if (hasRequiredRebase$1) return rebase;
	hasRequiredRebase$1 = 1;
	function rebaseFrom(rebaseOption) {
	  return undefined === rebaseOption ? true : !!rebaseOption;
	}

	rebase = rebaseFrom;
	return rebase;
}

var rebaseTo;
var hasRequiredRebaseTo;

function requireRebaseTo () {
	if (hasRequiredRebaseTo) return rebaseTo;
	hasRequiredRebaseTo = 1;
	var path = require$$0$3;

	function rebaseToFrom(option) {
	  return option ? path.resolve(option) : process.cwd();
	}

	rebaseTo = rebaseToFrom;
	return rebaseTo;
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports$1) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports$1.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports$1.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports$1.urlGenerate = urlGenerate;

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports$1.isAbsolute(path);

		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports$1.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports$1.join = join;

		exports$1.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports$1.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports$1.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports$1.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByOriginalPositions = compareByOriginalPositions;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports$1.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   sources entry.  This value is prepended to the individual
		    //   entries in the source field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   sourceRoot, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports$1.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = requireBase64Vlq();
	var util = requireUtil();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	(function (exports$1) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		exports$1.GREATEST_LOWER_BOUND = 1;
		exports$1.LEAST_UPPER_BOUND = 2;

		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports$1.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports$1.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}

		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports$1.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }

		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports$1.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }

		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }

		  return index;
		}; 
	} (binarySearch));
	return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredQuickSort;

function requireQuickSort () {
	if (hasRequiredQuickSort) return quickSort;
	hasRequiredQuickSort = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	quickSort.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};
	return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapConsumer;

function requireSourceMapConsumer () {
	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	hasRequiredSourceMapConsumer = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var binarySearch = requireBinarySearch();
	var ArraySet = requireArraySet().ArraySet;
	var base64VLQ = requireBase64Vlq();
	var quickSort = requireQuickSort().quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceNode;

function requireSourceNode () {
	if (hasRequiredSourceNode) return sourceNode;
	hasRequiredSourceNode = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	var util = requireUtil();

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	sourceNode.SourceNode = SourceNode;
	return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
	sourceMap.SourceNode = requireSourceNode().SourceNode;
	return sourceMap;
}

var inputSourceMapTracker_1;
var hasRequiredInputSourceMapTracker;

function requireInputSourceMapTracker () {
	if (hasRequiredInputSourceMapTracker) return inputSourceMapTracker_1;
	hasRequiredInputSourceMapTracker = 1;
	var SourceMapConsumer = requireSourceMap().SourceMapConsumer;

	function inputSourceMapTracker() {
	  var maps = {};

	  return {
	    all: all.bind(null, maps),
	    isTracking: isTracking.bind(null, maps),
	    originalPositionFor: originalPositionFor.bind(null, maps),
	    track: track.bind(null, maps)
	  };
	}

	function all(maps) {
	  return maps;
	}

	function isTracking(maps, source) {
	  return source in maps;
	}

	function originalPositionFor(maps, metadata, range, selectorFallbacks) {
	  var line = metadata[0];
	  var column = metadata[1];
	  var source = metadata[2];
	  var position = {
	    line: line,
	    column: column + range
	  };
	  var originalPosition;

	  while (!originalPosition && position.column > column) {
	    position.column--;
	    originalPosition = maps[source].originalPositionFor(position);
	  }

	  if (!originalPosition || originalPosition.column < 0) {
	    return metadata;
	  }

	  if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {
	    return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);
	  }

	  return originalPosition.line !== null ?
	    toMetadata(originalPosition) :
	    metadata;
	}

	function toMetadata(asHash) {
	  return [asHash.line, asHash.column, asHash.source];
	}

	function track(maps, source, data) {
	  maps[source] = new SourceMapConsumer(data);
	}

	inputSourceMapTracker_1 = inputSourceMapTracker;
	return inputSourceMapTracker_1;
}

var isRemoteResource_1;
var hasRequiredIsRemoteResource;

function requireIsRemoteResource () {
	if (hasRequiredIsRemoteResource) return isRemoteResource_1;
	hasRequiredIsRemoteResource = 1;
	var REMOTE_RESOURCE_PATTERN = /^(\w+:\/\/|\/\/)/;

	function isRemoteResource(uri) {
	  return REMOTE_RESOURCE_PATTERN.test(uri);
	}

	isRemoteResource_1 = isRemoteResource;
	return isRemoteResource_1;
}

var hasProtocol_1;
var hasRequiredHasProtocol;

function requireHasProtocol () {
	if (hasRequiredHasProtocol) return hasProtocol_1;
	hasRequiredHasProtocol = 1;
	var NO_PROTOCOL_RESOURCE_PATTERN = /^\/\//;

	function hasProtocol(uri) {
	  return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);
	}

	hasProtocol_1 = hasProtocol;
	return hasProtocol_1;
}

var isAllowedResource_1;
var hasRequiredIsAllowedResource;

function requireIsAllowedResource () {
	if (hasRequiredIsAllowedResource) return isAllowedResource_1;
	hasRequiredIsAllowedResource = 1;
	var path = require$$0$3;
	var url = require$$1$1;

	var isRemoteResource = requireIsRemoteResource();
	var hasProtocol = requireHasProtocol();

	var HTTP_PROTOCOL = 'http:';

	function isAllowedResource(uri, isRemote, rules) {
	  var match;
	  var absoluteUri;
	  var allowed = isRemote ? false : true;
	  var rule;
	  var isNegated;
	  var normalizedRule;
	  var i;

	  if (rules.length === 0) {
	    return false;
	  }

	  if (isRemote && !hasProtocol(uri)) {
	    uri = HTTP_PROTOCOL + uri;
	  }

	  match = isRemote ?
	    url.parse(uri).host :
	    uri;

	  absoluteUri = isRemote ?
	    uri :
	    path.resolve(uri);

	  for (i = 0; i < rules.length; i++) {
	    rule = rules[i];
	    isNegated = rule[0] == '!';
	    normalizedRule = rule.substring(1);

	    if (isNegated && isRemote && isRemoteRule(normalizedRule)) {
	      allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);
	    } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {
	      allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);
	    } else if (isNegated) {
	      allowed = allowed && true;
	    } else if (rule == 'all') {
	      allowed = true;
	    } else if (isRemote && rule == 'local') {
	      allowed = allowed || false;
	    } else if (isRemote && rule == 'remote') {
	      allowed = true;
	    } else if (!isRemote && rule == 'remote') {
	      allowed = false;
	    } else if (!isRemote && rule == 'local') {
	      allowed = true;
	    } else if (rule === match) {
	      allowed = true;
	    } else if (rule === uri) {
	      allowed = true;
	    } else if (isRemote && absoluteUri.indexOf(rule) === 0) {
	      allowed = true;
	    } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {
	      allowed = true;
	    } else if (isRemote != isRemoteRule(normalizedRule)) {
	      allowed = allowed && true;
	    } else {
	      allowed = false;
	    }
	  }

	  return allowed;
	}

	function isRemoteRule(rule) {
	  return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + '//' + rule).host == rule;
	}

	isAllowedResource_1 = isAllowedResource;
	return isAllowedResource_1;
}

var matchDataUri_1;
var hasRequiredMatchDataUri;

function requireMatchDataUri () {
	if (hasRequiredMatchDataUri) return matchDataUri_1;
	hasRequiredMatchDataUri = 1;
	var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;

	function matchDataUri(uri) {
	  return DATA_URI_PATTERN.exec(uri);
	}

	matchDataUri_1 = matchDataUri;
	return matchDataUri_1;
}

var rebaseLocalMap_1;
var hasRequiredRebaseLocalMap;

function requireRebaseLocalMap () {
	if (hasRequiredRebaseLocalMap) return rebaseLocalMap_1;
	hasRequiredRebaseLocalMap = 1;
	var path = require$$0$3;

	function rebaseLocalMap(sourceMap, sourceUri, rebaseTo) {
	  var currentPath = path.resolve('');
	  var absoluteUri = path.resolve(currentPath, sourceUri);
	  var absoluteUriDirectory = path.dirname(absoluteUri);

	  sourceMap.sources = sourceMap.sources.map(function(source) {
	    return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));
	  });

	  return sourceMap;
	}

	rebaseLocalMap_1 = rebaseLocalMap;
	return rebaseLocalMap_1;
}

var rebaseRemoteMap_1;
var hasRequiredRebaseRemoteMap;

function requireRebaseRemoteMap () {
	if (hasRequiredRebaseRemoteMap) return rebaseRemoteMap_1;
	hasRequiredRebaseRemoteMap = 1;
	var path = require$$0$3;
	var url = require$$1$1;

	function rebaseRemoteMap(sourceMap, sourceUri) {
	  var sourceDirectory = path.dirname(sourceUri);

	  sourceMap.sources = sourceMap.sources.map(function(source) {
	    return url.resolve(sourceDirectory, source);
	  });

	  return sourceMap;
	}

	rebaseRemoteMap_1 = rebaseRemoteMap;
	return rebaseRemoteMap_1;
}

var isDataUriResource_1;
var hasRequiredIsDataUriResource;

function requireIsDataUriResource () {
	if (hasRequiredIsDataUriResource) return isDataUriResource_1;
	hasRequiredIsDataUriResource = 1;
	var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;

	function isDataUriResource(uri) {
	  return DATA_URI_PATTERN.test(uri);
	}

	isDataUriResource_1 = isDataUriResource;
	return isDataUriResource_1;
}

var applySourceMaps_1;
var hasRequiredApplySourceMaps;

function requireApplySourceMaps () {
	if (hasRequiredApplySourceMaps) return applySourceMaps_1;
	hasRequiredApplySourceMaps = 1;
	var fs = require$$0$4;
	var path = require$$0$3;

	var isAllowedResource = requireIsAllowedResource();
	var matchDataUri = requireMatchDataUri();
	var rebaseLocalMap = requireRebaseLocalMap();
	var rebaseRemoteMap = requireRebaseRemoteMap();

	var Token = requireToken();
	var hasProtocol = requireHasProtocol();
	var isDataUriResource = requireIsDataUriResource();
	var isRemoteResource = requireIsRemoteResource();

	var MAP_MARKER_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;

	function applySourceMaps(tokens, context, callback) {
	  var applyContext = {
	    callback: callback,
	    fetch: context.options.fetch,
	    index: 0,
	    inline: context.options.inline,
	    inlineRequest: context.options.inlineRequest,
	    inlineTimeout: context.options.inlineTimeout,
	    inputSourceMapTracker: context.inputSourceMapTracker,
	    localOnly: context.localOnly,
	    processedTokens: [],
	    rebaseTo: context.options.rebaseTo,
	    sourceTokens: tokens,
	    warnings: context.warnings
	  };

	  return context.options.sourceMap && tokens.length > 0 ?
	    doApplySourceMaps(applyContext) :
	    callback(tokens);
	}

	function doApplySourceMaps(applyContext) {
	  var singleSourceTokens = [];
	  var lastSource = findTokenSource(applyContext.sourceTokens[0]);
	  var source;
	  var token;
	  var l;

	  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {
	    token = applyContext.sourceTokens[applyContext.index];
	    source = findTokenSource(token);

	    if (source != lastSource) {
	      singleSourceTokens = [];
	      lastSource = source;
	    }

	    singleSourceTokens.push(token);
	    applyContext.processedTokens.push(token);

	    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {
	      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);
	    }
	  }

	  return applyContext.callback(applyContext.processedTokens);
	}

	function findTokenSource(token) {
	  var scope;
	  var metadata;

	  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
	    metadata = token[2][0];
	  } else {
	    scope = token[1][0];
	    metadata = scope[2][0];
	  }

	  return metadata[2];
	}

	function fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {
	  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {
	    if (inputSourceMap) {
	      applyContext.inputSourceMapTracker.track(source, inputSourceMap);
	      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);
	    }

	    applyContext.index++;
	    return doApplySourceMaps(applyContext);
	  });
	}

	function extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {
	  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];
	  var absoluteUri;
	  var sourceMap;
	  var rebasedMap;

	  if (isDataUriResource(uri)) {
	    sourceMap = extractInputSourceMapFromDataUri(uri);
	    return whenSourceMapReady(sourceMap);
	  } else if (isRemoteResource(uri)) {
	    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {
	      var parsedMap;

	      if (sourceMap) {
	        parsedMap = JSON.parse(sourceMap);
	        rebasedMap = rebaseRemoteMap(parsedMap, uri);
	        whenSourceMapReady(rebasedMap);
	      } else {
	        whenSourceMapReady(null);
	      }
	    });
	  } else {
	    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment
	    // it is rebased to be consistent with rebasing other URIs
	    // however here we need to resolve it back to read it from disk
	    absoluteUri = path.resolve(applyContext.rebaseTo, uri);
	    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);

	    if (sourceMap) {
	      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);
	      return whenSourceMapReady(rebasedMap);
	    } else {
	      return whenSourceMapReady(null);
	    }
	  }
	}

	function extractInputSourceMapFromDataUri(uri) {
	  var dataUriMatch = matchDataUri(uri);
	  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';
	  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';
	  var data = encoding == 'utf8' ? commonjsGlobal.unescape(dataUriMatch[4]) : dataUriMatch[4];

	  var buffer = new Buffer(data, encoding);
	  buffer.charset = charset;

	  return JSON.parse(buffer.toString());
	}

	function loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {
	  var isAllowed = isAllowedResource(uri, true, applyContext.inline);
	  var isRuntimeResource = !hasProtocol(uri);

	  if (applyContext.localOnly) {
	    applyContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
	    return whenLoaded(null);
	  } else if (isRuntimeResource) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
	    return whenLoaded(null);
	  } else if (!isAllowed) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return whenLoaded(null);
	  }

	  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {
	    if (error) {
	      applyContext.warnings.push('Missing source map at "' + uri + '" - ' + error);
	      return whenLoaded(null);
	    }

	    whenLoaded(body);
	  });
	}

	function loadInputSourceMapFromLocalUri(uri, applyContext) {
	  var isAllowed = isAllowedResource(uri, false, applyContext.inline);
	  var sourceMap;

	  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {
	    applyContext.warnings.push('Ignoring local source map at "' + uri + '" as resource is missing.');
	    return null;
	  } else if (!isAllowed) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return null;
	  }

	  sourceMap = fs.readFileSync(uri, 'utf-8');
	  return JSON.parse(sourceMap);
	}

	function applySourceMapRecursively(tokens, inputSourceMapTracker) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	      case Token.AT_RULE:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.AT_RULE_BLOCK:
	        applySourceMapRecursively(token[1], inputSourceMapTracker);
	        applySourceMapRecursively(token[2], inputSourceMapTracker);
	        break;
	      case Token.AT_RULE_BLOCK_SCOPE:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.NESTED_BLOCK:
	        applySourceMapRecursively(token[1], inputSourceMapTracker);
	        applySourceMapRecursively(token[2], inputSourceMapTracker);
	        break;
	      case Token.NESTED_BLOCK_SCOPE:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.COMMENT:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.PROPERTY:
	        applySourceMapRecursively(token, inputSourceMapTracker);
	        break;
	      case Token.PROPERTY_BLOCK:
	        applySourceMapRecursively(token[1], inputSourceMapTracker);
	        break;
	      case Token.PROPERTY_NAME:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.PROPERTY_VALUE:
	        applySourceMapTo(token, inputSourceMapTracker);
	        break;
	      case Token.RULE:
	        applySourceMapRecursively(token[1], inputSourceMapTracker);
	        applySourceMapRecursively(token[2], inputSourceMapTracker);
	        break;
	      case Token.RULE_SCOPE:
	        applySourceMapTo(token, inputSourceMapTracker);
	    }
	  }

	  return tokens;
	}

	function applySourceMapTo(token, inputSourceMapTracker) {
	  var value = token[1];
	  var metadata = token[2];
	  var newMetadata = [];
	  var i, l;

	  for (i = 0, l = metadata.length; i < l; i++) {
	    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));
	  }

	  token[2] = newMetadata;
	}

	applySourceMaps_1 = applySourceMaps;
	return applySourceMaps_1;
}

var extractImportUrlAndMedia_1;
var hasRequiredExtractImportUrlAndMedia;

function requireExtractImportUrlAndMedia () {
	if (hasRequiredExtractImportUrlAndMedia) return extractImportUrlAndMedia_1;
	hasRequiredExtractImportUrlAndMedia = 1;
	var split = requireSplit();

	var BRACE_PREFIX = /^\(/;
	var BRACE_SUFFIX = /\)$/;
	var IMPORT_PREFIX_PATTERN = /^@import/i;
	var QUOTE_PREFIX_PATTERN = /['"]\s*/;
	var QUOTE_SUFFIX_PATTERN = /\s*['"]/;
	var URL_PREFIX_PATTERN = /^url\(\s*/i;
	var URL_SUFFIX_PATTERN = /\s*\)/i;

	function extractImportUrlAndMedia(atRuleValue) {
	  var uri;
	  var mediaQuery;
	  var stripped;
	  var parts;

	  stripped = atRuleValue
	    .replace(IMPORT_PREFIX_PATTERN, '')
	    .trim()
	    .replace(URL_PREFIX_PATTERN, '(')
	    .replace(URL_SUFFIX_PATTERN, ')')
	    .replace(QUOTE_PREFIX_PATTERN, '')
	    .replace(QUOTE_SUFFIX_PATTERN, '');

	  parts = split(stripped, ' ');

	  uri = parts[0]
	    .replace(BRACE_PREFIX, '')
	    .replace(BRACE_SUFFIX, '');
	  mediaQuery = parts.slice(1).join(' ');

	  return [uri, mediaQuery];
	}

	extractImportUrlAndMedia_1 = extractImportUrlAndMedia;
	return extractImportUrlAndMedia_1;
}

var loadOriginalSources_1;
var hasRequiredLoadOriginalSources;

function requireLoadOriginalSources () {
	if (hasRequiredLoadOriginalSources) return loadOriginalSources_1;
	hasRequiredLoadOriginalSources = 1;
	var fs = require$$0$4;
	var path = require$$0$3;

	var isAllowedResource = requireIsAllowedResource();

	var hasProtocol = requireHasProtocol();
	var isRemoteResource = requireIsRemoteResource();

	function loadOriginalSources(context, callback) {
	  var loadContext = {
	    callback: callback,
	    fetch: context.options.fetch,
	    index: 0,
	    inline: context.options.inline,
	    inlineRequest: context.options.inlineRequest,
	    inlineTimeout: context.options.inlineTimeout,
	    localOnly: context.localOnly,
	    rebaseTo: context.options.rebaseTo,
	    sourcesContent: context.sourcesContent,
	    uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),
	    warnings: context.warnings
	  };

	  return context.options.sourceMap && context.options.sourceMapInlineSources ?
	    doLoadOriginalSources(loadContext) :
	    callback();
	}

	function uriToSourceMapping(allSourceMapConsumers) {
	  var mapping = {};
	  var consumer;
	  var uri;
	  var source;
	  var i, l;

	  for (source in allSourceMapConsumers) {
	    consumer = allSourceMapConsumers[source];

	    for (i = 0, l = consumer.sources.length; i < l; i++) {
	      uri = consumer.sources[i];
	      source = consumer.sourceContentFor(uri, true);

	      mapping[uri] = source;
	    }
	  }

	  return mapping;
	}

	function doLoadOriginalSources(loadContext) {
	  var uris = Object.keys(loadContext.uriToSource);
	  var uri;
	  var source;
	  var total;

	  for (total = uris.length; loadContext.index < total; loadContext.index++) {
	    uri = uris[loadContext.index];
	    source = loadContext.uriToSource[uri];

	    if (source) {
	      loadContext.sourcesContent[uri] = source;
	    } else {
	      return loadOriginalSource(uri, loadContext);
	    }
	  }

	  return loadContext.callback();
	}

	function loadOriginalSource(uri, loadContext) {
	  var content;

	  if (isRemoteResource(uri)) {
	    return loadOriginalSourceFromRemoteUri(uri, loadContext, function (content) {
	      loadContext.index++;
	      loadContext.sourcesContent[uri] = content;
	      return doLoadOriginalSources(loadContext);
	    });
	  } else {
	    content = loadOriginalSourceFromLocalUri(uri, loadContext);
	    loadContext.index++;
	    loadContext.sourcesContent[uri] = content;
	    return doLoadOriginalSources(loadContext);
	  }
	}

	function loadOriginalSourceFromRemoteUri(uri, loadContext, whenLoaded) {
	  var isAllowed = isAllowedResource(uri, true, loadContext.inline);
	  var isRuntimeResource = !hasProtocol(uri);

	  if (loadContext.localOnly) {
	    loadContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
	    return whenLoaded(null);
	  } else if (isRuntimeResource) {
	    loadContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
	    return whenLoaded(null);
	  } else if (!isAllowed) {
	    loadContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return whenLoaded(null);
	  }

	  loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function (error, content) {
	    if (error) {
	      loadContext.warnings.push('Missing original source at "' + uri + '" - ' + error);
	    }

	    whenLoaded(content);
	  });
	}

	function loadOriginalSourceFromLocalUri(relativeUri, loadContext) {
	  var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);
	  var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);

	  if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {
	    loadContext.warnings.push('Ignoring local source map at "' + absoluteUri + '" as resource is missing.');
	    return null;
	  } else if (!isAllowed) {
	    loadContext.warnings.push('Cannot fetch "' + absoluteUri + '" as resource is not allowed.');
	    return null;
	  }

	  return fs.readFileSync(absoluteUri, 'utf8');
	}

	loadOriginalSources_1 = loadOriginalSources;
	return loadOriginalSources_1;
}

var normalizePath_1;
var hasRequiredNormalizePath;

function requireNormalizePath () {
	if (hasRequiredNormalizePath) return normalizePath_1;
	hasRequiredNormalizePath = 1;
	var UNIX_SEPARATOR = '/';
	var WINDOWS_SEPARATOR_PATTERN = /\\/g;

	function normalizePath(path) {
	  return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);
	}

	normalizePath_1 = normalizePath;
	return normalizePath_1;
}

var restoreImport_1;
var hasRequiredRestoreImport;

function requireRestoreImport () {
	if (hasRequiredRestoreImport) return restoreImport_1;
	hasRequiredRestoreImport = 1;
	function restoreImport(uri, mediaQuery) {
	  return ('@import ' + uri + ' ' + mediaQuery).trim();
	}

	restoreImport_1 = restoreImport;
	return restoreImport_1;
}

var rewriteUrl_1;
var hasRequiredRewriteUrl;

function requireRewriteUrl () {
	if (hasRequiredRewriteUrl) return rewriteUrl_1;
	hasRequiredRewriteUrl = 1;
	var path = require$$0$3;
	var url = require$$1$1;

	var DOUBLE_QUOTE = '"';
	var SINGLE_QUOTE = '\'';
	var URL_PREFIX = 'url(';
	var URL_SUFFIX = ')';

	var QUOTE_PREFIX_PATTERN = /^["']/;
	var QUOTE_SUFFIX_PATTERN = /["']$/;
	var ROUND_BRACKETS_PATTERN = /[\(\)]/;
	var URL_PREFIX_PATTERN = /^url\(/i;
	var URL_SUFFIX_PATTERN = /\)$/;
	var WHITESPACE_PATTERN = /\s/;

	var isWindows = process.platform == 'win32';

	function rebase(uri, rebaseConfig) {
	  if (!rebaseConfig) {
	    return uri;
	  }

	  if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {
	    return uri;
	  }

	  if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri)) {
	    return uri;
	  }

	  if (isData(uri)) {
	    return '\'' + uri + '\'';
	  }

	  if (isRemote(rebaseConfig.toBase)) {
	    return url.resolve(rebaseConfig.toBase, uri);
	  }

	  return rebaseConfig.absolute ?
	    normalize(absolute(uri, rebaseConfig)) :
	    normalize(relative(uri, rebaseConfig));
	}

	function isAbsolute(uri) {
	  return path.isAbsolute(uri);
	}

	function isSVGMarker(uri) {
	  return uri[0] == '#';
	}

	function isInternal(uri) {
	  return /^\w+:\w+/.test(uri);
	}

	function isRemote(uri) {
	  return /^[^:]+?:\/\//.test(uri) || uri.indexOf('//') === 0;
	}

	function isData(uri) {
	  return uri.indexOf('data:') === 0;
	}

	function absolute(uri, rebaseConfig) {
	  return path
	    .resolve(path.join(rebaseConfig.fromBase || '', uri))
	    .replace(rebaseConfig.toBase, '');
	}

	function relative(uri, rebaseConfig) {
	  return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || '', uri));
	}

	function normalize(uri) {
	  return isWindows ? uri.replace(/\\/g, '/') : uri;
	}

	function quoteFor(unquotedUrl) {
	  if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {
	    return DOUBLE_QUOTE;
	  } else if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {
	    return SINGLE_QUOTE;
	  } else if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {
	    return SINGLE_QUOTE;
	  } else {
	    return '';
	  }
	}

	function hasWhitespace(url) {
	  return WHITESPACE_PATTERN.test(url);
	}

	function hasRoundBrackets(url) {
	  return ROUND_BRACKETS_PATTERN.test(url);
	}

	function rewriteUrl(originalUrl, rebaseConfig, pathOnly) {
	  var strippedUrl = originalUrl
	    .replace(URL_PREFIX_PATTERN, '')
	    .replace(URL_SUFFIX_PATTERN, '')
	    .trim();

	  var unquotedUrl = strippedUrl
	    .replace(QUOTE_PREFIX_PATTERN, '')
	    .replace(QUOTE_SUFFIX_PATTERN, '')
	    .trim();

	  var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE ?
	    strippedUrl[0] :
	    quoteFor(unquotedUrl);

	  return pathOnly ?
	    rebase(unquotedUrl, rebaseConfig) :
	    URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;
	}

	rewriteUrl_1 = rewriteUrl;
	return rewriteUrl_1;
}

var isImport_1;
var hasRequiredIsImport;

function requireIsImport () {
	if (hasRequiredIsImport) return isImport_1;
	hasRequiredIsImport = 1;
	var IMPORT_PREFIX_PATTERN = /^@import/i;

	function isImport(value) {
	  return IMPORT_PREFIX_PATTERN.test(value);
	}

	isImport_1 = isImport;
	return isImport_1;
}

var rebase_1;
var hasRequiredRebase;

function requireRebase () {
	if (hasRequiredRebase) return rebase_1;
	hasRequiredRebase = 1;
	var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
	var restoreImport = requireRestoreImport();
	var rewriteUrl = requireRewriteUrl();

	var Token = requireToken();
	var isImport = requireIsImport();

	var SOURCE_MAP_COMMENT_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;

	function rebase(tokens, rebaseAll, validator, rebaseConfig) {
	  return rebaseAll ?
	    rebaseEverything(tokens, validator, rebaseConfig) :
	    rebaseAtRules(tokens, validator, rebaseConfig);
	}

	function rebaseEverything(tokens, validator, rebaseConfig) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	      case Token.AT_RULE:
	        rebaseAtRule(token, validator, rebaseConfig);
	        break;
	      case Token.AT_RULE_BLOCK:
	        rebaseProperties(token[2], validator, rebaseConfig);
	        break;
	      case Token.COMMENT:
	        rebaseSourceMapComment(token, rebaseConfig);
	        break;
	      case Token.NESTED_BLOCK:
	        rebaseEverything(token[2], validator, rebaseConfig);
	        break;
	      case Token.RULE:
	        rebaseProperties(token[2], validator, rebaseConfig);
	        break;
	    }
	  }

	  return tokens;
	}

	function rebaseAtRules(tokens, validator, rebaseConfig) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	      case Token.AT_RULE:
	        rebaseAtRule(token, validator, rebaseConfig);
	        break;
	    }
	  }

	  return tokens;
	}

	function rebaseAtRule(token, validator, rebaseConfig) {
	  if (!isImport(token[1])) {
	    return;
	  }

	  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
	  var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);
	  var mediaQuery = uriAndMediaQuery[1];

	  token[1] = restoreImport(newUrl, mediaQuery);
	}

	function rebaseSourceMapComment(token, rebaseConfig) {
	  var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);

	  if (matches && matches[1].indexOf('data:') === -1) {
	    token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));
	  }
	}

	function rebaseProperties(properties, validator, rebaseConfig) {
	  var property;
	  var value;
	  var i, l;
	  var j, m;

	  for (i = 0, l = properties.length; i < l; i++) {
	    property = properties[i];

	    for (j = 2 /* 0 is Token.PROPERTY, 1 is name */, m = property.length; j < m; j++) {
	      value = property[j][1];

	      if (validator.isUrl(value)) {
	        property[j][1] = rewriteUrl(value, rebaseConfig);
	      }
	    }
	  }
	}

	rebase_1 = rebase;
	return rebase_1;
}

var tokenize_1;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1;
	var Marker = requireMarker();
	var Token = requireToken();

	var formatPosition = requireFormatPosition();

	var Level = {
	  BLOCK: 'block',
	  COMMENT: 'comment',
	  DOUBLE_QUOTE: 'double-quote',
	  RULE: 'rule',
	  SINGLE_QUOTE: 'single-quote'
	};

	var AT_RULES = [
	  '@charset',
	  '@import'
	];

	var BLOCK_RULES = [
	  '@-moz-document',
	  '@document',
	  '@-moz-keyframes',
	  '@-ms-keyframes',
	  '@-o-keyframes',
	  '@-webkit-keyframes',
	  '@keyframes',
	  '@media',
	  '@supports'
	];

	var IGNORE_END_COMMENT_PATTERN = /\/\* clean\-css ignore:end \*\/$/;
	var IGNORE_START_COMMENT_PATTERN = /^\/\* clean\-css ignore:start \*\//;

	var PAGE_MARGIN_BOXES = [
	  '@bottom-center',
	  '@bottom-left',
	  '@bottom-left-corner',
	  '@bottom-right',
	  '@bottom-right-corner',
	  '@left-bottom',
	  '@left-middle',
	  '@left-top',
	  '@right-bottom',
	  '@right-middle',
	  '@right-top',
	  '@top-center',
	  '@top-left',
	  '@top-left-corner',
	  '@top-right',
	  '@top-right-corner'
	];

	var EXTRA_PAGE_BOXES = [
	  '@footnote',
	  '@footnotes',
	  '@left',
	  '@page-float-bottom',
	  '@page-float-top',
	  '@right'
	];

	var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
	var RULE_WORD_SEPARATOR_PATTERN = /[\s\(]/;
	var TAIL_BROKEN_VALUE_PATTERN = /[\s|\}]*$/;

	function tokenize(source, externalContext) {
	  var internalContext = {
	    level: Level.BLOCK,
	    position: {
	      source: externalContext.source || undefined,
	      line: 1,
	      column: 0,
	      index: 0
	    }
	  };

	  return intoTokens(source, externalContext, internalContext, false);
	}

	function intoTokens(source, externalContext, internalContext, isNested) {
	  var allTokens = [];
	  var newTokens = allTokens;
	  var lastToken;
	  var ruleToken;
	  var ruleTokens = [];
	  var propertyToken;
	  var metadata;
	  var metadatas = [];
	  var level = internalContext.level;
	  var levels = [];
	  var buffer = [];
	  var buffers = [];
	  var serializedBuffer;
	  var serializedBufferPart;
	  var roundBracketLevel = 0;
	  var isQuoted;
	  var isSpace;
	  var isNewLineNix;
	  var isNewLineWin;
	  var isCarriageReturn;
	  var isCommentStart;
	  var wasCommentStart = false;
	  var isCommentEnd;
	  var wasCommentEnd = false;
	  var isCommentEndMarker;
	  var isEscaped;
	  var wasEscaped = false;
	  var isRaw = false;
	  var seekingValue = false;
	  var seekingPropertyBlockClosing = false;
	  var position = internalContext.position;
	  var lastCommentStartAt;

	  for (; position.index < source.length; position.index++) {
	    var character = source[position.index];

	    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
	    isSpace = character == Marker.SPACE || character == Marker.TAB;
	    isNewLineNix = character == Marker.NEW_LINE_NIX;
	    isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;
	    isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;
	    isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;
	    isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;
	    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;
	    roundBracketLevel = Math.max(roundBracketLevel, 0);

	    metadata = buffer.length === 0 ?
	      [position.line, position.column, position.source] :
	      metadata;

	    if (isEscaped) {
	      // previous character was a backslash
	      buffer.push(character);
	    } else if (!isCommentEnd && level == Level.COMMENT) {
	      buffer.push(character);
	    } else if (!isCommentStart && !isCommentEnd && isRaw) {
	      buffer.push(character);
	    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
	      // comment start within block preceded by some content, e.g. div/*<--
	      metadatas.push(metadata);
	      buffer.push(character);
	      buffers.push(buffer.slice(0, buffer.length - 2));

	      buffer = buffer.slice(buffer.length - 2);
	      metadata = [position.line, position.column - 1, position.source];

	      levels.push(level);
	      level = Level.COMMENT;
	    } else if (isCommentStart) {
	      // comment start, e.g. /*<--
	      levels.push(level);
	      level = Level.COMMENT;
	      buffer.push(character);
	    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {
	      // ignore:start comment end, e.g. /* clean-css ignore:start */<--
	      serializedBuffer = buffer.join('').trim() + character;
	      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
	      newTokens.push(lastToken);

	      isRaw = true;
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {
	      // ignore:start comment end, e.g. /* clean-css ignore:end */<--
	      serializedBuffer = buffer.join('') + character;
	      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);

	      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
	      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
	      newTokens.push(lastToken);

	      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
	      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
	      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
	      newTokens.push(lastToken);

	      isRaw = false;
	      level = levels.pop();
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	    } else if (isCommentEnd) {
	      // comment end, e.g. /* comment */<--
	      serializedBuffer = buffer.join('').trim() + character;
	      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
	      newTokens.push(lastToken);

	      level = levels.pop();
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {
	      externalContext.warnings.push('Unexpected \'*/\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	      buffer = [];
	    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
	      // single quotation start, e.g. a[href^='https<--
	      levels.push(level);
	      level = Level.SINGLE_QUOTE;
	      buffer.push(character);
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
	      // single quotation end, e.g. a[href^='https'<--
	      level = levels.pop();
	      buffer.push(character);
	    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
	      // double quotation start, e.g. a[href^="<--
	      levels.push(level);
	      level = Level.DOUBLE_QUOTE;
	      buffer.push(character);
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
	      // double quotation end, e.g. a[href^="https"<--
	      level = levels.pop();
	      buffer.push(character);
	    } else if (!isCommentStart && !isCommentEnd && character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {
	      // character inside any function, e.g. hsla(.<--
	      buffer.push(character);
	    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
	      // round open bracket, e.g. @import url(<--
	      buffer.push(character);

	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
	      // round open bracket, e.g. @import url(test.css)<--
	      buffer.push(character);

	      roundBracketLevel--;
	    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {
	      // semicolon ending rule at block level, e.g. @import '...';<--
	      serializedBuffer = buffer.join('').trim();
	      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      buffer = [];
	    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {
	      // comma separator at block level, e.g. a,div,<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);

	      buffer = [];
	    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {
	      // comma separator at block level, e.g. @import url(...) screen,<--
	      // keep iterating as end semicolon will create the token
	      buffer.push(character);
	    } else if (character == Marker.COMMA && level == Level.BLOCK) {
	      // comma separator at block level, e.g. a,<--
	      ruleToken = [tokenTypeFrom(buffer), [], []];
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);

	      buffer = [];
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {
	      // open brace opening at-rule at block level, e.g. @media{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      allTokens.push(ruleToken);

	      levels.push(level);
	      position.column++;
	      position.index++;
	      buffer = [];

	      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
	      ruleToken = null;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
	      // open brace opening at-rule at block level, e.g. @media{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
	      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      allTokens.push(ruleToken);

	      levels.push(level);
	      position.column++;
	      position.index++;
	      buffer = [];

	      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
	      ruleToken = null;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {
	      // open brace opening rule at block level, e.g. div{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
	      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
	      newTokens = ruleToken[2];
	      allTokens.push(ruleToken);

	      levels.push(level);
	      level = Level.RULE;
	      buffer = [];
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {
	      // open brace opening rule at rule level, e.g. div{--variable:{<--
	      ruleTokens.push(ruleToken);
	      ruleToken = [Token.PROPERTY_BLOCK, []];
	      propertyToken.push(ruleToken);
	      newTokens = ruleToken[1];

	      levels.push(level);
	      level = Level.RULE;
	      seekingValue = false;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {
	      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleTokens.push(ruleToken);
	      ruleToken = [Token.AT_RULE_BLOCK, [], []];
	      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      newTokens.push(ruleToken);
	      newTokens = ruleToken[2];

	      levels.push(level);
	      level = Level.RULE;
	      buffer = [];
	    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {
	      // colon at rule level, e.g. a{color:<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];
	      newTokens.push(propertyToken);

	      seekingValue = true;
	      buffer = [];
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && buffer.length > 0 && buffer[0] == Marker.AT) {
	      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      buffer = [];
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length > 0) {
	      // semicolon at rule level, e.g. a{color:red;<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      propertyToken = null;
	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length === 0) {
	      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--
	      propertyToken = null;
	      seekingValue = false;
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
	      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--
	      serializedBuffer = buffer.join('');
	      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {
	      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--
	      seekingPropertyBlockClosing = false;
	      buffer = [];
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length === 0) ; else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && buffer.length > 0 && ruleTokens.length > 0) {
	      // close brace at rule level, e.g. a{--color:{color:red}<--
	      serializedBuffer = buffer.join('');
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0 && buffer[0] == Marker.AT && ruleTokens.length > 0) {
	      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--
	      serializedBuffer = buffer.join('');
	      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {
	      // close brace at rule level after space, e.g. a{--color:{color:red }<--
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0) {
	      // close brace at rule level, e.g. a{color:red}<--
	      serializedBuffer = buffer.join('');
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
	      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--
	      propertyToken = null;
	      ruleToken = null;
	      serializedBuffer = buffer.join('').trim();
	      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {
	      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      seekingPropertyBlockClosing = true;
	      buffer = [];
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {
	      // close brace after a rule, e.g. a{color:red;}<--
	      propertyToken = null;
	      ruleToken = null;
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {
	      // stray close brace at block level, e.g. a{color:red}color:blue}<--
	      externalContext.warnings.push('Unexpected \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	      buffer.push(character);
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {
	      // close brace at block level, e.g. @media screen {...}<--
	      break;
	    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {
	      // round open bracket, e.g. a{color:hsla(<--
	      buffer.push(character);
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {
	      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--
	      buffer.push(character);
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      roundBracketLevel--;
	      buffer = [];
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {
	      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--
	      buffer.push(character);
	      roundBracketLevel--;
	    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && buffer.length > 0) {
	      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

	      buffer = [];
	    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {
	      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--
	      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

	      buffer = [];
	    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && buffer.length > 0) {
	      // comma within a property, e.g. a{background:url(image.png),<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
	      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

	      buffer = [];
	    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {
	      // comma within a property after space, e.g. a{background:url(image.png) ,<--
	      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

	      buffer = [];
	    } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && buffer.length > 0 && isRepeatToken(buffer)) {
	      buffer.push(character);
	      serializedBuffer = buffer.join('').trim();
	      propertyToken[propertyToken.length - 1][1] += serializedBuffer;

	      buffer = [];
	    } else if ((isSpace || (isNewLineNix && !isNewLineWin)) && level == Level.RULE && seekingValue && propertyToken && buffer.length > 0) {
	      // space or *nix newline within property, e.g. a{margin:0 <--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      buffer = [];
	    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {
	      // win newline within property, e.g. a{margin:0\r\n<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	      buffer = [];
	    } else if (isNewLineWin && level == Level.RULE && seekingValue) {
	      // win newline
	      buffer = [];
	    } else if (buffer.length == 1 && isNewLineWin) {
	      // ignore windows newline which is composed of two characters
	      buffer.pop();
	    } else if (buffer.length > 0 || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {
	      // any character
	      buffer.push(character);
	    }

	    wasEscaped = isEscaped;
	    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;
	    wasCommentStart = isCommentStart;
	    wasCommentEnd = isCommentEnd;

	    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;
	    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;
	  }

	  if (seekingValue) {
	    externalContext.warnings.push('Missing \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	  }

	  if (seekingValue && buffer.length > 0) {
	    serializedBuffer = buffer.join('').replace(TAIL_BROKEN_VALUE_PATTERN, '');
	    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

	    buffer = [];
	  }

	  if (buffer.length > 0) {
	    externalContext.warnings.push('Invalid character(s) \'' + buffer.join('') + '\' at ' + formatPosition(metadata) + '. Ignoring.');
	  }

	  return allTokens;
	}

	function isIgnoreStartComment(buffer) {
	  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
	}

	function isIgnoreEndComment(buffer) {
	  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
	}

	function originalMetadata(metadata, value, externalContext, selectorFallbacks) {
	  var source = metadata[2];

	  return externalContext.inputSourceMapTracker.isTracking(source) ?
	    externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) :
	    metadata;
	}

	function tokenTypeFrom(buffer) {
	  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
	  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];

	  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {
	    return Token.NESTED_BLOCK;
	  } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {
	    return Token.AT_RULE;
	  } else if (isAtRule) {
	    return Token.AT_RULE_BLOCK;
	  } else {
	    return Token.RULE;
	  }
	}

	function tokenScopeFrom(tokenType) {
	  if (tokenType == Token.RULE) {
	    return Token.RULE_SCOPE;
	  } else if (tokenType == Token.NESTED_BLOCK) {
	    return Token.NESTED_BLOCK_SCOPE;
	  } else if (tokenType == Token.AT_RULE_BLOCK) {
	    return Token.AT_RULE_BLOCK_SCOPE;
	  }
	}

	function isPageMarginBox(buffer) {
	  var serializedBuffer = buffer.join('').trim();

	  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;
	}

	function isRepeatToken(buffer) {
	  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);
	}

	tokenize_1 = tokenize;
	return tokenize_1;
}

var readSources_1;
var hasRequiredReadSources;

function requireReadSources () {
	if (hasRequiredReadSources) return readSources_1;
	hasRequiredReadSources = 1;
	var fs = require$$0$4;
	var path = require$$0$3;

	var applySourceMaps = requireApplySourceMaps();
	var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
	var isAllowedResource = requireIsAllowedResource();
	var loadOriginalSources = requireLoadOriginalSources();
	var normalizePath = requireNormalizePath();
	var rebase = requireRebase();
	var rebaseLocalMap = requireRebaseLocalMap();
	var rebaseRemoteMap = requireRebaseRemoteMap();
	var restoreImport = requireRestoreImport();

	var tokenize = requireTokenize();
	var Token = requireToken();
	var Marker = requireMarker();
	var hasProtocol = requireHasProtocol();
	var isImport = requireIsImport();
	var isRemoteResource = requireIsRemoteResource();

	var UNKNOWN_URI = 'uri:unknown';

	function readSources(input, context, callback) {
	  return doReadSources(input, context, function (tokens) {
	    return applySourceMaps(tokens, context, function () {
	      return loadOriginalSources(context, function () { return callback(tokens); });
	    });
	  });
	}

	function doReadSources(input, context, callback) {
	  if (typeof input == 'string') {
	    return fromString(input, context, callback);
	  } else if (Buffer.isBuffer(input)) {
	    return fromString(input.toString(), context, callback);
	  } else if (Array.isArray(input)) {
	    return fromArray(input, context, callback);
	  } else if (typeof input == 'object') {
	    return fromHash(input, context, callback);
	  }
	}

	function fromString(input, context, callback) {
	  context.source = undefined;
	  context.sourcesContent[undefined] = input;
	  context.stats.originalSize += input.length;

	  return fromStyles(input, context, { inline: context.options.inline }, callback);
	}

	function fromArray(input, context, callback) {
	  var inputAsImports = input.reduce(function (accumulator, uriOrHash) {
	    if (typeof uriOrHash === 'string') {
	      return addStringSource(uriOrHash, accumulator);
	    } else {
	      return addHashSource(uriOrHash, context, accumulator);
	    }

	  }, []);

	  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);
	}

	function fromHash(input, context, callback) {
	  var inputAsImports = addHashSource(input, context, []);
	  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);
	}

	function addStringSource(input, imports) {
	  imports.push(restoreAsImport(normalizeUri(input)));
	  return imports;
	}

	function addHashSource(input, context, imports) {
	  var uri;
	  var normalizedUri;
	  var source;

	  for (uri in input) {
	    source = input[uri];
	    normalizedUri = normalizeUri(uri);

	    imports.push(restoreAsImport(normalizedUri));

	    context.sourcesContent[normalizedUri] = source.styles;

	    if (source.sourceMap) {
	      trackSourceMap(source.sourceMap, normalizedUri, context);
	    }
	  }

	  return imports;
	}

	function normalizeUri(uri) {
	  var currentPath = path.resolve('');
	  var absoluteUri;
	  var relativeToCurrentPath;
	  var normalizedUri;

	  if (isRemoteResource(uri)) {
	    return uri;
	  }

	  absoluteUri = path.isAbsolute(uri) ?
	    uri :
	    path.resolve(uri);
	  relativeToCurrentPath = path.relative(currentPath, absoluteUri);
	  normalizedUri = normalizePath(relativeToCurrentPath);

	  return normalizedUri;
	}

	function trackSourceMap(sourceMap, uri, context) {
	  var parsedMap = typeof sourceMap == 'string' ?
	      JSON.parse(sourceMap) :
	      sourceMap;
	  var rebasedMap = isRemoteResource(uri) ?
	    rebaseRemoteMap(parsedMap, uri) :
	    rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);

	  context.inputSourceMapTracker.track(uri, rebasedMap);
	}

	function restoreAsImport(uri) {
	  return restoreImport('url(' + uri + ')', '') + Marker.SEMICOLON;
	}

	function fromStyles(styles, context, parentInlinerContext, callback) {
	  var tokens;
	  var rebaseConfig = {};

	  if (!context.source) {
	    rebaseConfig.fromBase = path.resolve('');
	    rebaseConfig.toBase = context.options.rebaseTo;
	  } else if (isRemoteResource(context.source)) {
	    rebaseConfig.fromBase = context.source;
	    rebaseConfig.toBase = context.source;
	  } else if (path.isAbsolute(context.source)) {
	    rebaseConfig.fromBase = path.dirname(context.source);
	    rebaseConfig.toBase = context.options.rebaseTo;
	  } else {
	    rebaseConfig.fromBase = path.dirname(path.resolve(context.source));
	    rebaseConfig.toBase = context.options.rebaseTo;
	  }

	  tokens = tokenize(styles, context);
	  tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);

	  return allowsAnyImports(parentInlinerContext.inline) ?
	    inline(tokens, context, parentInlinerContext, callback) :
	    callback(tokens);
	}

	function allowsAnyImports(inline) {
	  return !(inline.length == 1 && inline[0] == 'none');
	}

	function inline(tokens, externalContext, parentInlinerContext, callback) {
	  var inlinerContext = {
	    afterContent: false,
	    callback: callback,
	    errors: externalContext.errors,
	    externalContext: externalContext,
	    fetch: externalContext.options.fetch,
	    inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,
	    inline: parentInlinerContext.inline,
	    inlineRequest: externalContext.options.inlineRequest,
	    inlineTimeout: externalContext.options.inlineTimeout,
	    isRemote: parentInlinerContext.isRemote || false,
	    localOnly: externalContext.localOnly,
	    outputTokens: [],
	    rebaseTo: externalContext.options.rebaseTo,
	    sourceTokens: tokens,
	    warnings: externalContext.warnings
	  };

	  return doInlineImports(inlinerContext);
	}

	function doInlineImports(inlinerContext) {
	  var token;
	  var i, l;

	  for (i = 0, l = inlinerContext.sourceTokens.length; i < l; i++) {
	    token = inlinerContext.sourceTokens[i];

	    if (token[0] == Token.AT_RULE && isImport(token[1])) {
	      inlinerContext.sourceTokens.splice(0, i);
	      return inlineStylesheet(token, inlinerContext);
	    } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
	      inlinerContext.outputTokens.push(token);
	    } else {
	      inlinerContext.outputTokens.push(token);
	      inlinerContext.afterContent = true;
	    }
	  }

	  inlinerContext.sourceTokens = [];
	  return inlinerContext.callback(inlinerContext.outputTokens);
	}

	function inlineStylesheet(token, inlinerContext) {
	  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
	  var uri = uriAndMediaQuery[0];
	  var mediaQuery = uriAndMediaQuery[1];
	  var metadata = token[2];

	  return isRemoteResource(uri) ?
	    inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) :
	    inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);
	}

	function inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) {
	  var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);
	  var originalUri = uri;
	  var isLoaded = uri in inlinerContext.externalContext.sourcesContent;
	  var isRuntimeResource = !hasProtocol(uri);

	  if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as it has already been imported.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } else if (inlinerContext.localOnly && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as no callback given and after other content.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } else if (isRuntimeResource) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no protocol given.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } else if (inlinerContext.localOnly && !isLoaded) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no callback given.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } else if (!isAllowed && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as resource is not allowed and after other content.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } else if (!isAllowed) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as resource is not allowed.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  }

	  inlinerContext.inlinedStylesheets.push(uri);

	  function whenLoaded(error, importedStyles) {
	    if (error) {
	      inlinerContext.errors.push('Broken @import declaration of "' + uri + '" - ' + error);

	      return process.nextTick(function () {
	        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	        doInlineImports(inlinerContext);
	      });
	    }

	    inlinerContext.inline = inlinerContext.externalContext.options.inline;
	    inlinerContext.isRemote = true;

	    inlinerContext.externalContext.source = originalUri;
	    inlinerContext.externalContext.sourcesContent[uri] = importedStyles;
	    inlinerContext.externalContext.stats.originalSize += importedStyles.length;

	    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {
	      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);

	      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
	      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	      return doInlineImports(inlinerContext);
	    });
	  }

	  return isLoaded ?
	    whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) :
	    inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);
	}

	function inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext) {
	  var currentPath = path.resolve('');
	  var absoluteUri = path.isAbsolute(uri) ?
	    path.resolve(currentPath, uri[0] == '/' ? uri.substring(1) : uri) :
	    path.resolve(inlinerContext.rebaseTo, uri);
	  var relativeToCurrentPath = path.relative(currentPath, absoluteUri);
	  var importedStyles;
	  var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);
	  var normalizedPath = normalizePath(relativeToCurrentPath);
	  var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;

	  if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as it has already been imported.');
	  } else if (!isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {
	    inlinerContext.errors.push('Ignoring local @import of "' + uri + '" as resource is missing.');
	  } else if (!isAllowed && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as resource is not allowed and after other content.');
	  } else if (inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as after other content.');
	  } else if (!isAllowed) {
	    inlinerContext.warnings.push('Skipping local @import of "' + uri + '" as resource is not allowed.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	  } else {
	    importedStyles = isLoaded ?
	      inlinerContext.externalContext.sourcesContent[normalizedPath] :
	      fs.readFileSync(absoluteUri, 'utf-8');

	    inlinerContext.inlinedStylesheets.push(absoluteUri);
	    inlinerContext.inline = inlinerContext.externalContext.options.inline;

	    inlinerContext.externalContext.source = normalizedPath;
	    inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;
	    inlinerContext.externalContext.stats.originalSize += importedStyles.length;

	    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {
	      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);

	      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
	      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	      return doInlineImports(inlinerContext);
	    });
	  }

	  inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	  return doInlineImports(inlinerContext);
	}

	function wrapInMedia(tokens, mediaQuery, metadata) {
	  if (mediaQuery) {
	    return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, '@media ' + mediaQuery, metadata]], tokens]];
	  } else {
	    return tokens;
	  }
	}

	readSources_1 = readSources;
	return readSources_1;
}

var simple;
var hasRequiredSimple;

function requireSimple () {
	if (hasRequiredSimple) return simple;
	hasRequiredSimple = 1;
	var all = requireHelpers().all;

	function store(serializeContext, token) {
	  var value = typeof token == 'string' ?
	    token :
	    token[1];
	  var wrap = serializeContext.wrap;

	  wrap(serializeContext, value);
	  track(serializeContext, value);
	  serializeContext.output.push(value);
	}

	function wrap(serializeContext, value) {
	  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
	    track(serializeContext, serializeContext.format.breakWith);
	    serializeContext.output.push(serializeContext.format.breakWith);
	  }
	}

	function track(serializeContext, value) {
	  var parts = value.split('\n');

	  serializeContext.line += parts.length - 1;
	  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);
	}

	function serializeStyles(tokens, context) {
	  var serializeContext = {
	    column: 0,
	    format: context.options.format,
	    indentBy: 0,
	    indentWith: '',
	    line: 1,
	    output: [],
	    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
	    store: store,
	    wrap: context.options.format.wrapAt ?
	      wrap :
	      function () { /* noop */  }
	  };

	  all(serializeContext, tokens);

	  return {
	    styles: serializeContext.output.join('')
	  };
	}

	simple = serializeStyles;
	return simple;
}

var sourceMaps;
var hasRequiredSourceMaps;

function requireSourceMaps () {
	if (hasRequiredSourceMaps) return sourceMaps;
	hasRequiredSourceMaps = 1;
	var SourceMapGenerator = requireSourceMap().SourceMapGenerator;
	var all = requireHelpers().all;

	var isRemoteResource = requireIsRemoteResource();

	var isWindows = process.platform == 'win32';

	var NIX_SEPARATOR_PATTERN = /\//g;
	var UNKNOWN_SOURCE = '$stdin';
	var WINDOWS_SEPARATOR = '\\';

	function store(serializeContext, element) {
	  var fromString = typeof element == 'string';
	  var value = fromString ? element : element[1];
	  var mappings = fromString ? null : element[2];
	  var wrap = serializeContext.wrap;

	  wrap(serializeContext, value);
	  track(serializeContext, value, mappings);
	  serializeContext.output.push(value);
	}

	function wrap(serializeContext, value) {
	  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
	    track(serializeContext, serializeContext.format.breakWith, false);
	    serializeContext.output.push(serializeContext.format.breakWith);
	  }
	}

	function track(serializeContext, value, mappings) {
	  var parts = value.split('\n');

	  if (mappings) {
	    trackAllMappings(serializeContext, mappings);
	  }

	  serializeContext.line += parts.length - 1;
	  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);
	}

	function trackAllMappings(serializeContext, mappings) {
	  for (var i = 0, l = mappings.length; i < l; i++) {
	    trackMapping(serializeContext, mappings[i]);
	  }
	}

	function trackMapping(serializeContext, mapping) {
	  var line = mapping[0];
	  var column = mapping[1];
	  var originalSource = mapping[2];
	  var source = originalSource;
	  var storedSource = source || UNKNOWN_SOURCE;

	  if (isWindows && source && !isRemoteResource(source)) {
	    storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);
	  }

	  serializeContext.outputMap.addMapping({
	    generated: {
	      line: serializeContext.line,
	      column: serializeContext.column
	    },
	    source: storedSource,
	    original: {
	      line: line,
	      column: column
	    }
	  });

	  if (serializeContext.inlineSources && (originalSource in serializeContext.sourcesContent)) {
	    serializeContext.outputMap.setSourceContent(storedSource, serializeContext.sourcesContent[originalSource]);
	  }
	}

	function serializeStylesAndSourceMap(tokens, context) {
	  var serializeContext = {
	    column: 0,
	    format: context.options.format,
	    indentBy: 0,
	    indentWith: '',
	    inlineSources: context.options.sourceMapInlineSources,
	    line: 1,
	    output: [],
	    outputMap: new SourceMapGenerator(),
	    sourcesContent: context.sourcesContent,
	    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
	    store: store,
	    wrap: context.options.format.wrapAt ?
	      wrap :
	      function () { /* noop */  }
	  };

	  all(serializeContext, tokens);

	  return {
	    sourceMap: serializeContext.outputMap,
	    styles: serializeContext.output.join('')
	  };
	}

	sourceMaps = serializeStylesAndSourceMap;
	return sourceMaps;
}

/**
 * Clean-css - https://github.com/jakubpawlowicz/clean-css
 * Released under the terms of MIT license
 *
 * Copyright (C) 2017 JakubPawlowicz.com
 */

var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean.exports;
	hasRequiredClean = 1;
	var level0Optimize = requireOptimize$3();
	var level1Optimize = requireOptimize$2();
	var level2Optimize = requireOptimize();
	var validator = requireValidator();

	var compatibilityFrom = requireCompatibility();
	var fetchFrom = requireFetch();
	var formatFrom = requireFormat$1().formatFrom;
	var inlineFrom = requireInline();
	var inlineRequestFrom = requireInlineRequest();
	var inlineTimeoutFrom = requireInlineTimeout();
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
	var optimizationLevelFrom = requireOptimizationLevel().optimizationLevelFrom;
	var rebaseFrom = requireRebase$1();
	var rebaseToFrom = requireRebaseTo();

	var inputSourceMapTracker = requireInputSourceMapTracker();
	var readSources = requireReadSources();

	var serializeStyles = requireSimple();
	var serializeStylesAndSourceMap = requireSourceMaps();

	var CleanCSS = clean.exports = function CleanCSS(options) {
	  options = options || {};

	  this.options = {
	    compatibility: compatibilityFrom(options.compatibility),
	    fetch: fetchFrom(options.fetch),
	    format: formatFrom(options.format),
	    inline: inlineFrom(options.inline),
	    inlineRequest: inlineRequestFrom(options.inlineRequest),
	    inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),
	    level: optimizationLevelFrom(options.level),
	    rebase: rebaseFrom(options.rebase),
	    rebaseTo: rebaseToFrom(options.rebaseTo),
	    returnPromise: !!options.returnPromise,
	    sourceMap: !!options.sourceMap,
	    sourceMapInlineSources: !!options.sourceMapInlineSources
	  };
	};


	// for compatibility with optimize-css-assets-webpack-plugin
	CleanCSS.process = function (input, opts) {
	  var cleanCss;
	  var optsTo = opts.to;

	  delete opts.to;
	  cleanCss = new CleanCSS(Object.assign({ returnPromise: true, rebaseTo: optsTo }, opts));

	  return cleanCss.minify(input)
	    .then(function(output) {
	      return { css: output.styles };
	    });
	};


	CleanCSS.prototype.minify = function (input, maybeSourceMap, maybeCallback) {
	  var options = this.options;

	  if (options.returnPromise) {
	    return new Promise(function (resolve, reject) {
	      minify(input, options, maybeSourceMap, function (errors, output) {
	        return errors ?
	          reject(errors) :
	          resolve(output);
	      });
	    });
	  } else {
	    return minify(input, options, maybeSourceMap, maybeCallback);
	  }
	};

	function minify(input, options, maybeSourceMap, maybeCallback) {
	  var sourceMap = typeof maybeSourceMap != 'function' ?
	    maybeSourceMap :
	    null;
	  var callback = typeof maybeCallback == 'function' ?
	    maybeCallback :
	    (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);
	  var context = {
	    stats: {
	      efficiency: 0,
	      minifiedSize: 0,
	      originalSize: 0,
	      startedAt: Date.now(),
	      timeSpent: 0
	    },
	    cache: {
	      specificity: {}
	    },
	    errors: [],
	    inlinedStylesheets: [],
	    inputSourceMapTracker: inputSourceMapTracker(),
	    localOnly: !callback,
	    options: options,
	    source: null,
	    sourcesContent: {},
	    validator: validator(options.compatibility),
	    warnings: []
	  };

	  if (sourceMap) {
	    context.inputSourceMapTracker.track(undefined, sourceMap);
	  }

	  return runner(context.localOnly)(function () {
	    return readSources(input, context, function (tokens) {
	      var serialize = context.options.sourceMap ?
	        serializeStylesAndSourceMap :
	        serializeStyles;

	      var optimizedTokens = optimize(tokens, context);
	      var optimizedStyles = serialize(optimizedTokens, context);
	      var output = withMetadata(optimizedStyles, context);

	      return callback ?
	        callback(context.errors.length > 0 ? context.errors : null, output) :
	        output;
	    });
	  });
	}

	function runner(localOnly) {
	  // to always execute code asynchronously when a callback is given
	  // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony
	  return localOnly ?
	    function (callback) { return callback(); } :
	    process.nextTick;
	}

	function optimize(tokens, context) {
	  var optimized;

	  optimized = level0Optimize(tokens, context);
	  optimized = OptimizationLevel.One in context.options.level ?
	    level1Optimize(tokens, context) :
	    tokens;
	  optimized = OptimizationLevel.Two in context.options.level ?
	    level2Optimize(tokens, context, true) :
	    optimized;

	  return optimized;
	}

	function withMetadata(output, context) {
	  output.stats = calculateStatsFrom(output.styles, context);
	  output.errors = context.errors;
	  output.inlinedStylesheets = context.inlinedStylesheets;
	  output.warnings = context.warnings;

	  return output;
	}

	function calculateStatsFrom(styles, context) {
	  var finishedAt = Date.now();
	  var timeSpent = finishedAt - context.stats.startedAt;

	  delete context.stats.startedAt;
	  context.stats.timeSpent = timeSpent;
	  context.stats.efficiency = 1 - styles.length / context.stats.originalSize;
	  context.stats.minifiedSize = styles.length;

	  return context.stats;
	}
	return clean.exports;
}

var cleanCss;
var hasRequiredCleanCss;

function requireCleanCss () {
	if (hasRequiredCleanCss) return cleanCss;
	hasRequiredCleanCss = 1;
	cleanCss = requireClean();
	return cleanCss;
}

var he$1 = {exports: {}};

/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var he = he$1.exports;

var hasRequiredHe;

function requireHe () {
	if (hasRequiredHe) return he$1.exports;
	hasRequiredHe = 1;
	(function (module, exports$1) {
(function(root) {

			// Detect free variables `exports`.
			var freeExports = exports$1;

			// Detect free variable `module`.
			var freeModule = module &&
				module.exports == freeExports && module;

			// Detect free variable `global`, from Node.js or Browserified code,
			// and use it as `root`.
			var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
			if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
				root = freeGlobal;
			}

			/*--------------------------------------------------------------------------*/

			// All astral symbols.
			var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
			// All ASCII symbols (not just printable ASCII) except those listed in the
			// first column of the overrides table.
			// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
			var regexAsciiWhitelist = /[\x01-\x7F]/g;
			// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
			// code points listed in the first column of the overrides table on
			// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
			var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

			var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
			var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

			var regexEscape = /["&'<>`]/g;
			var escapeMap = {
				'"': '&quot;',
				'&': '&amp;',
				'\'': '&#x27;',
				'<': '&lt;',
				// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
				// following is not strictly necessary unless its part of a tag or an
				// unquoted attribute value. Were only escaping it to support those
				// situations, and for XML support.
				'>': '&gt;',
				// In Internet Explorer  8, the backtick character can be used
				// to break out of (un)quoted attribute values or HTML comments.
				// See http://html5sec.org/#102, http://html5sec.org/#108, and
				// http://html5sec.org/#133.
				'`': '&#x60;'
			};

			var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
			var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
			var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
			var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
			var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
			var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
			var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

			/*--------------------------------------------------------------------------*/

			var stringFromCharCode = String.fromCharCode;

			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			var has = function(object, propertyName) {
				return hasOwnProperty.call(object, propertyName);
			};

			var contains = function(array, value) {
				var index = -1;
				var length = array.length;
				while (++index < length) {
					if (array[index] == value) {
						return true;
					}
				}
				return false;
			};

			var merge = function(options, defaults) {
				if (!options) {
					return defaults;
				}
				var result = {};
				var key;
				for (key in defaults) {
					// A `hasOwnProperty` check is not needed here, since only recognized
					// option names are used anyway. Any others are ignored.
					result[key] = has(options, key) ? options[key] : defaults[key];
				}
				return result;
			};

			// Modified version of `ucs2encode`; see https://mths.be/punycode.
			var codePointToSymbol = function(codePoint, strict) {
				var output = '';
				if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
					// See issue #4:
					// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
					// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
					// REPLACEMENT CHARACTER.
					if (strict) {
						parseError('character reference outside the permissible Unicode range');
					}
					return '\uFFFD';
				}
				if (has(decodeMapNumeric, codePoint)) {
					if (strict) {
						parseError('disallowed character reference');
					}
					return decodeMapNumeric[codePoint];
				}
				if (strict && contains(invalidReferenceCodePoints, codePoint)) {
					parseError('disallowed character reference');
				}
				if (codePoint > 0xFFFF) {
					codePoint -= 0x10000;
					output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
					codePoint = 0xDC00 | codePoint & 0x3FF;
				}
				output += stringFromCharCode(codePoint);
				return output;
			};

			var hexEscape = function(codePoint) {
				return '&#x' + codePoint.toString(16).toUpperCase() + ';';
			};

			var decEscape = function(codePoint) {
				return '&#' + codePoint + ';';
			};

			var parseError = function(message) {
				throw Error('Parse error: ' + message);
			};

			/*--------------------------------------------------------------------------*/

			var encode = function(string, options) {
				options = merge(options, encode.options);
				var strict = options.strict;
				if (strict && regexInvalidRawCodePoint.test(string)) {
					parseError('forbidden code point');
				}
				var encodeEverything = options.encodeEverything;
				var useNamedReferences = options.useNamedReferences;
				var allowUnsafeSymbols = options.allowUnsafeSymbols;
				var escapeCodePoint = options.decimal ? decEscape : hexEscape;

				var escapeBmpSymbol = function(symbol) {
					return escapeCodePoint(symbol.charCodeAt(0));
				};

				if (encodeEverything) {
					// Encode ASCII symbols.
					string = string.replace(regexAsciiWhitelist, function(symbol) {
						// Use named references if requested & possible.
						if (useNamedReferences && has(encodeMap, symbol)) {
							return '&' + encodeMap[symbol] + ';';
						}
						return escapeBmpSymbol(symbol);
					});
					// Shorten a few escapes that represent two symbols, of which at least one
					// is within the ASCII range.
					if (useNamedReferences) {
						string = string
							.replace(/&gt;\u20D2/g, '&nvgt;')
							.replace(/&lt;\u20D2/g, '&nvlt;')
							.replace(/&#x66;&#x6A;/g, '&fjlig;');
					}
					// Encode non-ASCII symbols.
					if (useNamedReferences) {
						// Encode non-ASCII symbols that can be replaced with a named reference.
						string = string.replace(regexEncodeNonAscii, function(string) {
							// Note: there is no need to check `has(encodeMap, string)` here.
							return '&' + encodeMap[string] + ';';
						});
					}
					// Note: any remaining non-ASCII symbols are handled outside of the `if`.
				} else if (useNamedReferences) {
					// Apply named character references.
					// Encode `<>"'&` using named character references.
					if (!allowUnsafeSymbols) {
						string = string.replace(regexEscape, function(string) {
							return '&' + encodeMap[string] + ';'; // no need to check `has()` here
						});
					}
					// Shorten escapes that represent two symbols, of which at least one is
					// `<>"'&`.
					string = string
						.replace(/&gt;\u20D2/g, '&nvgt;')
						.replace(/&lt;\u20D2/g, '&nvlt;');
					// Encode non-ASCII symbols that can be replaced with a named reference.
					string = string.replace(regexEncodeNonAscii, function(string) {
						// Note: there is no need to check `has(encodeMap, string)` here.
						return '&' + encodeMap[string] + ';';
					});
				} else if (!allowUnsafeSymbols) {
					// Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
					// using named character references.
					string = string.replace(regexEscape, escapeBmpSymbol);
				}
				return string
					// Encode astral symbols.
					.replace(regexAstralSymbols, function($0) {
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						var high = $0.charCodeAt(0);
						var low = $0.charCodeAt(1);
						var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
						return escapeCodePoint(codePoint);
					})
					// Encode any remaining BMP symbols that are not printable ASCII symbols
					// using a hexadecimal escape.
					.replace(regexBmpWhitelist, escapeBmpSymbol);
			};
			// Expose default options (so they can be overridden globally).
			encode.options = {
				'allowUnsafeSymbols': false,
				'encodeEverything': false,
				'strict': false,
				'useNamedReferences': false,
				'decimal' : false
			};

			var decode = function(html, options) {
				options = merge(options, decode.options);
				var strict = options.strict;
				if (strict && regexInvalidEntity.test(html)) {
					parseError('malformed character reference');
				}
				return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
					var codePoint;
					var semicolon;
					var decDigits;
					var hexDigits;
					var reference;
					var next;

					if ($1) {
						reference = $1;
						// Note: there is no need to check `has(decodeMap, reference)`.
						return decodeMap[reference];
					}

					if ($2) {
						// Decode named character references without trailing `;`, e.g. `&amp`.
						// This is only a parse error if it gets converted to `&`, or if it is
						// followed by `=` in an attribute context.
						reference = $2;
						next = $3;
						if (next && options.isAttributeValue) {
							if (strict && next == '=') {
								parseError('`&` did not start a character reference');
							}
							return $0;
						} else {
							if (strict) {
								parseError(
									'named character reference was not terminated by a semicolon'
								);
							}
							// Note: there is no need to check `has(decodeMapLegacy, reference)`.
							return decodeMapLegacy[reference] + (next || '');
						}
					}

					if ($4) {
						// Decode decimal escapes, e.g. `&#119558;`.
						decDigits = $4;
						semicolon = $5;
						if (strict && !semicolon) {
							parseError('character reference was not terminated by a semicolon');
						}
						codePoint = parseInt(decDigits, 10);
						return codePointToSymbol(codePoint, strict);
					}

					if ($6) {
						// Decode hexadecimal escapes, e.g. `&#x1D306;`.
						hexDigits = $6;
						semicolon = $7;
						if (strict && !semicolon) {
							parseError('character reference was not terminated by a semicolon');
						}
						codePoint = parseInt(hexDigits, 16);
						return codePointToSymbol(codePoint, strict);
					}

					// If were still here, `if ($7)` is implied; its an ambiguous
					// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					return $0;
				});
			};
			// Expose default options (so they can be overridden globally).
			decode.options = {
				'isAttributeValue': false,
				'strict': false
			};

			var escape = function(string) {
				return string.replace(regexEscape, function($0) {
					// Note: there is no need to check `has(escapeMap, $0)` here.
					return escapeMap[$0];
				});
			};

			/*--------------------------------------------------------------------------*/

			var he = {
				'version': '1.2.0',
				'encode': encode,
				'decode': decode,
				'escape': escape,
				'unescape': decode
			};

			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (freeExports && !freeExports.nodeType) {
				if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
					freeModule.exports = he;
				} else { // in Narwhal or RingoJS v0.7.0-
					for (var key in he) {
						has(he, key) && (freeExports[key] = he[key]);
					}
				}
			} else { // in Rhino or a web browser
				root.he = he;
			}

		}(he)); 
	} (he$1, he$1.exports));
	return he$1.exports;
}

var htmlparser = {};

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	function createMap(values, ignoreCase) {
	  var map = {};
	  values.forEach(function(value) {
	    map[value] = 1;
	  });
	  return ignoreCase ? function(value) {
	    return map[value.toLowerCase()] === 1;
	  } : function(value) {
	    return map[value] === 1;
	  };
	}

	utils.createMap = createMap;
	utils.createMapFromString = function(values, ignoreCase) {
	  return createMap(values.split(/,/), ignoreCase);
	};
	return utils;
}

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

var hasRequiredHtmlparser;

function requireHtmlparser () {
	if (hasRequiredHtmlparser) return htmlparser;
	hasRequiredHtmlparser = 1;

	var createMapFromString = requireUtils().createMapFromString;

	function makeMap(values) {
	  return createMapFromString(values, true);
	}

	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/,
	    singleAttrAssigns = [/=/],
	    singleAttrValues = [
	      // attr value double quotes
	      /"([^"]*)"+/.source,
	      // attr value, single quotes
	      /'([^']*)'+/.source,
	      // attr value, no quotes
	      /([^ \t\n\f\r"'`=<>]+)/.source
	    ],
	    // https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	    qnameCapture = (function() {
	      // based on https://www.npmjs.com/package/ncname
	      var combiningChar = '\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A';
	      var digit = '0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29';
	      var extender = '\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309E\\u30FC-\\u30FE';
	      var letter = 'A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3';
	      var ncname = '[' + letter + '_][' + letter + digit + '\\.\\-_' + combiningChar + extender + ']*';
	      return '((?:' + ncname + '\\:)?' + ncname + ')';
	    })(),
	    startTagOpen = new RegExp('^<' + qnameCapture),
	    startTagClose = /^\s*(\/?)>/,
	    endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>'),
	    doctype = /^<!DOCTYPE\s?[^>]+>/i;

	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function(m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});

	// Empty Elements
	var empty = makeMap('area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr');

	// Inline Elements
	var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var');

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var closeSelf = makeMap('colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source');

	// Attributes that have their values filled in disabled='disabled'
	var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');

	// Special Elements (can contain anything)
	var special = makeMap('script,style');

	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var nonPhrasing = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul');

	var reCache = {};

	function attrForHandler(handler) {
	  var pattern = singleAttrIdentifier.source +
	                '(?:\\s*(' + joinSingleAttrAssigns(handler) + ')' +
	                '[ \\t\\n\\f\\r]*(?:' + singleAttrValues.join('|') + '))?';
	  if (handler.customAttrSurround) {
	    var attrClauses = [];
	    for (var i = handler.customAttrSurround.length - 1; i >= 0; i--) {
	      attrClauses[i] = '(?:' +
	                       '(' + handler.customAttrSurround[i][0].source + ')\\s*' +
	                       pattern +
	                       '\\s*(' + handler.customAttrSurround[i][1].source + ')' +
	                       ')';
	    }
	    attrClauses.push('(?:' + pattern + ')');
	    pattern = '(?:' + attrClauses.join('|') + ')';
	  }
	  return new RegExp('^\\s*' + pattern);
	}

	function joinSingleAttrAssigns(handler) {
	  return singleAttrAssigns.concat(
	    handler.customAttrAssign || []
	  ).map(function(assign) {
	    return '(?:' + assign.source + ')';
	  }).join('|');
	}

	function HTMLParser(html, handler) {
	  var stack = [], lastTag;
	  var attribute = attrForHandler(handler);
	  var last, prevTag, nextTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a script or style element
	    if (!lastTag || !special(lastTag)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (/^<!--/.test(html)) {
	          var commentEnd = html.indexOf('-->');

	          if (commentEnd >= 0) {
	            if (handler.comment) {
	              handler.comment(html.substring(4, commentEnd));
	            }
	            html = html.substring(commentEnd + 3);
	            prevTag = '';
	            continue;
	          }
	        }

	        // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (/^<!\[/.test(html)) {
	          var conditionalEnd = html.indexOf(']>');

	          if (conditionalEnd >= 0) {
	            if (handler.comment) {
	              handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);
	            }
	            html = html.substring(conditionalEnd + 2);
	            prevTag = '';
	            continue;
	          }
	        }

	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          if (handler.doctype) {
	            handler.doctype(doctypeMatch[0]);
	          }
	          html = html.substring(doctypeMatch[0].length);
	          prevTag = '';
	          continue;
	        }

	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          html = html.substring(endTagMatch[0].length);
	          endTagMatch[0].replace(endTag, parseEndTag);
	          prevTag = '/' + endTagMatch[1].toLowerCase();
	          continue;
	        }

	        // Start tag:
	        var startTagMatch = parseStartTag(html);
	        if (startTagMatch) {
	          html = startTagMatch.rest;
	          handleStartTag(startTagMatch);
	          prevTag = startTagMatch.tagName.toLowerCase();
	          continue;
	        }

	        // Treat `<` as text
	        if (handler.continueOnParseError) {
	          textEnd = html.indexOf('<', 1);
	        }
	      }

	      var text;
	      if (textEnd >= 0) {
	        text = html.substring(0, textEnd);
	        html = html.substring(textEnd);
	      }
	      else {
	        text = html;
	        html = '';
	      }

	      // next tag
	      var nextTagMatch = parseStartTag(html);
	      if (nextTagMatch) {
	        nextTag = nextTagMatch.tagName;
	      }
	      else {
	        nextTagMatch = html.match(endTag);
	        if (nextTagMatch) {
	          nextTag = '/' + nextTagMatch[1];
	        }
	        else {
	          nextTag = '';
	        }
	      }

	      if (handler.chars) {
	        handler.chars(text, prevTag, nextTag);
	      }
	      prevTag = '';
	    }
	    else {
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)</' + stackedTag + '[^>]*>', 'i'));

	      html = html.replace(reStackedTag, function(all, text) {
	        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
	          text = text
	            .replace(/<!--([\s\S]*?)-->/g, '$1')
	            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }

	        if (handler.chars) {
	          handler.chars(text);
	        }

	        return '';
	      });

	      parseEndTag('</' + stackedTag + '>', stackedTag);
	    }

	    if (html === last) {
	      throw new Error('Parse Error: ' + html);
	    }
	  }

	  if (!handler.partialMarkup) {
	    // Clean up any remaining tags
	    parseEndTag();
	  }

	  function parseStartTag(input) {
	    var start = input.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: []
	      };
	      input = input.slice(start[0].length);
	      var end, attr;
	      while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {
	        input = input.slice(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        match.rest = input.slice(end[0].length);
	        return match;
	      }
	    }
	  }

	  function closeIfFound(tagName) {
	    if (findTag(tagName) >= 0) {
	      parseEndTag('', tagName);
	      return true;
	    }
	  }

	  function handleStartTag(match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;

	    if (handler.html5) {
	      if (lastTag === 'p' && nonPhrasing(tagName)) {
	        parseEndTag('', lastTag);
	      }
	      else if (tagName === 'tbody') {
	        closeIfFound('thead');
	      }
	      else if (tagName === 'tfoot') {
	        if (!closeIfFound('tbody')) {
	          closeIfFound('thead');
	        }
	      }
	      if (tagName === 'col' && findTag('colgroup') < 0) {
	        lastTag = 'colgroup';
	        stack.push({ tag: lastTag, attrs: [] });
	        if (handler.start) {
	          handler.start(lastTag, [], false, '');
	        }
	      }
	    }

	    if (!handler.html5 && !inline(tagName)) {
	      while (lastTag && inline(lastTag)) {
	        parseEndTag('', lastTag);
	      }
	    }

	    if (closeSelf(tagName) && lastTag === tagName) {
	      parseEndTag('', tagName);
	    }

	    var unary = empty(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

	    var attrs = match.attrs.map(function(args) {
	      var name, value, customOpen, customClose, customAssign, quote;
	      var ncp = 7; // number of captured parts, scalar

	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') { delete args[3]; }
	        if (args[4] === '') { delete args[4]; }
	        if (args[5] === '') { delete args[5]; }
	      }

	      function populate(index) {
	        customAssign = args[index];
	        value = args[index + 1];
	        if (typeof value !== 'undefined') {
	          return '"';
	        }
	        value = args[index + 2];
	        if (typeof value !== 'undefined') {
	          return '\'';
	        }
	        value = args[index + 3];
	        if (typeof value === 'undefined' && fillAttrs(name)) {
	          value = name;
	        }
	        return '';
	      }

	      var j = 1;
	      if (handler.customAttrSurround) {
	        for (var i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {
	          name = args[j + 1];
	          if (name) {
	            quote = populate(j + 2);
	            customOpen = args[j];
	            customClose = args[j + 6];
	            break;
	          }
	        }
	      }

	      if (!name && (name = args[j])) {
	        quote = populate(j + 1);
	      }

	      return {
	        name: name,
	        value: value,
	        customAssign: customAssign || '=',
	        customOpen: customOpen || '',
	        customClose: customClose || '',
	        quote: quote || ''
	      };
	    });

	    if (!unary) {
	      stack.push({ tag: tagName, attrs: attrs });
	      lastTag = tagName;
	      unarySlash = '';
	    }

	    if (handler.start) {
	      handler.start(tagName, attrs, unary, unarySlash);
	    }
	  }

	  function findTag(tagName) {
	    var pos;
	    var needle = tagName.toLowerCase();
	    for (pos = stack.length - 1; pos >= 0; pos--) {
	      if (stack[pos].tag.toLowerCase() === needle) {
	        break;
	      }
	    }
	    return pos;
	  }

	  function parseEndTag(tag, tagName) {
	    var pos;

	    // Find the closest opened tag of the same type
	    if (tagName) {
	      pos = findTag(tagName);
	    }
	    // If no tag name is provided, clean shop
	    else {
	      pos = 0;
	    }

	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (handler.end) {
	          handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
	        }
	      }

	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    }
	    else if (tagName.toLowerCase() === 'br') {
	      if (handler.start) {
	        handler.start(tagName, [], true, '');
	      }
	    }
	    else if (tagName.toLowerCase() === 'p') {
	      if (handler.start) {
	        handler.start(tagName, [], false, '', true);
	      }
	      if (handler.end) {
	        handler.end(tagName, []);
	      }
	    }
	  }
	}

	htmlparser.HTMLParser = HTMLParser;
	htmlparser.HTMLtoXML = function(html) {
	  var results = '';

	  new HTMLParser(html, {
	    start: function(tag, attrs, unary) {
	      results += '<' + tag;

	      for (var i = 0, len = attrs.length; i < len; i++) {
	        results += ' ' + attrs[i].name + '="' + (attrs[i].value || '').replace(/"/g, '&#34;') + '"';
	      }

	      results += (unary ? '/' : '') + '>';
	    },
	    end: function(tag) {
	      results += '</' + tag + '>';
	    },
	    chars: function(text) {
	      results += text;
	    },
	    comment: function(text) {
	      results += '<!--' + text + '-->';
	    },
	    ignore: function(text) {
	      results += text;
	    }
	  });

	  return results;
	};

	htmlparser.HTMLtoDOM = function(html, doc) {
	  // There can be only one of these elements
	  var one = {
	    html: true,
	    head: true,
	    body: true,
	    title: true
	  };

	  // Enforce a structure for the document
	  var structure = {
	    link: 'head',
	    base: 'head'
	  };

	  if (doc) {
	    doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;
	  }
	  else if (typeof DOMDocument !== 'undefined') {
	    doc = new DOMDocument();
	  }
	  else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {
	    doc = document.implementation.createDocument('', '', null);
	  }
	  else if (typeof ActiveX !== 'undefined') {
	    doc = new ActiveXObject('Msxml.DOMDocument');
	  }

	  var elems = [],
	      documentElement = doc.documentElement ||
	        doc.getDocumentElement && doc.getDocumentElement();

	  // If we're dealing with an empty document then we
	  // need to pre-populate it with the HTML document structure
	  if (!documentElement && doc.createElement) {
	    (function() {
	      var html = doc.createElement('html');
	      var head = doc.createElement('head');
	      head.appendChild(doc.createElement('title'));
	      html.appendChild(head);
	      html.appendChild(doc.createElement('body'));
	      doc.appendChild(html);
	    })();
	  }

	  // Find all the unique elements
	  if (doc.getElementsByTagName) {
	    for (var i in one) {
	      one[i] = doc.getElementsByTagName(i)[0];
	    }
	  }

	  // If we're working with a document, inject contents into
	  // the body element
	  var curParentNode = one.body;

	  new HTMLParser(html, {
	    start: function(tagName, attrs, unary) {
	      // If it's a pre-built element, then we can ignore
	      // its construction
	      if (one[tagName]) {
	        curParentNode = one[tagName];
	        return;
	      }

	      var elem = doc.createElement(tagName);

	      for (var attr in attrs) {
	        elem.setAttribute(attrs[attr].name, attrs[attr].value);
	      }

	      if (structure[tagName] && typeof one[structure[tagName]] !== 'boolean') {
	        one[structure[tagName]].appendChild(elem);
	      }
	      else if (curParentNode && curParentNode.appendChild) {
	        curParentNode.appendChild(elem);
	      }

	      if (!unary) {
	        elems.push(elem);
	        curParentNode = elem;
	      }
	    },
	    end: function(/* tag */) {
	      elems.length -= 1;

	      // Init the new parentNode
	      curParentNode = elems[elems.length - 1];
	    },
	    chars: function(text) {
	      curParentNode.appendChild(doc.createTextNode(text));
	    },
	    comment: function(/* text */) {
	      // create comment node
	    },
	    ignore: function(/* text */) {
	      // What to do here?
	    }
	  });

	  return doc;
	};
	return htmlparser;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants =
	{
		// Output
		ABSOLUTE:      "absolute",
		PATH_RELATIVE: "pathRelative",
		ROOT_RELATIVE: "rootRelative",
		SHORTEST:      "shortest"
	};
	return constants;
}

var format;
var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format;
	hasRequiredFormat = 1;

	var constants = requireConstants();



	function formatAuth(urlObj, options)
	{
		if (urlObj.auth && !options.removeAuth && (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE))
		{
			return urlObj.auth + "@";
		}
		
		return "";
	}



	function formatHash(urlObj, options)
	{
		return urlObj.hash ? urlObj.hash : "";
	}



	function formatHost(urlObj, options)
	{
		if (urlObj.host.full && (urlObj.extra.relation.maximumAuth || options.output===constants.ABSOLUTE))
		{
			return urlObj.host.full;
		}
		
		return "";
	}



	function formatPath(urlObj, options)
	{
		var str = "";
		
		var absolutePath = urlObj.path.absolute.string;
		var relativePath = urlObj.path.relative.string;
		var resource = showResource(urlObj, options);
		
		if (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE || options.output===constants.ROOT_RELATIVE)
		{
			str = absolutePath;
		}
		else if (relativePath.length<=absolutePath.length && options.output===constants.SHORTEST || options.output===constants.PATH_RELATIVE)
		{
			str = relativePath;
			
			if (str === "")
			{
				var query = showQuery(urlObj,options) && !!getQuery(urlObj,options);
				
				if (urlObj.extra.relation.maximumPath && !resource)
				{
					str = "./";
				}
				else if (urlObj.extra.relation.overridesQuery && !resource && !query)
				{
					str = "./";
				}
			}
		}
		else
		{
			str = absolutePath;
		}
		
		if ( str==="/" && !resource && options.removeRootTrailingSlash && (!urlObj.extra.relation.minimumPort || options.output===constants.ABSOLUTE) )
		{
			str = "";
		}
		
		return str;
	}



	function formatPort(urlObj, options)
	{
		if (urlObj.port && !urlObj.extra.portIsDefault && urlObj.extra.relation.maximumHost)
		{
			return ":" + urlObj.port;
		}
		
		return "";
	}



	function formatQuery(urlObj, options)
	{
		return showQuery(urlObj,options) ? getQuery(urlObj, options) : "";
	}



	function formatResource(urlObj, options)
	{
		return showResource(urlObj,options) ? urlObj.resource : "";
	}



	function formatScheme(urlObj, options)
	{
		var str = "";
		
		if (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE)
		{
			if (!urlObj.extra.relation.minimumScheme || !options.schemeRelative || options.output===constants.ABSOLUTE)
			{
				str += urlObj.scheme + "://";
			}
			else
			{
				str += "//";
			}
		}
		
		return str;
	}



	function formatUrl(urlObj, options)
	{
		var url = "";
		
		url += formatScheme(urlObj, options);
		url += formatAuth(urlObj, options);
		url += formatHost(urlObj, options);
		url += formatPort(urlObj);
		url += formatPath(urlObj, options);
		url += formatResource(urlObj, options);
		url += formatQuery(urlObj, options);
		url += formatHash(urlObj);
		
		return url;
	}



	function getQuery(urlObj, options)
	{
		var stripQuery = options.removeEmptyQueries && urlObj.extra.relation.minimumPort;
		
		return urlObj.query.string[ stripQuery ? "stripped" : "full" ];
	}



	function showQuery(urlObj, options)
	{
		return !urlObj.extra.relation.minimumQuery || options.output===constants.ABSOLUTE || options.output===constants.ROOT_RELATIVE;
	}



	function showResource(urlObj, options)
	{
		var removeIndex = options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex;
		var removeMatchingResource = urlObj.extra.relation.minimumResource && options.output!==constants.ABSOLUTE && options.output!==constants.ROOT_RELATIVE;
		
		return !!urlObj.resource && !removeMatchingResource && !removeIndex;
	}



	format = formatUrl;
	return format;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;

	/*
		Deep-clone an object.
	*/
	function clone(obj)
	{
		if (obj instanceof Object)
		{
			var clonedObj = (obj instanceof Array) ? [] : {};
			
			for (var i in obj)
			{
				if ( obj.hasOwnProperty(i) )
				{
					clonedObj[i] = clone( obj[i] );
				}
			}
			
			return clonedObj;
		}
		
		return obj;
	}



	/*
		https://github.com/jonschlinkert/is-plain-object
	*/
	function isPlainObject(obj)
	{
		return !!obj && typeof obj==="object" && obj.constructor===Object;
	}



	/*
		Shallow-merge two objects.
	*/
	function shallowMerge(target, source)
	{
		if (target instanceof Object && source instanceof Object)
		{
			for (var i in source)
			{
				if ( source.hasOwnProperty(i) )
				{
					target[i] = source[i];
				}
			}
		}
		
		return target;
	}



	object =
	{
		clone: clone,
		isPlainObject: isPlainObject,
		shallowMerge: shallowMerge
	};
	return object;
}

var options;
var hasRequiredOptions;

function requireOptions () {
	if (hasRequiredOptions) return options;
	hasRequiredOptions = 1;

	var objUtils = requireObject();



	function getOptions(options, defaults)
	{
		if ( objUtils.isPlainObject(options) )
		{
			var newOptions = {};
			
			for (var i in defaults)
			{
				if ( defaults.hasOwnProperty(i) )
				{
					if (options[i] !== undefined)
					{
						newOptions[i] = mergeOption(options[i], defaults[i]);
					}
					else
					{
						newOptions[i] = defaults[i];
					}
				}
			}
			
			return newOptions;
		}
		else
		{
			return defaults;
		}
	}



	function mergeOption(newValues, defaultValues)
	{
		if (defaultValues instanceof Object && newValues instanceof Object)
		{
			if (defaultValues instanceof Array && newValues instanceof Array)
			{
				return defaultValues.concat(newValues);
			}
			else
			{
				return objUtils.shallowMerge(newValues, defaultValues);
			}
		}
		
		return newValues;
	}



	options = getOptions;
	return options;
}

var hrefInfo_1;
var hasRequiredHrefInfo;

function requireHrefInfo () {
	if (hasRequiredHrefInfo) return hrefInfo_1;
	hasRequiredHrefInfo = 1;

	function hrefInfo(urlObj)
	{
		var minimumPathOnly     = (!urlObj.scheme && !urlObj.auth && !urlObj.host.full && !urlObj.port);
		var minimumResourceOnly = (minimumPathOnly && !urlObj.path.absolute.string);
		var minimumQueryOnly    = (minimumResourceOnly && !urlObj.resource);
		var minimumHashOnly     = (minimumQueryOnly && !urlObj.query.string.full.length);
		var empty               = (minimumHashOnly && !urlObj.hash);
		
		urlObj.extra.hrefInfo.minimumPathOnly     = minimumPathOnly;
		urlObj.extra.hrefInfo.minimumResourceOnly = minimumResourceOnly;
		urlObj.extra.hrefInfo.minimumQueryOnly    = minimumQueryOnly;
		urlObj.extra.hrefInfo.minimumHashOnly     = minimumHashOnly;
		urlObj.extra.hrefInfo.empty = empty;
	}



	hrefInfo_1 = hrefInfo;
	return hrefInfo_1;
}

var host;
var hasRequiredHost;

function requireHost () {
	if (hasRequiredHost) return host;
	hasRequiredHost = 1;

	function parseHost(urlObj, options)
	{
		// TWEAK :: condition only for speed optimization
		if (options.ignore_www)
		{
			var host = urlObj.host.full;
			
			if (host)
			{
				var stripped = host;
				
				if (host.indexOf("www.") === 0)
				{
					stripped = host.substr(4);
				}
				
				urlObj.host.stripped = stripped;
			}
		}
	}



	host = parseHost;
	return host;
}

var path$1;
var hasRequiredPath$1;

function requirePath$1 () {
	if (hasRequiredPath$1) return path$1;
	hasRequiredPath$1 = 1;

	function isDirectoryIndex(resource, options)
	{
		var verdict = false;
		
		options.directoryIndexes.every( function(index)
		{
			if (index === resource)
			{
				verdict = true;
				return false;
			}
			
			return true;
		});
		
		return verdict;
	}



	function parsePath(urlObj, options)
	{
		var path = urlObj.path.absolute.string;
		
		if (path)
		{
			var lastSlash = path.lastIndexOf("/");
			
			if (lastSlash > -1)
			{
				if (++lastSlash < path.length)
				{
					var resource = path.substr(lastSlash);
					
					if (resource!=="." && resource!=="..")
					{
						urlObj.resource = resource;
						path = path.substr(0, lastSlash);
					}
					else
					{
						path += "/";
					}
				}
				
				urlObj.path.absolute.string = path;
				urlObj.path.absolute.array = splitPath(path);
			}
			else if (path==="." || path==="..")
			{
				// "..?var", "..#anchor", etc ... not "..index.html"
				path += "/";
				
				urlObj.path.absolute.string = path;
				urlObj.path.absolute.array = splitPath(path);
			}
			else
			{
				// Resource-only
				urlObj.resource = path;
				urlObj.path.absolute.string = null;
			}
			
			urlObj.extra.resourceIsIndex = isDirectoryIndex(urlObj.resource, options);
		}
		// Else: query/hash-only or empty
	}



	function splitPath(path)
	{
		// TWEAK :: condition only for speed optimization
		if (path !== "/")
		{
			var cleaned = [];
			
			path.split("/").forEach( function(dir)
			{
				// Cleanup -- splitting "/dir/" becomes ["","dir",""]
				if (dir !== "")
				{
					cleaned.push(dir);
				}
			});
			
			return cleaned;
		}
		else
		{
			// Faster to skip the above block and just create an array
			return [];
		}
	}



	path$1 = parsePath;
	return path$1;
}

var port;
var hasRequiredPort;

function requirePort () {
	if (hasRequiredPort) return port;
	hasRequiredPort = 1;

	function parsePort(urlObj, options)
	{
		var defaultPort = -1;
		
		for (var i in options.defaultPorts)
		{
			if ( i===urlObj.scheme && options.defaultPorts.hasOwnProperty(i) )
			{
				defaultPort = options.defaultPorts[i];
				break;
			}
		}
		
		if (defaultPort > -1)
		{
			// Force same type as urlObj.port
			defaultPort = defaultPort.toString();
			
			if (urlObj.port === null)
			{
				urlObj.port = defaultPort;
			}
			
			urlObj.extra.portIsDefault = (urlObj.port === defaultPort);
		}
	}



	port = parsePort;
	return port;
}

var query;
var hasRequiredQuery;

function requireQuery () {
	if (hasRequiredQuery) return query;
	hasRequiredQuery = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;



	function parseQuery(urlObj, options)
	{
		urlObj.query.string.full = stringify(urlObj.query.object, false);
		
		// TWEAK :: condition only for speed optimization
		if (options.removeEmptyQueries)
		{
			urlObj.query.string.stripped = stringify(urlObj.query.object, true);
		}
	}



	function stringify(queryObj, removeEmptyQueries)
	{
		var count = 0;
		var str = "";
		
		for (var i in queryObj)
		{
			if ( i!=="" && hasOwnProperty.call(queryObj, i)===true )
			{
				var value = queryObj[i];
				
				if (value !== "" || !removeEmptyQueries)
				{
					str += (++count===1) ? "?" : "&";
					
					i = encodeURIComponent(i);
					
					if (value !== "")
					{
						str += i +"="+ encodeURIComponent(value).replace(/%20/g,"+");
					}
					else
					{
						str += i;
					}
				}
			}
		}
		
		return str;
	}



	query = parseQuery;
	return query;
}

var urlstring;
var hasRequiredUrlstring;

function requireUrlstring () {
	if (hasRequiredUrlstring) return urlstring;
	hasRequiredUrlstring = 1;

	var _parseUrl = require$$1$1.parse;



	/*
		Customize the URL object that Node generates
		because:
		
		* necessary data for later
		* urlObj.host is useless
		* urlObj.hostname is too long
		* urlObj.path is useless
		* urlObj.pathname is too long
		* urlObj.protocol is inaccurate; should be called "scheme"
		* urlObj.search is mostly useless
	*/
	function clean(urlObj)
	{
		var scheme = urlObj.protocol;
		
		if (scheme)
		{
			// Remove ":" suffix
			if (scheme.indexOf(":") === scheme.length-1)
			{
				scheme = scheme.substr(0, scheme.length-1);
			}
		}
		
		urlObj.host =
		{
			// TODO :: unescape(encodeURIComponent(s)) ? ... http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html
			full: urlObj.hostname,
			stripped: null
		};
		
		urlObj.path =
		{
			absolute:
			{
				array: null,
				string: urlObj.pathname
			},
			relative:
			{
				array: null,
				string: null
			}
		};
		
		urlObj.query =
		{
			object: urlObj.query,
			string:
			{
				full: null,
				stripped: null
			}
		};
		
		urlObj.extra =
		{
			hrefInfo:
			{
				minimumPathOnly: null,
				minimumResourceOnly: null,
				minimumQueryOnly: null,
				minimumHashOnly: null,
				empty: null,
				
				separatorOnlyQuery: urlObj.search==="?"
			},
			portIsDefault: null,
			relation:
			{
				maximumScheme: null,
				maximumAuth: null,
				maximumHost: null,
				maximumPort: null,
				maximumPath: null,
				maximumResource: null,
				maximumQuery: null,
				maximumHash: null,
				
				minimumScheme: null,
				minimumAuth: null,
				minimumHost: null,
				minimumPort: null,
				minimumPath: null,
				minimumResource: null,
				minimumQuery: null,
				minimumHash: null,
				
				overridesQuery: null
			},
			resourceIsIndex: null,
			slashes: urlObj.slashes
		};
		
		urlObj.resource = null;
		urlObj.scheme = scheme;
		delete urlObj.hostname;
		delete urlObj.pathname;
		delete urlObj.protocol;
		delete urlObj.search;
		delete urlObj.slashes;
		
		return urlObj;
	}



	function validScheme(url, options)
	{
		var valid = true;
		
		options.rejectedSchemes.every( function(rejectedScheme)
		{
			valid = !(url.indexOf(rejectedScheme+":") === 0);
			
			// Break loop
			return valid;
		});
		
		return valid;
	}



	function parseUrlString(url, options)
	{
		if ( validScheme(url,options) )
		{
			return clean( _parseUrl(url, true, options.slashesDenoteHost) );
		}
		else
		{
			return {href:url, valid:false};
		}
	}



	urlstring = parseUrlString;
	return urlstring;
}

var path;
var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;

	function joinPath(pathArray)
	{
		if (pathArray.length > 0)
		{
			return pathArray.join("/") + "/";
		}
		else
		{
			return "";
		}
	}



	function resolveDotSegments(pathArray)
	{
		var pathAbsolute = [];
		
		pathArray.forEach( function(dir)
		{
			if (dir !== "..")
			{
				if (dir !== ".")
				{
					pathAbsolute.push(dir);
				}
			}
			else
			{
				// Remove parent
				if (pathAbsolute.length > 0)
				{
					pathAbsolute.splice(pathAbsolute.length-1, 1);
				}
			}
		});
		
		return pathAbsolute;
	}



	path =
	{
		join: joinPath,
		resolveDotSegments: resolveDotSegments
	};
	return path;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var hrefInfo   = requireHrefInfo();
	var parseHost  = requireHost();
	var parsePath  = requirePath$1();
	var parsePort  = requirePort();
	var parseQuery = requireQuery();
	var parseUrlString = requireUrlstring();
	var pathUtils      = requirePath();



	function parseFromUrl(url, options, fallback)
	{
		if (url)
		{
			var urlObj = parseUrl(url, options);
			
			// Because the following occurs in the relate stage for "to" URLs,
			// such had to be mostly duplicated here
			
			var pathArray = pathUtils.resolveDotSegments(urlObj.path.absolute.array);
			
			urlObj.path.absolute.array  = pathArray;
			urlObj.path.absolute.string = "/" + pathUtils.join(pathArray);
			
			return urlObj;
		}
		else
		{
			return fallback;
		}
	}



	function parseUrl(url, options)
	{
		var urlObj = parseUrlString(url, options);
		
		if (urlObj.valid===false) return urlObj;
		
		parseHost(urlObj, options);
		parsePort(urlObj, options);
		parsePath(urlObj, options);
		parseQuery(urlObj, options);
		hrefInfo(urlObj);
		
		return urlObj;
	}



	parse =
	{
		from: parseFromUrl,
		to:   parseUrl
	};
	return parse;
}

var findRelation;
var hasRequiredFindRelation;

function requireFindRelation () {
	if (hasRequiredFindRelation) return findRelation;
	hasRequiredFindRelation = 1;

	function findRelation_upToPath(urlObj, siteUrlObj, options)
	{
		// Path- or root-relative URL
		var pathOnly = urlObj.extra.hrefInfo.minimumPathOnly;
		
		// Matching scheme, scheme-relative or path-only
		var minimumScheme = (urlObj.scheme===siteUrlObj.scheme || !urlObj.scheme);
		
		// Matching auth, ignoring auth or path-only
		var minimumAuth = minimumScheme && (urlObj.auth===siteUrlObj.auth || options.removeAuth || pathOnly);
		
		// Matching host or path-only
		var www = options.ignore_www ? "stripped" : "full";
		var minimumHost = minimumAuth && (urlObj.host[www]===siteUrlObj.host[www] || pathOnly);
		
		// Matching port or path-only
		var minimumPort = minimumHost && (urlObj.port===siteUrlObj.port || pathOnly);
		
		urlObj.extra.relation.minimumScheme = minimumScheme;
		urlObj.extra.relation.minimumAuth   = minimumAuth;
		urlObj.extra.relation.minimumHost   = minimumHost;
		urlObj.extra.relation.minimumPort   = minimumPort;
		
		urlObj.extra.relation.maximumScheme = !minimumScheme || minimumScheme && !minimumAuth;
		urlObj.extra.relation.maximumAuth   = !minimumScheme || minimumScheme && !minimumHost;
		urlObj.extra.relation.maximumHost   = !minimumScheme || minimumScheme && !minimumPort;
	}



	function findRelation_pathOn(urlObj, siteUrlObj, options)
	{
		var queryOnly = urlObj.extra.hrefInfo.minimumQueryOnly;
		var hashOnly  = urlObj.extra.hrefInfo.minimumHashOnly;
		var empty     = urlObj.extra.hrefInfo.empty;	// not required, but self-documenting
		
		// From upToPath()
		var minimumPort   = urlObj.extra.relation.minimumPort;
		var minimumScheme = urlObj.extra.relation.minimumScheme;
		
		// Matching port and path
		var minimumPath = minimumPort && urlObj.path.absolute.string===siteUrlObj.path.absolute.string;
		
		// Matching resource or query/hash-only or empty
		var matchingResource = (urlObj.resource===siteUrlObj.resource || !urlObj.resource && siteUrlObj.extra.resourceIsIndex) || (options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex && !siteUrlObj.resource);
		var minimumResource = minimumPath && (matchingResource || queryOnly || hashOnly || empty);
		
		// Matching query or hash-only/empty
		var query = options.removeEmptyQueries ? "stripped" : "full";
		var urlQuery = urlObj.query.string[query];
		var siteUrlQuery = siteUrlObj.query.string[query];
		var minimumQuery = (minimumResource && !!urlQuery && urlQuery===siteUrlQuery) || ((hashOnly || empty) && !urlObj.extra.hrefInfo.separatorOnlyQuery);
		
		var minimumHash = minimumQuery && urlObj.hash===siteUrlObj.hash;
		
		urlObj.extra.relation.minimumPath     = minimumPath;
		urlObj.extra.relation.minimumResource = minimumResource;
		urlObj.extra.relation.minimumQuery    = minimumQuery;
		urlObj.extra.relation.minimumHash     = minimumHash;
		
		urlObj.extra.relation.maximumPort     = !minimumScheme || minimumScheme && !minimumPath;
		urlObj.extra.relation.maximumPath     = !minimumScheme || minimumScheme && !minimumResource;
		urlObj.extra.relation.maximumResource = !minimumScheme || minimumScheme && !minimumQuery;
		urlObj.extra.relation.maximumQuery    = !minimumScheme || minimumScheme && !minimumHash;
		urlObj.extra.relation.maximumHash     = !minimumScheme || minimumScheme && !minimumHash;	// there's nothing after hash, so it's the same as maximumQuery
		
		// Matching path and/or resource with existing but non-matching site query
		urlObj.extra.relation.overridesQuery  = minimumPath && urlObj.extra.relation.maximumResource && !minimumQuery && !!siteUrlQuery;
	}



	findRelation =
	{
		pathOn:   findRelation_pathOn,
		upToPath: findRelation_upToPath
	};
	return findRelation;
}

var absolutize_1;
var hasRequiredAbsolutize;

function requireAbsolutize () {
	if (hasRequiredAbsolutize) return absolutize_1;
	hasRequiredAbsolutize = 1;

	var findRelation = requireFindRelation();
	var objUtils     = requireObject();
	var pathUtils    = requirePath();



	function absolutize(urlObj, siteUrlObj, options)
	{
		findRelation.upToPath(urlObj, siteUrlObj, options);
		
		// Fill in relative URLs
		if (urlObj.extra.relation.minimumScheme) urlObj.scheme = siteUrlObj.scheme;
		if (urlObj.extra.relation.minimumAuth)   urlObj.auth   = siteUrlObj.auth;
		if (urlObj.extra.relation.minimumHost)   urlObj.host   = objUtils.clone(siteUrlObj.host);
		if (urlObj.extra.relation.minimumPort)   copyPort(urlObj, siteUrlObj);
		if (urlObj.extra.relation.minimumScheme) copyPath(urlObj, siteUrlObj);
		
		// Check remaining relativeness now that path has been copied and/or resolved
		findRelation.pathOn(urlObj, siteUrlObj, options);
		
		// Fill in relative URLs
		if (urlObj.extra.relation.minimumResource) copyResource(urlObj, siteUrlObj);
		if (urlObj.extra.relation.minimumQuery)    urlObj.query = objUtils.clone(siteUrlObj.query);
		if (urlObj.extra.relation.minimumHash)     urlObj.hash  = siteUrlObj.hash;
	}



	/*
		Get an absolute path that's relative to site url.
	*/
	function copyPath(urlObj, siteUrlObj)
	{
		if (urlObj.extra.relation.maximumHost || !urlObj.extra.hrefInfo.minimumResourceOnly)
		{
			var pathArray = urlObj.path.absolute.array;
			var pathString = "/";
			
			// If not erroneous URL
			if (pathArray)
			{
				// If is relative path
				if (urlObj.extra.hrefInfo.minimumPathOnly && urlObj.path.absolute.string.indexOf("/")!==0)
				{
					// Append path to site path
					pathArray = siteUrlObj.path.absolute.array.concat(pathArray);
				}
				
				pathArray   = pathUtils.resolveDotSegments(pathArray);
				pathString += pathUtils.join(pathArray);
			}
			else
			{
				pathArray = [];
			}
			
			urlObj.path.absolute.array  = pathArray;
			urlObj.path.absolute.string = pathString;
		}
		else
		{
			// Resource-, query- or hash-only or empty
			urlObj.path = objUtils.clone(siteUrlObj.path);
		}
	}



	function copyPort(urlObj, siteUrlObj)
	{
		urlObj.port = siteUrlObj.port;
		
		urlObj.extra.portIsDefault = siteUrlObj.extra.portIsDefault;
	}



	function copyResource(urlObj, siteUrlObj)
	{
		urlObj.resource = siteUrlObj.resource;
		
		urlObj.extra.resourceIsIndex = siteUrlObj.extra.resourceIsIndex;
	}



	absolutize_1 = absolutize;
	return absolutize_1;
}

var relativize_1;
var hasRequiredRelativize;

function requireRelativize () {
	if (hasRequiredRelativize) return relativize_1;
	hasRequiredRelativize = 1;

	var pathUtils = requirePath();



	/*
		Get a path relative to the site path.
	*/
	function relatePath(absolutePath, siteAbsolutePath)
	{
		var relativePath = [];
		
		// At this point, it's related to the host/port
		var related = true;
		var parentIndex = -1;
		
		// Find parents
		siteAbsolutePath.forEach( function(siteAbsoluteDir, i)
		{
			if (related)
			{
				if (absolutePath[i] !== siteAbsoluteDir)
				{
					related = false;
				}
				else
				{
					parentIndex = i;
				}
			}
			
			if (!related)
			{
				// Up one level
				relativePath.push("..");
			}
		});
		
		// Form path
		absolutePath.forEach( function(dir, i)
		{
			if (i > parentIndex)
			{
				relativePath.push(dir);
			}
		});
		
		return relativePath;
	}



	function relativize(urlObj, siteUrlObj, options)
	{
		if (urlObj.extra.relation.minimumScheme)
		{
			var pathArray = relatePath(urlObj.path.absolute.array, siteUrlObj.path.absolute.array);
			
			urlObj.path.relative.array  = pathArray;
			urlObj.path.relative.string = pathUtils.join(pathArray);
		}
	}



	relativize_1 = relativize;
	return relativize_1;
}

var relate;
var hasRequiredRelate;

function requireRelate () {
	if (hasRequiredRelate) return relate;
	hasRequiredRelate = 1;

	var absolutize = requireAbsolutize();
	var relativize = requireRelativize();



	function relateUrl(siteUrlObj, urlObj, options)
	{
		absolutize(urlObj, siteUrlObj, options);
		relativize(urlObj, siteUrlObj, options);
		
		return urlObj;
	}



	relate = relateUrl;
	return relate;
}

var lib$t;
var hasRequiredLib$v;

function requireLib$v () {
	if (hasRequiredLib$v) return lib$t;
	hasRequiredLib$v = 1;

	var constants  = requireConstants();
	var formatUrl  = requireFormat();
	var getOptions = requireOptions();
	var objUtils   = requireObject();
	var parseUrl   = requireParse();
	var relateUrl  = requireRelate();



	function RelateUrl(from, options)
	{
		this.options = getOptions(options,
		{
			defaultPorts: {ftp:21, http:80, https:443},
			directoryIndexes: ["index.html"],
			ignore_www: false,
			output: RelateUrl.SHORTEST,
			rejectedSchemes: ["data","javascript","mailto"],
			removeAuth: false,
			removeDirectoryIndexes: true,
			removeEmptyQueries: false,
			removeRootTrailingSlash: true,
			schemeRelative: true,
			site: undefined,
			slashesDenoteHost: true
		});
		
		this.from = parseUrl.from(from, this.options, null);
	}



	/*
		Usage: instance=new RelateUrl(); instance.relate();
	*/
	RelateUrl.prototype.relate = function(from, to, options)
	{
		// relate(to,options)
		if ( objUtils.isPlainObject(to) )
		{
			options = to;
			to = from;
			from = null;
		}
		// relate(to)
		else if (!to)
		{
			to = from;
			from = null;
		}
		
		options = getOptions(options, this.options);
		from = from || options.site;
		from = parseUrl.from(from, options, this.from);
		
		if (!from || !from.href)
		{
			throw new Error("from value not defined.");
		}
		else if (from.extra.hrefInfo.minimumPathOnly)
		{
			throw new Error("from value supplied is not absolute: "+from.href);
		}
		
		to = parseUrl.to(to, options);
		
		if (to.valid===false) return to.href;
		
		to = relateUrl(from, to, options);
		to = formatUrl(to, options);
		
		return to;
	};



	/*
		Usage: RelateUrl.relate();
	*/
	RelateUrl.relate = function(from, to, options)
	{
		return new RelateUrl().relate(from, to, options);
	};



	// Make constants accessible from API
	objUtils.shallowMerge(RelateUrl, constants);



	lib$t = RelateUrl;
	return lib$t;
}

var tokenchain;
var hasRequiredTokenchain;

function requireTokenchain () {
	if (hasRequiredTokenchain) return tokenchain;
	hasRequiredTokenchain = 1;

	function Sorter() {
	}

	Sorter.prototype.sort = function(tokens, fromIndex) {
	  fromIndex = fromIndex || 0;
	  for (var i = 0, len = this.keys.length; i < len; i++) {
	    var key = this.keys[i];
	    var token = key.slice(1);
	    var index = tokens.indexOf(token, fromIndex);
	    if (index !== -1) {
	      do {
	        if (index !== fromIndex) {
	          tokens.splice(index, 1);
	          tokens.splice(fromIndex, 0, token);
	        }
	        fromIndex++;
	      } while ((index = tokens.indexOf(token, fromIndex)) !== -1);
	      return this[key].sort(tokens, fromIndex);
	    }
	  }
	  return tokens;
	};

	function TokenChain() {
	}

	TokenChain.prototype = {
	  add: function(tokens) {
	    var self = this;
	    tokens.forEach(function(token) {
	      var key = '$' + token;
	      if (!self[key]) {
	        self[key] = [];
	        self[key].processed = 0;
	      }
	      self[key].push(tokens);
	    });
	  },
	  createSorter: function() {
	    var self = this;
	    var sorter = new Sorter();
	    sorter.keys = Object.keys(self).sort(function(j, k) {
	      var m = self[j].length;
	      var n = self[k].length;
	      return m < n ? 1 : m > n ? -1 : j < k ? -1 : j > k ? 1 : 0;
	    }).filter(function(key) {
	      if (self[key].processed < self[key].length) {
	        var token = key.slice(1);
	        var chain = new TokenChain();
	        self[key].forEach(function(tokens) {
	          var index;
	          while ((index = tokens.indexOf(token)) !== -1) {
	            tokens.splice(index, 1);
	          }
	          tokens.forEach(function(token) {
	            self['$' + token].processed++;
	          });
	          chain.add(tokens.slice(0));
	        });
	        sorter[key] = chain.createSorter();
	        return true;
	      }
	      return false;
	    });
	    return sorter;
	  }
	};

	tokenchain = TokenChain;
	return tokenchain;
}

var node = {};

const require$$1 = /* #__PURE__ */ JSON.parse("[\"$&\",\"$'\",\"$*\",\"$+\",\"$1\",\"$2\",\"$3\",\"$4\",\"$5\",\"$6\",\"$7\",\"$8\",\"$9\",\"$_\",\"$`\",\"$input\",\"-moz-animation\",\"-moz-animation-delay\",\"-moz-animation-direction\",\"-moz-animation-duration\",\"-moz-animation-fill-mode\",\"-moz-animation-iteration-count\",\"-moz-animation-name\",\"-moz-animation-play-state\",\"-moz-animation-timing-function\",\"-moz-appearance\",\"-moz-backface-visibility\",\"-moz-binding\",\"-moz-border-end\",\"-moz-border-end-color\",\"-moz-border-end-style\",\"-moz-border-end-width\",\"-moz-border-image\",\"-moz-border-start\",\"-moz-border-start-color\",\"-moz-border-start-style\",\"-moz-border-start-width\",\"-moz-box-align\",\"-moz-box-direction\",\"-moz-box-flex\",\"-moz-box-ordinal-group\",\"-moz-box-orient\",\"-moz-box-pack\",\"-moz-box-sizing\",\"-moz-column-count\",\"-moz-column-fill\",\"-moz-column-gap\",\"-moz-column-rule\",\"-moz-column-rule-color\",\"-moz-column-rule-style\",\"-moz-column-rule-width\",\"-moz-column-width\",\"-moz-columns\",\"-moz-float-edge\",\"-moz-font-feature-settings\",\"-moz-font-language-override\",\"-moz-force-broken-image-icon\",\"-moz-hyphens\",\"-moz-image-region\",\"-moz-margin-end\",\"-moz-margin-start\",\"-moz-orient\",\"-moz-outline-radius\",\"-moz-outline-radius-bottomleft\",\"-moz-outline-radius-bottomright\",\"-moz-outline-radius-topleft\",\"-moz-outline-radius-topright\",\"-moz-padding-end\",\"-moz-padding-start\",\"-moz-perspective\",\"-moz-perspective-origin\",\"-moz-stack-sizing\",\"-moz-tab-size\",\"-moz-text-size-adjust\",\"-moz-transform\",\"-moz-transform-origin\",\"-moz-transform-style\",\"-moz-transition\",\"-moz-transition-delay\",\"-moz-transition-duration\",\"-moz-transition-property\",\"-moz-transition-timing-function\",\"-moz-user-focus\",\"-moz-user-input\",\"-moz-user-modify\",\"-moz-user-select\",\"-moz-window-dragging\",\"-webkit-align-content\",\"-webkit-align-items\",\"-webkit-align-self\",\"-webkit-animation\",\"-webkit-animation-delay\",\"-webkit-animation-direction\",\"-webkit-animation-duration\",\"-webkit-animation-fill-mode\",\"-webkit-animation-iteration-count\",\"-webkit-animation-name\",\"-webkit-animation-play-state\",\"-webkit-animation-timing-function\",\"-webkit-appearance\",\"-webkit-backface-visibility\",\"-webkit-background-clip\",\"-webkit-background-origin\",\"-webkit-background-size\",\"-webkit-border-bottom-left-radius\",\"-webkit-border-bottom-right-radius\",\"-webkit-border-image\",\"-webkit-border-radius\",\"-webkit-border-top-left-radius\",\"-webkit-border-top-right-radius\",\"-webkit-box-align\",\"-webkit-box-direction\",\"-webkit-box-flex\",\"-webkit-box-ordinal-group\",\"-webkit-box-orient\",\"-webkit-box-pack\",\"-webkit-box-shadow\",\"-webkit-box-sizing\",\"-webkit-filter\",\"-webkit-flex\",\"-webkit-flex-basis\",\"-webkit-flex-direction\",\"-webkit-flex-flow\",\"-webkit-flex-grow\",\"-webkit-flex-shrink\",\"-webkit-flex-wrap\",\"-webkit-justify-content\",\"-webkit-line-clamp\",\"-webkit-mask\",\"-webkit-mask-clip\",\"-webkit-mask-composite\",\"-webkit-mask-image\",\"-webkit-mask-origin\",\"-webkit-mask-position\",\"-webkit-mask-position-x\",\"-webkit-mask-position-y\",\"-webkit-mask-repeat\",\"-webkit-mask-size\",\"-webkit-order\",\"-webkit-perspective\",\"-webkit-perspective-origin\",\"-webkit-text-fill-color\",\"-webkit-text-size-adjust\",\"-webkit-text-stroke\",\"-webkit-text-stroke-color\",\"-webkit-text-stroke-width\",\"-webkit-transform\",\"-webkit-transform-origin\",\"-webkit-transform-style\",\"-webkit-transition\",\"-webkit-transition-delay\",\"-webkit-transition-duration\",\"-webkit-transition-property\",\"-webkit-transition-timing-function\",\"-webkit-user-select\",\"0\",\"1\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"2\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"3\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"37\",\"38\",\"39\",\"4\",\"40\",\"41\",\"42\",\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\"5\",\"50\",\"51\",\"6\",\"7\",\"8\",\"9\",\"@@iterator\",\"ABORT_ERR\",\"ACTIVE\",\"ACTIVE_ATTRIBUTES\",\"ACTIVE_TEXTURE\",\"ACTIVE_UNIFORMS\",\"ACTIVE_UNIFORM_BLOCKS\",\"ADDITION\",\"ALIASED_LINE_WIDTH_RANGE\",\"ALIASED_POINT_SIZE_RANGE\",\"ALLOW_KEYBOARD_INPUT\",\"ALLPASS\",\"ALPHA\",\"ALPHA_BITS\",\"ALREADY_SIGNALED\",\"ALT_MASK\",\"ALWAYS\",\"ANDROID\",\"ANGLE_instanced_arrays\",\"ANY_SAMPLES_PASSED\",\"ANY_SAMPLES_PASSED_CONSERVATIVE\",\"ANY_TYPE\",\"ANY_UNORDERED_NODE_TYPE\",\"APP_UPDATE\",\"ARM\",\"ARRAY_BUFFER\",\"ARRAY_BUFFER_BINDING\",\"ATTACHED_SHADERS\",\"ATTRIBUTE_NODE\",\"AT_TARGET\",\"AbortController\",\"AbortSignal\",\"AbsoluteOrientationSensor\",\"AbstractRange\",\"Accelerometer\",\"ActiveXObject\",\"AddSearchProvider\",\"AesGcmEncryptResult\",\"AggregateError\",\"AnalyserNode\",\"Animation\",\"AnimationEffect\",\"AnimationEvent\",\"AnimationPlaybackEvent\",\"AnimationTimeline\",\"AnonXMLHttpRequest\",\"AppBannerPromptResult\",\"ApplicationCache\",\"ApplicationCacheErrorEvent\",\"Array\",\"ArrayBuffer\",\"Atomics\",\"Attr\",\"Audio\",\"AudioBuffer\",\"AudioBufferSourceNode\",\"AudioContext\",\"AudioDestinationNode\",\"AudioListener\",\"AudioNode\",\"AudioParam\",\"AudioParamMap\",\"AudioProcessingEvent\",\"AudioScheduledSourceNode\",\"AudioStreamTrack\",\"AudioTrack\",\"AudioTrackList\",\"AudioWorklet\",\"AudioWorkletNode\",\"AuthenticatorAssertionResponse\",\"AuthenticatorAttestationResponse\",\"AuthenticatorResponse\",\"AutocompleteErrorEvent\",\"BACK\",\"BAD_BOUNDARYPOINTS_ERR\",\"BAD_REQUEST\",\"BANDPASS\",\"BLEND\",\"BLEND_COLOR\",\"BLEND_DST_ALPHA\",\"BLEND_DST_RGB\",\"BLEND_EQUATION\",\"BLEND_EQUATION_ALPHA\",\"BLEND_EQUATION_RGB\",\"BLEND_SRC_ALPHA\",\"BLEND_SRC_RGB\",\"BLUE_BITS\",\"BLUR\",\"BOOL\",\"BOOLEAN_TYPE\",\"BOOL_VEC2\",\"BOOL_VEC3\",\"BOOL_VEC4\",\"BOTH\",\"BROWSER_DEFAULT_WEBGL\",\"BUBBLING_PHASE\",\"BUFFER_SIZE\",\"BUFFER_USAGE\",\"BYTE\",\"BYTES_PER_ELEMENT\",\"BackgroundFetchManager\",\"BackgroundFetchRecord\",\"BackgroundFetchRegistration\",\"BarProp\",\"BarcodeDetector\",\"BaseAudioContext\",\"BaseHref\",\"BatteryManager\",\"BeforeInstallPromptEvent\",\"BeforeLoadEvent\",\"BeforeUnloadEvent\",\"BigInt\",\"BigInt64Array\",\"BigUint64Array\",\"BiquadFilterNode\",\"Blob\",\"BlobEvent\",\"Bluetooth\",\"BluetoothCharacteristicProperties\",\"BluetoothDevice\",\"BluetoothRemoteGATTCharacteristic\",\"BluetoothRemoteGATTDescriptor\",\"BluetoothRemoteGATTServer\",\"BluetoothRemoteGATTService\",\"BluetoothUUID\",\"BookmarkCollection\",\"Boolean\",\"BroadcastChannel\",\"ByteLengthQueuingStrategy\",\"CANNOT_RUN\",\"CAPTURING_PHASE\",\"CCW\",\"CDATASection\",\"CDATA_SECTION_NODE\",\"CHANGE\",\"CHARSET_RULE\",\"CHECKING\",\"CHROME_UPDATE\",\"CLAMP_TO_EDGE\",\"CLICK\",\"CLOSED\",\"CLOSING\",\"COLOR\",\"COLOR_ATTACHMENT0\",\"COLOR_ATTACHMENT1\",\"COLOR_ATTACHMENT10\",\"COLOR_ATTACHMENT11\",\"COLOR_ATTACHMENT12\",\"COLOR_ATTACHMENT13\",\"COLOR_ATTACHMENT14\",\"COLOR_ATTACHMENT15\",\"COLOR_ATTACHMENT2\",\"COLOR_ATTACHMENT3\",\"COLOR_ATTACHMENT4\",\"COLOR_ATTACHMENT5\",\"COLOR_ATTACHMENT6\",\"COLOR_ATTACHMENT7\",\"COLOR_ATTACHMENT8\",\"COLOR_ATTACHMENT9\",\"COLOR_BUFFER_BIT\",\"COLOR_CLEAR_VALUE\",\"COLOR_WRITEMASK\",\"COMMENT_NODE\",\"COMPARE_REF_TO_TEXTURE\",\"COMPILE_STATUS\",\"COMPRESSED_RGBA_S3TC_DXT1_EXT\",\"COMPRESSED_RGBA_S3TC_DXT3_EXT\",\"COMPRESSED_RGBA_S3TC_DXT5_EXT\",\"COMPRESSED_RGB_S3TC_DXT1_EXT\",\"COMPRESSED_TEXTURE_FORMATS\",\"CONDITION_SATISFIED\",\"CONFIGURATION_UNSUPPORTED\",\"CONNECTING\",\"CONSTANT_ALPHA\",\"CONSTANT_COLOR\",\"CONSTRAINT_ERR\",\"CONTENT\",\"CONTEXT_LOST_WEBGL\",\"CONTROL_MASK\",\"COPY_READ_BUFFER\",\"COPY_READ_BUFFER_BINDING\",\"COPY_WRITE_BUFFER\",\"COPY_WRITE_BUFFER_BINDING\",\"COUNTER_STYLE_RULE\",\"CROS\",\"CSS\",\"CSS2Properties\",\"CSSAnimation\",\"CSSCharsetRule\",\"CSSConditionRule\",\"CSSCounterStyleRule\",\"CSSFontFaceRule\",\"CSSFontFeatureValuesRule\",\"CSSGroupingRule\",\"CSSImageValue\",\"CSSImportRule\",\"CSSKeyframeRule\",\"CSSKeyframesRule\",\"CSSKeywordValue\",\"CSSMathInvert\",\"CSSMathMax\",\"CSSMathMin\",\"CSSMathNegate\",\"CSSMathProduct\",\"CSSMathSum\",\"CSSMathValue\",\"CSSMatrixComponent\",\"CSSMediaRule\",\"CSSMozDocumentRule\",\"CSSNameSpaceRule\",\"CSSNamespaceRule\",\"CSSNumericArray\",\"CSSNumericValue\",\"CSSPageRule\",\"CSSPerspective\",\"CSSPositionValue\",\"CSSPrimitiveValue\",\"CSSRotate\",\"CSSRule\",\"CSSRuleList\",\"CSSScale\",\"CSSSkew\",\"CSSSkewX\",\"CSSSkewY\",\"CSSStyleDeclaration\",\"CSSStyleRule\",\"CSSStyleSheet\",\"CSSStyleValue\",\"CSSSupportsRule\",\"CSSTransformComponent\",\"CSSTransformValue\",\"CSSTransition\",\"CSSTranslate\",\"CSSUnitValue\",\"CSSUnknownRule\",\"CSSUnparsedValue\",\"CSSValue\",\"CSSValueList\",\"CSSVariableReferenceValue\",\"CSSVariablesDeclaration\",\"CSSVariablesRule\",\"CSSViewportRule\",\"CSS_ATTR\",\"CSS_CM\",\"CSS_COUNTER\",\"CSS_CUSTOM\",\"CSS_DEG\",\"CSS_DIMENSION\",\"CSS_EMS\",\"CSS_EXS\",\"CSS_FILTER_BLUR\",\"CSS_FILTER_BRIGHTNESS\",\"CSS_FILTER_CONTRAST\",\"CSS_FILTER_CUSTOM\",\"CSS_FILTER_DROP_SHADOW\",\"CSS_FILTER_GRAYSCALE\",\"CSS_FILTER_HUE_ROTATE\",\"CSS_FILTER_INVERT\",\"CSS_FILTER_OPACITY\",\"CSS_FILTER_REFERENCE\",\"CSS_FILTER_SATURATE\",\"CSS_FILTER_SEPIA\",\"CSS_GRAD\",\"CSS_HZ\",\"CSS_IDENT\",\"CSS_IN\",\"CSS_INHERIT\",\"CSS_KHZ\",\"CSS_MATRIX\",\"CSS_MATRIX3D\",\"CSS_MM\",\"CSS_MS\",\"CSS_NUMBER\",\"CSS_PC\",\"CSS_PERCENTAGE\",\"CSS_PERSPECTIVE\",\"CSS_PRIMITIVE_VALUE\",\"CSS_PT\",\"CSS_PX\",\"CSS_RAD\",\"CSS_RECT\",\"CSS_RGBCOLOR\",\"CSS_ROTATE\",\"CSS_ROTATE3D\",\"CSS_ROTATEX\",\"CSS_ROTATEY\",\"CSS_ROTATEZ\",\"CSS_S\",\"CSS_SCALE\",\"CSS_SCALE3D\",\"CSS_SCALEX\",\"CSS_SCALEY\",\"CSS_SCALEZ\",\"CSS_SKEW\",\"CSS_SKEWX\",\"CSS_SKEWY\",\"CSS_STRING\",\"CSS_TRANSLATE\",\"CSS_TRANSLATE3D\",\"CSS_TRANSLATEX\",\"CSS_TRANSLATEY\",\"CSS_TRANSLATEZ\",\"CSS_UNKNOWN\",\"CSS_URI\",\"CSS_VALUE_LIST\",\"CSS_VH\",\"CSS_VMAX\",\"CSS_VMIN\",\"CSS_VW\",\"CULL_FACE\",\"CULL_FACE_MODE\",\"CURRENT_PROGRAM\",\"CURRENT_QUERY\",\"CURRENT_VERTEX_ATTRIB\",\"CUSTOM\",\"CW\",\"Cache\",\"CacheStorage\",\"CanvasCaptureMediaStream\",\"CanvasCaptureMediaStreamTrack\",\"CanvasGradient\",\"CanvasPattern\",\"CanvasPixelArray\",\"CanvasRenderingContext2D\",\"CaretPosition\",\"ChannelMergerNode\",\"ChannelSplitterNode\",\"CharacterData\",\"Chrome PDF Plugin\",\"Chrome PDF Viewer\",\"ClientRect\",\"ClientRectList\",\"Clipboard\",\"ClipboardEvent\",\"ClipboardItem\",\"CloseEvent\",\"Collator\",\"CollectGarbage\",\"CommandEvent\",\"Comment\",\"CompileError\",\"CompositionEvent\",\"CompressionStream\",\"Console\",\"ConstantSourceNode\",\"ControlRangeCollection\",\"Controllers\",\"ConvolverNode\",\"Coordinates\",\"CountQueuingStrategy\",\"Counter\",\"Credential\",\"CredentialsContainer\",\"Crypto\",\"CryptoKey\",\"CryptoOperation\",\"CustomElementRegistry\",\"CustomEvent\",\"DATABASE_ERR\",\"DATA_CLONE_ERR\",\"DATA_ERR\",\"DBLCLICK\",\"DECR\",\"DECR_WRAP\",\"DELETE_STATUS\",\"DEPTH\",\"DEPTH24_STENCIL8\",\"DEPTH32F_STENCIL8\",\"DEPTH_ATTACHMENT\",\"DEPTH_BITS\",\"DEPTH_BUFFER_BIT\",\"DEPTH_CLEAR_VALUE\",\"DEPTH_COMPONENT\",\"DEPTH_COMPONENT16\",\"DEPTH_COMPONENT24\",\"DEPTH_COMPONENT32F\",\"DEPTH_FUNC\",\"DEPTH_RANGE\",\"DEPTH_STENCIL\",\"DEPTH_STENCIL_ATTACHMENT\",\"DEPTH_TEST\",\"DEPTH_WRITEMASK\",\"DEVICE_INELIGIBLE\",\"DIRECTION_DOWN\",\"DIRECTION_LEFT\",\"DIRECTION_RIGHT\",\"DIRECTION_UP\",\"DISABLED\",\"DISPATCH_REQUEST_ERR\",\"DITHER\",\"DOCUMENT_FRAGMENT_NODE\",\"DOCUMENT_NODE\",\"DOCUMENT_POSITION_CONTAINED_BY\",\"DOCUMENT_POSITION_CONTAINS\",\"DOCUMENT_POSITION_DISCONNECTED\",\"DOCUMENT_POSITION_FOLLOWING\",\"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\",\"DOCUMENT_POSITION_PRECEDING\",\"DOCUMENT_TYPE_NODE\",\"DOMCursor\",\"DOMError\",\"DOMException\",\"DOMImplementation\",\"DOMImplementationLS\",\"DOMMatrix\",\"DOMMatrixReadOnly\",\"DOMParser\",\"DOMPoint\",\"DOMPointReadOnly\",\"DOMQuad\",\"DOMRect\",\"DOMRectList\",\"DOMRectReadOnly\",\"DOMRequest\",\"DOMSTRING_SIZE_ERR\",\"DOMSettableTokenList\",\"DOMStringList\",\"DOMStringMap\",\"DOMTokenList\",\"DOMTransactionEvent\",\"DOM_DELTA_LINE\",\"DOM_DELTA_PAGE\",\"DOM_DELTA_PIXEL\",\"DOM_INPUT_METHOD_DROP\",\"DOM_INPUT_METHOD_HANDWRITING\",\"DOM_INPUT_METHOD_IME\",\"DOM_INPUT_METHOD_KEYBOARD\",\"DOM_INPUT_METHOD_MULTIMODAL\",\"DOM_INPUT_METHOD_OPTION\",\"DOM_INPUT_METHOD_PASTE\",\"DOM_INPUT_METHOD_SCRIPT\",\"DOM_INPUT_METHOD_UNKNOWN\",\"DOM_INPUT_METHOD_VOICE\",\"DOM_KEY_LOCATION_JOYSTICK\",\"DOM_KEY_LOCATION_LEFT\",\"DOM_KEY_LOCATION_MOBILE\",\"DOM_KEY_LOCATION_NUMPAD\",\"DOM_KEY_LOCATION_RIGHT\",\"DOM_KEY_LOCATION_STANDARD\",\"DOM_VK_0\",\"DOM_VK_1\",\"DOM_VK_2\",\"DOM_VK_3\",\"DOM_VK_4\",\"DOM_VK_5\",\"DOM_VK_6\",\"DOM_VK_7\",\"DOM_VK_8\",\"DOM_VK_9\",\"DOM_VK_A\",\"DOM_VK_ACCEPT\",\"DOM_VK_ADD\",\"DOM_VK_ALT\",\"DOM_VK_ALTGR\",\"DOM_VK_AMPERSAND\",\"DOM_VK_ASTERISK\",\"DOM_VK_AT\",\"DOM_VK_ATTN\",\"DOM_VK_B\",\"DOM_VK_BACKSPACE\",\"DOM_VK_BACK_QUOTE\",\"DOM_VK_BACK_SLASH\",\"DOM_VK_BACK_SPACE\",\"DOM_VK_C\",\"DOM_VK_CANCEL\",\"DOM_VK_CAPS_LOCK\",\"DOM_VK_CIRCUMFLEX\",\"DOM_VK_CLEAR\",\"DOM_VK_CLOSE_BRACKET\",\"DOM_VK_CLOSE_CURLY_BRACKET\",\"DOM_VK_CLOSE_PAREN\",\"DOM_VK_COLON\",\"DOM_VK_COMMA\",\"DOM_VK_CONTEXT_MENU\",\"DOM_VK_CONTROL\",\"DOM_VK_CONVERT\",\"DOM_VK_CRSEL\",\"DOM_VK_CTRL\",\"DOM_VK_D\",\"DOM_VK_DECIMAL\",\"DOM_VK_DELETE\",\"DOM_VK_DIVIDE\",\"DOM_VK_DOLLAR\",\"DOM_VK_DOUBLE_QUOTE\",\"DOM_VK_DOWN\",\"DOM_VK_E\",\"DOM_VK_EISU\",\"DOM_VK_END\",\"DOM_VK_ENTER\",\"DOM_VK_EQUALS\",\"DOM_VK_EREOF\",\"DOM_VK_ESCAPE\",\"DOM_VK_EXCLAMATION\",\"DOM_VK_EXECUTE\",\"DOM_VK_EXSEL\",\"DOM_VK_F\",\"DOM_VK_F1\",\"DOM_VK_F10\",\"DOM_VK_F11\",\"DOM_VK_F12\",\"DOM_VK_F13\",\"DOM_VK_F14\",\"DOM_VK_F15\",\"DOM_VK_F16\",\"DOM_VK_F17\",\"DOM_VK_F18\",\"DOM_VK_F19\",\"DOM_VK_F2\",\"DOM_VK_F20\",\"DOM_VK_F21\",\"DOM_VK_F22\",\"DOM_VK_F23\",\"DOM_VK_F24\",\"DOM_VK_F25\",\"DOM_VK_F26\",\"DOM_VK_F27\",\"DOM_VK_F28\",\"DOM_VK_F29\",\"DOM_VK_F3\",\"DOM_VK_F30\",\"DOM_VK_F31\",\"DOM_VK_F32\",\"DOM_VK_F33\",\"DOM_VK_F34\",\"DOM_VK_F35\",\"DOM_VK_F36\",\"DOM_VK_F4\",\"DOM_VK_F5\",\"DOM_VK_F6\",\"DOM_VK_F7\",\"DOM_VK_F8\",\"DOM_VK_F9\",\"DOM_VK_FINAL\",\"DOM_VK_FRONT\",\"DOM_VK_G\",\"DOM_VK_GREATER_THAN\",\"DOM_VK_H\",\"DOM_VK_HANGUL\",\"DOM_VK_HANJA\",\"DOM_VK_HASH\",\"DOM_VK_HELP\",\"DOM_VK_HK_TOGGLE\",\"DOM_VK_HOME\",\"DOM_VK_HYPHEN_MINUS\",\"DOM_VK_I\",\"DOM_VK_INSERT\",\"DOM_VK_J\",\"DOM_VK_JUNJA\",\"DOM_VK_K\",\"DOM_VK_KANA\",\"DOM_VK_KANJI\",\"DOM_VK_L\",\"DOM_VK_LEFT\",\"DOM_VK_LEFT_TAB\",\"DOM_VK_LESS_THAN\",\"DOM_VK_M\",\"DOM_VK_META\",\"DOM_VK_MODECHANGE\",\"DOM_VK_MULTIPLY\",\"DOM_VK_N\",\"DOM_VK_NONCONVERT\",\"DOM_VK_NUMPAD0\",\"DOM_VK_NUMPAD1\",\"DOM_VK_NUMPAD2\",\"DOM_VK_NUMPAD3\",\"DOM_VK_NUMPAD4\",\"DOM_VK_NUMPAD5\",\"DOM_VK_NUMPAD6\",\"DOM_VK_NUMPAD7\",\"DOM_VK_NUMPAD8\",\"DOM_VK_NUMPAD9\",\"DOM_VK_NUM_LOCK\",\"DOM_VK_O\",\"DOM_VK_OEM_1\",\"DOM_VK_OEM_102\",\"DOM_VK_OEM_2\",\"DOM_VK_OEM_3\",\"DOM_VK_OEM_4\",\"DOM_VK_OEM_5\",\"DOM_VK_OEM_6\",\"DOM_VK_OEM_7\",\"DOM_VK_OEM_8\",\"DOM_VK_OEM_COMMA\",\"DOM_VK_OEM_MINUS\",\"DOM_VK_OEM_PERIOD\",\"DOM_VK_OEM_PLUS\",\"DOM_VK_OPEN_BRACKET\",\"DOM_VK_OPEN_CURLY_BRACKET\",\"DOM_VK_OPEN_PAREN\",\"DOM_VK_P\",\"DOM_VK_PA1\",\"DOM_VK_PAGEDOWN\",\"DOM_VK_PAGEUP\",\"DOM_VK_PAGE_DOWN\",\"DOM_VK_PAGE_UP\",\"DOM_VK_PAUSE\",\"DOM_VK_PERCENT\",\"DOM_VK_PERIOD\",\"DOM_VK_PIPE\",\"DOM_VK_PLAY\",\"DOM_VK_PLUS\",\"DOM_VK_PRINT\",\"DOM_VK_PRINTSCREEN\",\"DOM_VK_PROCESSKEY\",\"DOM_VK_PROPERITES\",\"DOM_VK_Q\",\"DOM_VK_QUESTION_MARK\",\"DOM_VK_QUOTE\",\"DOM_VK_R\",\"DOM_VK_REDO\",\"DOM_VK_RETURN\",\"DOM_VK_RIGHT\",\"DOM_VK_S\",\"DOM_VK_SCROLL_LOCK\",\"DOM_VK_SELECT\",\"DOM_VK_SEMICOLON\",\"DOM_VK_SEPARATOR\",\"DOM_VK_SHIFT\",\"DOM_VK_SLASH\",\"DOM_VK_SLEEP\",\"DOM_VK_SPACE\",\"DOM_VK_SUBTRACT\",\"DOM_VK_T\",\"DOM_VK_TAB\",\"DOM_VK_TILDE\",\"DOM_VK_U\",\"DOM_VK_UNDERSCORE\",\"DOM_VK_UNDO\",\"DOM_VK_UNICODE\",\"DOM_VK_UP\",\"DOM_VK_V\",\"DOM_VK_VOLUME_DOWN\",\"DOM_VK_VOLUME_MUTE\",\"DOM_VK_VOLUME_UP\",\"DOM_VK_W\",\"DOM_VK_WIN\",\"DOM_VK_WINDOW\",\"DOM_VK_WIN_ICO_00\",\"DOM_VK_WIN_ICO_CLEAR\",\"DOM_VK_WIN_ICO_HELP\",\"DOM_VK_WIN_OEM_ATTN\",\"DOM_VK_WIN_OEM_AUTO\",\"DOM_VK_WIN_OEM_BACKTAB\",\"DOM_VK_WIN_OEM_CLEAR\",\"DOM_VK_WIN_OEM_COPY\",\"DOM_VK_WIN_OEM_CUSEL\",\"DOM_VK_WIN_OEM_ENLW\",\"DOM_VK_WIN_OEM_FINISH\",\"DOM_VK_WIN_OEM_FJ_JISHO\",\"DOM_VK_WIN_OEM_FJ_LOYA\",\"DOM_VK_WIN_OEM_FJ_MASSHOU\",\"DOM_VK_WIN_OEM_FJ_ROYA\",\"DOM_VK_WIN_OEM_FJ_TOUROKU\",\"DOM_VK_WIN_OEM_JUMP\",\"DOM_VK_WIN_OEM_PA1\",\"DOM_VK_WIN_OEM_PA2\",\"DOM_VK_WIN_OEM_PA3\",\"DOM_VK_WIN_OEM_RESET\",\"DOM_VK_WIN_OEM_WSCTRL\",\"DOM_VK_X\",\"DOM_VK_XF86XK_ADD_FAVORITE\",\"DOM_VK_XF86XK_APPLICATION_LEFT\",\"DOM_VK_XF86XK_APPLICATION_RIGHT\",\"DOM_VK_XF86XK_AUDIO_CYCLE_TRACK\",\"DOM_VK_XF86XK_AUDIO_FORWARD\",\"DOM_VK_XF86XK_AUDIO_LOWER_VOLUME\",\"DOM_VK_XF86XK_AUDIO_MEDIA\",\"DOM_VK_XF86XK_AUDIO_MUTE\",\"DOM_VK_XF86XK_AUDIO_NEXT\",\"DOM_VK_XF86XK_AUDIO_PAUSE\",\"DOM_VK_XF86XK_AUDIO_PLAY\",\"DOM_VK_XF86XK_AUDIO_PREV\",\"DOM_VK_XF86XK_AUDIO_RAISE_VOLUME\",\"DOM_VK_XF86XK_AUDIO_RANDOM_PLAY\",\"DOM_VK_XF86XK_AUDIO_RECORD\",\"DOM_VK_XF86XK_AUDIO_REPEAT\",\"DOM_VK_XF86XK_AUDIO_REWIND\",\"DOM_VK_XF86XK_AUDIO_STOP\",\"DOM_VK_XF86XK_AWAY\",\"DOM_VK_XF86XK_BACK\",\"DOM_VK_XF86XK_BACK_FORWARD\",\"DOM_VK_XF86XK_BATTERY\",\"DOM_VK_XF86XK_BLUE\",\"DOM_VK_XF86XK_BLUETOOTH\",\"DOM_VK_XF86XK_BOOK\",\"DOM_VK_XF86XK_BRIGHTNESS_ADJUST\",\"DOM_VK_XF86XK_CALCULATOR\",\"DOM_VK_XF86XK_CALENDAR\",\"DOM_VK_XF86XK_CD\",\"DOM_VK_XF86XK_CLOSE\",\"DOM_VK_XF86XK_COMMUNITY\",\"DOM_VK_XF86XK_CONTRAST_ADJUST\",\"DOM_VK_XF86XK_COPY\",\"DOM_VK_XF86XK_CUT\",\"DOM_VK_XF86XK_CYCLE_ANGLE\",\"DOM_VK_XF86XK_DISPLAY\",\"DOM_VK_XF86XK_DOCUMENTS\",\"DOM_VK_XF86XK_DOS\",\"DOM_VK_XF86XK_EJECT\",\"DOM_VK_XF86XK_EXCEL\",\"DOM_VK_XF86XK_EXPLORER\",\"DOM_VK_XF86XK_FAVORITES\",\"DOM_VK_XF86XK_FINANCE\",\"DOM_VK_XF86XK_FORWARD\",\"DOM_VK_XF86XK_FRAME_BACK\",\"DOM_VK_XF86XK_FRAME_FORWARD\",\"DOM_VK_XF86XK_GAME\",\"DOM_VK_XF86XK_GO\",\"DOM_VK_XF86XK_GREEN\",\"DOM_VK_XF86XK_HIBERNATE\",\"DOM_VK_XF86XK_HISTORY\",\"DOM_VK_XF86XK_HOME_PAGE\",\"DOM_VK_XF86XK_HOT_LINKS\",\"DOM_VK_XF86XK_I_TOUCH\",\"DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN\",\"DOM_VK_XF86XK_KBD_BRIGHTNESS_UP\",\"DOM_VK_XF86XK_KBD_LIGHT_ON_OFF\",\"DOM_VK_XF86XK_LAUNCH0\",\"DOM_VK_XF86XK_LAUNCH1\",\"DOM_VK_XF86XK_LAUNCH2\",\"DOM_VK_XF86XK_LAUNCH3\",\"DOM_VK_XF86XK_LAUNCH4\",\"DOM_VK_XF86XK_LAUNCH5\",\"DOM_VK_XF86XK_LAUNCH6\",\"DOM_VK_XF86XK_LAUNCH7\",\"DOM_VK_XF86XK_LAUNCH8\",\"DOM_VK_XF86XK_LAUNCH9\",\"DOM_VK_XF86XK_LAUNCH_A\",\"DOM_VK_XF86XK_LAUNCH_B\",\"DOM_VK_XF86XK_LAUNCH_C\",\"DOM_VK_XF86XK_LAUNCH_D\",\"DOM_VK_XF86XK_LAUNCH_E\",\"DOM_VK_XF86XK_LAUNCH_F\",\"DOM_VK_XF86XK_LIGHT_BULB\",\"DOM_VK_XF86XK_LOG_OFF\",\"DOM_VK_XF86XK_MAIL\",\"DOM_VK_XF86XK_MAIL_FORWARD\",\"DOM_VK_XF86XK_MARKET\",\"DOM_VK_XF86XK_MEETING\",\"DOM_VK_XF86XK_MEMO\",\"DOM_VK_XF86XK_MENU_KB\",\"DOM_VK_XF86XK_MENU_PB\",\"DOM_VK_XF86XK_MESSENGER\",\"DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN\",\"DOM_VK_XF86XK_MON_BRIGHTNESS_UP\",\"DOM_VK_XF86XK_MUSIC\",\"DOM_VK_XF86XK_MY_COMPUTER\",\"DOM_VK_XF86XK_MY_SITES\",\"DOM_VK_XF86XK_NEW\",\"DOM_VK_XF86XK_NEWS\",\"DOM_VK_XF86XK_OFFICE_HOME\",\"DOM_VK_XF86XK_OPEN\",\"DOM_VK_XF86XK_OPEN_URL\",\"DOM_VK_XF86XK_OPTION\",\"DOM_VK_XF86XK_PASTE\",\"DOM_VK_XF86XK_PHONE\",\"DOM_VK_XF86XK_PICTURES\",\"DOM_VK_XF86XK_POWER_DOWN\",\"DOM_VK_XF86XK_POWER_OFF\",\"DOM_VK_XF86XK_RED\",\"DOM_VK_XF86XK_REFRESH\",\"DOM_VK_XF86XK_RELOAD\",\"DOM_VK_XF86XK_REPLY\",\"DOM_VK_XF86XK_ROCKER_DOWN\",\"DOM_VK_XF86XK_ROCKER_ENTER\",\"DOM_VK_XF86XK_ROCKER_UP\",\"DOM_VK_XF86XK_ROTATE_WINDOWS\",\"DOM_VK_XF86XK_ROTATION_KB\",\"DOM_VK_XF86XK_ROTATION_PB\",\"DOM_VK_XF86XK_SAVE\",\"DOM_VK_XF86XK_SCREEN_SAVER\",\"DOM_VK_XF86XK_SCROLL_CLICK\",\"DOM_VK_XF86XK_SCROLL_DOWN\",\"DOM_VK_XF86XK_SCROLL_UP\",\"DOM_VK_XF86XK_SEARCH\",\"DOM_VK_XF86XK_SEND\",\"DOM_VK_XF86XK_SHOP\",\"DOM_VK_XF86XK_SPELL\",\"DOM_VK_XF86XK_SPLIT_SCREEN\",\"DOM_VK_XF86XK_STANDBY\",\"DOM_VK_XF86XK_START\",\"DOM_VK_XF86XK_STOP\",\"DOM_VK_XF86XK_SUBTITLE\",\"DOM_VK_XF86XK_SUPPORT\",\"DOM_VK_XF86XK_SUSPEND\",\"DOM_VK_XF86XK_TASK_PANE\",\"DOM_VK_XF86XK_TERMINAL\",\"DOM_VK_XF86XK_TIME\",\"DOM_VK_XF86XK_TOOLS\",\"DOM_VK_XF86XK_TOP_MENU\",\"DOM_VK_XF86XK_TO_DO_LIST\",\"DOM_VK_XF86XK_TRAVEL\",\"DOM_VK_XF86XK_USER1KB\",\"DOM_VK_XF86XK_USER2KB\",\"DOM_VK_XF86XK_USER_PB\",\"DOM_VK_XF86XK_UWB\",\"DOM_VK_XF86XK_VENDOR_HOME\",\"DOM_VK_XF86XK_VIDEO\",\"DOM_VK_XF86XK_VIEW\",\"DOM_VK_XF86XK_WAKE_UP\",\"DOM_VK_XF86XK_WEB_CAM\",\"DOM_VK_XF86XK_WHEEL_BUTTON\",\"DOM_VK_XF86XK_WLAN\",\"DOM_VK_XF86XK_WORD\",\"DOM_VK_XF86XK_WWW\",\"DOM_VK_XF86XK_XFER\",\"DOM_VK_XF86XK_YELLOW\",\"DOM_VK_XF86XK_ZOOM_IN\",\"DOM_VK_XF86XK_ZOOM_OUT\",\"DOM_VK_Y\",\"DOM_VK_Z\",\"DOM_VK_ZOOM\",\"DONE\",\"DONT_CARE\",\"DOWNLOADING\",\"DRAGDROP\",\"DRAW_BUFFER0\",\"DRAW_BUFFER1\",\"DRAW_BUFFER10\",\"DRAW_BUFFER11\",\"DRAW_BUFFER12\",\"DRAW_BUFFER13\",\"DRAW_BUFFER14\",\"DRAW_BUFFER15\",\"DRAW_BUFFER2\",\"DRAW_BUFFER3\",\"DRAW_BUFFER4\",\"DRAW_BUFFER5\",\"DRAW_BUFFER6\",\"DRAW_BUFFER7\",\"DRAW_BUFFER8\",\"DRAW_BUFFER9\",\"DRAW_FRAMEBUFFER\",\"DRAW_FRAMEBUFFER_BINDING\",\"DST_ALPHA\",\"DST_COLOR\",\"DYNAMIC_COPY\",\"DYNAMIC_DRAW\",\"DYNAMIC_READ\",\"DataChannel\",\"DataCue\",\"DataTransfer\",\"DataTransferItem\",\"DataTransferItemList\",\"DataView\",\"Database\",\"Date\",\"DateTimeFormat\",\"Debug\",\"DecompressionStream\",\"Default Browser Helper\",\"DelayNode\",\"DesktopNotification\",\"DesktopNotificationCenter\",\"DeviceAcceleration\",\"DeviceLightEvent\",\"DeviceMotionEvent\",\"DeviceMotionEventAcceleration\",\"DeviceMotionEventRotationRate\",\"DeviceOrientationEvent\",\"DeviceProximityEvent\",\"DeviceRotationRate\",\"DeviceStorage\",\"DeviceStorageChangeEvent\",\"Directory\",\"DisplayNames\",\"Document\",\"DocumentFragment\",\"DocumentTimeline\",\"DocumentType\",\"DragEvent\",\"DynamicsCompressorNode\",\"E\",\"ELEMENT_ARRAY_BUFFER\",\"ELEMENT_ARRAY_BUFFER_BINDING\",\"ELEMENT_NODE\",\"EMPTY\",\"ENCODING_ERR\",\"ENDED\",\"END_TO_END\",\"END_TO_START\",\"ENTITY_NODE\",\"ENTITY_REFERENCE_NODE\",\"EPSILON\",\"EQUAL\",\"EQUALPOWER\",\"ERROR\",\"EXPONENTIAL_DISTANCE\",\"EXT_texture_filter_anisotropic\",\"Element\",\"ElementInternals\",\"ElementQuery\",\"EnterPictureInPictureEvent\",\"Entity\",\"EntityReference\",\"Enumerator\",\"Error\",\"ErrorEvent\",\"EvalError\",\"Event\",\"EventException\",\"EventSource\",\"EventTarget\",\"External\",\"FASTEST\",\"FIDOSDK\",\"FILTER_ACCEPT\",\"FILTER_INTERRUPT\",\"FILTER_REJECT\",\"FILTER_SKIP\",\"FINISHED_STATE\",\"FIRST_ORDERED_NODE_TYPE\",\"FLOAT\",\"FLOAT_32_UNSIGNED_INT_24_8_REV\",\"FLOAT_MAT2\",\"FLOAT_MAT2x3\",\"FLOAT_MAT2x4\",\"FLOAT_MAT3\",\"FLOAT_MAT3x2\",\"FLOAT_MAT3x4\",\"FLOAT_MAT4\",\"FLOAT_MAT4x2\",\"FLOAT_MAT4x3\",\"FLOAT_VEC2\",\"FLOAT_VEC3\",\"FLOAT_VEC4\",\"FOCUS\",\"FONT_FACE_RULE\",\"FONT_FEATURE_VALUES_RULE\",\"FRAGMENT_SHADER\",\"FRAGMENT_SHADER_DERIVATIVE_HINT\",\"FRAGMENT_SHADER_DERIVATIVE_HINT_OES\",\"FRAMEBUFFER\",\"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\",\"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\",\"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\",\"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\",\"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\",\"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\",\"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\",\"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\",\"FRAMEBUFFER_ATTACHMENT_RED_SIZE\",\"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\",\"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\",\"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\",\"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\",\"FRAMEBUFFER_BINDING\",\"FRAMEBUFFER_COMPLETE\",\"FRAMEBUFFER_DEFAULT\",\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\",\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\",\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\",\"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\",\"FRAMEBUFFER_UNSUPPORTED\",\"FRONT\",\"FRONT_AND_BACK\",\"FRONT_FACE\",\"FUNC_ADD\",\"FUNC_REVERSE_SUBTRACT\",\"FUNC_SUBTRACT\",\"FeaturePolicy\",\"FederatedCredential\",\"Feed\",\"FeedEntry\",\"File\",\"FileError\",\"FileList\",\"FileReader\",\"FileSystem\",\"FileSystemDirectoryEntry\",\"FileSystemDirectoryReader\",\"FileSystemEntry\",\"FileSystemFileEntry\",\"FinalizationRegistry\",\"FindInPage\",\"Float32Array\",\"Float64Array\",\"FocusEvent\",\"FontFace\",\"FontFaceSet\",\"FontFaceSetLoadEvent\",\"FormData\",\"FormDataEvent\",\"FragmentDirective\",\"Function\",\"GENERATE_MIPMAP_HINT\",\"GEQUAL\",\"GREATER\",\"GREEN_BITS\",\"GainNode\",\"Gamepad\",\"GamepadButton\",\"GamepadEvent\",\"GamepadHapticActuator\",\"GamepadPose\",\"Geolocation\",\"GeolocationCoordinates\",\"GeolocationPosition\",\"GeolocationPositionError\",\"GestureEvent\",\"Global\",\"Gyroscope\",\"HALF_FLOAT\",\"HAVE_CURRENT_DATA\",\"HAVE_ENOUGH_DATA\",\"HAVE_FUTURE_DATA\",\"HAVE_METADATA\",\"HAVE_NOTHING\",\"HEADERS_RECEIVED\",\"HIDDEN\",\"HIERARCHY_REQUEST_ERR\",\"HIGHPASS\",\"HIGHSHELF\",\"HIGH_FLOAT\",\"HIGH_INT\",\"HORIZONTAL\",\"HORIZONTAL_AXIS\",\"HRTF\",\"HTMLAllCollection\",\"HTMLAnchorElement\",\"HTMLAppletElement\",\"HTMLAreaElement\",\"HTMLAreasCollection\",\"HTMLAudioElement\",\"HTMLBGSoundElement\",\"HTMLBRElement\",\"HTMLBaseElement\",\"HTMLBaseFontElement\",\"HTMLBlockElement\",\"HTMLBlockquoteElement\",\"HTMLBodyElement\",\"HTMLButtonElement\",\"HTMLCanvasElement\",\"HTMLCollection\",\"HTMLCommandElement\",\"HTMLContentElement\",\"HTMLDDElement\",\"HTMLDListElement\",\"HTMLDTElement\",\"HTMLDataElement\",\"HTMLDataListElement\",\"HTMLDetailsElement\",\"HTMLDialogElement\",\"HTMLDirectoryElement\",\"HTMLDivElement\",\"HTMLDocument\",\"HTMLElement\",\"HTMLEmbedElement\",\"HTMLFieldSetElement\",\"HTMLFontElement\",\"HTMLFormControlsCollection\",\"HTMLFormElement\",\"HTMLFrameElement\",\"HTMLFrameSetElement\",\"HTMLHRElement\",\"HTMLHeadElement\",\"HTMLHeadingElement\",\"HTMLHtmlElement\",\"HTMLIFrameElement\",\"HTMLImageElement\",\"HTMLInputElement\",\"HTMLIsIndexElement\",\"HTMLKeygenElement\",\"HTMLLIElement\",\"HTMLLabelElement\",\"HTMLLegendElement\",\"HTMLLinkElement\",\"HTMLMapElement\",\"HTMLMarqueeElement\",\"HTMLMediaElement\",\"HTMLMenuElement\",\"HTMLMenuItemElement\",\"HTMLMetaElement\",\"HTMLMeterElement\",\"HTMLModElement\",\"HTMLNextIdElement\",\"HTMLOListElement\",\"HTMLObjectElement\",\"HTMLOptGroupElement\",\"HTMLOptionElement\",\"HTMLOptionsCollection\",\"HTMLOutputElement\",\"HTMLParagraphElement\",\"HTMLParamElement\",\"HTMLPhraseElement\",\"HTMLPictureElement\",\"HTMLPreElement\",\"HTMLProgressElement\",\"HTMLPropertiesCollection\",\"HTMLQuoteElement\",\"HTMLScriptElement\",\"HTMLSelectElement\",\"HTMLShadowElement\",\"HTMLSlotElement\",\"HTMLSourceElement\",\"HTMLSpanElement\",\"HTMLStyleElement\",\"HTMLTableCaptionElement\",\"HTMLTableCellElement\",\"HTMLTableColElement\",\"HTMLTableDataCellElement\",\"HTMLTableElement\",\"HTMLTableHeaderCellElement\",\"HTMLTableRowElement\",\"HTMLTableSectionElement\",\"HTMLTemplateElement\",\"HTMLTextAreaElement\",\"HTMLTimeElement\",\"HTMLTitleElement\",\"HTMLTrackElement\",\"HTMLUListElement\",\"HTMLUnknownElement\",\"HTMLVideoElement\",\"HashChangeEvent\",\"Headers\",\"History\",\"Hz\",\"ICE_CHECKING\",\"ICE_CLOSED\",\"ICE_COMPLETED\",\"ICE_CONNECTED\",\"ICE_FAILED\",\"ICE_GATHERING\",\"ICE_WAITING\",\"IDBCursor\",\"IDBCursorWithValue\",\"IDBDatabase\",\"IDBDatabaseException\",\"IDBFactory\",\"IDBFileHandle\",\"IDBFileRequest\",\"IDBIndex\",\"IDBKeyRange\",\"IDBMutableFile\",\"IDBObjectStore\",\"IDBOpenDBRequest\",\"IDBRequest\",\"IDBTransaction\",\"IDBVersionChangeEvent\",\"IDLE\",\"IIRFilterNode\",\"IMPLEMENTATION_COLOR_READ_FORMAT\",\"IMPLEMENTATION_COLOR_READ_TYPE\",\"IMPORT_RULE\",\"INCR\",\"INCR_WRAP\",\"INDEX_SIZE_ERR\",\"INSTALL\",\"INSTALLED\",\"INT\",\"INTERLEAVED_ATTRIBS\",\"INT_2_10_10_10_REV\",\"INT_SAMPLER_2D\",\"INT_SAMPLER_2D_ARRAY\",\"INT_SAMPLER_3D\",\"INT_SAMPLER_CUBE\",\"INT_VEC2\",\"INT_VEC3\",\"INT_VEC4\",\"INUSE_ATTRIBUTE_ERR\",\"INVALID_ACCESS_ERR\",\"INVALID_CHARACTER_ERR\",\"INVALID_ENUM\",\"INVALID_EXPRESSION_ERR\",\"INVALID_FRAMEBUFFER_OPERATION\",\"INVALID_INDEX\",\"INVALID_MODIFICATION_ERR\",\"INVALID_NODE_TYPE_ERR\",\"INVALID_OPERATION\",\"INVALID_STATE_ERR\",\"INVALID_VALUE\",\"INVERSE_DISTANCE\",\"INVERT\",\"IceCandidate\",\"IdleDeadline\",\"Image\",\"ImageBitmap\",\"ImageBitmapRenderingContext\",\"ImageCapture\",\"ImageData\",\"Infinity\",\"InputDeviceCapabilities\",\"InputDeviceInfo\",\"InputEvent\",\"InputMethodContext\",\"InstallState\",\"InstallTrigger\",\"Instance\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Intent\",\"InternalError\",\"IntersectionObserver\",\"IntersectionObserverEntry\",\"Intl\",\"IsSearchProviderInstalled\",\"Iterator\",\"JSON\",\"Java Deployment Toolkit 7.0.250.17\",\"Java(TM) Platform SE 7 U25\",\"KEEP\",\"KEYDOWN\",\"KEYFRAMES_RULE\",\"KEYFRAME_RULE\",\"KEYPRESS\",\"KEYUP\",\"Key\",\"KeyEvent\",\"KeyOperation\",\"KeyPair\",\"Keyboard\",\"KeyboardEvent\",\"KeyboardLayoutMap\",\"KeyframeEffect\",\"LENGTHADJUST_SPACING\",\"LENGTHADJUST_SPACINGANDGLYPHS\",\"LENGTHADJUST_UNKNOWN\",\"LEQUAL\",\"LESS\",\"LINEAR\",\"LINEAR_DISTANCE\",\"LINEAR_MIPMAP_LINEAR\",\"LINEAR_MIPMAP_NEAREST\",\"LINES\",\"LINE_LOOP\",\"LINE_STRIP\",\"LINE_WIDTH\",\"LINK_STATUS\",\"LINUX\",\"LIVE\",\"LN10\",\"LN2\",\"LOADED\",\"LOADING\",\"LOCALE\",\"LOG10E\",\"LOG2E\",\"LOWPASS\",\"LOWSHELF\",\"LOW_FLOAT\",\"LOW_INT\",\"LSException\",\"LSParserFilter\",\"LUMINANCE\",\"LUMINANCE_ALPHA\",\"LargestContentfulPaint\",\"LayoutShift\",\"LayoutShiftAttribution\",\"LinearAccelerationSensor\",\"LinkError\",\"ListFormat\",\"LocalMediaStream\",\"Locale\",\"Location\",\"Lock\",\"LockManager\",\"MAC\",\"MAX\",\"MAX_3D_TEXTURE_SIZE\",\"MAX_ARRAY_TEXTURE_LAYERS\",\"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\",\"MAX_COLOR_ATTACHMENTS\",\"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\",\"MAX_COMBINED_TEXTURE_IMAGE_UNITS\",\"MAX_COMBINED_UNIFORM_BLOCKS\",\"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\",\"MAX_CUBE_MAP_TEXTURE_SIZE\",\"MAX_DRAW_BUFFERS\",\"MAX_ELEMENTS_INDICES\",\"MAX_ELEMENTS_VERTICES\",\"MAX_ELEMENT_INDEX\",\"MAX_FRAGMENT_INPUT_COMPONENTS\",\"MAX_FRAGMENT_UNIFORM_BLOCKS\",\"MAX_FRAGMENT_UNIFORM_COMPONENTS\",\"MAX_FRAGMENT_UNIFORM_VECTORS\",\"MAX_PROGRAM_TEXEL_OFFSET\",\"MAX_RENDERBUFFER_SIZE\",\"MAX_SAFE_INTEGER\",\"MAX_SAMPLES\",\"MAX_SERVER_WAIT_TIMEOUT\",\"MAX_TEXTURE_IMAGE_UNITS\",\"MAX_TEXTURE_LOD_BIAS\",\"MAX_TEXTURE_MAX_ANISOTROPY_EXT\",\"MAX_TEXTURE_SIZE\",\"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\",\"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\",\"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\",\"MAX_UNIFORM_BLOCK_SIZE\",\"MAX_UNIFORM_BUFFER_BINDINGS\",\"MAX_VALUE\",\"MAX_VARYING_COMPONENTS\",\"MAX_VARYING_VECTORS\",\"MAX_VERTEX_ATTRIBS\",\"MAX_VERTEX_OUTPUT_COMPONENTS\",\"MAX_VERTEX_TEXTURE_IMAGE_UNITS\",\"MAX_VERTEX_UNIFORM_BLOCKS\",\"MAX_VERTEX_UNIFORM_COMPONENTS\",\"MAX_VERTEX_UNIFORM_VECTORS\",\"MAX_VIEWPORT_DIMS\",\"MEDIA_ERR_ABORTED\",\"MEDIA_ERR_DECODE\",\"MEDIA_ERR_ENCRYPTED\",\"MEDIA_ERR_NETWORK\",\"MEDIA_ERR_SRC_NOT_SUPPORTED\",\"MEDIA_KEYERR_CLIENT\",\"MEDIA_KEYERR_DOMAIN\",\"MEDIA_KEYERR_HARDWARECHANGE\",\"MEDIA_KEYERR_OUTPUT\",\"MEDIA_KEYERR_SERVICE\",\"MEDIA_KEYERR_UNKNOWN\",\"MEDIA_RULE\",\"MEDIUM_FLOAT\",\"MEDIUM_INT\",\"META_MASK\",\"MIDIAccess\",\"MIDIConnectionEvent\",\"MIDIInput\",\"MIDIInputMap\",\"MIDIMessageEvent\",\"MIDIOutput\",\"MIDIOutputMap\",\"MIDIPort\",\"MIN\",\"MIN_PROGRAM_TEXEL_OFFSET\",\"MIN_SAFE_INTEGER\",\"MIN_VALUE\",\"MIRRORED_REPEAT\",\"MODE_ASYNCHRONOUS\",\"MODE_SYNCHRONOUS\",\"MODIFICATION\",\"MOUSEDOWN\",\"MOUSEDRAG\",\"MOUSEMOVE\",\"MOUSEOUT\",\"MOUSEOVER\",\"MOUSEUP\",\"MOZ_KEYFRAMES_RULE\",\"MOZ_KEYFRAME_RULE\",\"MOZ_SOURCE_CURSOR\",\"MOZ_SOURCE_ERASER\",\"MOZ_SOURCE_KEYBOARD\",\"MOZ_SOURCE_MOUSE\",\"MOZ_SOURCE_PEN\",\"MOZ_SOURCE_TOUCH\",\"MOZ_SOURCE_UNKNOWN\",\"MSBehaviorUrnsCollection\",\"MSBlobBuilder\",\"MSCSSMatrix\",\"MSCSSProperties\",\"MSCSSRuleList\",\"MSCompatibleInfo\",\"MSCompatibleInfoCollection\",\"MSCurrentStyleCSSProperties\",\"MSEventObj\",\"MSGESTURE_FLAG_BEGIN\",\"MSGESTURE_FLAG_CANCEL\",\"MSGESTURE_FLAG_END\",\"MSGESTURE_FLAG_INERTIA\",\"MSGESTURE_FLAG_NONE\",\"MSGesture\",\"MSGestureEvent\",\"MSGraphicsTrust\",\"MSInputMethodContext\",\"MSManipulationEvent\",\"MSMediaKeyError\",\"MSMediaKeyMessageEvent\",\"MSMediaKeyNeededEvent\",\"MSMediaKeySession\",\"MSMediaKeys\",\"MSMimeTypesCollection\",\"MSPOINTER_TYPE_MOUSE\",\"MSPOINTER_TYPE_PEN\",\"MSPOINTER_TYPE_TOUCH\",\"MSPluginsCollection\",\"MSPointerEvent\",\"MSRangeCollection\",\"MSSiteModeEvent\",\"MSStream\",\"MSStreamReader\",\"MSStyleCSSProperties\",\"MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE\",\"MS_ASYNC_CALLBACK_STATUS_CANCEL\",\"MS_ASYNC_CALLBACK_STATUS_CHOOSEANY\",\"MS_ASYNC_CALLBACK_STATUS_ERROR\",\"MS_ASYNC_CALLBACK_STATUS_JOIN\",\"MS_ASYNC_OP_STATUS_CANCELED\",\"MS_ASYNC_OP_STATUS_ERROR\",\"MS_ASYNC_OP_STATUS_SUCCESS\",\"MS_MANIPULATION_STATE_ACTIVE\",\"MS_MANIPULATION_STATE_CANCELLED\",\"MS_MANIPULATION_STATE_COMMITTED\",\"MS_MANIPULATION_STATE_DRAGGING\",\"MS_MANIPULATION_STATE_INERTIA\",\"MS_MANIPULATION_STATE_PRESELECT\",\"MS_MANIPULATION_STATE_SELECTING\",\"MS_MANIPULATION_STATE_STOPPED\",\"MS_MEDIA_ERR_ENCRYPTED\",\"MS_MEDIA_KEYERR_CLIENT\",\"MS_MEDIA_KEYERR_DOMAIN\",\"MS_MEDIA_KEYERR_HARDWARECHANGE\",\"MS_MEDIA_KEYERR_OUTPUT\",\"MS_MEDIA_KEYERR_SERVICE\",\"MS_MEDIA_KEYERR_UNKNOWN\",\"Map\",\"Math\",\"MathMLElement\",\"MediaCapabilities\",\"MediaCapabilitiesInfo\",\"MediaController\",\"MediaDeviceInfo\",\"MediaDevices\",\"MediaElementAudioSourceNode\",\"MediaEncryptedEvent\",\"MediaError\",\"MediaKeyError\",\"MediaKeyEvent\",\"MediaKeyMessageEvent\",\"MediaKeyNeededEvent\",\"MediaKeySession\",\"MediaKeyStatusMap\",\"MediaKeySystemAccess\",\"MediaKeys\",\"MediaList\",\"MediaMetadata\",\"MediaQueryList\",\"MediaQueryListEvent\",\"MediaRecorder\",\"MediaRecorderErrorEvent\",\"MediaSession\",\"MediaSettingsRange\",\"MediaSource\",\"MediaStream\",\"MediaStreamAudioDestinationNode\",\"MediaStreamAudioSourceNode\",\"MediaStreamEvent\",\"MediaStreamTrack\",\"MediaStreamTrackAudioSourceNode\",\"MediaStreamTrackEvent\",\"Memory\",\"MessageChannel\",\"MessageEvent\",\"MessagePort\",\"Methods\",\"Microsoft DRM\",\"MimeType\",\"MimeTypeArray\",\"Module\",\"MouseEvent\",\"MouseScrollEvent\",\"MouseWheelEvent\",\"MozAnimation\",\"MozAnimationDelay\",\"MozAnimationDirection\",\"MozAnimationDuration\",\"MozAnimationFillMode\",\"MozAnimationIterationCount\",\"MozAnimationName\",\"MozAnimationPlayState\",\"MozAnimationTimingFunction\",\"MozAppearance\",\"MozBackfaceVisibility\",\"MozBinding\",\"MozBorderBottomColors\",\"MozBorderEnd\",\"MozBorderEndColor\",\"MozBorderEndStyle\",\"MozBorderEndWidth\",\"MozBorderImage\",\"MozBorderLeftColors\",\"MozBorderRightColors\",\"MozBorderStart\",\"MozBorderStartColor\",\"MozBorderStartStyle\",\"MozBorderStartWidth\",\"MozBorderTopColors\",\"MozBoxAlign\",\"MozBoxDirection\",\"MozBoxFlex\",\"MozBoxOrdinalGroup\",\"MozBoxOrient\",\"MozBoxPack\",\"MozBoxSizing\",\"MozCSSKeyframeRule\",\"MozCSSKeyframesRule\",\"MozColumnCount\",\"MozColumnFill\",\"MozColumnGap\",\"MozColumnRule\",\"MozColumnRuleColor\",\"MozColumnRuleStyle\",\"MozColumnRuleWidth\",\"MozColumnWidth\",\"MozColumns\",\"MozContactChangeEvent\",\"MozFloatEdge\",\"MozFontFeatureSettings\",\"MozFontLanguageOverride\",\"MozForceBrokenImageIcon\",\"MozHyphens\",\"MozImageRegion\",\"MozMarginEnd\",\"MozMarginStart\",\"MozMmsEvent\",\"MozMmsMessage\",\"MozMobileMessageThread\",\"MozOSXFontSmoothing\",\"MozOrient\",\"MozOutlineRadius\",\"MozOutlineRadiusBottomleft\",\"MozOutlineRadiusBottomright\",\"MozOutlineRadiusTopleft\",\"MozOutlineRadiusTopright\",\"MozPaddingEnd\",\"MozPaddingStart\",\"MozPerspective\",\"MozPerspectiveOrigin\",\"MozPowerManager\",\"MozSettingsEvent\",\"MozSmsEvent\",\"MozSmsMessage\",\"MozStackSizing\",\"MozTabSize\",\"MozTextAlignLast\",\"MozTextDecorationColor\",\"MozTextDecorationLine\",\"MozTextDecorationStyle\",\"MozTextSizeAdjust\",\"MozTransform\",\"MozTransformOrigin\",\"MozTransformStyle\",\"MozTransition\",\"MozTransitionDelay\",\"MozTransitionDuration\",\"MozTransitionProperty\",\"MozTransitionTimingFunction\",\"MozUserFocus\",\"MozUserInput\",\"MozUserModify\",\"MozUserSelect\",\"MozWindowDragging\",\"MozWindowShadow\",\"MutationEvent\",\"MutationObserver\",\"MutationRecord\",\"NAMESPACE_ERR\",\"NAMESPACE_RULE\",\"NEAREST\",\"NEAREST_MIPMAP_LINEAR\",\"NEAREST_MIPMAP_NEAREST\",\"NEGATIVE_INFINITY\",\"NETWORK_EMPTY\",\"NETWORK_ERR\",\"NETWORK_IDLE\",\"NETWORK_LOADED\",\"NETWORK_LOADING\",\"NETWORK_NO_SOURCE\",\"NEVER\",\"NEW\",\"NEXT\",\"NEXT_NO_DUPLICATE\",\"NICEST\",\"NODE_AFTER\",\"NODE_BEFORE\",\"NODE_BEFORE_AND_AFTER\",\"NODE_INSIDE\",\"NONE\",\"NON_TRANSIENT_ERR\",\"NOTATION_NODE\",\"NOTCH\",\"NOTEQUAL\",\"NOT_ALLOWED_ERR\",\"NOT_FOUND_ERR\",\"NOT_INSTALLED\",\"NOT_READABLE_ERR\",\"NOT_SUPPORTED_ERR\",\"NO_DATA_ALLOWED_ERR\",\"NO_ERR\",\"NO_ERROR\",\"NO_MODIFICATION_ALLOWED_ERR\",\"NO_UPDATE\",\"NUMBER_TYPE\",\"NUM_COMPRESSED_TEXTURE_FORMATS\",\"NaN\",\"NamedNodeMap\",\"Native Client\",\"NavigationPreloadManager\",\"Navigator\",\"NearbyLinks\",\"NetworkInformation\",\"Node\",\"NodeFilter\",\"NodeIterator\",\"NodeList\",\"Notation\",\"Notification\",\"NotifyPaintEvent\",\"Number\",\"NumberFormat\",\"OBJECT_TYPE\",\"OBSOLETE\",\"OES_element_index_uint\",\"OES_standard_derivatives\",\"OES_texture_float\",\"OES_texture_float_linear\",\"OK\",\"ONE\",\"ONE_MINUS_CONSTANT_ALPHA\",\"ONE_MINUS_CONSTANT_COLOR\",\"ONE_MINUS_DST_ALPHA\",\"ONE_MINUS_DST_COLOR\",\"ONE_MINUS_SRC_ALPHA\",\"ONE_MINUS_SRC_COLOR\",\"OPEN\",\"OPENBSD\",\"OPENED\",\"OPENING\",\"ORDERED_NODE_ITERATOR_TYPE\",\"ORDERED_NODE_SNAPSHOT_TYPE\",\"OS_UPDATE\",\"OTHER_ERROR\",\"OUT_OF_MEMORY\",\"Object\",\"OfflineAudioCompletionEvent\",\"OfflineAudioContext\",\"OfflineResourceList\",\"OffscreenCanvas\",\"OffscreenCanvasRenderingContext2D\",\"OnInstalledReason\",\"OnRestartRequiredReason\",\"Option\",\"OrientationSensor\",\"OscillatorNode\",\"OverconstrainedError\",\"OverconstrainedErrorEvent\",\"OverflowEvent\",\"PACKAGE\",\"PACK_ALIGNMENT\",\"PACK_ROW_LENGTH\",\"PACK_SKIP_PIXELS\",\"PACK_SKIP_ROWS\",\"PAGE_RULE\",\"PARSE_ERR\",\"PATHSEG_ARC_ABS\",\"PATHSEG_ARC_REL\",\"PATHSEG_CLOSEPATH\",\"PATHSEG_CURVETO_CUBIC_ABS\",\"PATHSEG_CURVETO_CUBIC_REL\",\"PATHSEG_CURVETO_CUBIC_SMOOTH_ABS\",\"PATHSEG_CURVETO_CUBIC_SMOOTH_REL\",\"PATHSEG_CURVETO_QUADRATIC_ABS\",\"PATHSEG_CURVETO_QUADRATIC_REL\",\"PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS\",\"PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL\",\"PATHSEG_LINETO_ABS\",\"PATHSEG_LINETO_HORIZONTAL_ABS\",\"PATHSEG_LINETO_HORIZONTAL_REL\",\"PATHSEG_LINETO_REL\",\"PATHSEG_LINETO_VERTICAL_ABS\",\"PATHSEG_LINETO_VERTICAL_REL\",\"PATHSEG_MOVETO_ABS\",\"PATHSEG_MOVETO_REL\",\"PATHSEG_UNKNOWN\",\"PATH_EXISTS_ERR\",\"PEAKING\",\"PERIODIC\",\"PERMISSION_DENIED\",\"PERSISTENT\",\"PI\",\"PIXEL_PACK_BUFFER\",\"PIXEL_PACK_BUFFER_BINDING\",\"PIXEL_UNPACK_BUFFER\",\"PIXEL_UNPACK_BUFFER_BINDING\",\"PLAYING_STATE\",\"POINTS\",\"POLYGON_OFFSET_FACTOR\",\"POLYGON_OFFSET_FILL\",\"POLYGON_OFFSET_UNITS\",\"POSITION_UNAVAILABLE\",\"POSITIVE_INFINITY\",\"PREV\",\"PREV_NO_DUPLICATE\",\"PROCESSING_INSTRUCTION_NODE\",\"PageChangeEvent\",\"PageTransitionEvent\",\"PaintRequest\",\"PaintRequestList\",\"PannerNode\",\"PasswordCredential\",\"Path2D\",\"PaymentAddress\",\"PaymentInstruments\",\"PaymentManager\",\"PaymentMethodChangeEvent\",\"PaymentRequest\",\"PaymentRequestUpdateEvent\",\"PaymentResponse\",\"Performance\",\"PerformanceElementTiming\",\"PerformanceEntry\",\"PerformanceEventTiming\",\"PerformanceLongTaskTiming\",\"PerformanceMark\",\"PerformanceMeasure\",\"PerformanceNavigation\",\"PerformanceNavigationTiming\",\"PerformanceObserver\",\"PerformanceObserverEntryList\",\"PerformancePaintTiming\",\"PerformanceResourceTiming\",\"PerformanceServerTiming\",\"PerformanceTiming\",\"PeriodicSyncManager\",\"PeriodicWave\",\"PermissionStatus\",\"Permissions\",\"PhotoCapabilities\",\"PictureInPictureWindow\",\"PlatformArch\",\"PlatformNaclArch\",\"PlatformOs\",\"Plugin\",\"PluginArray\",\"PluralRules\",\"PointerEvent\",\"PopStateEvent\",\"PopupBlockedEvent\",\"Position\",\"PositionError\",\"Presentation\",\"PresentationAvailability\",\"PresentationConnection\",\"PresentationConnectionAvailableEvent\",\"PresentationConnectionCloseEvent\",\"PresentationConnectionList\",\"PresentationReceiver\",\"PresentationRequest\",\"ProcessingInstruction\",\"ProgressEvent\",\"Promise\",\"PromiseRejectionEvent\",\"PropertyNodeList\",\"Proxy\",\"PublicKeyCredential\",\"PushManager\",\"PushSubscription\",\"PushSubscriptionOptions\",\"Q\",\"QUERY_RESULT\",\"QUERY_RESULT_AVAILABLE\",\"QUOTA_ERR\",\"QUOTA_EXCEEDED_ERR\",\"QueryInterface\",\"R11F_G11F_B10F\",\"R16F\",\"R16I\",\"R16UI\",\"R32F\",\"R32I\",\"R32UI\",\"R8\",\"R8I\",\"R8UI\",\"R8_SNORM\",\"RASTERIZER_DISCARD\",\"READY_TO_RUN\",\"READ_BUFFER\",\"READ_FRAMEBUFFER\",\"READ_FRAMEBUFFER_BINDING\",\"READ_ONLY\",\"READ_ONLY_ERR\",\"READ_WRITE\",\"RED\",\"RED_BITS\",\"RED_INTEGER\",\"REMOVAL\",\"RENDERBUFFER\",\"RENDERBUFFER_ALPHA_SIZE\",\"RENDERBUFFER_BINDING\",\"RENDERBUFFER_BLUE_SIZE\",\"RENDERBUFFER_DEPTH_SIZE\",\"RENDERBUFFER_GREEN_SIZE\",\"RENDERBUFFER_HEIGHT\",\"RENDERBUFFER_INTERNAL_FORMAT\",\"RENDERBUFFER_RED_SIZE\",\"RENDERBUFFER_SAMPLES\",\"RENDERBUFFER_STENCIL_SIZE\",\"RENDERBUFFER_WIDTH\",\"RENDERER\",\"RENDERING_INTENT_ABSOLUTE_COLORIMETRIC\",\"RENDERING_INTENT_AUTO\",\"RENDERING_INTENT_PERCEPTUAL\",\"RENDERING_INTENT_RELATIVE_COLORIMETRIC\",\"RENDERING_INTENT_SATURATION\",\"RENDERING_INTENT_UNKNOWN\",\"REPEAT\",\"REPLACE\",\"RG\",\"RG16F\",\"RG16I\",\"RG16UI\",\"RG32F\",\"RG32I\",\"RG32UI\",\"RG8\",\"RG8I\",\"RG8UI\",\"RG8_SNORM\",\"RGB\",\"RGB10_A2\",\"RGB10_A2UI\",\"RGB16F\",\"RGB16I\",\"RGB16UI\",\"RGB32F\",\"RGB32I\",\"RGB32UI\",\"RGB565\",\"RGB5_A1\",\"RGB8\",\"RGB8I\",\"RGB8UI\",\"RGB8_SNORM\",\"RGB9_E5\",\"RGBA\",\"RGBA16F\",\"RGBA16I\",\"RGBA16UI\",\"RGBA32F\",\"RGBA32I\",\"RGBA32UI\",\"RGBA4\",\"RGBA8\",\"RGBA8I\",\"RGBA8UI\",\"RGBA8_SNORM\",\"RGBA_INTEGER\",\"RGBColor\",\"RGB_INTEGER\",\"RG_INTEGER\",\"ROTATION_CLOCKWISE\",\"ROTATION_COUNTERCLOCKWISE\",\"RTCCertificate\",\"RTCDTMFSender\",\"RTCDTMFToneChangeEvent\",\"RTCDataChannel\",\"RTCDataChannelEvent\",\"RTCDtlsTransport\",\"RTCError\",\"RTCErrorEvent\",\"RTCIceCandidate\",\"RTCIceTransport\",\"RTCPeerConnection\",\"RTCPeerConnectionIceErrorEvent\",\"RTCPeerConnectionIceEvent\",\"RTCRtpReceiver\",\"RTCRtpSender\",\"RTCRtpTransceiver\",\"RTCSctpTransport\",\"RTCSessionDescription\",\"RTCStatsReport\",\"RTCTrackEvent\",\"RUNNING\",\"RadioNodeList\",\"Range\",\"RangeError\",\"RangeException\",\"ReadableByteStream\",\"ReadableStream\",\"ReadableStreamDefaultReader\",\"RecordErrorEvent\",\"Rect\",\"ReferenceError\",\"Reflect\",\"RegExp\",\"RelativeOrientationSensor\",\"RelativeTimeFormat\",\"RemotePlayback\",\"ReportingObserver\",\"Request\",\"RequestUpdateCheckStatus\",\"ResizeObserver\",\"ResizeObserverEntry\",\"ResizeObserverSize\",\"Response\",\"RunningState\",\"RuntimeError\",\"SAMPLER_2D\",\"SAMPLER_2D_ARRAY\",\"SAMPLER_2D_ARRAY_SHADOW\",\"SAMPLER_2D_SHADOW\",\"SAMPLER_3D\",\"SAMPLER_BINDING\",\"SAMPLER_CUBE\",\"SAMPLER_CUBE_SHADOW\",\"SAMPLES\",\"SAMPLE_ALPHA_TO_COVERAGE\",\"SAMPLE_BUFFERS\",\"SAMPLE_COVERAGE\",\"SAMPLE_COVERAGE_INVERT\",\"SAMPLE_COVERAGE_VALUE\",\"SAWTOOTH\",\"SCHEDULED_STATE\",\"SCISSOR_BOX\",\"SCISSOR_TEST\",\"SCROLL_PAGE_DOWN\",\"SCROLL_PAGE_UP\",\"SDP_ANSWER\",\"SDP_OFFER\",\"SDP_PRANSWER\",\"SECURITY_ERR\",\"SELECT\",\"SEPARATE_ATTRIBS\",\"SERIALIZE_ERR\",\"SEVERITY_ERROR\",\"SEVERITY_FATAL_ERROR\",\"SEVERITY_WARNING\",\"SHADER_COMPILER\",\"SHADER_TYPE\",\"SHADING_LANGUAGE_VERSION\",\"SHARED_MODULE_UPDATE\",\"SHIFT_MASK\",\"SHORT\",\"SHOWING\",\"SHOW_ALL\",\"SHOW_ATTRIBUTE\",\"SHOW_CDATA_SECTION\",\"SHOW_COMMENT\",\"SHOW_DOCUMENT\",\"SHOW_DOCUMENT_FRAGMENT\",\"SHOW_DOCUMENT_TYPE\",\"SHOW_ELEMENT\",\"SHOW_ENTITY\",\"SHOW_ENTITY_REFERENCE\",\"SHOW_NOTATION\",\"SHOW_PROCESSING_INSTRUCTION\",\"SHOW_TEXT\",\"SIGNALED\",\"SIGNED_NORMALIZED\",\"SINE\",\"SKIN\",\"SOUNDFIELD\",\"SQLError\",\"SQLException\",\"SQLResultSet\",\"SQLResultSetRowList\",\"SQLTransaction\",\"SQRT1_2\",\"SQRT2\",\"SQUARE\",\"SRC_ALPHA\",\"SRC_ALPHA_SATURATE\",\"SRC_COLOR\",\"SRGB\",\"SRGB8\",\"SRGB8_ALPHA8\",\"START_TO_END\",\"START_TO_START\",\"STATIC_COPY\",\"STATIC_DRAW\",\"STATIC_READ\",\"STENCIL\",\"STENCIL_ATTACHMENT\",\"STENCIL_BACK_FAIL\",\"STENCIL_BACK_FUNC\",\"STENCIL_BACK_PASS_DEPTH_FAIL\",\"STENCIL_BACK_PASS_DEPTH_PASS\",\"STENCIL_BACK_REF\",\"STENCIL_BACK_VALUE_MASK\",\"STENCIL_BACK_WRITEMASK\",\"STENCIL_BITS\",\"STENCIL_BUFFER_BIT\",\"STENCIL_CLEAR_VALUE\",\"STENCIL_FAIL\",\"STENCIL_FUNC\",\"STENCIL_INDEX\",\"STENCIL_INDEX8\",\"STENCIL_PASS_DEPTH_FAIL\",\"STENCIL_PASS_DEPTH_PASS\",\"STENCIL_REF\",\"STENCIL_TEST\",\"STENCIL_VALUE_MASK\",\"STENCIL_WRITEMASK\",\"STREAM_COPY\",\"STREAM_DRAW\",\"STREAM_READ\",\"STRING_TYPE\",\"STYLE_RULE\",\"SUBPIXEL_BITS\",\"SUPPORTS_RULE\",\"SVGAElement\",\"SVGAltGlyphDefElement\",\"SVGAltGlyphElement\",\"SVGAltGlyphItemElement\",\"SVGAngle\",\"SVGAnimateColorElement\",\"SVGAnimateElement\",\"SVGAnimateMotionElement\",\"SVGAnimateTransformElement\",\"SVGAnimatedAngle\",\"SVGAnimatedBoolean\",\"SVGAnimatedEnumeration\",\"SVGAnimatedInteger\",\"SVGAnimatedLength\",\"SVGAnimatedLengthList\",\"SVGAnimatedNumber\",\"SVGAnimatedNumberList\",\"SVGAnimatedPreserveAspectRatio\",\"SVGAnimatedRect\",\"SVGAnimatedString\",\"SVGAnimatedTransformList\",\"SVGAnimationElement\",\"SVGCircleElement\",\"SVGClipPathElement\",\"SVGColor\",\"SVGComponentTransferFunctionElement\",\"SVGCursorElement\",\"SVGDefsElement\",\"SVGDescElement\",\"SVGDiscardElement\",\"SVGDocument\",\"SVGElement\",\"SVGElementInstance\",\"SVGElementInstanceList\",\"SVGEllipseElement\",\"SVGException\",\"SVGFEBlendElement\",\"SVGFEColorMatrixElement\",\"SVGFEComponentTransferElement\",\"SVGFECompositeElement\",\"SVGFEConvolveMatrixElement\",\"SVGFEDiffuseLightingElement\",\"SVGFEDisplacementMapElement\",\"SVGFEDistantLightElement\",\"SVGFEDropShadowElement\",\"SVGFEFloodElement\",\"SVGFEFuncAElement\",\"SVGFEFuncBElement\",\"SVGFEFuncGElement\",\"SVGFEFuncRElement\",\"SVGFEGaussianBlurElement\",\"SVGFEImageElement\",\"SVGFEMergeElement\",\"SVGFEMergeNodeElement\",\"SVGFEMorphologyElement\",\"SVGFEOffsetElement\",\"SVGFEPointLightElement\",\"SVGFESpecularLightingElement\",\"SVGFESpotLightElement\",\"SVGFETileElement\",\"SVGFETurbulenceElement\",\"SVGFilterElement\",\"SVGFontElement\",\"SVGFontFaceElement\",\"SVGFontFaceFormatElement\",\"SVGFontFaceNameElement\",\"SVGFontFaceSrcElement\",\"SVGFontFaceUriElement\",\"SVGForeignObjectElement\",\"SVGGElement\",\"SVGGeometryElement\",\"SVGGlyphElement\",\"SVGGlyphRefElement\",\"SVGGradientElement\",\"SVGGraphicsElement\",\"SVGHKernElement\",\"SVGImageElement\",\"SVGLength\",\"SVGLengthList\",\"SVGLineElement\",\"SVGLinearGradientElement\",\"SVGMPathElement\",\"SVGMarkerElement\",\"SVGMaskElement\",\"SVGMatrix\",\"SVGMetadataElement\",\"SVGMissingGlyphElement\",\"SVGNumber\",\"SVGNumberList\",\"SVGPaint\",\"SVGPathElement\",\"SVGPathSeg\",\"SVGPathSegArcAbs\",\"SVGPathSegArcRel\",\"SVGPathSegClosePath\",\"SVGPathSegCurvetoCubicAbs\",\"SVGPathSegCurvetoCubicRel\",\"SVGPathSegCurvetoCubicSmoothAbs\",\"SVGPathSegCurvetoCubicSmoothRel\",\"SVGPathSegCurvetoQuadraticAbs\",\"SVGPathSegCurvetoQuadraticRel\",\"SVGPathSegCurvetoQuadraticSmoothAbs\",\"SVGPathSegCurvetoQuadraticSmoothRel\",\"SVGPathSegLinetoAbs\",\"SVGPathSegLinetoHorizontalAbs\",\"SVGPathSegLinetoHorizontalRel\",\"SVGPathSegLinetoRel\",\"SVGPathSegLinetoVerticalAbs\",\"SVGPathSegLinetoVerticalRel\",\"SVGPathSegList\",\"SVGPathSegMovetoAbs\",\"SVGPathSegMovetoRel\",\"SVGPatternElement\",\"SVGPoint\",\"SVGPointList\",\"SVGPolygonElement\",\"SVGPolylineElement\",\"SVGPreserveAspectRatio\",\"SVGRadialGradientElement\",\"SVGRect\",\"SVGRectElement\",\"SVGRenderingIntent\",\"SVGSVGElement\",\"SVGScriptElement\",\"SVGSetElement\",\"SVGStopElement\",\"SVGStringList\",\"SVGStyleElement\",\"SVGSwitchElement\",\"SVGSymbolElement\",\"SVGTRefElement\",\"SVGTSpanElement\",\"SVGTextContentElement\",\"SVGTextElement\",\"SVGTextPathElement\",\"SVGTextPositioningElement\",\"SVGTitleElement\",\"SVGTransform\",\"SVGTransformList\",\"SVGUnitTypes\",\"SVGUseElement\",\"SVGVKernElement\",\"SVGViewElement\",\"SVGViewSpec\",\"SVGZoomAndPan\",\"SVGZoomEvent\",\"SVG_ANGLETYPE_DEG\",\"SVG_ANGLETYPE_GRAD\",\"SVG_ANGLETYPE_RAD\",\"SVG_ANGLETYPE_UNKNOWN\",\"SVG_ANGLETYPE_UNSPECIFIED\",\"SVG_CHANNEL_A\",\"SVG_CHANNEL_B\",\"SVG_CHANNEL_G\",\"SVG_CHANNEL_R\",\"SVG_CHANNEL_UNKNOWN\",\"SVG_COLORTYPE_CURRENTCOLOR\",\"SVG_COLORTYPE_RGBCOLOR\",\"SVG_COLORTYPE_RGBCOLOR_ICCCOLOR\",\"SVG_COLORTYPE_UNKNOWN\",\"SVG_EDGEMODE_DUPLICATE\",\"SVG_EDGEMODE_NONE\",\"SVG_EDGEMODE_UNKNOWN\",\"SVG_EDGEMODE_WRAP\",\"SVG_FEBLEND_MODE_COLOR\",\"SVG_FEBLEND_MODE_COLOR_BURN\",\"SVG_FEBLEND_MODE_COLOR_DODGE\",\"SVG_FEBLEND_MODE_DARKEN\",\"SVG_FEBLEND_MODE_DIFFERENCE\",\"SVG_FEBLEND_MODE_EXCLUSION\",\"SVG_FEBLEND_MODE_HARD_LIGHT\",\"SVG_FEBLEND_MODE_HUE\",\"SVG_FEBLEND_MODE_LIGHTEN\",\"SVG_FEBLEND_MODE_LUMINOSITY\",\"SVG_FEBLEND_MODE_MULTIPLY\",\"SVG_FEBLEND_MODE_NORMAL\",\"SVG_FEBLEND_MODE_OVERLAY\",\"SVG_FEBLEND_MODE_SATURATION\",\"SVG_FEBLEND_MODE_SCREEN\",\"SVG_FEBLEND_MODE_SOFT_LIGHT\",\"SVG_FEBLEND_MODE_UNKNOWN\",\"SVG_FECOLORMATRIX_TYPE_HUEROTATE\",\"SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA\",\"SVG_FECOLORMATRIX_TYPE_MATRIX\",\"SVG_FECOLORMATRIX_TYPE_SATURATE\",\"SVG_FECOLORMATRIX_TYPE_UNKNOWN\",\"SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE\",\"SVG_FECOMPONENTTRANSFER_TYPE_GAMMA\",\"SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY\",\"SVG_FECOMPONENTTRANSFER_TYPE_LINEAR\",\"SVG_FECOMPONENTTRANSFER_TYPE_TABLE\",\"SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN\",\"SVG_FECOMPOSITE_OPERATOR_ARITHMETIC\",\"SVG_FECOMPOSITE_OPERATOR_ATOP\",\"SVG_FECOMPOSITE_OPERATOR_IN\",\"SVG_FECOMPOSITE_OPERATOR_OUT\",\"SVG_FECOMPOSITE_OPERATOR_OVER\",\"SVG_FECOMPOSITE_OPERATOR_UNKNOWN\",\"SVG_FECOMPOSITE_OPERATOR_XOR\",\"SVG_INVALID_VALUE_ERR\",\"SVG_LENGTHTYPE_CM\",\"SVG_LENGTHTYPE_EMS\",\"SVG_LENGTHTYPE_EXS\",\"SVG_LENGTHTYPE_IN\",\"SVG_LENGTHTYPE_MM\",\"SVG_LENGTHTYPE_NUMBER\",\"SVG_LENGTHTYPE_PC\",\"SVG_LENGTHTYPE_PERCENTAGE\",\"SVG_LENGTHTYPE_PT\",\"SVG_LENGTHTYPE_PX\",\"SVG_LENGTHTYPE_UNKNOWN\",\"SVG_MARKERUNITS_STROKEWIDTH\",\"SVG_MARKERUNITS_UNKNOWN\",\"SVG_MARKERUNITS_USERSPACEONUSE\",\"SVG_MARKER_ORIENT_ANGLE\",\"SVG_MARKER_ORIENT_AUTO\",\"SVG_MARKER_ORIENT_UNKNOWN\",\"SVG_MASKTYPE_ALPHA\",\"SVG_MASKTYPE_LUMINANCE\",\"SVG_MATRIX_NOT_INVERTABLE\",\"SVG_MEETORSLICE_MEET\",\"SVG_MEETORSLICE_SLICE\",\"SVG_MEETORSLICE_UNKNOWN\",\"SVG_MORPHOLOGY_OPERATOR_DILATE\",\"SVG_MORPHOLOGY_OPERATOR_ERODE\",\"SVG_MORPHOLOGY_OPERATOR_UNKNOWN\",\"SVG_PAINTTYPE_CURRENTCOLOR\",\"SVG_PAINTTYPE_NONE\",\"SVG_PAINTTYPE_RGBCOLOR\",\"SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR\",\"SVG_PAINTTYPE_UNKNOWN\",\"SVG_PAINTTYPE_URI\",\"SVG_PAINTTYPE_URI_CURRENTCOLOR\",\"SVG_PAINTTYPE_URI_NONE\",\"SVG_PAINTTYPE_URI_RGBCOLOR\",\"SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR\",\"SVG_PRESERVEASPECTRATIO_NONE\",\"SVG_PRESERVEASPECTRATIO_UNKNOWN\",\"SVG_PRESERVEASPECTRATIO_XMAXYMAX\",\"SVG_PRESERVEASPECTRATIO_XMAXYMID\",\"SVG_PRESERVEASPECTRATIO_XMAXYMIN\",\"SVG_PRESERVEASPECTRATIO_XMIDYMAX\",\"SVG_PRESERVEASPECTRATIO_XMIDYMID\",\"SVG_PRESERVEASPECTRATIO_XMIDYMIN\",\"SVG_PRESERVEASPECTRATIO_XMINYMAX\",\"SVG_PRESERVEASPECTRATIO_XMINYMID\",\"SVG_PRESERVEASPECTRATIO_XMINYMIN\",\"SVG_SPREADMETHOD_PAD\",\"SVG_SPREADMETHOD_REFLECT\",\"SVG_SPREADMETHOD_REPEAT\",\"SVG_SPREADMETHOD_UNKNOWN\",\"SVG_STITCHTYPE_NOSTITCH\",\"SVG_STITCHTYPE_STITCH\",\"SVG_STITCHTYPE_UNKNOWN\",\"SVG_TRANSFORM_MATRIX\",\"SVG_TRANSFORM_ROTATE\",\"SVG_TRANSFORM_SCALE\",\"SVG_TRANSFORM_SKEWX\",\"SVG_TRANSFORM_SKEWY\",\"SVG_TRANSFORM_TRANSLATE\",\"SVG_TRANSFORM_UNKNOWN\",\"SVG_TURBULENCE_TYPE_FRACTALNOISE\",\"SVG_TURBULENCE_TYPE_TURBULENCE\",\"SVG_TURBULENCE_TYPE_UNKNOWN\",\"SVG_UNIT_TYPE_OBJECTBOUNDINGBOX\",\"SVG_UNIT_TYPE_UNKNOWN\",\"SVG_UNIT_TYPE_USERSPACEONUSE\",\"SVG_WRONG_TYPE_ERR\",\"SVG_ZOOMANDPAN_DISABLE\",\"SVG_ZOOMANDPAN_MAGNIFY\",\"SVG_ZOOMANDPAN_UNKNOWN\",\"SYNC_CONDITION\",\"SYNC_FENCE\",\"SYNC_FLAGS\",\"SYNC_FLUSH_COMMANDS_BIT\",\"SYNC_GPU_COMMANDS_COMPLETE\",\"SYNC_STATUS\",\"SYNTAX_ERR\",\"SavedPages\",\"Screen\",\"ScreenOrientation\",\"Script\",\"ScriptEngine\",\"ScriptEngineBuildVersion\",\"ScriptEngineMajorVersion\",\"ScriptEngineMinorVersion\",\"ScriptProcessorNode\",\"ScrollAreaEvent\",\"SecurityPolicyViolationEvent\",\"Selection\",\"Sensor\",\"SensorErrorEvent\",\"ServiceWorker\",\"ServiceWorkerContainer\",\"ServiceWorkerMessageEvent\",\"ServiceWorkerRegistration\",\"SessionDescription\",\"Set\",\"ShadowRoot\",\"SharedArrayBuffer\",\"SharedWorker\",\"SimpleGestureEvent\",\"SourceBuffer\",\"SourceBufferList\",\"SpeechSynthesis\",\"SpeechSynthesisErrorEvent\",\"SpeechSynthesisEvent\",\"SpeechSynthesisUtterance\",\"SpeechSynthesisVoice\",\"StaticRange\",\"StereoPannerNode\",\"StopIteration\",\"Storage\",\"StorageEvent\",\"StorageManager\",\"String\",\"StyleMedia\",\"StylePropertyMap\",\"StylePropertyMapReadOnly\",\"StyleSheet\",\"StyleSheetList\",\"StyleSheetPageList\",\"SubmitEvent\",\"SubtleCrypto\",\"Symbol\",\"SyncManager\",\"SyntaxError\",\"TEMPORARY\",\"TEXTPATH_METHODTYPE_ALIGN\",\"TEXTPATH_METHODTYPE_STRETCH\",\"TEXTPATH_METHODTYPE_UNKNOWN\",\"TEXTPATH_SPACINGTYPE_AUTO\",\"TEXTPATH_SPACINGTYPE_EXACT\",\"TEXTPATH_SPACINGTYPE_UNKNOWN\",\"TEXTURE\",\"TEXTURE0\",\"TEXTURE1\",\"TEXTURE10\",\"TEXTURE11\",\"TEXTURE12\",\"TEXTURE13\",\"TEXTURE14\",\"TEXTURE15\",\"TEXTURE16\",\"TEXTURE17\",\"TEXTURE18\",\"TEXTURE19\",\"TEXTURE2\",\"TEXTURE20\",\"TEXTURE21\",\"TEXTURE22\",\"TEXTURE23\",\"TEXTURE24\",\"TEXTURE25\",\"TEXTURE26\",\"TEXTURE27\",\"TEXTURE28\",\"TEXTURE29\",\"TEXTURE3\",\"TEXTURE30\",\"TEXTURE31\",\"TEXTURE4\",\"TEXTURE5\",\"TEXTURE6\",\"TEXTURE7\",\"TEXTURE8\",\"TEXTURE9\",\"TEXTURE_2D\",\"TEXTURE_2D_ARRAY\",\"TEXTURE_3D\",\"TEXTURE_BASE_LEVEL\",\"TEXTURE_BINDING_2D\",\"TEXTURE_BINDING_2D_ARRAY\",\"TEXTURE_BINDING_3D\",\"TEXTURE_BINDING_CUBE_MAP\",\"TEXTURE_COMPARE_FUNC\",\"TEXTURE_COMPARE_MODE\",\"TEXTURE_CUBE_MAP\",\"TEXTURE_CUBE_MAP_NEGATIVE_X\",\"TEXTURE_CUBE_MAP_NEGATIVE_Y\",\"TEXTURE_CUBE_MAP_NEGATIVE_Z\",\"TEXTURE_CUBE_MAP_POSITIVE_X\",\"TEXTURE_CUBE_MAP_POSITIVE_Y\",\"TEXTURE_CUBE_MAP_POSITIVE_Z\",\"TEXTURE_IMMUTABLE_FORMAT\",\"TEXTURE_IMMUTABLE_LEVELS\",\"TEXTURE_MAG_FILTER\",\"TEXTURE_MAX_ANISOTROPY_EXT\",\"TEXTURE_MAX_LEVEL\",\"TEXTURE_MAX_LOD\",\"TEXTURE_MIN_FILTER\",\"TEXTURE_MIN_LOD\",\"TEXTURE_WRAP_R\",\"TEXTURE_WRAP_S\",\"TEXTURE_WRAP_T\",\"TEXT_NODE\",\"THROTTLED\",\"TIMEOUT\",\"TIMEOUT_ERR\",\"TIMEOUT_EXPIRED\",\"TIMEOUT_IGNORED\",\"TOO_LARGE_ERR\",\"TRANSACTION_INACTIVE_ERR\",\"TRANSFORM_FEEDBACK\",\"TRANSFORM_FEEDBACK_ACTIVE\",\"TRANSFORM_FEEDBACK_BINDING\",\"TRANSFORM_FEEDBACK_BUFFER\",\"TRANSFORM_FEEDBACK_BUFFER_BINDING\",\"TRANSFORM_FEEDBACK_BUFFER_MODE\",\"TRANSFORM_FEEDBACK_BUFFER_SIZE\",\"TRANSFORM_FEEDBACK_BUFFER_START\",\"TRANSFORM_FEEDBACK_PAUSED\",\"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\",\"TRANSFORM_FEEDBACK_VARYINGS\",\"TRIANGLE\",\"TRIANGLES\",\"TRIANGLE_FAN\",\"TRIANGLE_STRIP\",\"TYPE_BACK_FORWARD\",\"TYPE_ERR\",\"TYPE_MISMATCH_ERR\",\"TYPE_NAVIGATE\",\"TYPE_RELOAD\",\"TYPE_RESERVED\",\"Table\",\"TaskAttributionTiming\",\"Text\",\"TextDecoder\",\"TextDecoderStream\",\"TextEncoder\",\"TextEncoderStream\",\"TextEvent\",\"TextMetrics\",\"TextRange\",\"TextRangeCollection\",\"TextTrack\",\"TextTrackCue\",\"TextTrackCueList\",\"TextTrackList\",\"TimeEvent\",\"TimeRanges\",\"Touch\",\"TouchEvent\",\"TouchList\",\"TrackEvent\",\"TransformStream\",\"TransitionEvent\",\"TreeWalker\",\"TrustedHTML\",\"TrustedScript\",\"TrustedScriptURL\",\"TrustedTypePolicy\",\"TrustedTypePolicyFactory\",\"TypeError\",\"U2F\",\"UIEvent\",\"UNCACHED\",\"UNIFORM_ARRAY_STRIDE\",\"UNIFORM_BLOCK_ACTIVE_UNIFORMS\",\"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\",\"UNIFORM_BLOCK_BINDING\",\"UNIFORM_BLOCK_DATA_SIZE\",\"UNIFORM_BLOCK_INDEX\",\"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\",\"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\",\"UNIFORM_BUFFER\",\"UNIFORM_BUFFER_BINDING\",\"UNIFORM_BUFFER_OFFSET_ALIGNMENT\",\"UNIFORM_BUFFER_SIZE\",\"UNIFORM_BUFFER_START\",\"UNIFORM_IS_ROW_MAJOR\",\"UNIFORM_MATRIX_STRIDE\",\"UNIFORM_OFFSET\",\"UNIFORM_SIZE\",\"UNIFORM_TYPE\",\"UNKNOWN_ERR\",\"UNKNOWN_RULE\",\"UNMASKED_RENDERER_WEBGL\",\"UNMASKED_VENDOR_WEBGL\",\"UNORDERED_NODE_ITERATOR_TYPE\",\"UNORDERED_NODE_SNAPSHOT_TYPE\",\"UNPACK_ALIGNMENT\",\"UNPACK_COLORSPACE_CONVERSION_WEBGL\",\"UNPACK_FLIP_Y_WEBGL\",\"UNPACK_IMAGE_HEIGHT\",\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\",\"UNPACK_ROW_LENGTH\",\"UNPACK_SKIP_IMAGES\",\"UNPACK_SKIP_PIXELS\",\"UNPACK_SKIP_ROWS\",\"UNSCHEDULED_STATE\",\"UNSENT\",\"UNSIGNALED\",\"UNSIGNED_BYTE\",\"UNSIGNED_INT\",\"UNSIGNED_INT_10F_11F_11F_REV\",\"UNSIGNED_INT_24_8\",\"UNSIGNED_INT_2_10_10_10_REV\",\"UNSIGNED_INT_5_9_9_9_REV\",\"UNSIGNED_INT_SAMPLER_2D\",\"UNSIGNED_INT_SAMPLER_2D_ARRAY\",\"UNSIGNED_INT_SAMPLER_3D\",\"UNSIGNED_INT_SAMPLER_CUBE\",\"UNSIGNED_INT_VEC2\",\"UNSIGNED_INT_VEC3\",\"UNSIGNED_INT_VEC4\",\"UNSIGNED_NORMALIZED\",\"UNSIGNED_SHORT\",\"UNSIGNED_SHORT_4_4_4_4\",\"UNSIGNED_SHORT_5_5_5_1\",\"UNSIGNED_SHORT_5_6_5\",\"UNSPECIFIED_EVENT_TYPE_ERR\",\"UPDATE\",\"UPDATEREADY\",\"UPDATE_AVAILABLE\",\"URIError\",\"URL\",\"URLSearchParams\",\"URLUnencoded\",\"URL_MISMATCH_ERR\",\"USB\",\"USBAlternateInterface\",\"USBConfiguration\",\"USBConnectionEvent\",\"USBDevice\",\"USBEndpoint\",\"USBInTransferResult\",\"USBInterface\",\"USBIsochronousInTransferPacket\",\"USBIsochronousInTransferResult\",\"USBIsochronousOutTransferPacket\",\"USBIsochronousOutTransferResult\",\"USBOutTransferResult\",\"UTC\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"UserActivation\",\"UserMessageHandler\",\"UserMessageHandlersNamespace\",\"UserProximityEvent\",\"VALIDATE_STATUS\",\"VALIDATION_ERR\",\"VARIABLES_RULE\",\"VBArray\",\"VENDOR\",\"VERSION\",\"VERSION_CHANGE\",\"VERSION_ERR\",\"VERTEX_ARRAY_BINDING\",\"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\",\"VERTEX_ATTRIB_ARRAY_DIVISOR\",\"VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE\",\"VERTEX_ATTRIB_ARRAY_ENABLED\",\"VERTEX_ATTRIB_ARRAY_INTEGER\",\"VERTEX_ATTRIB_ARRAY_NORMALIZED\",\"VERTEX_ATTRIB_ARRAY_POINTER\",\"VERTEX_ATTRIB_ARRAY_SIZE\",\"VERTEX_ATTRIB_ARRAY_STRIDE\",\"VERTEX_ATTRIB_ARRAY_TYPE\",\"VERTEX_SHADER\",\"VERTICAL\",\"VERTICAL_AXIS\",\"VER_ERR\",\"VIEWPORT\",\"VIEWPORT_RULE\",\"VRDisplay\",\"VRDisplayCapabilities\",\"VRDisplayEvent\",\"VREyeParameters\",\"VRFieldOfView\",\"VRFrameData\",\"VRPose\",\"VRStageParameters\",\"VTTCue\",\"VTTRegion\",\"ValidityState\",\"VideoPlaybackQuality\",\"VideoStreamTrack\",\"VideoTrack\",\"VideoTrackList\",\"VisualViewport\",\"WAIT_FAILED\",\"WEBGL_compressed_texture_s3tc\",\"WEBGL_debug_renderer_info\",\"WEBKIT_FILTER_RULE\",\"WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN\",\"WEBKIT_FORCE_AT_MOUSE_DOWN\",\"WEBKIT_KEYFRAMES_RULE\",\"WEBKIT_KEYFRAME_RULE\",\"WEBKIT_REGION_RULE\",\"WIN\",\"WRONG_DOCUMENT_ERR\",\"WakeLock\",\"WakeLockSentinel\",\"WaveShaperNode\",\"WeakMap\",\"WeakRef\",\"WeakSet\",\"WebAssembly\",\"WebGL2RenderingContext\",\"WebGLActiveInfo\",\"WebGLBuffer\",\"WebGLContextEvent\",\"WebGLFramebuffer\",\"WebGLObject\",\"WebGLProgram\",\"WebGLQuery\",\"WebGLRenderbuffer\",\"WebGLRenderingContext\",\"WebGLSampler\",\"WebGLShader\",\"WebGLShaderPrecisionFormat\",\"WebGLSync\",\"WebGLTexture\",\"WebGLTransformFeedback\",\"WebGLUniformLocation\",\"WebGLVertexArray\",\"WebGLVertexArrayObject\",\"WebKit built-in PDF\",\"WebKitAnimationEvent\",\"WebKitBlobBuilder\",\"WebKitCSSFilterRule\",\"WebKitCSSFilterValue\",\"WebKitCSSKeyframeRule\",\"WebKitCSSKeyframesRule\",\"WebKitCSSMatrix\",\"WebKitCSSRegionRule\",\"WebKitCSSTransformValue\",\"WebKitDataCue\",\"WebKitGamepad\",\"WebKitMediaKeyError\",\"WebKitMediaKeyMessageEvent\",\"WebKitMediaKeyNeededEvent\",\"WebKitMediaKeySession\",\"WebKitMediaKeys\",\"WebKitMediaSource\",\"WebKitMutationObserver\",\"WebKitNamespace\",\"WebKitPlaybackTargetAvailabilityEvent\",\"WebKitPoint\",\"WebKitShadowRoot\",\"WebKitSourceBuffer\",\"WebKitSourceBufferList\",\"WebKitTransitionEvent\",\"WebSocket\",\"WebkitAlignContent\",\"WebkitAlignItems\",\"WebkitAlignSelf\",\"WebkitAnimation\",\"WebkitAnimationDelay\",\"WebkitAnimationDirection\",\"WebkitAnimationDuration\",\"WebkitAnimationFillMode\",\"WebkitAnimationIterationCount\",\"WebkitAnimationName\",\"WebkitAnimationPlayState\",\"WebkitAnimationTimingFunction\",\"WebkitAppearance\",\"WebkitBackfaceVisibility\",\"WebkitBackgroundClip\",\"WebkitBackgroundOrigin\",\"WebkitBackgroundSize\",\"WebkitBorderBottomLeftRadius\",\"WebkitBorderBottomRightRadius\",\"WebkitBorderImage\",\"WebkitBorderRadius\",\"WebkitBorderTopLeftRadius\",\"WebkitBorderTopRightRadius\",\"WebkitBoxAlign\",\"WebkitBoxDirection\",\"WebkitBoxFlex\",\"WebkitBoxOrdinalGroup\",\"WebkitBoxOrient\",\"WebkitBoxPack\",\"WebkitBoxShadow\",\"WebkitBoxSizing\",\"WebkitFilter\",\"WebkitFlex\",\"WebkitFlexBasis\",\"WebkitFlexDirection\",\"WebkitFlexFlow\",\"WebkitFlexGrow\",\"WebkitFlexShrink\",\"WebkitFlexWrap\",\"WebkitJustifyContent\",\"WebkitLineClamp\",\"WebkitMask\",\"WebkitMaskClip\",\"WebkitMaskComposite\",\"WebkitMaskImage\",\"WebkitMaskOrigin\",\"WebkitMaskPosition\",\"WebkitMaskPositionX\",\"WebkitMaskPositionY\",\"WebkitMaskRepeat\",\"WebkitMaskSize\",\"WebkitOrder\",\"WebkitPerspective\",\"WebkitPerspectiveOrigin\",\"WebkitTextFillColor\",\"WebkitTextSizeAdjust\",\"WebkitTextStroke\",\"WebkitTextStrokeColor\",\"WebkitTextStrokeWidth\",\"WebkitTransform\",\"WebkitTransformOrigin\",\"WebkitTransformStyle\",\"WebkitTransition\",\"WebkitTransitionDelay\",\"WebkitTransitionDuration\",\"WebkitTransitionProperty\",\"WebkitTransitionTimingFunction\",\"WebkitUserSelect\",\"WheelEvent\",\"Window\",\"Windows Media Player Plug-in Dynamic Link Library\",\"Windows Presentation Foundation\",\"Worker\",\"Worklet\",\"WritableStream\",\"WritableStreamDefaultWriter\",\"X86_32\",\"X86_64\",\"XMLDocument\",\"XMLHttpRequest\",\"XMLHttpRequestEventTarget\",\"XMLHttpRequestException\",\"XMLHttpRequestProgressEvent\",\"XMLHttpRequestUpload\",\"XMLSerializer\",\"XMLStylesheetProcessingInstruction\",\"XPathEvaluator\",\"XPathException\",\"XPathExpression\",\"XPathNSResolver\",\"XPathResult\",\"XR\",\"XRBoundedReferenceSpace\",\"XRDOMOverlayState\",\"XRFrame\",\"XRHitTestResult\",\"XRHitTestSource\",\"XRInputSource\",\"XRInputSourceArray\",\"XRInputSourceEvent\",\"XRInputSourcesChangeEvent\",\"XRLayer\",\"XRPose\",\"XRRay\",\"XRReferenceSpace\",\"XRReferenceSpaceEvent\",\"XRRenderState\",\"XRRigidTransform\",\"XRSession\",\"XRSessionEvent\",\"XRSpace\",\"XRSystem\",\"XRTransientInputHitTestResult\",\"XRTransientInputHitTestSource\",\"XRView\",\"XRViewerPose\",\"XRViewport\",\"XRWebGLLayer\",\"XSLTProcessor\",\"ZERO\",\"_XD0M_\",\"_YD0M_\",\"__defineGetter__\",\"__defineSetter__\",\"__lookupGetter__\",\"__lookupSetter__\",\"__opera\",\"__proto__\",\"__relevantExtensionKeys\",\"_browserjsran\",\"a\",\"aLink\",\"abbr\",\"abort\",\"aborted\",\"abs\",\"absolute\",\"acceleration\",\"accelerationIncludingGravity\",\"accelerator\",\"accept\",\"acceptCharset\",\"acceptNode\",\"accessKey\",\"accessKeyLabel\",\"accuracy\",\"acos\",\"acosh\",\"action\",\"actionURL\",\"actions\",\"activated\",\"active\",\"activeCues\",\"activeElement\",\"activeSourceBuffers\",\"activeSourceCount\",\"activeTexture\",\"activeVRDisplays\",\"actualBoundingBoxAscent\",\"actualBoundingBoxDescent\",\"actualBoundingBoxLeft\",\"actualBoundingBoxRight\",\"add\",\"addAll\",\"addBehavior\",\"addCandidate\",\"addColorStop\",\"addCue\",\"addElement\",\"addEventListener\",\"addFilter\",\"addFromString\",\"addFromUri\",\"addIceCandidate\",\"addImport\",\"addListener\",\"addModule\",\"addNamed\",\"addPageRule\",\"addPath\",\"addPointer\",\"addRange\",\"addRegion\",\"addRule\",\"addRules\",\"addSearchEngine\",\"addSourceBuffer\",\"addStream\",\"addTextTrack\",\"addTrack\",\"addTransceiver\",\"addWakeLockListener\",\"added\",\"addedNodes\",\"additionalName\",\"additiveSymbols\",\"addons\",\"address\",\"addressLine\",\"adoptNode\",\"adoptText\",\"adoptedCallback\",\"adoptedStyleSheets\",\"adr\",\"advance\",\"after\",\"album\",\"alert\",\"algorithm\",\"align\",\"align-content\",\"align-items\",\"align-self\",\"alignContent\",\"alignItems\",\"alignSelf\",\"alignmentBaseline\",\"alinkColor\",\"all\",\"allSettled\",\"allow\",\"allowFullscreen\",\"allowPaymentRequest\",\"allowTransparency\",\"allowedDirections\",\"allowedFeatures\",\"allowsFeature\",\"alpha\",\"alphabeticBaseline\",\"alt\",\"altGraphKey\",\"altHtml\",\"altKey\",\"altLeft\",\"alternate\",\"alternateSetting\",\"alternates\",\"altitude\",\"altitudeAccuracy\",\"amplitude\",\"ancestorOrigins\",\"anchor\",\"anchorNode\",\"anchorOffset\",\"anchors\",\"and\",\"angle\",\"angularAcceleration\",\"angularVelocity\",\"animVal\",\"animate\",\"animatedInstanceRoot\",\"animatedNormalizedPathSegList\",\"animatedPathSegList\",\"animatedPoints\",\"animation\",\"animation-delay\",\"animation-direction\",\"animation-duration\",\"animation-fill-mode\",\"animation-iteration-count\",\"animation-name\",\"animation-play-state\",\"animation-timing-function\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationStartTime\",\"animationTimingFunction\",\"animationsPaused\",\"anniversary\",\"antialias\",\"any\",\"app\",\"appCodeName\",\"appMinorVersion\",\"appName\",\"appNotifications\",\"appVersion\",\"appearance\",\"append\",\"appendBuffer\",\"appendChild\",\"appendData\",\"appendItem\",\"appendMedium\",\"appendNamed\",\"appendRule\",\"appendStream\",\"appendWindowEnd\",\"appendWindowStart\",\"appleTrailingWord\",\"applets\",\"application/apple-default-browser\",\"application/asx\",\"application/java-deployment-toolkit\",\"application/pdf\",\"application/postscript\",\"application/x-drm\",\"application/x-drm-v2\",\"application/x-google-chrome-pdf\",\"application/x-java-applet\",\"application/x-java-applet;deploy=10.25.2\",\"application/x-java-applet;javafx=2.2.25\",\"application/x-java-applet;jpi-version=1.7.0_25\",\"application/x-java-applet;version=1.1\",\"application/x-java-applet;version=1.1.1\",\"application/x-java-applet;version=1.1.2\",\"application/x-java-applet;version=1.1.3\",\"application/x-java-applet;version=1.2\",\"application/x-java-applet;version=1.2.1\",\"application/x-java-applet;version=1.2.2\",\"application/x-java-applet;version=1.3\",\"application/x-java-applet;version=1.3.1\",\"application/x-java-applet;version=1.4\",\"application/x-java-applet;version=1.4.1\",\"application/x-java-applet;version=1.4.2\",\"application/x-java-applet;version=1.5\",\"application/x-java-applet;version=1.6\",\"application/x-java-applet;version=1.7\",\"application/x-java-bean\",\"application/x-java-bean;jpi-version=1.7.0_25\",\"application/x-java-bean;version=1.1\",\"application/x-java-bean;version=1.1.1\",\"application/x-java-bean;version=1.1.2\",\"application/x-java-bean;version=1.1.3\",\"application/x-java-bean;version=1.2\",\"application/x-java-bean;version=1.2.1\",\"application/x-java-bean;version=1.2.2\",\"application/x-java-bean;version=1.3\",\"application/x-java-bean;version=1.3.1\",\"application/x-java-bean;version=1.4\",\"application/x-java-bean;version=1.4.1\",\"application/x-java-bean;version=1.4.2\",\"application/x-java-bean;version=1.5\",\"application/x-java-bean;version=1.6\",\"application/x-java-bean;version=1.7\",\"application/x-java-vm\",\"application/x-java-vm-npruntime\",\"application/x-mplayer2\",\"application/x-ms-xbap\",\"application/x-nacl\",\"application/x-pnacl\",\"application/xaml+xml\",\"applicationCache\",\"applicationServerKey\",\"apply\",\"applyConstraints\",\"applyElement\",\"arc\",\"arcTo\",\"archive\",\"areas\",\"arguments\",\"aria-activedescendant\",\"aria-busy\",\"aria-checked\",\"aria-controls\",\"aria-describedby\",\"aria-disabled\",\"aria-expanded\",\"aria-flowto\",\"aria-haspopup\",\"aria-hidden\",\"aria-invalid\",\"aria-labelledby\",\"aria-level\",\"aria-live\",\"aria-multiselectable\",\"aria-owns\",\"aria-posinset\",\"aria-pressed\",\"aria-readonly\",\"aria-relevant\",\"aria-required\",\"aria-secret\",\"aria-selected\",\"aria-setsize\",\"aria-valuemax\",\"aria-valuemin\",\"aria-valuenow\",\"ariaAtomic\",\"ariaAutoComplete\",\"ariaBusy\",\"ariaChecked\",\"ariaColCount\",\"ariaColIndex\",\"ariaColSpan\",\"ariaCurrent\",\"ariaDescription\",\"ariaDisabled\",\"ariaExpanded\",\"ariaHasPopup\",\"ariaHidden\",\"ariaKeyShortcuts\",\"ariaLabel\",\"ariaLevel\",\"ariaLive\",\"ariaModal\",\"ariaMultiLine\",\"ariaMultiSelectable\",\"ariaOrientation\",\"ariaPlaceholder\",\"ariaPosInSet\",\"ariaPressed\",\"ariaReadOnly\",\"ariaRelevant\",\"ariaRequired\",\"ariaRoleDescription\",\"ariaRowCount\",\"ariaRowIndex\",\"ariaRowSpan\",\"ariaSelected\",\"ariaSetSize\",\"ariaSort\",\"ariaValueMax\",\"ariaValueMin\",\"ariaValueNow\",\"ariaValueText\",\"arrayBuffer\",\"artist\",\"artwork\",\"as\",\"asIntN\",\"asUintN\",\"asin\",\"asinh\",\"assert\",\"assign\",\"assignedElements\",\"assignedNodes\",\"assignedSlot\",\"async\",\"asyncIterator\",\"atEnd\",\"atan\",\"atan2\",\"atanh\",\"atob\",\"atomic\",\"attachEvent\",\"attachInternals\",\"attachShader\",\"attachShadow\",\"attachments\",\"attack\",\"attestationObject\",\"attrChange\",\"attrName\",\"attributeChangedCallback\",\"attributeFilter\",\"attributeName\",\"attributeNamespace\",\"attributeOldValue\",\"attributeStyleMap\",\"attributes\",\"attribution\",\"audio/x-ms-wax\",\"audio/x-ms-wma\",\"audioBitsPerSecond\",\"audioTracks\",\"audioWorklet\",\"authenticatedSignedWrites\",\"authenticatorData\",\"autoIncrement\",\"autobuffer\",\"autocapitalize\",\"autocomplete\",\"autocorrect\",\"autofocus\",\"automationRate\",\"autoplay\",\"availHeight\",\"availLeft\",\"availTop\",\"availWidth\",\"availability\",\"available\",\"aversion\",\"ax\",\"axes\",\"axis\",\"ay\",\"azimuth\",\"b\",\"back\",\"backdropFilter\",\"backface-visibility\",\"backfaceVisibility\",\"background\",\"background-attachment\",\"background-blend-mode\",\"background-clip\",\"background-color\",\"background-image\",\"background-origin\",\"background-position\",\"background-position-x\",\"background-position-y\",\"background-repeat\",\"background-size\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundFetch\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"badInput\",\"badge\",\"balance\",\"baseFrequencyX\",\"baseFrequencyY\",\"baseLatency\",\"baseLayer\",\"baseName\",\"baseNode\",\"baseOffset\",\"baseURI\",\"baseVal\",\"baselineShift\",\"battery\",\"bday\",\"before\",\"beginElement\",\"beginElementAt\",\"beginPath\",\"beginQuery\",\"beginTransformFeedback\",\"behavior\",\"behaviorCookie\",\"behaviorPart\",\"behaviorUrns\",\"beta\",\"bezierCurveTo\",\"bgColor\",\"bgProperties\",\"bias\",\"big\",\"binaryType\",\"bind\",\"bindAttribLocation\",\"bindBuffer\",\"bindBufferBase\",\"bindBufferRange\",\"bindFramebuffer\",\"bindRenderbuffer\",\"bindSampler\",\"bindTexture\",\"bindTransformFeedback\",\"bindVertexArray\",\"blendColor\",\"blendEquation\",\"blendEquationSeparate\",\"blendFunc\",\"blendFuncSeparate\",\"blink\",\"blitFramebuffer\",\"blob\",\"block-size\",\"blockDirection\",\"blockSize\",\"blockedURI\",\"blue\",\"bluetooth\",\"blur\",\"body\",\"bodyUsed\",\"bold\",\"bookmarks\",\"booleanValue\",\"border\",\"border-block\",\"border-block-color\",\"border-block-end\",\"border-block-end-color\",\"border-block-end-style\",\"border-block-end-width\",\"border-block-start\",\"border-block-start-color\",\"border-block-start-style\",\"border-block-start-width\",\"border-block-style\",\"border-block-width\",\"border-bottom\",\"border-bottom-color\",\"border-bottom-left-radius\",\"border-bottom-right-radius\",\"border-bottom-style\",\"border-bottom-width\",\"border-collapse\",\"border-color\",\"border-end-end-radius\",\"border-end-start-radius\",\"border-image\",\"border-image-outset\",\"border-image-repeat\",\"border-image-slice\",\"border-image-source\",\"border-image-width\",\"border-inline\",\"border-inline-color\",\"border-inline-end\",\"border-inline-end-color\",\"border-inline-end-style\",\"border-inline-end-width\",\"border-inline-start\",\"border-inline-start-color\",\"border-inline-start-style\",\"border-inline-start-width\",\"border-inline-style\",\"border-inline-width\",\"border-left\",\"border-left-color\",\"border-left-style\",\"border-left-width\",\"border-radius\",\"border-right\",\"border-right-color\",\"border-right-style\",\"border-right-width\",\"border-spacing\",\"border-start-end-radius\",\"border-start-start-radius\",\"border-style\",\"border-top\",\"border-top-color\",\"border-top-left-radius\",\"border-top-right-radius\",\"border-top-style\",\"border-top-width\",\"border-width\",\"borderBlock\",\"borderBlockColor\",\"borderBlockEnd\",\"borderBlockEndColor\",\"borderBlockEndStyle\",\"borderBlockEndWidth\",\"borderBlockStart\",\"borderBlockStartColor\",\"borderBlockStartStyle\",\"borderBlockStartWidth\",\"borderBlockStyle\",\"borderBlockWidth\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderBoxSize\",\"borderCollapse\",\"borderColor\",\"borderColorDark\",\"borderColorLight\",\"borderEndEndRadius\",\"borderEndStartRadius\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderInline\",\"borderInlineColor\",\"borderInlineEnd\",\"borderInlineEndColor\",\"borderInlineEndStyle\",\"borderInlineEndWidth\",\"borderInlineStart\",\"borderInlineStartColor\",\"borderInlineStartStyle\",\"borderInlineStartWidth\",\"borderInlineStyle\",\"borderInlineWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStartEndRadius\",\"borderStartStartRadius\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"bottomMargin\",\"bound\",\"boundElements\",\"boundingClientRect\",\"boundingHeight\",\"boundingLeft\",\"boundingTop\",\"boundingWidth\",\"bounds\",\"boundsGeometry\",\"box-decoration-break\",\"box-shadow\",\"box-sizing\",\"boxDecorationBreak\",\"boxShadow\",\"boxSizing\",\"break-after\",\"break-before\",\"break-inside\",\"breakAfter\",\"breakBefore\",\"breakInside\",\"breakType\",\"broadcast\",\"browserLanguage\",\"btoa\",\"bubbles\",\"buffer\",\"bufferData\",\"bufferDepth\",\"bufferSize\",\"bufferSubData\",\"buffered\",\"bufferedAmount\",\"bufferedAmountLowThreshold\",\"bufferedRendering\",\"buildID\",\"buildNumber\",\"button\",\"buttonID\",\"buttons\",\"byteLength\",\"byteOffset\",\"bytesWritten\",\"c\",\"cache\",\"caches\",\"calendar\",\"call\",\"caller\",\"canBeFormatted\",\"canBeMounted\",\"canBeShared\",\"canHaveChildren\",\"canHaveHTML\",\"canInsertDTMF\",\"canMakePayment\",\"canPlayType\",\"canPresent\",\"canTrickleIceCandidates\",\"cancel\",\"cancelAndHoldAtTime\",\"cancelAnimationFrame\",\"cancelBubble\",\"cancelIdleCallback\",\"cancelScheduledValues\",\"cancelVideoFrameCallback\",\"cancelWatchAvailability\",\"cancelable\",\"candidate\",\"canonicalUUID\",\"canvas\",\"capabilities\",\"caption\",\"caption-side\",\"captionSide\",\"capture\",\"captureEvents\",\"captureStackTrace\",\"captureStream\",\"caret-color\",\"caretBidiLevel\",\"caretColor\",\"caretPositionFromPoint\",\"caretRangeFromPoint\",\"caseFirst\",\"cast\",\"catch\",\"category\",\"cbrt\",\"cd\",\"ceil\",\"cellIndex\",\"cellPadding\",\"cellSpacing\",\"cells\",\"ch\",\"chOff\",\"chain\",\"challenge\",\"changeType\",\"changeVersion\",\"changedTouches\",\"channel\",\"channelCount\",\"channelCountMode\",\"channelInterpretation\",\"char\",\"charAt\",\"charCode\",\"charCodeAt\",\"charIndex\",\"charLength\",\"characterData\",\"characterDataOldValue\",\"characterSet\",\"characteristic\",\"charging\",\"chargingTime\",\"charset\",\"check\",\"checkEnclosure\",\"checkFramebufferStatus\",\"checkInstalled\",\"checkIntersection\",\"checkValidity\",\"checked\",\"childElementCount\",\"childList\",\"childNodes\",\"children\",\"chrome\",\"ciphertext\",\"cite\",\"city\",\"claimInterface\",\"claimed\",\"classList\",\"className\",\"classid\",\"clear\",\"clearAppBadge\",\"clearAttributes\",\"clearBufferfi\",\"clearBufferfv\",\"clearBufferiv\",\"clearBufferuiv\",\"clearColor\",\"clearData\",\"clearDepth\",\"clearHalt\",\"clearImmediate\",\"clearInterval\",\"clearLiveSeekableRange\",\"clearMarks\",\"clearMeasures\",\"clearParameters\",\"clearRect\",\"clearResourceTimings\",\"clearShadow\",\"clearStencil\",\"clearTimeout\",\"clearWatch\",\"click\",\"clickCount\",\"clientDataJSON\",\"clientHeight\",\"clientInformation\",\"clientLeft\",\"clientRect\",\"clientRects\",\"clientTop\",\"clientWaitSync\",\"clientWidth\",\"clientX\",\"clientY\",\"clip\",\"clip-path\",\"clip-rule\",\"clipBottom\",\"clipLeft\",\"clipPath\",\"clipPathUnits\",\"clipRight\",\"clipRule\",\"clipTop\",\"clipboard\",\"clipboardData\",\"clone\",\"cloneContents\",\"cloneNode\",\"cloneRange\",\"close\",\"closePath\",\"closed\",\"closest\",\"clz\",\"clz32\",\"cm\",\"cmp\",\"code\",\"codeBase\",\"codePointAt\",\"codeType\",\"colSpan\",\"collapse\",\"collapseToEnd\",\"collapseToStart\",\"collapsed\",\"collation\",\"collect\",\"colno\",\"color\",\"color-adjust\",\"color-interpolation\",\"color-interpolation-filters\",\"colorAdjust\",\"colorDepth\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorMask\",\"colorProfile\",\"colorRendering\",\"colorScheme\",\"colorType\",\"cols\",\"column\",\"column-count\",\"column-fill\",\"column-gap\",\"column-rule\",\"column-rule-color\",\"column-rule-style\",\"column-rule-width\",\"column-span\",\"column-width\",\"columnCount\",\"columnFill\",\"columnGap\",\"columnNumber\",\"columnRule\",\"columnRuleColor\",\"columnRuleStyle\",\"columnRuleWidth\",\"columnSpan\",\"columnWidth\",\"columns\",\"command\",\"commit\",\"commitLoadTime\",\"commitPreferences\",\"commitStyles\",\"commonAncestorContainer\",\"compact\",\"compare\",\"compareBoundaryPoints\",\"compareDocumentPosition\",\"compareEndPoints\",\"compareExchange\",\"compareNode\",\"comparePoint\",\"compatMode\",\"compatible\",\"compile\",\"compileShader\",\"compileStreaming\",\"complete\",\"component\",\"componentFromPoint\",\"composed\",\"composedPath\",\"composite\",\"compositionEndOffset\",\"compositionStartOffset\",\"compressedTexImage2D\",\"compressedTexImage3D\",\"compressedTexSubImage2D\",\"compressedTexSubImage3D\",\"computedStyleMap\",\"concat\",\"conditionText\",\"coneInnerAngle\",\"coneOuterAngle\",\"coneOuterGain\",\"configuration\",\"configurationName\",\"configurationValue\",\"configurations\",\"confirm\",\"confirmComposition\",\"confirmSiteSpecificTrackingException\",\"confirmWebWideTrackingException\",\"connect\",\"connectEnd\",\"connectStart\",\"connected\",\"connectedCallback\",\"connection\",\"connectionInfo\",\"connectionList\",\"connectionSpeed\",\"connectionState\",\"connections\",\"console\",\"consoleHistory\",\"consolidate\",\"constraint\",\"constrictionActive\",\"construct\",\"constructor\",\"contactID\",\"contain\",\"containIntrinsicSize\",\"containerId\",\"containerName\",\"containerSrc\",\"containerType\",\"contains\",\"containsNode\",\"content\",\"contentBoxSize\",\"contentDocument\",\"contentEditable\",\"contentHint\",\"contentOverflow\",\"contentRect\",\"contentScriptType\",\"contentStyleType\",\"contentType\",\"contentWindow\",\"context\",\"contextMenu\",\"contextmenu\",\"continue\",\"continuePrimaryKey\",\"continuous\",\"control\",\"controlTransferIn\",\"controlTransferOut\",\"controller\",\"controls\",\"controlsList\",\"convertToBlob\",\"convertToSpecifiedUnits\",\"cookie\",\"cookieEnabled\",\"coords\",\"copyBufferSubData\",\"copyFromChannel\",\"copyTexImage2D\",\"copyTexSubImage2D\",\"copyTexSubImage3D\",\"copyToChannel\",\"copyWithin\",\"correspondingElement\",\"correspondingUseElement\",\"corruptedVideoFrames\",\"cos\",\"cosh\",\"count\",\"countReset\",\"counter-increment\",\"counter-reset\",\"counter-set\",\"counterIncrement\",\"counterReset\",\"counterSet\",\"country\",\"cpuClass\",\"cpuSleepAllowed\",\"create\",\"createAnalyser\",\"createAnswer\",\"createAttribute\",\"createAttributeNS\",\"createBiquadFilter\",\"createBuffer\",\"createBufferSource\",\"createCDATASection\",\"createCSSStyleSheet\",\"createCaption\",\"createChannelMerger\",\"createChannelSplitter\",\"createComment\",\"createConstantSource\",\"createContextualFragment\",\"createControlRange\",\"createConvolver\",\"createDTMFSender\",\"createDataChannel\",\"createDelay\",\"createDelayNode\",\"createDocument\",\"createDocumentFragment\",\"createDocumentType\",\"createDynamicsCompressor\",\"createElement\",\"createElementNS\",\"createEntityReference\",\"createEvent\",\"createEventObject\",\"createExpression\",\"createFramebuffer\",\"createFunction\",\"createGain\",\"createGainNode\",\"createHTML\",\"createHTMLDocument\",\"createIIRFilter\",\"createImageBitmap\",\"createImageData\",\"createIndex\",\"createJavaScriptNode\",\"createLinearGradient\",\"createMediaElementSource\",\"createMediaKeys\",\"createMediaStreamDestination\",\"createMediaStreamSource\",\"createMediaStreamTrackSource\",\"createMutableFile\",\"createNSResolver\",\"createNodeIterator\",\"createNotification\",\"createObjectStore\",\"createObjectURL\",\"createOffer\",\"createOscillator\",\"createPanner\",\"createPattern\",\"createPeriodicWave\",\"createPolicy\",\"createPopup\",\"createProcessingInstruction\",\"createProgram\",\"createQuery\",\"createRadialGradient\",\"createRange\",\"createRangeCollection\",\"createReader\",\"createRenderbuffer\",\"createSVGAngle\",\"createSVGLength\",\"createSVGMatrix\",\"createSVGNumber\",\"createSVGPathSegArcAbs\",\"createSVGPathSegArcRel\",\"createSVGPathSegClosePath\",\"createSVGPathSegCurvetoCubicAbs\",\"createSVGPathSegCurvetoCubicRel\",\"createSVGPathSegCurvetoCubicSmoothAbs\",\"createSVGPathSegCurvetoCubicSmoothRel\",\"createSVGPathSegCurvetoQuadraticAbs\",\"createSVGPathSegCurvetoQuadraticRel\",\"createSVGPathSegCurvetoQuadraticSmoothAbs\",\"createSVGPathSegCurvetoQuadraticSmoothRel\",\"createSVGPathSegLinetoAbs\",\"createSVGPathSegLinetoHorizontalAbs\",\"createSVGPathSegLinetoHorizontalRel\",\"createSVGPathSegLinetoRel\",\"createSVGPathSegLinetoVerticalAbs\",\"createSVGPathSegLinetoVerticalRel\",\"createSVGPathSegMovetoAbs\",\"createSVGPathSegMovetoRel\",\"createSVGPoint\",\"createSVGRect\",\"createSVGTransform\",\"createSVGTransformFromMatrix\",\"createSampler\",\"createScript\",\"createScriptProcessor\",\"createScriptURL\",\"createSession\",\"createShader\",\"createShadowRoot\",\"createStereoPanner\",\"createStyleSheet\",\"createTBody\",\"createTFoot\",\"createTHead\",\"createTextNode\",\"createTextRange\",\"createTexture\",\"createTouch\",\"createTouchList\",\"createTransformFeedback\",\"createTreeWalker\",\"createVertexArray\",\"createWaveShaper\",\"creationTime\",\"credentials\",\"crossOrigin\",\"crossOriginIsolated\",\"crypto\",\"csi\",\"csp\",\"cssFloat\",\"cssRules\",\"cssText\",\"cssValueType\",\"ctrlKey\",\"ctrlLeft\",\"cues\",\"cullFace\",\"currency\",\"currencyDisplay\",\"current\",\"currentDirection\",\"currentLocalDescription\",\"currentNode\",\"currentPage\",\"currentRect\",\"currentRemoteDescription\",\"currentScale\",\"currentScript\",\"currentSrc\",\"currentState\",\"currentStyle\",\"currentTarget\",\"currentTime\",\"currentTranslate\",\"currentView\",\"cursor\",\"curve\",\"customElements\",\"customError\",\"customSections\",\"cx\",\"cy\",\"d\",\"data\",\"dataFld\",\"dataFormatAs\",\"dataLoss\",\"dataLossMessage\",\"dataPageSize\",\"dataSrc\",\"dataTransfer\",\"database\",\"databases\",\"dataset\",\"dateTime\",\"day\",\"db\",\"debug\",\"debuggerEnabled\",\"declare\",\"decode\",\"decodeAudioData\",\"decodeURI\",\"decodeURIComponent\",\"decodedBodySize\",\"decoding\",\"decodingInfo\",\"decrypt\",\"default\",\"defaultCharset\",\"defaultChecked\",\"defaultMuted\",\"defaultPlaybackRate\",\"defaultPolicy\",\"defaultPrevented\",\"defaultRequest\",\"defaultSelected\",\"defaultStatus\",\"defaultURL\",\"defaultValue\",\"defaultView\",\"defaultstatus\",\"defer\",\"define\",\"defineMagicFunction\",\"defineMagicVariable\",\"defineProperties\",\"defineProperty\",\"deg\",\"delay\",\"delayTime\",\"delegatesFocus\",\"delete\",\"deleteBuffer\",\"deleteCaption\",\"deleteCell\",\"deleteContents\",\"deleteData\",\"deleteDatabase\",\"deleteFramebuffer\",\"deleteFromDocument\",\"deleteIndex\",\"deleteMedium\",\"deleteObjectStore\",\"deleteProgram\",\"deleteProperty\",\"deleteQuery\",\"deleteRenderbuffer\",\"deleteRow\",\"deleteRule\",\"deleteSampler\",\"deleteShader\",\"deleteSync\",\"deleteTFoot\",\"deleteTHead\",\"deleteTexture\",\"deleteTransformFeedback\",\"deleteVertexArray\",\"deliverChangeRecords\",\"delivery\",\"deliveryInfo\",\"deliveryStatus\",\"deliveryTimestamp\",\"delta\",\"deltaMode\",\"deltaX\",\"deltaY\",\"deltaZ\",\"dependentLocality\",\"depthFar\",\"depthFunc\",\"depthMask\",\"depthNear\",\"depthRange\",\"deref\",\"deriveBits\",\"deriveKey\",\"description\",\"deselectAll\",\"designMode\",\"desiredSize\",\"destination\",\"destinationURL\",\"detach\",\"detachEvent\",\"detachShader\",\"detail\",\"details\",\"detect\",\"detune\",\"device\",\"deviceClass\",\"deviceId\",\"deviceMemory\",\"devicePixelContentBoxSize\",\"devicePixelRatio\",\"deviceProtocol\",\"deviceSessionId\",\"deviceSubclass\",\"deviceVersionMajor\",\"deviceVersionMinor\",\"deviceVersionSubminor\",\"deviceXDPI\",\"deviceYDPI\",\"didTimeout\",\"diffuseConstant\",\"digest\",\"dimensions\",\"dir\",\"dirName\",\"dirXml\",\"direction\",\"dirxml\",\"disable\",\"disablePictureInPicture\",\"disableRemotePlayback\",\"disableVertexAttribArray\",\"disabled\",\"dischargingTime\",\"disconnect\",\"disconnectedCallback\",\"dispatch\",\"dispatchEvent\",\"dispatchToListener\",\"display\",\"displayId\",\"displayName\",\"disposition\",\"distanceModel\",\"div\",\"divisor\",\"djsapi\",\"djsproxy\",\"doImport\",\"doNotTrack\",\"doScroll\",\"doctype\",\"document\",\"documentElement\",\"documentMode\",\"documentURI\",\"dolphin\",\"dolphinGameCenter\",\"dolphininfo\",\"dolphinmeta\",\"domComplete\",\"domContentLoadedEventEnd\",\"domContentLoadedEventStart\",\"domInteractive\",\"domLoading\",\"domOverlayState\",\"domain\",\"domainLookupEnd\",\"domainLookupStart\",\"dominant-baseline\",\"dominantBaseline\",\"done\",\"dopplerFactor\",\"dotAll\",\"downDegrees\",\"downlink\",\"download\",\"downloadTotal\",\"downloaded\",\"dpcm\",\"dpi\",\"dppx\",\"dragDrop\",\"draggable\",\"drawArrays\",\"drawArraysInstanced\",\"drawArraysInstancedANGLE\",\"drawBuffers\",\"drawCustomFocusRing\",\"drawElements\",\"drawElementsInstanced\",\"drawElementsInstancedANGLE\",\"drawFocusIfNeeded\",\"drawImage\",\"drawImageFromRect\",\"drawRangeElements\",\"drawSystemFocusRing\",\"drawingBufferHeight\",\"drawingBufferWidth\",\"dropEffect\",\"droppedVideoFrames\",\"dropzone\",\"dtmf\",\"dump\",\"duplicate\",\"durability\",\"duration\",\"dvname\",\"dvnum\",\"dx\",\"dy\",\"dynsrc\",\"e\",\"edgeMode\",\"effect\",\"effectAllowed\",\"effectiveDirective\",\"effectiveType\",\"elapsedTime\",\"element\",\"elementFromPoint\",\"elementTiming\",\"elements\",\"elementsFromPoint\",\"elevation\",\"ellipse\",\"em\",\"emHeightAscent\",\"emHeightDescent\",\"email\",\"embeds\",\"emma\",\"empty\",\"empty-cells\",\"emptyCells\",\"emptyHTML\",\"emptyScript\",\"emulatedPosition\",\"enable\",\"enableBackground\",\"enableDelegations\",\"enableHighAccuracy\",\"enableStyleSheetsForSet\",\"enableVertexAttribArray\",\"enabled\",\"enabledPlugin\",\"encode\",\"encodeInto\",\"encodeURI\",\"encodeURIComponent\",\"encodedBodySize\",\"encoding\",\"encodingInfo\",\"encrypt\",\"enctype\",\"end\",\"endContainer\",\"endElement\",\"endElementAt\",\"endOfStream\",\"endOffset\",\"endQuery\",\"endTime\",\"endTransformFeedback\",\"ended\",\"endpoint\",\"endpointNumber\",\"endpoints\",\"endsWith\",\"enterKeyHint\",\"entities\",\"entries\",\"entryType\",\"enumerate\",\"enumerateDevices\",\"enumerateEditable\",\"environmentBlendMode\",\"epubCaptionSide\",\"epubTextCombine\",\"epubTextEmphasis\",\"epubTextEmphasisColor\",\"epubTextEmphasisStyle\",\"epubTextOrientation\",\"epubTextTransform\",\"epubWordBreak\",\"epubWritingMode\",\"equals\",\"era\",\"error\",\"errorCode\",\"errorDetail\",\"errorText\",\"escape\",\"estimate\",\"eval\",\"evaluate\",\"event\",\"eventPhase\",\"every\",\"ex\",\"exception\",\"exchange\",\"exec\",\"execCommand\",\"execCommandShowHelp\",\"execScript\",\"executeSql\",\"exitFullscreen\",\"exitPictureInPicture\",\"exitPointerLock\",\"exitPresent\",\"exp\",\"expand\",\"expandEntityReferences\",\"expando\",\"expansion\",\"expiration\",\"expirationTime\",\"expires\",\"expiryDate\",\"explicitOriginalTarget\",\"expm1\",\"exponent\",\"exponentialRampToValueAtTime\",\"exportKey\",\"exports\",\"extend\",\"extensions\",\"extentNode\",\"extentOffset\",\"external\",\"externalResourcesRequired\",\"extractContents\",\"extractable\",\"eye\",\"f\",\"face\",\"factoryReset\",\"failureReason\",\"fallback\",\"family\",\"familyName\",\"farthestViewportElement\",\"fastSeek\",\"fatal\",\"featurePolicy\",\"featureSettings\",\"features\",\"fenceSync\",\"fetch\",\"fetchStart\",\"fftSize\",\"fgColor\",\"fieldOfView\",\"file\",\"fileCreatedDate\",\"fileHandle\",\"fileModifiedDate\",\"fileName\",\"fileSize\",\"fileUpdatedDate\",\"filename\",\"files\",\"filesystem\",\"fill\",\"fill-opacity\",\"fill-rule\",\"fillLightMode\",\"fillOpacity\",\"fillRect\",\"fillRule\",\"fillStyle\",\"fillText\",\"filter\",\"filterResX\",\"filterResY\",\"filterUnits\",\"filters\",\"finally\",\"find\",\"findIndex\",\"findRule\",\"findText\",\"finish\",\"finishDocumentLoadTime\",\"finishLoadTime\",\"finished\",\"fireEvent\",\"firesTouchEvents\",\"first\",\"firstChild\",\"firstElementChild\",\"firstPage\",\"firstPaintAfterLoadTime\",\"firstPaintTime\",\"fixed\",\"flags\",\"flat\",\"flatMap\",\"flex\",\"flex-basis\",\"flex-direction\",\"flex-flow\",\"flex-grow\",\"flex-shrink\",\"flex-wrap\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"flipX\",\"flipY\",\"float\",\"flood-color\",\"flood-opacity\",\"floodColor\",\"floodOpacity\",\"floor\",\"flush\",\"focus\",\"focusNode\",\"focusOffset\",\"font\",\"font-family\",\"font-feature-settings\",\"font-kerning\",\"font-language-override\",\"font-size\",\"font-size-adjust\",\"font-stretch\",\"font-style\",\"font-synthesis\",\"font-variant\",\"font-variant-alternates\",\"font-variant-caps\",\"font-variant-east-asian\",\"font-variant-ligatures\",\"font-variant-numeric\",\"font-variant-position\",\"font-weight\",\"fontBoundingBoxAscent\",\"fontBoundingBoxDescent\",\"fontDisplay\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontLanguageOverride\",\"fontOpticalSizing\",\"fontSize\",\"fontSizeAdjust\",\"fontSmoothingEnabled\",\"fontStretch\",\"fontStyle\",\"fontSynthesis\",\"fontVariant\",\"fontVariantAlternates\",\"fontVariantCaps\",\"fontVariantEastAsian\",\"fontVariantLigatures\",\"fontVariantNumeric\",\"fontVariantPosition\",\"fontVariationSettings\",\"fontWeight\",\"fontcolor\",\"fontfaces\",\"fonts\",\"fontsize\",\"for\",\"forEach\",\"force\",\"forceRedraw\",\"form\",\"formAction\",\"formData\",\"formEnctype\",\"formMethod\",\"formNoValidate\",\"formTarget\",\"format\",\"formatRange\",\"formatRangeToParts\",\"formatToParts\",\"forms\",\"forward\",\"forwardX\",\"forwardY\",\"forwardZ\",\"foundation\",\"fr\",\"fragmentDirective\",\"frame\",\"frameBorder\",\"frameElement\",\"frameSpacing\",\"framebuffer\",\"framebufferHeight\",\"framebufferRenderbuffer\",\"framebufferTexture2D\",\"framebufferTextureLayer\",\"framebufferWidth\",\"frames\",\"freeSpace\",\"freeze\",\"frequency\",\"frequencyBinCount\",\"from\",\"fromCharCode\",\"fromCodePoint\",\"fromElement\",\"fromEntries\",\"fromFloat32Array\",\"fromFloat64Array\",\"fromMatrix\",\"fromPoint\",\"fromQuad\",\"fromRect\",\"frontFace\",\"fround\",\"fullPath\",\"fullScreen\",\"fullscreen\",\"fullscreenElement\",\"fullscreenEnabled\",\"fx\",\"fy\",\"gain\",\"gamepad\",\"gamma\",\"gap\",\"gatheringState\",\"gatt\",\"genderIdentity\",\"generateCertificate\",\"generateKey\",\"generateMipmap\",\"generateRequest\",\"geolocation\",\"gestureObject\",\"get\",\"getActiveAttrib\",\"getActiveUniform\",\"getActiveUniformBlockName\",\"getActiveUniformBlockParameter\",\"getActiveUniforms\",\"getAdditionalLanguages\",\"getAdjacentText\",\"getAll\",\"getAllKeys\",\"getAllResponseHeaders\",\"getAllowlistForFeature\",\"getAnimations\",\"getAsFile\",\"getAsString\",\"getAttachedShaders\",\"getAttribLocation\",\"getAttribute\",\"getAttributeNS\",\"getAttributeNames\",\"getAttributeNode\",\"getAttributeNodeNS\",\"getAttributeType\",\"getAudioTracks\",\"getAvailability\",\"getBBox\",\"getBattery\",\"getBigInt64\",\"getBigUint64\",\"getBlob\",\"getBookmark\",\"getBoundingClientRect\",\"getBounds\",\"getBufferParameter\",\"getBufferSubData\",\"getByteFrequencyData\",\"getByteTimeDomainData\",\"getCSSCanvasContext\",\"getCTM\",\"getCandidateWindowClientRect\",\"getCanonicalLocales\",\"getCapabilities\",\"getChannelData\",\"getCharNumAtPosition\",\"getCharacteristic\",\"getCharacteristics\",\"getClientExtensionResults\",\"getClientRect\",\"getClientRects\",\"getCoalescedEvents\",\"getCompositionAlternatives\",\"getComputedStyle\",\"getComputedTextLength\",\"getComputedTiming\",\"getConfiguration\",\"getConstraints\",\"getContext\",\"getContextAttributes\",\"getContributingSources\",\"getCount\",\"getCounterValue\",\"getCueAsHTML\",\"getCueById\",\"getCurrentPosition\",\"getCurrentTime\",\"getData\",\"getDatabaseNames\",\"getDate\",\"getDay\",\"getDefaultComputedStyle\",\"getDescriptor\",\"getDescriptors\",\"getDestinationInsertionPoints\",\"getDetails\",\"getDevices\",\"getDirectory\",\"getDisplayMedia\",\"getDistributedNodes\",\"getEditable\",\"getElementById\",\"getElementsByClassName\",\"getElementsByName\",\"getElementsByTagName\",\"getElementsByTagNameNS\",\"getEnclosureList\",\"getEndPositionOfChar\",\"getEntries\",\"getEntriesByName\",\"getEntriesByType\",\"getError\",\"getExtension\",\"getExtentOfChar\",\"getEyeParameters\",\"getFeature\",\"getFile\",\"getFiles\",\"getFilesAndDirectories\",\"getFingerprints\",\"getFloat32\",\"getFloat64\",\"getFloatFrequencyData\",\"getFloatTimeDomainData\",\"getFloatValue\",\"getFragDataLocation\",\"getFrameData\",\"getFramebufferAttachmentParameter\",\"getFrequencyResponse\",\"getFullYear\",\"getGamepads\",\"getHitTestResults\",\"getHitTestResultsForTransientInput\",\"getHours\",\"getIdentityAssertion\",\"getIds\",\"getImageData\",\"getIndexedParameter\",\"getInstalled\",\"getInstalledRelatedApps\",\"getInt16\",\"getInt32\",\"getInt8\",\"getInternalformatParameter\",\"getIntersectionList\",\"getIsInstalled\",\"getItem\",\"getItems\",\"getKey\",\"getKeyframes\",\"getLayers\",\"getLayoutMap\",\"getLineDash\",\"getLocalCandidates\",\"getLocalParameters\",\"getLocalStreams\",\"getLocalizationResource\",\"getMarks\",\"getMatchedCSSRules\",\"getMeasures\",\"getMetadata\",\"getMilliseconds\",\"getMinutes\",\"getModifierState\",\"getMonth\",\"getNamedItem\",\"getNamedItemNS\",\"getNativeFramebufferScaleFactor\",\"getNotifications\",\"getNotifier\",\"getNumberOfChars\",\"getOffsetReferenceSpace\",\"getOutputTimestamp\",\"getOverrideHistoryNavigationMode\",\"getOverrideStyle\",\"getOwnPropertyDescriptor\",\"getOwnPropertyDescriptors\",\"getOwnPropertyNames\",\"getOwnPropertySymbols\",\"getParameter\",\"getParameters\",\"getParent\",\"getPathSegAtLength\",\"getPhotoCapabilities\",\"getPhotoSettings\",\"getPointAtLength\",\"getPose\",\"getPredictedEvents\",\"getPreference\",\"getPreferenceDefault\",\"getPresentationAttribute\",\"getPreventDefault\",\"getPrimaryService\",\"getPrimaryServices\",\"getProgramInfoLog\",\"getProgramParameter\",\"getPropertyCSSValue\",\"getPropertyPriority\",\"getPropertyShorthand\",\"getPropertyType\",\"getPropertyValue\",\"getPrototypeOf\",\"getQuery\",\"getQueryParameter\",\"getRGBColorValue\",\"getRandomValues\",\"getRangeAt\",\"getReader\",\"getReceivers\",\"getRectValue\",\"getRegistration\",\"getRegistrations\",\"getRemoteCandidates\",\"getRemoteCertificates\",\"getRemoteParameters\",\"getRemoteStreams\",\"getRenderbufferParameter\",\"getResponseHeader\",\"getRevision\",\"getRoot\",\"getRootNode\",\"getRotationOfChar\",\"getRules\",\"getSVGDocument\",\"getSamplerParameter\",\"getScreenCTM\",\"getSeconds\",\"getSelectedCandidatePair\",\"getSelection\",\"getSelf\",\"getSenders\",\"getService\",\"getSettings\",\"getShaderInfoLog\",\"getShaderParameter\",\"getShaderPrecisionFormat\",\"getShaderSource\",\"getSimpleDuration\",\"getSiteIcons\",\"getSources\",\"getSpeculativeParserUrls\",\"getStartDate\",\"getStartPositionOfChar\",\"getStartTime\",\"getState\",\"getStats\",\"getStatusForPolicy\",\"getStorageUpdates\",\"getStreamById\",\"getStringValue\",\"getSubStringLength\",\"getSubscription\",\"getSupportedConstraints\",\"getSupportedExtensions\",\"getSupportedFormats\",\"getSyncParameter\",\"getSynchronizationSources\",\"getTags\",\"getTargetRanges\",\"getTexParameter\",\"getTime\",\"getTimezoneOffset\",\"getTiming\",\"getTotalLength\",\"getTrackById\",\"getTracks\",\"getTransceivers\",\"getTransform\",\"getTransformFeedbackVarying\",\"getTransformToElement\",\"getTransports\",\"getType\",\"getTypeMapping\",\"getUTCDate\",\"getUTCDay\",\"getUTCFullYear\",\"getUTCHours\",\"getUTCMilliseconds\",\"getUTCMinutes\",\"getUTCMonth\",\"getUTCSeconds\",\"getUint16\",\"getUint32\",\"getUint8\",\"getUniform\",\"getUniformBlockIndex\",\"getUniformIndices\",\"getUniformLocation\",\"getUserMedia\",\"getVRDisplays\",\"getValues\",\"getVarDate\",\"getVariableValue\",\"getVertexAttrib\",\"getVertexAttribOffset\",\"getVideoPlaybackQuality\",\"getVideoTracks\",\"getViewerPose\",\"getViewport\",\"getVoices\",\"getWakeLockState\",\"getWriter\",\"getYear\",\"givenName\",\"global\",\"globalAlpha\",\"globalCompositeOperation\",\"globalThis\",\"glyphOrientationHorizontal\",\"glyphOrientationVertical\",\"glyphRef\",\"go\",\"grabFrame\",\"grad\",\"gradientTransform\",\"gradientUnits\",\"grammars\",\"green\",\"grid\",\"grid-area\",\"grid-auto-columns\",\"grid-auto-flow\",\"grid-auto-rows\",\"grid-column\",\"grid-column-end\",\"grid-column-gap\",\"grid-column-start\",\"grid-gap\",\"grid-row\",\"grid-row-end\",\"grid-row-gap\",\"grid-row-start\",\"grid-template\",\"grid-template-areas\",\"grid-template-columns\",\"grid-template-rows\",\"gridArea\",\"gridAutoColumns\",\"gridAutoFlow\",\"gridAutoRows\",\"gridColumn\",\"gridColumnEnd\",\"gridColumnGap\",\"gridColumnStart\",\"gridGap\",\"gridRow\",\"gridRowEnd\",\"gridRowGap\",\"gridRowStart\",\"gridTemplate\",\"gridTemplateAreas\",\"gridTemplateColumns\",\"gridTemplateRows\",\"gripSpace\",\"group\",\"groupCollapsed\",\"groupEnd\",\"groupId\",\"grow\",\"hadRecentInput\",\"hand\",\"handedness\",\"hangingBaseline\",\"hangingPunctuation\",\"hapticActuators\",\"hardwareConcurrency\",\"has\",\"hasAttribute\",\"hasAttributeNS\",\"hasAttributes\",\"hasBeenActive\",\"hasChildNodes\",\"hasComposition\",\"hasEnrolledInstrument\",\"hasExtension\",\"hasExternalDisplay\",\"hasFeature\",\"hasFocus\",\"hasInstance\",\"hasLayout\",\"hasListener\",\"hasListeners\",\"hasOrientation\",\"hasOwnProperty\",\"hasPointerCapture\",\"hasPosition\",\"hasReading\",\"hasStorageAccess\",\"hash\",\"head\",\"headers\",\"heading\",\"height\",\"hidden\",\"hide\",\"hideFocus\",\"high\",\"highWaterMark\",\"hint\",\"history\",\"honorificPrefix\",\"honorificSuffix\",\"horizontalOverflow\",\"host\",\"hostCandidate\",\"hostname\",\"hour\",\"hour12\",\"hourCycle\",\"href\",\"hrefTranslate\",\"hreflang\",\"hspace\",\"html5TagCheckInerface\",\"htmlFor\",\"htmlText\",\"httpEquiv\",\"httpRequestStatusCode\",\"hwTimestamp\",\"hyphens\",\"hypot\",\"iccId\",\"iceConnectionState\",\"iceGatheringState\",\"iceTransport\",\"icon\",\"iconURL\",\"id\",\"identifier\",\"identity\",\"ideographicBaseline\",\"idpLoginUrl\",\"ignoreBOM\",\"ignoreCase\",\"ignoreDepthValues\",\"ignoreMutedMedia\",\"ignorePunctuation\",\"image-orientation\",\"image-rendering\",\"imageHeight\",\"imageOrientation\",\"imageRendering\",\"imageSizes\",\"imageSmoothingEnabled\",\"imageSmoothingQuality\",\"imageSrcset\",\"imageWidth\",\"images\",\"ime-mode\",\"imeMode\",\"implementation\",\"import\",\"importKey\",\"importNode\",\"importStylesheet\",\"imports\",\"impp\",\"imul\",\"in\",\"in1\",\"in2\",\"inBandMetadataTrackDispatchType\",\"inRange\",\"includes\",\"incremental\",\"indeterminate\",\"index\",\"indexNames\",\"indexOf\",\"indexedDB\",\"indicate\",\"inertiaDestinationX\",\"inertiaDestinationY\",\"info\",\"init\",\"initAnimationEvent\",\"initBeforeLoadEvent\",\"initClipboardEvent\",\"initCloseEvent\",\"initCommandEvent\",\"initCompositionEvent\",\"initCustomEvent\",\"initData\",\"initDataType\",\"initDeviceMotionEvent\",\"initDeviceOrientationEvent\",\"initDragEvent\",\"initErrorEvent\",\"initEvent\",\"initFocusEvent\",\"initGestureEvent\",\"initHashChangeEvent\",\"initKeyEvent\",\"initKeyboardEvent\",\"initMSManipulationEvent\",\"initMessageEvent\",\"initMouseEvent\",\"initMouseScrollEvent\",\"initMouseWheelEvent\",\"initMutationEvent\",\"initNSMouseEvent\",\"initOverflowEvent\",\"initPageEvent\",\"initPageTransitionEvent\",\"initPointerEvent\",\"initPopStateEvent\",\"initProgressEvent\",\"initScrollAreaEvent\",\"initSimpleGestureEvent\",\"initStorageEvent\",\"initTextEvent\",\"initTimeEvent\",\"initTouchEvent\",\"initTransitionEvent\",\"initUIEvent\",\"initWebKitAnimationEvent\",\"initWebKitTransitionEvent\",\"initWebKitWheelEvent\",\"initWheelEvent\",\"initialTime\",\"initialize\",\"initiatorType\",\"inline-size\",\"inlineSize\",\"inlineVerticalFieldOfView\",\"inner\",\"innerHTML\",\"innerHeight\",\"innerText\",\"innerWidth\",\"input\",\"inputBuffer\",\"inputEncoding\",\"inputMethod\",\"inputMode\",\"inputSource\",\"inputSources\",\"inputType\",\"inputs\",\"insertAdjacentElement\",\"insertAdjacentHTML\",\"insertAdjacentText\",\"insertBefore\",\"insertCell\",\"insertDTMF\",\"insertData\",\"insertId\",\"insertItemBefore\",\"insertNode\",\"insertRow\",\"insertRule\",\"inset\",\"inset-block\",\"inset-block-end\",\"inset-block-start\",\"inset-inline\",\"inset-inline-end\",\"inset-inline-start\",\"insetBlock\",\"insetBlockEnd\",\"insetBlockStart\",\"insetInline\",\"insetInlineEnd\",\"insetInlineStart\",\"install\",\"installChrome\",\"installPackage\",\"installState\",\"installing\",\"instanceRoot\",\"instantiate\",\"instantiateStreaming\",\"instruments\",\"integrity\",\"interactionMode\",\"intercept\",\"interfaceClass\",\"interfaceName\",\"interfaceNumber\",\"interfaceProtocol\",\"interfaceSubclass\",\"interfaces\",\"interimResults\",\"internalSubset\",\"interpretation\",\"intersectionRatio\",\"intersectionRect\",\"intersectsNode\",\"interval\",\"invalidIteratorState\",\"invalidateFramebuffer\",\"invalidateSubFramebuffer\",\"inverse\",\"invertSelf\",\"is\",\"is2D\",\"isActive\",\"isAlternate\",\"isArray\",\"isBingCurrentSearchDefault\",\"isBuffer\",\"isCandidateWindowVisible\",\"isChar\",\"isCollapsed\",\"isComposing\",\"isConcatSpreadable\",\"isConnected\",\"isContentEditable\",\"isContentHandlerRegistered\",\"isContextLost\",\"isDefaultNamespace\",\"isDirectory\",\"isDisabled\",\"isEnabled\",\"isEqual\",\"isEqualNode\",\"isExtensible\",\"isExternalCTAP2SecurityKeySupported\",\"isFile\",\"isFinite\",\"isFramebuffer\",\"isFrozen\",\"isGenerator\",\"isHTML\",\"isHistoryNavigation\",\"isId\",\"isIdentity\",\"isInjected\",\"isInstalled\",\"isInteger\",\"isIntersecting\",\"isLockFree\",\"isMap\",\"isMultiLine\",\"isNaN\",\"isOpen\",\"isPointInFill\",\"isPointInPath\",\"isPointInRange\",\"isPointInStroke\",\"isPrefAlternate\",\"isPresenting\",\"isPrimary\",\"isProgram\",\"isPropertyImplicit\",\"isProtocolHandlerRegistered\",\"isPrototypeOf\",\"isQuery\",\"isRenderbuffer\",\"isSafeInteger\",\"isSameNode\",\"isSampler\",\"isScript\",\"isScriptURL\",\"isSealed\",\"isSecureContext\",\"isSessionSupported\",\"isShader\",\"isSupported\",\"isSync\",\"isTextEdit\",\"isTexture\",\"isTransformFeedback\",\"isTrusted\",\"isTypeSupported\",\"isTypeSupportedWithFeatures\",\"isUserVerifyingPlatformAuthenticatorAvailable\",\"isVertexArray\",\"isView\",\"isVisible\",\"isochronousTransferIn\",\"isochronousTransferOut\",\"isolation\",\"italics\",\"item\",\"itemId\",\"itemProp\",\"itemRef\",\"itemScope\",\"itemType\",\"itemValue\",\"items\",\"iterateNext\",\"iterator\",\"javaEnabled\",\"jobTitle\",\"join\",\"jsHeapSizeLimit\",\"json\",\"justify-content\",\"justify-items\",\"justify-self\",\"justifyContent\",\"justifyItems\",\"justifySelf\",\"k1\",\"k2\",\"k3\",\"k4\",\"kHz\",\"keepalive\",\"kernelMatrix\",\"kernelUnitLengthX\",\"kernelUnitLengthY\",\"kerning\",\"key\",\"keyCode\",\"keyFor\",\"keyIdentifier\",\"keyLightEnabled\",\"keyLocation\",\"keyPath\",\"keyStatuses\",\"keySystem\",\"keyText\",\"keyUsage\",\"keyboard\",\"keys\",\"keytype\",\"kind\",\"knee\",\"label\",\"labels\",\"lang\",\"language\",\"languages\",\"largeArcFlag\",\"lastActivePanel\",\"lastChild\",\"lastElementChild\",\"lastEventId\",\"lastIndex\",\"lastIndexOf\",\"lastInputTime\",\"lastMatch\",\"lastMessageSubject\",\"lastMessageType\",\"lastModified\",\"lastModifiedDate\",\"lastPage\",\"lastParen\",\"lastState\",\"lastStyleSheetSet\",\"latitude\",\"layerX\",\"layerY\",\"layoutFlow\",\"layoutGrid\",\"layoutGridChar\",\"layoutGridLine\",\"layoutGridMode\",\"layoutGridType\",\"lbound\",\"left\",\"leftContext\",\"leftDegrees\",\"leftMargin\",\"leftProjectionMatrix\",\"leftViewMatrix\",\"length\",\"lengthAdjust\",\"lengthComputable\",\"letter-spacing\",\"letterSpacing\",\"level\",\"lighting-color\",\"lightingColor\",\"limitingConeAngle\",\"line\",\"line-break\",\"line-height\",\"lineAlign\",\"lineBreak\",\"lineCap\",\"lineDashOffset\",\"lineHeight\",\"lineJoin\",\"lineNumber\",\"lineTo\",\"lineWidth\",\"linearAcceleration\",\"linearRampToValueAtTime\",\"linearVelocity\",\"lineno\",\"lines\",\"link\",\"linkColor\",\"linkProgram\",\"links\",\"list\",\"list-style\",\"list-style-image\",\"list-style-position\",\"list-style-type\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"listener\",\"load\",\"loadEventEnd\",\"loadEventStart\",\"loadTime\",\"loadTimes\",\"loaded\",\"loading\",\"localDescription\",\"localName\",\"localService\",\"localStorage\",\"locale\",\"localeCompare\",\"location\",\"locationbar\",\"lock\",\"locked\",\"lockedFile\",\"locks\",\"log\",\"log10\",\"log1p\",\"log2\",\"logicalXDPI\",\"logicalYDPI\",\"longDesc\",\"longitude\",\"lookupNamespaceURI\",\"lookupPrefix\",\"loop\",\"loopEnd\",\"loopStart\",\"looping\",\"low\",\"lower\",\"lowerBound\",\"lowerOpen\",\"lowsrc\",\"m11\",\"m12\",\"m13\",\"m14\",\"m21\",\"m22\",\"m23\",\"m24\",\"m31\",\"m32\",\"m33\",\"m34\",\"m41\",\"m42\",\"m43\",\"m44\",\"makeXRCompatible\",\"manifest\",\"manufacturer\",\"manufacturerName\",\"map\",\"mapping\",\"margin\",\"margin-block\",\"margin-block-end\",\"margin-block-start\",\"margin-bottom\",\"margin-inline\",\"margin-inline-end\",\"margin-inline-start\",\"margin-left\",\"margin-right\",\"margin-top\",\"marginBlock\",\"marginBlockEnd\",\"marginBlockStart\",\"marginBottom\",\"marginHeight\",\"marginInline\",\"marginInlineEnd\",\"marginInlineStart\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marginWidth\",\"mark\",\"markTimeline\",\"marker\",\"marker-end\",\"marker-mid\",\"marker-offset\",\"marker-start\",\"markerEnd\",\"markerHeight\",\"markerMid\",\"markerOffset\",\"markerStart\",\"markerUnits\",\"markerWidth\",\"marks\",\"mask\",\"mask-clip\",\"mask-composite\",\"mask-image\",\"mask-mode\",\"mask-origin\",\"mask-position\",\"mask-position-x\",\"mask-position-y\",\"mask-repeat\",\"mask-size\",\"mask-type\",\"maskClip\",\"maskComposite\",\"maskContentUnits\",\"maskImage\",\"maskMode\",\"maskOrigin\",\"maskPosition\",\"maskPositionX\",\"maskPositionY\",\"maskRepeat\",\"maskSize\",\"maskType\",\"maskUnits\",\"match\",\"matchAll\",\"matchMedia\",\"matchMedium\",\"matches\",\"matrix\",\"matrixTransform\",\"max\",\"max-block-size\",\"max-height\",\"max-inline-size\",\"max-width\",\"maxActions\",\"maxAlternatives\",\"maxBlockSize\",\"maxChannelCount\",\"maxChannels\",\"maxConnectionsPerServer\",\"maxDecibels\",\"maxDistance\",\"maxHeight\",\"maxInlineSize\",\"maxLayers\",\"maxLength\",\"maxMessageSize\",\"maxPacketLifeTime\",\"maxRetransmits\",\"maxTouchPoints\",\"maxValue\",\"maxWidth\",\"maxZoom\",\"maximize\",\"maximumAge\",\"maximumFractionDigits\",\"measure\",\"measureText\",\"media\",\"mediaCapabilities\",\"mediaDevices\",\"mediaElement\",\"mediaGroup\",\"mediaKeys\",\"mediaSession\",\"mediaStream\",\"mediaText\",\"meetOrSlice\",\"memory\",\"menubar\",\"mergeAttributes\",\"message\",\"messageClass\",\"messageHandlers\",\"messageType\",\"metaKey\",\"metadata\",\"method\",\"methodDetails\",\"methodName\",\"mid\",\"mimeType\",\"mimeTypes\",\"min\",\"min-block-size\",\"min-height\",\"min-inline-size\",\"min-width\",\"minBlockSize\",\"minDecibels\",\"minHeight\",\"minInlineSize\",\"minLength\",\"minValue\",\"minWidth\",\"minZoom\",\"minimize\",\"minimumFractionDigits\",\"minimumIntegerDigits\",\"minute\",\"miterLimit\",\"mix-blend-mode\",\"mixBlendMode\",\"mm\",\"mode\",\"modify\",\"month\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"mount\",\"move\",\"moveBy\",\"moveEnd\",\"moveFirst\",\"moveFocusDown\",\"moveFocusLeft\",\"moveFocusRight\",\"moveFocusUp\",\"moveNext\",\"moveRow\",\"moveStart\",\"moveTo\",\"moveToBookmark\",\"moveToElementText\",\"moveToPoint\",\"movementX\",\"movementY\",\"mozAdd\",\"mozAnimationStartTime\",\"mozAnon\",\"mozApps\",\"mozAudioCaptured\",\"mozAudioChannelType\",\"mozAutoplayEnabled\",\"mozCancelAnimationFrame\",\"mozCancelFullScreen\",\"mozCancelRequestAnimationFrame\",\"mozCaptureStream\",\"mozCaptureStreamUntilEnded\",\"mozClearDataAt\",\"mozContact\",\"mozContacts\",\"mozCreateFileHandle\",\"mozCurrentTransform\",\"mozCurrentTransformInverse\",\"mozCursor\",\"mozDash\",\"mozDashOffset\",\"mozDecodedFrames\",\"mozExitPointerLock\",\"mozFillRule\",\"mozFragmentEnd\",\"mozFrameDelay\",\"mozFullScreen\",\"mozFullScreenElement\",\"mozFullScreenEnabled\",\"mozGetAll\",\"mozGetAllKeys\",\"mozGetAsFile\",\"mozGetDataAt\",\"mozGetMetadata\",\"mozGetUserMedia\",\"mozHasAudio\",\"mozHasItem\",\"mozHidden\",\"mozImageSmoothingEnabled\",\"mozIndexedDB\",\"mozInnerScreenX\",\"mozInnerScreenY\",\"mozInputSource\",\"mozIsTextField\",\"mozItem\",\"mozItemCount\",\"mozItems\",\"mozLength\",\"mozLockOrientation\",\"mozMatchesSelector\",\"mozMovementX\",\"mozMovementY\",\"mozOpaque\",\"mozOrientation\",\"mozPaintCount\",\"mozPaintedFrames\",\"mozParsedFrames\",\"mozPay\",\"mozPointerLockElement\",\"mozPresentedFrames\",\"mozPreservesPitch\",\"mozPressure\",\"mozPrintCallback\",\"mozRTCIceCandidate\",\"mozRTCPeerConnection\",\"mozRTCSessionDescription\",\"mozRemove\",\"mozRequestAnimationFrame\",\"mozRequestFullScreen\",\"mozRequestPointerLock\",\"mozSetDataAt\",\"mozSetImageElement\",\"mozSourceNode\",\"mozSrcObject\",\"mozSystem\",\"mozTCPSocket\",\"mozTextStyle\",\"mozTypesAt\",\"mozUnlockOrientation\",\"mozUserCancelled\",\"mozVisibilityState\",\"ms\",\"msAnimation\",\"msAnimationDelay\",\"msAnimationDirection\",\"msAnimationDuration\",\"msAnimationFillMode\",\"msAnimationIterationCount\",\"msAnimationName\",\"msAnimationPlayState\",\"msAnimationStartTime\",\"msAnimationTimingFunction\",\"msBackfaceVisibility\",\"msBlockProgression\",\"msCSSOMElementFloatMetrics\",\"msCaching\",\"msCachingEnabled\",\"msCancelRequestAnimationFrame\",\"msCapsLockWarningOff\",\"msClearImmediate\",\"msClose\",\"msContentZoomChaining\",\"msContentZoomFactor\",\"msContentZoomLimit\",\"msContentZoomLimitMax\",\"msContentZoomLimitMin\",\"msContentZoomSnap\",\"msContentZoomSnapPoints\",\"msContentZoomSnapType\",\"msContentZooming\",\"msConvertURL\",\"msCrypto\",\"msDoNotTrack\",\"msElementsFromPoint\",\"msElementsFromRect\",\"msExitFullscreen\",\"msExtendedCode\",\"msFillRule\",\"msFirstPaint\",\"msFlex\",\"msFlexAlign\",\"msFlexDirection\",\"msFlexFlow\",\"msFlexItemAlign\",\"msFlexLinePack\",\"msFlexNegative\",\"msFlexOrder\",\"msFlexPack\",\"msFlexPositive\",\"msFlexPreferredSize\",\"msFlexWrap\",\"msFlowFrom\",\"msFlowInto\",\"msFontFeatureSettings\",\"msFullscreenElement\",\"msFullscreenEnabled\",\"msGetInputContext\",\"msGetRegionContent\",\"msGetUntransformedBounds\",\"msGraphicsTrustStatus\",\"msGridColumn\",\"msGridColumnAlign\",\"msGridColumnSpan\",\"msGridColumns\",\"msGridRow\",\"msGridRowAlign\",\"msGridRowSpan\",\"msGridRows\",\"msHidden\",\"msHighContrastAdjust\",\"msHyphenateLimitChars\",\"msHyphenateLimitLines\",\"msHyphenateLimitZone\",\"msHyphens\",\"msImageSmoothingEnabled\",\"msImeAlign\",\"msIndexedDB\",\"msInterpolationMode\",\"msIsStaticHTML\",\"msKeySystem\",\"msKeys\",\"msLaunchUri\",\"msLockOrientation\",\"msManipulationViewsEnabled\",\"msMatchMedia\",\"msMatchesSelector\",\"msMaxTouchPoints\",\"msOrientation\",\"msOverflowStyle\",\"msPerspective\",\"msPerspectiveOrigin\",\"msPlayToDisabled\",\"msPlayToPreferredSourceUri\",\"msPlayToPrimary\",\"msPointerEnabled\",\"msRegionOverflow\",\"msReleasePointerCapture\",\"msRequestAnimationFrame\",\"msRequestFullscreen\",\"msSaveBlob\",\"msSaveOrOpenBlob\",\"msScrollChaining\",\"msScrollLimit\",\"msScrollLimitXMax\",\"msScrollLimitXMin\",\"msScrollLimitYMax\",\"msScrollLimitYMin\",\"msScrollRails\",\"msScrollSnapPointsX\",\"msScrollSnapPointsY\",\"msScrollSnapType\",\"msScrollSnapX\",\"msScrollSnapY\",\"msScrollTranslation\",\"msSetImmediate\",\"msSetMediaKeys\",\"msSetPointerCapture\",\"msTextCombineHorizontal\",\"msTextSizeAdjust\",\"msToBlob\",\"msTouchAction\",\"msTouchSelect\",\"msTraceAsyncCallbackCompleted\",\"msTraceAsyncCallbackStarting\",\"msTraceAsyncOperationCompleted\",\"msTraceAsyncOperationStarting\",\"msTransform\",\"msTransformOrigin\",\"msTransformStyle\",\"msTransition\",\"msTransitionDelay\",\"msTransitionDuration\",\"msTransitionProperty\",\"msTransitionTimingFunction\",\"msUnlockOrientation\",\"msUpdateAsyncCallbackRelation\",\"msUserSelect\",\"msVisibilityState\",\"msWrapFlow\",\"msWrapMargin\",\"msWrapThrough\",\"msWriteProfilerMark\",\"msZoom\",\"msZoomTo\",\"mt\",\"mul\",\"multiEntry\",\"multiSelectionObj\",\"multiline\",\"multiple\",\"multiply\",\"multiplySelf\",\"mutableFile\",\"muted\",\"n\",\"name\",\"nameProp\",\"namedItem\",\"namedRecordset\",\"names\",\"namespaceURI\",\"namespaces\",\"naturalHeight\",\"naturalWidth\",\"navigate\",\"navigation\",\"navigationMode\",\"navigationPreload\",\"navigationStart\",\"navigationType\",\"navigator\",\"near\",\"nearestViewportElement\",\"negative\",\"negotiated\",\"netscape\",\"networkState\",\"newScale\",\"newTranslate\",\"newURL\",\"newValue\",\"newValueSpecifiedUnits\",\"newVersion\",\"newhome\",\"next\",\"nextElementSibling\",\"nextHopProtocol\",\"nextNode\",\"nextPage\",\"nextSibling\",\"nickname\",\"noHref\",\"noModule\",\"noResize\",\"noShade\",\"noValidate\",\"noWrap\",\"node\",\"nodeName\",\"nodeType\",\"nodeValue\",\"nonce\",\"normalize\",\"normalizedPathSegList\",\"notationName\",\"notations\",\"note\",\"noteGrainOn\",\"noteOff\",\"noteOn\",\"notify\",\"now\",\"npnNegotiatedProtocol\",\"numOctaves\",\"number\",\"numberOfChannels\",\"numberOfInputs\",\"numberOfItems\",\"numberOfOutputs\",\"numberValue\",\"numberingSystem\",\"numeric\",\"oMatchesSelector\",\"object\",\"object-fit\",\"object-position\",\"objectFit\",\"objectPosition\",\"objectStore\",\"objectStoreNames\",\"observe\",\"observedAttributes\",\"of\",\"offscreenBuffering\",\"offset\",\"offset-anchor\",\"offset-block-end\",\"offset-block-start\",\"offset-distance\",\"offset-inline-end\",\"offset-inline-start\",\"offset-path\",\"offset-rotate\",\"offsetAnchor\",\"offsetBlockEnd\",\"offsetBlockStart\",\"offsetDistance\",\"offsetHeight\",\"offsetInlineEnd\",\"offsetInlineStart\",\"offsetLeft\",\"offsetNode\",\"offsetParent\",\"offsetPath\",\"offsetRotate\",\"offsetTop\",\"offsetWidth\",\"offsetX\",\"offsetY\",\"ok\",\"oldURL\",\"oldValue\",\"oldVersion\",\"olderShadowRoot\",\"onDownloadProgress\",\"onInstallStageChanged\",\"onLine\",\"onabort\",\"onabsolutedeviceorientation\",\"onactivate\",\"onactive\",\"onaddsourcebuffer\",\"onaddstream\",\"onaddtrack\",\"onafterprint\",\"onafterscriptexecute\",\"onafterupdate\",\"onanimationcancel\",\"onanimationend\",\"onanimationiteration\",\"onanimationstart\",\"onappinstalled\",\"onaudioend\",\"onaudioprocess\",\"onaudiostart\",\"onautocomplete\",\"onautocompleteerror\",\"onauxclick\",\"onbeforeactivate\",\"onbeforecopy\",\"onbeforecut\",\"onbeforedeactivate\",\"onbeforeeditfocus\",\"onbeforeinput\",\"onbeforeinstallprompt\",\"onbeforeload\",\"onbeforepaste\",\"onbeforeprint\",\"onbeforescriptexecute\",\"onbeforeunload\",\"onbeforeupdate\",\"onbeforexrselect\",\"onbegin\",\"onblocked\",\"onblur\",\"onbounce\",\"onboundary\",\"onbufferedamountlow\",\"oncached\",\"oncancel\",\"oncandidatewindowhide\",\"oncandidatewindowshow\",\"oncandidatewindowupdate\",\"oncanplay\",\"oncanplaythrough\",\"once\",\"oncellchange\",\"onchange\",\"oncharacteristicvaluechanged\",\"onchargingchange\",\"onchargingtimechange\",\"onchecking\",\"onclick\",\"onclose\",\"onclosing\",\"oncompassneedscalibration\",\"oncomplete\",\"onconnect\",\"onconnecting\",\"onconnectionavailable\",\"onconnectionstatechange\",\"oncontactchange\",\"oncontextmenu\",\"oncontrollerchange\",\"oncontrolselect\",\"oncopy\",\"oncuechange\",\"oncut\",\"ondataavailable\",\"ondatachannel\",\"ondatasetchanged\",\"ondatasetcomplete\",\"ondblclick\",\"ondeactivate\",\"ondevicechange\",\"ondevicelight\",\"ondevicemotion\",\"ondeviceorientation\",\"ondeviceorientationabsolute\",\"ondeviceproximity\",\"ondischargingtimechange\",\"ondisconnect\",\"ondisplay\",\"ondownloading\",\"ondrag\",\"ondragend\",\"ondragenter\",\"ondragexit\",\"ondragleave\",\"ondragover\",\"ondragstart\",\"ondrop\",\"ondurationchange\",\"onemptied\",\"onencrypted\",\"onend\",\"onended\",\"onenter\",\"onenterpictureinpicture\",\"onerror\",\"onerrorupdate\",\"onexit\",\"onfilterchange\",\"onfinish\",\"onfocus\",\"onfocusin\",\"onfocusout\",\"onformdata\",\"onfreeze\",\"onfullscreenchange\",\"onfullscreenerror\",\"ongatheringstatechange\",\"ongattserverdisconnected\",\"ongesturechange\",\"ongestureend\",\"ongesturestart\",\"ongotpointercapture\",\"onhashchange\",\"onhelp\",\"onicecandidate\",\"onicecandidateerror\",\"oniceconnectionstatechange\",\"onicegatheringstatechange\",\"oninactive\",\"oninput\",\"oninputsourceschange\",\"oninvalid\",\"onkeydown\",\"onkeypress\",\"onkeystatuseschange\",\"onkeyup\",\"onlanguagechange\",\"onlayoutcomplete\",\"onleavepictureinpicture\",\"onlevelchange\",\"onload\",\"onloadT\",\"onloadeddata\",\"onloadedmetadata\",\"onloadend\",\"onloading\",\"onloadingdone\",\"onloadingerror\",\"onloadstart\",\"onlosecapture\",\"onlostpointercapture\",\"only\",\"onmark\",\"onmessage\",\"onmessageerror\",\"onmidimessage\",\"onmousedown\",\"onmouseenter\",\"onmouseleave\",\"onmousemove\",\"onmouseout\",\"onmouseover\",\"onmouseup\",\"onmousewheel\",\"onmove\",\"onmoveend\",\"onmovestart\",\"onmozfullscreenchange\",\"onmozfullscreenerror\",\"onmozorientationchange\",\"onmozpointerlockchange\",\"onmozpointerlockerror\",\"onmscontentzoom\",\"onmsfullscreenchange\",\"onmsfullscreenerror\",\"onmsgesturechange\",\"onmsgesturedoubletap\",\"onmsgestureend\",\"onmsgesturehold\",\"onmsgesturestart\",\"onmsgesturetap\",\"onmsgotpointercapture\",\"onmsinertiastart\",\"onmslostpointercapture\",\"onmsmanipulationstatechanged\",\"onmsneedkey\",\"onmsorientationchange\",\"onmspointercancel\",\"onmspointerdown\",\"onmspointerenter\",\"onmspointerhover\",\"onmspointerleave\",\"onmspointermove\",\"onmspointerout\",\"onmspointerover\",\"onmspointerup\",\"onmssitemodejumplistitemremoved\",\"onmsthumbnailclick\",\"onmute\",\"onnegotiationneeded\",\"onnomatch\",\"onnoupdate\",\"onobsolete\",\"onoffline\",\"ononline\",\"onopen\",\"onorientationchange\",\"onoverconstrained\",\"onpage\",\"onpagechange\",\"onpagehide\",\"onpageshow\",\"onpaste\",\"onpause\",\"onpayerdetailchange\",\"onpaymentmethodchange\",\"onplay\",\"onplaying\",\"onpluginstreamstart\",\"onpointercancel\",\"onpointerdown\",\"onpointerenter\",\"onpointerleave\",\"onpointerlockchange\",\"onpointerlockerror\",\"onpointermove\",\"onpointerout\",\"onpointerover\",\"onpointerrawupdate\",\"onpointerup\",\"onpopstate\",\"onprocessorerror\",\"onprogress\",\"onpropertychange\",\"onratechange\",\"onreading\",\"onreadystatechange\",\"onrejectionhandled\",\"onrelease\",\"onremove\",\"onremovesourcebuffer\",\"onremovestream\",\"onremovetrack\",\"onrepeat\",\"onreset\",\"onresize\",\"onresizeend\",\"onresizestart\",\"onresourcetimingbufferfull\",\"onresult\",\"onresume\",\"onrowenter\",\"onrowexit\",\"onrowsdelete\",\"onrowsinserted\",\"onscroll\",\"onsearch\",\"onsecuritypolicyviolation\",\"onseeked\",\"onseeking\",\"onselect\",\"onselectedcandidatepairchange\",\"onselectend\",\"onselectionchange\",\"onselectstart\",\"onshippingaddresschange\",\"onshippingoptionchange\",\"onshow\",\"onsignalingstatechange\",\"onsoundend\",\"onsoundstart\",\"onsourceclose\",\"onsourceclosed\",\"onsourceended\",\"onsourceopen\",\"onspeechend\",\"onspeechstart\",\"onsqueeze\",\"onsqueezeend\",\"onsqueezestart\",\"onstalled\",\"onstart\",\"onstatechange\",\"onstop\",\"onstorage\",\"onstoragecommit\",\"onsubmit\",\"onsuccess\",\"onsuspend\",\"onterminate\",\"ontextinput\",\"ontimeout\",\"ontimeupdate\",\"ontoggle\",\"ontonechange\",\"ontouchcancel\",\"ontouchend\",\"ontouchmove\",\"ontouchstart\",\"ontrack\",\"ontransitioncancel\",\"ontransitionend\",\"ontransitionrun\",\"ontransitionstart\",\"onunhandledrejection\",\"onunload\",\"onunmute\",\"onupdate\",\"onupdateend\",\"onupdatefound\",\"onupdateready\",\"onupdatestart\",\"onupgradeneeded\",\"onuserproximity\",\"onversionchange\",\"onvisibilitychange\",\"onvoiceschanged\",\"onvolumechange\",\"onvrdisplayactivate\",\"onvrdisplayconnect\",\"onvrdisplaydeactivate\",\"onvrdisplaydisconnect\",\"onvrdisplaypresentchange\",\"onwaiting\",\"onwaitingforkey\",\"onwarning\",\"onwebkitanimationend\",\"onwebkitanimationiteration\",\"onwebkitanimationstart\",\"onwebkitcurrentplaybacktargetiswirelesschanged\",\"onwebkitfullscreenchange\",\"onwebkitfullscreenerror\",\"onwebkitkeyadded\",\"onwebkitkeyerror\",\"onwebkitkeymessage\",\"onwebkitmouseforcechanged\",\"onwebkitmouseforcedown\",\"onwebkitmouseforceup\",\"onwebkitmouseforcewillbegin\",\"onwebkitneedkey\",\"onwebkitorientationchange\",\"onwebkitplaybacktargetavailabilitychanged\",\"onwebkitpointerlockchange\",\"onwebkitpointerlockerror\",\"onwebkitresourcetimingbufferfull\",\"onwebkittransitionend\",\"onwheel\",\"onzoom\",\"opacity\",\"open\",\"openCursor\",\"openDatabase\",\"openKeyCursor\",\"opened\",\"opener\",\"opera\",\"operationType\",\"operator\",\"opr\",\"opsProfile\",\"optimum\",\"options\",\"or\",\"order\",\"orderX\",\"orderY\",\"ordered\",\"org\",\"organization\",\"orient\",\"orientAngle\",\"orientType\",\"orientation\",\"orientationX\",\"orientationY\",\"orientationZ\",\"origin\",\"originalPolicy\",\"originalTarget\",\"orphans\",\"oscpu\",\"outcome\",\"outerHTML\",\"outerHeight\",\"outerText\",\"outerWidth\",\"outline\",\"outline-color\",\"outline-offset\",\"outline-style\",\"outline-width\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"outputBuffer\",\"outputLatency\",\"outputs\",\"overflow\",\"overflow-anchor\",\"overflow-block\",\"overflow-inline\",\"overflow-wrap\",\"overflow-x\",\"overflow-y\",\"overflowAnchor\",\"overflowBlock\",\"overflowInline\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"overrideMimeType\",\"oversample\",\"overscroll-behavior\",\"overscroll-behavior-block\",\"overscroll-behavior-inline\",\"overscroll-behavior-x\",\"overscroll-behavior-y\",\"overscrollBehavior\",\"overscrollBehaviorBlock\",\"overscrollBehaviorInline\",\"overscrollBehaviorX\",\"overscrollBehaviorY\",\"ownKeys\",\"ownerDocument\",\"ownerElement\",\"ownerNode\",\"ownerRule\",\"ownerSVGElement\",\"owningElement\",\"p1\",\"p2\",\"p3\",\"p4\",\"packetSize\",\"packets\",\"pad\",\"padEnd\",\"padStart\",\"padding\",\"padding-block\",\"padding-block-end\",\"padding-block-start\",\"padding-bottom\",\"padding-inline\",\"padding-inline-end\",\"padding-inline-start\",\"padding-left\",\"padding-right\",\"padding-top\",\"paddingBlock\",\"paddingBlockEnd\",\"paddingBlockStart\",\"paddingBottom\",\"paddingInline\",\"paddingInlineEnd\",\"paddingInlineStart\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"page-break-after\",\"page-break-before\",\"page-break-inside\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"pageCount\",\"pageLeft\",\"pageT\",\"pageTop\",\"pageX\",\"pageXOffset\",\"pageY\",\"pageYOffset\",\"pages\",\"paint-order\",\"paintOrder\",\"paintRequests\",\"paintType\",\"paintWorklet\",\"palette\",\"pan\",\"panningModel\",\"parameters\",\"parent\",\"parentElement\",\"parentNode\",\"parentRule\",\"parentStyleSheet\",\"parentTextEdit\",\"parentWindow\",\"parse\",\"parseAll\",\"parseFloat\",\"parseFromString\",\"parseInt\",\"part\",\"participants\",\"passive\",\"password\",\"pasteHTML\",\"path\",\"pathLength\",\"pathSegList\",\"pathSegType\",\"pathSegTypeAsLetter\",\"pathname\",\"pattern\",\"patternContentUnits\",\"patternMismatch\",\"patternTransform\",\"patternUnits\",\"pause\",\"pauseAnimations\",\"pauseOnExit\",\"pauseTransformFeedback\",\"paused\",\"payerEmail\",\"payerName\",\"payerPhone\",\"paymentManager\",\"pc\",\"peerIdentity\",\"pending\",\"pendingLocalDescription\",\"pendingRemoteDescription\",\"percent\",\"performance\",\"periodicSync\",\"permission\",\"permissionState\",\"permissions\",\"persist\",\"persisted\",\"personalbar\",\"perspective\",\"perspective-origin\",\"perspectiveOrigin\",\"perspectiveOriginX\",\"perspectiveOriginY\",\"phone\",\"phoneticFamilyName\",\"phoneticGivenName\",\"photo\",\"pictureInPictureElement\",\"pictureInPictureEnabled\",\"pictureInPictureWindow\",\"ping\",\"pipeThrough\",\"pipeTo\",\"pitch\",\"pixelBottom\",\"pixelDepth\",\"pixelHeight\",\"pixelLeft\",\"pixelRight\",\"pixelStorei\",\"pixelTop\",\"pixelUnitToMillimeterX\",\"pixelUnitToMillimeterY\",\"pixelWidth\",\"place-content\",\"place-items\",\"place-self\",\"placeContent\",\"placeItems\",\"placeSelf\",\"placeholder\",\"platform\",\"platforms\",\"play\",\"playEffect\",\"playState\",\"playbackRate\",\"playbackState\",\"playbackTime\",\"played\",\"playoutDelayHint\",\"playsInline\",\"plugins\",\"pluginspage\",\"pname\",\"pointer-events\",\"pointerBeforeReferenceNode\",\"pointerEnabled\",\"pointerEvents\",\"pointerId\",\"pointerLockElement\",\"pointerType\",\"points\",\"pointsAtX\",\"pointsAtY\",\"pointsAtZ\",\"polygonOffset\",\"pop\",\"populateMatrix\",\"popupWindowFeatures\",\"popupWindowName\",\"popupWindowURI\",\"port\",\"port1\",\"port2\",\"ports\",\"posBottom\",\"posHeight\",\"posLeft\",\"posRight\",\"posTop\",\"posWidth\",\"pose\",\"position\",\"positionAlign\",\"positionX\",\"positionY\",\"positionZ\",\"postError\",\"postMessage\",\"postalCode\",\"poster\",\"pow\",\"powerEfficient\",\"powerOff\",\"preMultiplySelf\",\"precision\",\"preferredStyleSheetSet\",\"preferredStylesheetSet\",\"prefix\",\"preload\",\"prepend\",\"presentation\",\"preserveAlpha\",\"preserveAspectRatio\",\"preserveAspectRatioString\",\"pressed\",\"pressure\",\"prevValue\",\"preventDefault\",\"preventExtensions\",\"preventSilentAccess\",\"previousElementSibling\",\"previousNode\",\"previousPage\",\"previousRect\",\"previousScale\",\"previousSibling\",\"previousTranslate\",\"primaryKey\",\"primitiveType\",\"primitiveUnits\",\"principals\",\"print\",\"priority\",\"privateKey\",\"probablySupportsContext\",\"process\",\"processIceMessage\",\"processingEnd\",\"processingStart\",\"product\",\"productId\",\"productName\",\"productSub\",\"profile\",\"profileEnd\",\"profiles\",\"projectionMatrix\",\"promise\",\"prompt\",\"properties\",\"propertyIsEnumerable\",\"propertyName\",\"protocol\",\"protocolLong\",\"prototype\",\"provider\",\"pseudoClass\",\"pseudoElement\",\"pt\",\"publicId\",\"publicKey\",\"published\",\"pulse\",\"push\",\"pushManager\",\"pushNotification\",\"pushState\",\"put\",\"putImageData\",\"px\",\"quadraticCurveTo\",\"qualifier\",\"quaternion\",\"query\",\"queryCommandEnabled\",\"queryCommandIndeterm\",\"queryCommandState\",\"queryCommandSupported\",\"queryCommandText\",\"queryCommandValue\",\"querySelector\",\"querySelectorAll\",\"queryUsageAndQuota\",\"queueMicrotask\",\"quote\",\"quotes\",\"r\",\"r1\",\"r2\",\"race\",\"rad\",\"radiogroup\",\"radiusX\",\"radiusY\",\"random\",\"range\",\"rangeCount\",\"rangeMax\",\"rangeMin\",\"rangeOffset\",\"rangeOverflow\",\"rangeParent\",\"rangeUnderflow\",\"rate\",\"ratio\",\"raw\",\"rawId\",\"read\",\"readAsArrayBuffer\",\"readAsBinaryString\",\"readAsBlob\",\"readAsDataURL\",\"readAsText\",\"readBuffer\",\"readEntries\",\"readOnly\",\"readPixels\",\"readReportRequested\",\"readText\",\"readTransaction\",\"readValue\",\"readable\",\"ready\",\"readyState\",\"reason\",\"reboot\",\"receivedAlert\",\"receivedTime\",\"receiver\",\"receivers\",\"recipient\",\"reconnect\",\"record\",\"recordEnd\",\"recordNumber\",\"recordsAvailable\",\"recordset\",\"rect\",\"red\",\"redEyeReduction\",\"redirect\",\"redirectCount\",\"redirectEnd\",\"redirectStart\",\"redirected\",\"reduce\",\"reduceRight\",\"reduction\",\"refDistance\",\"refX\",\"refY\",\"referenceNode\",\"referenceSpace\",\"referrer\",\"referrerPolicy\",\"refresh\",\"region\",\"regionAnchorX\",\"regionAnchorY\",\"regionId\",\"regions\",\"register\",\"registerContentHandler\",\"registerElement\",\"registerProperty\",\"registerProtocolHandler\",\"reject\",\"rel\",\"relList\",\"relatedAddress\",\"relatedNode\",\"relatedPort\",\"relatedTarget\",\"release\",\"releaseCapture\",\"releaseEvents\",\"releaseInterface\",\"releaseLock\",\"releasePointerCapture\",\"releaseShaderCompiler\",\"reliable\",\"reliableWrite\",\"reload\",\"rem\",\"remainingSpace\",\"remote\",\"remoteDescription\",\"remove\",\"removeAllRanges\",\"removeAttribute\",\"removeAttributeNS\",\"removeAttributeNode\",\"removeBehavior\",\"removeChild\",\"removeCue\",\"removeEventListener\",\"removeFilter\",\"removeImport\",\"removeItem\",\"removeListener\",\"removeNamedItem\",\"removeNamedItemNS\",\"removeNode\",\"removeParameter\",\"removeProperty\",\"removeRange\",\"removeRegion\",\"removeRule\",\"removeRules\",\"removeSiteSpecificTrackingException\",\"removeSourceBuffer\",\"removeStream\",\"removeTrack\",\"removeVariable\",\"removeWakeLockListener\",\"removeWebWideTrackingException\",\"removed\",\"removedNodes\",\"renderHeight\",\"renderState\",\"renderTime\",\"renderWidth\",\"renderbufferStorage\",\"renderbufferStorageMultisample\",\"renderedBuffer\",\"renderingMode\",\"renotify\",\"repeat\",\"replace\",\"replaceAdjacentText\",\"replaceAll\",\"replaceChild\",\"replaceChildren\",\"replaceData\",\"replaceId\",\"replaceItem\",\"replaceNode\",\"replaceState\",\"replaceSync\",\"replaceTrack\",\"replaceWholeText\",\"replaceWith\",\"reportValidity\",\"request\",\"requestAnimationFrame\",\"requestAutocomplete\",\"requestData\",\"requestDevice\",\"requestFrame\",\"requestFullscreen\",\"requestHitTestSource\",\"requestHitTestSourceForTransientInput\",\"requestId\",\"requestIdleCallback\",\"requestMIDIAccess\",\"requestMediaKeySystemAccess\",\"requestPermission\",\"requestPictureInPicture\",\"requestPointerLock\",\"requestPresent\",\"requestQuota\",\"requestReferenceSpace\",\"requestSession\",\"requestStart\",\"requestStorageAccess\",\"requestSubmit\",\"requestTime\",\"requestVideoFrameCallback\",\"requestedLocale\",\"requestingWindow\",\"requireInteraction\",\"required\",\"requiredExtensions\",\"requiredFeatures\",\"reset\",\"resetPose\",\"resetTransform\",\"resize\",\"resizeBy\",\"resizeTo\",\"resolve\",\"resolved\",\"resolvedOptions\",\"resource-history\",\"resourcesFramesExpanded\",\"response\",\"responseBody\",\"responseEnd\",\"responseReady\",\"responseStart\",\"responseText\",\"responseType\",\"responseURL\",\"responseXML\",\"restartIce\",\"restore\",\"result\",\"resultIndex\",\"resultType\",\"results\",\"resume\",\"resumeTransformFeedback\",\"retry\",\"returnValue\",\"rev\",\"reverse\",\"reversed\",\"revocable\",\"revokeObjectURL\",\"rgbColor\",\"right\",\"rightContext\",\"rightDegrees\",\"rightMargin\",\"rightProjectionMatrix\",\"rightViewMatrix\",\"role\",\"rolloffFactor\",\"root\",\"rootBounds\",\"rootElement\",\"rootMargin\",\"rotate\",\"rotateAxisAngle\",\"rotateAxisAngleSelf\",\"rotateFromVector\",\"rotateFromVectorSelf\",\"rotateSelf\",\"rotation\",\"rotationAngle\",\"rotationRate\",\"round\",\"row-gap\",\"rowGap\",\"rowIndex\",\"rowSpan\",\"rows\",\"rowsAffected\",\"rtcpTransport\",\"rtt\",\"ruby-align\",\"ruby-position\",\"rubyAlign\",\"rubyOverhang\",\"rubyPosition\",\"rules\",\"runningState\",\"runtime\",\"runtimeStyle\",\"rx\",\"ry\",\"s\",\"safari\",\"sample\",\"sampleCoverage\",\"sampleRate\",\"samplerParameterf\",\"samplerParameteri\",\"sandbox\",\"save\",\"saveData\",\"scale\",\"scale3d\",\"scale3dSelf\",\"scaleNonUniform\",\"scaleNonUniformSelf\",\"scaleSelf\",\"scheme\",\"scissor\",\"scope\",\"scopeName\",\"scoped\",\"screen\",\"screenBrightness\",\"screenEnabled\",\"screenLeft\",\"screenPixelToMillimeterX\",\"screenPixelToMillimeterY\",\"screenTop\",\"screenX\",\"screenY\",\"script\",\"scriptURL\",\"scripts\",\"scroll\",\"scroll-behavior\",\"scroll-margin\",\"scroll-margin-block\",\"scroll-margin-block-end\",\"scroll-margin-block-start\",\"scroll-margin-bottom\",\"scroll-margin-inline\",\"scroll-margin-inline-end\",\"scroll-margin-inline-start\",\"scroll-margin-left\",\"scroll-margin-right\",\"scroll-margin-top\",\"scroll-padding\",\"scroll-padding-block\",\"scroll-padding-block-end\",\"scroll-padding-block-start\",\"scroll-padding-bottom\",\"scroll-padding-inline\",\"scroll-padding-inline-end\",\"scroll-padding-inline-start\",\"scroll-padding-left\",\"scroll-padding-right\",\"scroll-padding-top\",\"scroll-snap-align\",\"scroll-snap-coordinate\",\"scroll-snap-destination\",\"scroll-snap-points-x\",\"scroll-snap-points-y\",\"scroll-snap-type\",\"scroll-snap-type-x\",\"scroll-snap-type-y\",\"scrollAmount\",\"scrollBehavior\",\"scrollBy\",\"scrollByLines\",\"scrollByPages\",\"scrollDelay\",\"scrollHeight\",\"scrollIntoView\",\"scrollIntoViewIfNeeded\",\"scrollLeft\",\"scrollLeftMax\",\"scrollMargin\",\"scrollMarginBlock\",\"scrollMarginBlockEnd\",\"scrollMarginBlockStart\",\"scrollMarginBottom\",\"scrollMarginInline\",\"scrollMarginInlineEnd\",\"scrollMarginInlineStart\",\"scrollMarginLeft\",\"scrollMarginRight\",\"scrollMarginTop\",\"scrollMaxX\",\"scrollMaxY\",\"scrollPadding\",\"scrollPaddingBlock\",\"scrollPaddingBlockEnd\",\"scrollPaddingBlockStart\",\"scrollPaddingBottom\",\"scrollPaddingInline\",\"scrollPaddingInlineEnd\",\"scrollPaddingInlineStart\",\"scrollPaddingLeft\",\"scrollPaddingRight\",\"scrollPaddingTop\",\"scrollRestoration\",\"scrollSnapAlign\",\"scrollSnapCoordinate\",\"scrollSnapDestination\",\"scrollSnapMargin\",\"scrollSnapMarginBottom\",\"scrollSnapMarginLeft\",\"scrollSnapMarginRight\",\"scrollSnapMarginTop\",\"scrollSnapPointsX\",\"scrollSnapPointsY\",\"scrollSnapStop\",\"scrollSnapType\",\"scrollSnapTypeX\",\"scrollSnapTypeY\",\"scrollTo\",\"scrollTop\",\"scrollTopMax\",\"scrollWidth\",\"scrollX\",\"scrollY\",\"scrollbar-color\",\"scrollbar-width\",\"scrollbar3dLightColor\",\"scrollbarArrowColor\",\"scrollbarBaseColor\",\"scrollbarColor\",\"scrollbarDarkShadowColor\",\"scrollbarFaceColor\",\"scrollbarHighlightColor\",\"scrollbarShadowColor\",\"scrollbarTrackColor\",\"scrollbarWidth\",\"scrollbars\",\"scrolling\",\"scrollingElement\",\"sctp\",\"sctpCauseCode\",\"sdp\",\"sdpLineNumber\",\"sdpMLineIndex\",\"sdpMid\",\"seal\",\"search\",\"searchBox\",\"searchBoxJavaBridge_\",\"searchParams\",\"second\",\"sectionRowIndex\",\"secureConnectionStart\",\"security\",\"seed\",\"seekToNextFrame\",\"seekable\",\"seeking\",\"select\",\"selectAllChildren\",\"selectAlternateInterface\",\"selectConfiguration\",\"selectNode\",\"selectNodeContents\",\"selectNodes\",\"selectSingleNode\",\"selectSubString\",\"selected\",\"selectedIndex\",\"selectedOption\",\"selectedOptions\",\"selectedStyleSheetSet\",\"selectedStylesheetSet\",\"selection\",\"selectionDirection\",\"selectionEnd\",\"selectionStart\",\"selector\",\"selectorText\",\"self\",\"send\",\"sendAsBinary\",\"sendBeacon\",\"sendMessage\",\"sender\",\"sensitivity\",\"sentAlert\",\"sentTimestamp\",\"separator\",\"serialNumber\",\"serializeToString\",\"serverTiming\",\"service\",\"serviceWorker\",\"session\",\"sessionId\",\"sessionStorage\",\"set\",\"setActionHandler\",\"setActive\",\"setAlpha\",\"setAppBadge\",\"setAttribute\",\"setAttributeNS\",\"setAttributeNode\",\"setAttributeNodeNS\",\"setBaseAndExtent\",\"setBigInt64\",\"setBigUint64\",\"setBingCurrentSearchDefault\",\"setCapture\",\"setCodecPreferences\",\"setColor\",\"setCompositeOperation\",\"setConfiguration\",\"setCurrentTime\",\"setCustomValidity\",\"setData\",\"setDate\",\"setDirection\",\"setDragImage\",\"setEnd\",\"setEndAfter\",\"setEndBefore\",\"setEndPoint\",\"setFillColor\",\"setFilterRes\",\"setFloat32\",\"setFloat64\",\"setFloatValue\",\"setFormValue\",\"setFullYear\",\"setHeaderValue\",\"setHours\",\"setIdentityProvider\",\"setImmediate\",\"setInt16\",\"setInt32\",\"setInt8\",\"setInterval\",\"setItem\",\"setKeyframes\",\"setLineCap\",\"setLineDash\",\"setLineJoin\",\"setLineWidth\",\"setLiveSeekableRange\",\"setLocalDescription\",\"setMatrix\",\"setMatrixValue\",\"setMediaKeys\",\"setMilliseconds\",\"setMinutes\",\"setMiterLimit\",\"setMonth\",\"setNamedItem\",\"setNamedItemNS\",\"setNonUserCodeExceptions\",\"setOrientToAngle\",\"setOrientToAuto\",\"setOrientation\",\"setOverrideHistoryNavigationMode\",\"setPaint\",\"setParameter\",\"setParameters\",\"setPeriodicWave\",\"setPointerCapture\",\"setPosition\",\"setPositionState\",\"setPreference\",\"setProperty\",\"setPrototypeOf\",\"setRGBColor\",\"setRGBColorICCColor\",\"setRadius\",\"setRangeText\",\"setRemoteDescription\",\"setRequestHeader\",\"setResizable\",\"setResourceTimingBufferSize\",\"setRotate\",\"setScale\",\"setSeconds\",\"setSelectionRange\",\"setServerCertificate\",\"setShadow\",\"setSinkId\",\"setSkewX\",\"setSkewY\",\"setStart\",\"setStartAfter\",\"setStartBefore\",\"setStdDeviation\",\"setStreams\",\"setStringValue\",\"setStrokeColor\",\"setSuggestResult\",\"setTargetAtTime\",\"setTargetValueAtTime\",\"setTime\",\"setTimeout\",\"setTransform\",\"setTranslate\",\"setUTCDate\",\"setUTCFullYear\",\"setUTCHours\",\"setUTCMilliseconds\",\"setUTCMinutes\",\"setUTCMonth\",\"setUTCSeconds\",\"setUint16\",\"setUint32\",\"setUint8\",\"setUri\",\"setValidity\",\"setValueAtTime\",\"setValueCurveAtTime\",\"setVariable\",\"setVelocity\",\"setVersion\",\"setYear\",\"settingName\",\"settingValue\",\"sex\",\"shaderSource\",\"shadowBlur\",\"shadowColor\",\"shadowOffsetX\",\"shadowOffsetY\",\"shadowRoot\",\"shape\",\"shape-image-threshold\",\"shape-margin\",\"shape-outside\",\"shape-rendering\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"sheet\",\"shift\",\"shiftKey\",\"shiftLeft\",\"shippingAddress\",\"shippingOption\",\"shippingType\",\"show\",\"showHelp\",\"showModal\",\"showModalDialog\",\"showModelessDialog\",\"showNotification\",\"sidebar\",\"sign\",\"signal\",\"signalingState\",\"signature\",\"silent\",\"sin\",\"singleNodeValue\",\"sinh\",\"sinkId\",\"sittingToStandingTransform\",\"size\",\"sizeToContent\",\"sizeX\",\"sizeZ\",\"sizes\",\"skewX\",\"skewXSelf\",\"skewY\",\"skewYSelf\",\"slice\",\"slope\",\"slot\",\"small\",\"smil\",\"smooth\",\"smoothingTimeConstant\",\"snapToLines\",\"snapshotItem\",\"snapshotLength\",\"some\",\"sort\",\"sortingCode\",\"source\",\"sourceBuffer\",\"sourceBuffers\",\"sourceCapabilities\",\"sourceFile\",\"sourceIndex\",\"sourceURL\",\"sources\",\"spacing\",\"span\",\"speak\",\"speakAs\",\"speaking\",\"species\",\"specified\",\"specularConstant\",\"specularExponent\",\"speechSynthesis\",\"speed\",\"speedOfSound\",\"spellcheck\",\"splice\",\"split\",\"splitText\",\"spreadMethod\",\"sqrt\",\"src\",\"srcElement\",\"srcFilter\",\"srcObject\",\"srcUrn\",\"srcdoc\",\"srclang\",\"srcset\",\"stack\",\"stackTraceLimit\",\"stacktrace\",\"stageParameters\",\"standalone\",\"standby\",\"start\",\"startContainer\",\"startE\",\"startIce\",\"startLoadTime\",\"startMessages\",\"startNotifications\",\"startOffset\",\"startRendering\",\"startSoftwareUpdate\",\"startTime\",\"startsWith\",\"state\",\"status\",\"statusCode\",\"statusMessage\",\"statusText\",\"statusbar\",\"stdDeviationX\",\"stdDeviationY\",\"stencilFunc\",\"stencilFuncSeparate\",\"stencilMask\",\"stencilMaskSeparate\",\"stencilOp\",\"stencilOpSeparate\",\"step\",\"stepDown\",\"stepMismatch\",\"stepUp\",\"sticky\",\"stitchTiles\",\"stop\",\"stop-color\",\"stop-opacity\",\"stopColor\",\"stopImmediatePropagation\",\"stopNotifications\",\"stopOpacity\",\"stopPropagation\",\"stopped\",\"storage\",\"storageArea\",\"storageName\",\"storageStatus\",\"store\",\"storeSiteSpecificTrackingException\",\"storeWebWideTrackingException\",\"stpVersion\",\"stream\",\"streams\",\"strength\",\"stretch\",\"strike\",\"stringValue\",\"stringify\",\"stroke\",\"stroke-dasharray\",\"stroke-dashoffset\",\"stroke-linecap\",\"stroke-linejoin\",\"stroke-miterlimit\",\"stroke-opacity\",\"stroke-width\",\"strokeColor\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeRect\",\"strokeStyle\",\"strokeText\",\"strokeWidth\",\"style\",\"styleFloat\",\"styleMap\",\"styleMedia\",\"styleSheet\",\"styleSheetSets\",\"styleSheets\",\"sub\",\"subarray\",\"subject\",\"submit\",\"submitFrame\",\"submitter\",\"subscribe\",\"substr\",\"substring\",\"substringData\",\"subtle\",\"subtree\",\"suffix\",\"suffixes\",\"summary\",\"sup\",\"supported\",\"supportedContentEncodings\",\"supportedEntryTypes\",\"supportedLocalesOf\",\"supports\",\"supportsSession\",\"surfaceScale\",\"surroundContents\",\"suspend\",\"suspendRedraw\",\"swapCache\",\"swapNode\",\"sweepFlag\",\"symbols\",\"sync\",\"sysexEnabled\",\"system\",\"systemCode\",\"systemId\",\"systemLanguage\",\"systemXDPI\",\"systemYDPI\",\"tBodies\",\"tFoot\",\"tHead\",\"tabIndex\",\"tabSize\",\"table\",\"table-layout\",\"tableLayout\",\"tableValues\",\"tag\",\"tagName\",\"tagUrn\",\"tags\",\"taintEnabled\",\"takeHeapSnapshot\",\"takePhoto\",\"takeRecords\",\"tan\",\"tangentialPressure\",\"tanh\",\"target\",\"targetElement\",\"targetRayMode\",\"targetRaySpace\",\"targetTouches\",\"targetX\",\"targetY\",\"tcpType\",\"tee\",\"tel\",\"terminate\",\"test\",\"texImage2D\",\"texImage3D\",\"texParameterf\",\"texParameteri\",\"texStorage2D\",\"texStorage3D\",\"texSubImage2D\",\"texSubImage3D\",\"text\",\"text-align\",\"text-align-last\",\"text-anchor\",\"text-combine-upright\",\"text-decoration\",\"text-decoration-color\",\"text-decoration-line\",\"text-decoration-skip-ink\",\"text-decoration-style\",\"text-decoration-thickness\",\"text-emphasis\",\"text-emphasis-color\",\"text-emphasis-position\",\"text-emphasis-style\",\"text-indent\",\"text-justify\",\"text-orientation\",\"text-overflow\",\"text-rendering\",\"text-shadow\",\"text-transform\",\"text-underline-offset\",\"text-underline-position\",\"text/pdf\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textAutospace\",\"textBaseline\",\"textCombineUpright\",\"textContent\",\"textDecoration\",\"textDecorationBlink\",\"textDecorationColor\",\"textDecorationLine\",\"textDecorationLineThrough\",\"textDecorationNone\",\"textDecorationOverline\",\"textDecorationSkipInk\",\"textDecorationStyle\",\"textDecorationThickness\",\"textDecorationUnderline\",\"textEmphasis\",\"textEmphasisColor\",\"textEmphasisPosition\",\"textEmphasisStyle\",\"textIndent\",\"textJustify\",\"textJustifyTrim\",\"textKashida\",\"textKashidaSpace\",\"textLength\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textSizeAdjust\",\"textTracks\",\"textTransform\",\"textUnderlineOffset\",\"textUnderlinePosition\",\"then\",\"threadId\",\"threshold\",\"thresholds\",\"tiltX\",\"tiltY\",\"time\",\"timeEnd\",\"timeLog\",\"timeOrigin\",\"timeRemaining\",\"timeStamp\",\"timeZone\",\"timeZoneName\",\"timecode\",\"timeline\",\"timelineEnd\",\"timelineTime\",\"timeout\",\"timestamp\",\"timestampOffset\",\"timing\",\"title\",\"to\",\"toArray\",\"toBlob\",\"toDataURL\",\"toDateString\",\"toElement\",\"toExponential\",\"toFixed\",\"toFloat32Array\",\"toFloat64Array\",\"toGMTString\",\"toISOString\",\"toJSON\",\"toLocaleDateString\",\"toLocaleFormat\",\"toLocaleLowerCase\",\"toLocaleString\",\"toLocaleTimeString\",\"toLocaleUpperCase\",\"toLowerCase\",\"toMatrix\",\"toMethod\",\"toPrecision\",\"toPrimitive\",\"toSdp\",\"toSource\",\"toStaticHTML\",\"toString\",\"toStringTag\",\"toSum\",\"toTimeString\",\"toUTCString\",\"toUpperCase\",\"toggle\",\"toggleAttribute\",\"toggleLongPressEnabled\",\"tone\",\"toneBuffer\",\"tooLong\",\"tooShort\",\"toolbar\",\"top\",\"topMargin\",\"total\",\"totalFrameDelay\",\"totalJSHeapSize\",\"totalSize\",\"totalVideoFrames\",\"touch-action\",\"touchAction\",\"touched\",\"touches\",\"trace\",\"track\",\"trackVisibility\",\"tran\",\"transaction\",\"transactions\",\"transceiver\",\"transferControlToOffscreen\",\"transferFromImageBitmap\",\"transferImageBitmap\",\"transferIn\",\"transferOut\",\"transferSize\",\"transferToImageBitmap\",\"transform\",\"transform-box\",\"transform-origin\",\"transform-style\",\"transformBox\",\"transformFeedbackVaryings\",\"transformOrigin\",\"transformOriginX\",\"transformOriginY\",\"transformOriginZ\",\"transformPoint\",\"transformString\",\"transformStyle\",\"transformToDocument\",\"transformToFragment\",\"transition\",\"transition-delay\",\"transition-duration\",\"transition-property\",\"transition-timing-function\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"translate\",\"translateSelf\",\"translationX\",\"translationY\",\"transport\",\"trim\",\"trimEnd\",\"trimLeft\",\"trimRight\",\"trimStart\",\"trueSpeed\",\"trunc\",\"truncate\",\"trustedTypes\",\"turn\",\"twist\",\"type\",\"typeDetail\",\"typeMismatch\",\"typeMustMatch\",\"types\",\"tz\",\"u2f\",\"ubound\",\"undefined\",\"unescape\",\"uneval\",\"unicode\",\"unicode-bidi\",\"unicodeBidi\",\"unicodeRange\",\"uniform1f\",\"uniform1fv\",\"uniform1i\",\"uniform1iv\",\"uniform1ui\",\"uniform1uiv\",\"uniform2f\",\"uniform2fv\",\"uniform2i\",\"uniform2iv\",\"uniform2ui\",\"uniform2uiv\",\"uniform3f\",\"uniform3fv\",\"uniform3i\",\"uniform3iv\",\"uniform3ui\",\"uniform3uiv\",\"uniform4f\",\"uniform4fv\",\"uniform4i\",\"uniform4iv\",\"uniform4ui\",\"uniform4uiv\",\"uniformBlockBinding\",\"uniformMatrix2fv\",\"uniformMatrix2x3fv\",\"uniformMatrix2x4fv\",\"uniformMatrix3fv\",\"uniformMatrix3x2fv\",\"uniformMatrix3x4fv\",\"uniformMatrix4fv\",\"uniformMatrix4x2fv\",\"uniformMatrix4x3fv\",\"unique\",\"uniqueID\",\"uniqueNumber\",\"unit\",\"unitType\",\"units\",\"unloadEventEnd\",\"unloadEventStart\",\"unlock\",\"unmount\",\"unobserve\",\"unpause\",\"unpauseAnimations\",\"unreadCount\",\"unregister\",\"unregisterContentHandler\",\"unregisterProtocolHandler\",\"unscopables\",\"unselectable\",\"unshift\",\"unsubscribe\",\"unsuspendRedraw\",\"unsuspendRedrawAll\",\"unwatch\",\"unwrapKey\",\"upDegrees\",\"upX\",\"upY\",\"upZ\",\"update\",\"updateCommands\",\"updateEnabled\",\"updateIce\",\"updateInterval\",\"updatePlaybackRate\",\"updateRenderState\",\"updateSettings\",\"updateTiming\",\"updateViaCache\",\"updateWith\",\"updated\",\"updating\",\"upgrade\",\"upload\",\"uploadTotal\",\"uploaded\",\"upper\",\"upperBound\",\"upperOpen\",\"uri\",\"url\",\"urn\",\"urns\",\"usage\",\"usages\",\"usb\",\"usbVersionMajor\",\"usbVersionMinor\",\"usbVersionSubminor\",\"useCurrentView\",\"useGrouping\",\"useMap\",\"useProgram\",\"usedJSHeapSize\",\"usedSpace\",\"user-select\",\"userActivation\",\"userAgent\",\"userChoice\",\"userHandle\",\"userHint\",\"userLanguage\",\"userProfile\",\"userSelect\",\"userVisibleOnly\",\"userZoom\",\"username\",\"usernameFragment\",\"utterance\",\"uuid\",\"v8BreakIterator\",\"v8Parse\",\"vAlign\",\"vLink\",\"valid\",\"validate\",\"validateProgram\",\"validationMessage\",\"validity\",\"value\",\"valueAsDate\",\"valueAsNumber\",\"valueAsString\",\"valueInSpecifiedUnits\",\"valueMissing\",\"valueOf\",\"valueText\",\"valueType\",\"values\",\"variable\",\"variant\",\"vector-effect\",\"vectorEffect\",\"velocityAngular\",\"velocityExpansion\",\"velocityX\",\"velocityY\",\"vendor\",\"vendorId\",\"vendorSub\",\"verify\",\"version\",\"vertexAttrib1f\",\"vertexAttrib1fv\",\"vertexAttrib2f\",\"vertexAttrib2fv\",\"vertexAttrib3f\",\"vertexAttrib3fv\",\"vertexAttrib4f\",\"vertexAttrib4fv\",\"vertexAttribDivisor\",\"vertexAttribDivisorANGLE\",\"vertexAttribI4i\",\"vertexAttribI4iv\",\"vertexAttribI4ui\",\"vertexAttribI4uiv\",\"vertexAttribIPointer\",\"vertexAttribPointer\",\"vertical\",\"vertical-align\",\"verticalAlign\",\"verticalOverflow\",\"vh\",\"vibrate\",\"vibrationActuator\",\"video/x-ms-asf\",\"video/x-ms-asf-plugin\",\"video/x-ms-wm\",\"video/x-ms-wmv\",\"video/x-ms-wvx\",\"videoBitsPerSecond\",\"videoHeight\",\"videoTracks\",\"videoWidth\",\"view\",\"viewBox\",\"viewBoxString\",\"viewTarget\",\"viewTargetString\",\"viewport\",\"viewportAnchorX\",\"viewportAnchorY\",\"viewportElement\",\"views\",\"violatedDirective\",\"visibility\",\"visibilityState\",\"visible\",\"visualViewport\",\"vlinkColor\",\"vmax\",\"vmin\",\"voice\",\"voiceURI\",\"volume\",\"vrml\",\"vspace\",\"vw\",\"w\",\"wait\",\"waitSync\",\"waiting\",\"wake\",\"wakeLock\",\"wand\",\"warn\",\"wasAlternateProtocolAvailable\",\"wasClean\",\"wasDiscarded\",\"wasFetchedViaSpdy\",\"wasNpnNegotiated\",\"watch\",\"watchAvailability\",\"watchPosition\",\"webdriver\",\"webkitAddKey\",\"webkitAlignContent\",\"webkitAlignItems\",\"webkitAlignSelf\",\"webkitAnimation\",\"webkitAnimationDelay\",\"webkitAnimationDirection\",\"webkitAnimationDuration\",\"webkitAnimationFillMode\",\"webkitAnimationIterationCount\",\"webkitAnimationName\",\"webkitAnimationPlayState\",\"webkitAnimationTimingFunction\",\"webkitAppRegion\",\"webkitAppearance\",\"webkitAspectRatio\",\"webkitAudioContext\",\"webkitAudioDecodedByteCount\",\"webkitAudioPannerNode\",\"webkitBackdropFilter\",\"webkitBackfaceVisibility\",\"webkitBackground\",\"webkitBackgroundAttachment\",\"webkitBackgroundClip\",\"webkitBackgroundColor\",\"webkitBackgroundComposite\",\"webkitBackgroundImage\",\"webkitBackgroundOrigin\",\"webkitBackgroundPosition\",\"webkitBackgroundPositionX\",\"webkitBackgroundPositionY\",\"webkitBackgroundRepeat\",\"webkitBackgroundSize\",\"webkitBackingStorePixelRatio\",\"webkitBorderAfter\",\"webkitBorderAfterColor\",\"webkitBorderAfterStyle\",\"webkitBorderAfterWidth\",\"webkitBorderBefore\",\"webkitBorderBeforeColor\",\"webkitBorderBeforeStyle\",\"webkitBorderBeforeWidth\",\"webkitBorderBottomLeftRadius\",\"webkitBorderBottomRightRadius\",\"webkitBorderEnd\",\"webkitBorderEndColor\",\"webkitBorderEndStyle\",\"webkitBorderEndWidth\",\"webkitBorderFit\",\"webkitBorderHorizontalSpacing\",\"webkitBorderImage\",\"webkitBorderImageOutset\",\"webkitBorderImageRepeat\",\"webkitBorderImageSlice\",\"webkitBorderImageSource\",\"webkitBorderImageWidth\",\"webkitBorderRadius\",\"webkitBorderStart\",\"webkitBorderStartColor\",\"webkitBorderStartStyle\",\"webkitBorderStartWidth\",\"webkitBorderTopLeftRadius\",\"webkitBorderTopRightRadius\",\"webkitBorderVerticalSpacing\",\"webkitBoxAlign\",\"webkitBoxDecorationBreak\",\"webkitBoxDirection\",\"webkitBoxFlex\",\"webkitBoxFlexGroup\",\"webkitBoxLines\",\"webkitBoxOrdinalGroup\",\"webkitBoxOrient\",\"webkitBoxPack\",\"webkitBoxReflect\",\"webkitBoxShadow\",\"webkitBoxSizing\",\"webkitCancelAnimationFrame\",\"webkitCancelFullScreen\",\"webkitCancelKeyRequest\",\"webkitCancelRequestAnimationFrame\",\"webkitClearResourceTimings\",\"webkitClipPath\",\"webkitClosedCaptionsVisible\",\"webkitColumnAxis\",\"webkitColumnBreakAfter\",\"webkitColumnBreakBefore\",\"webkitColumnBreakInside\",\"webkitColumnCount\",\"webkitColumnGap\",\"webkitColumnProgression\",\"webkitColumnRule\",\"webkitColumnRuleColor\",\"webkitColumnRuleStyle\",\"webkitColumnRuleWidth\",\"webkitColumnSpan\",\"webkitColumnWidth\",\"webkitColumns\",\"webkitConvertPointFromNodeToPage\",\"webkitConvertPointFromPageToNode\",\"webkitCreateShadowRoot\",\"webkitCurrentFullScreenElement\",\"webkitCurrentPlaybackTargetIsWireless\",\"webkitCursorVisibility\",\"webkitDashboardRegion\",\"webkitDecodedFrameCount\",\"webkitDirectionInvertedFromDevice\",\"webkitDisplayingFullscreen\",\"webkitDroppedFrameCount\",\"webkitEnterFullScreen\",\"webkitEnterFullscreen\",\"webkitEntries\",\"webkitExitFullScreen\",\"webkitExitFullscreen\",\"webkitExitPointerLock\",\"webkitFilter\",\"webkitFlex\",\"webkitFlexBasis\",\"webkitFlexDirection\",\"webkitFlexFlow\",\"webkitFlexGrow\",\"webkitFlexShrink\",\"webkitFlexWrap\",\"webkitFontFeatureSettings\",\"webkitFontKerning\",\"webkitFontSizeDelta\",\"webkitFontSmoothing\",\"webkitForce\",\"webkitFullScreenKeyboardInputAllowed\",\"webkitFullscreenElement\",\"webkitFullscreenEnabled\",\"webkitGenerateKeyRequest\",\"webkitGetAsEntry\",\"webkitGetDatabaseNames\",\"webkitGetEntries\",\"webkitGetEntriesByName\",\"webkitGetEntriesByType\",\"webkitGetFlowByName\",\"webkitGetGamepads\",\"webkitGetImageDataHD\",\"webkitGetNamedFlows\",\"webkitGetRegionFlowRanges\",\"webkitGetUserMedia\",\"webkitHasClosedCaptions\",\"webkitHidden\",\"webkitHighlight\",\"webkitHyphenateCharacter\",\"webkitHyphenateLimitAfter\",\"webkitHyphenateLimitBefore\",\"webkitHyphenateLimitLines\",\"webkitHyphens\",\"webkitIDBCursor\",\"webkitIDBDatabase\",\"webkitIDBDatabaseError\",\"webkitIDBDatabaseException\",\"webkitIDBFactory\",\"webkitIDBIndex\",\"webkitIDBKeyRange\",\"webkitIDBObjectStore\",\"webkitIDBRequest\",\"webkitIDBTransaction\",\"webkitImageSmoothingEnabled\",\"webkitIndexedDB\",\"webkitInitMessageEvent\",\"webkitInitialLetter\",\"webkitIsFullScreen\",\"webkitJustifyContent\",\"webkitKeys\",\"webkitLineAlign\",\"webkitLineBoxContain\",\"webkitLineBreak\",\"webkitLineClamp\",\"webkitLineDash\",\"webkitLineDashOffset\",\"webkitLineGrid\",\"webkitLineSnap\",\"webkitLocale\",\"webkitLockOrientation\",\"webkitLogicalHeight\",\"webkitLogicalWidth\",\"webkitMarginAfter\",\"webkitMarginAfterCollapse\",\"webkitMarginBefore\",\"webkitMarginBeforeCollapse\",\"webkitMarginBottomCollapse\",\"webkitMarginCollapse\",\"webkitMarginEnd\",\"webkitMarginStart\",\"webkitMarginTopCollapse\",\"webkitMarquee\",\"webkitMarqueeDirection\",\"webkitMarqueeIncrement\",\"webkitMarqueeRepetition\",\"webkitMarqueeSpeed\",\"webkitMarqueeStyle\",\"webkitMask\",\"webkitMaskBoxImage\",\"webkitMaskBoxImageOutset\",\"webkitMaskBoxImageRepeat\",\"webkitMaskBoxImageSlice\",\"webkitMaskBoxImageSource\",\"webkitMaskBoxImageWidth\",\"webkitMaskClip\",\"webkitMaskComposite\",\"webkitMaskImage\",\"webkitMaskOrigin\",\"webkitMaskPosition\",\"webkitMaskPositionX\",\"webkitMaskPositionY\",\"webkitMaskRepeat\",\"webkitMaskRepeatX\",\"webkitMaskRepeatY\",\"webkitMaskSize\",\"webkitMaskSourceType\",\"webkitMatchesSelector\",\"webkitMaxLogicalHeight\",\"webkitMaxLogicalWidth\",\"webkitMediaStream\",\"webkitMinLogicalHeight\",\"webkitMinLogicalWidth\",\"webkitNbspMode\",\"webkitNotifications\",\"webkitOfflineAudioContext\",\"webkitOpacity\",\"webkitOrder\",\"webkitOrientation\",\"webkitPaddingAfter\",\"webkitPaddingBefore\",\"webkitPaddingEnd\",\"webkitPaddingStart\",\"webkitPeerConnection00\",\"webkitPersistentStorage\",\"webkitPerspective\",\"webkitPerspectiveOrigin\",\"webkitPerspectiveOriginX\",\"webkitPerspectiveOriginY\",\"webkitPointerLockElement\",\"webkitPostMessage\",\"webkitPreservesPitch\",\"webkitPrintColorAdjust\",\"webkitPutImageDataHD\",\"webkitRTCPeerConnection\",\"webkitRegionOverset\",\"webkitRelativePath\",\"webkitRequestAnimationFrame\",\"webkitRequestFileSystem\",\"webkitRequestFullScreen\",\"webkitRequestFullscreen\",\"webkitRequestPointerLock\",\"webkitResolveLocalFileSystemURL\",\"webkitRtlOrdering\",\"webkitRubyPosition\",\"webkitSetMediaKeys\",\"webkitSetResourceTimingBufferSize\",\"webkitShadowRoot\",\"webkitShapeImageThreshold\",\"webkitShapeMargin\",\"webkitShapeOutside\",\"webkitShowPlaybackTargetPicker\",\"webkitSlice\",\"webkitSpeechGrammar\",\"webkitSpeechGrammarList\",\"webkitSpeechRecognition\",\"webkitSpeechRecognitionError\",\"webkitSpeechRecognitionEvent\",\"webkitStorageInfo\",\"webkitSupportsFullscreen\",\"webkitSvgShadow\",\"webkitTapHighlightColor\",\"webkitTemporaryStorage\",\"webkitTextCombine\",\"webkitTextDecoration\",\"webkitTextDecorationColor\",\"webkitTextDecorationLine\",\"webkitTextDecorationSkip\",\"webkitTextDecorationStyle\",\"webkitTextDecorationsInEffect\",\"webkitTextEmphasis\",\"webkitTextEmphasisColor\",\"webkitTextEmphasisPosition\",\"webkitTextEmphasisStyle\",\"webkitTextFillColor\",\"webkitTextOrientation\",\"webkitTextSecurity\",\"webkitTextSizeAdjust\",\"webkitTextStroke\",\"webkitTextStrokeColor\",\"webkitTextStrokeWidth\",\"webkitTextUnderlinePosition\",\"webkitTextZoom\",\"webkitTransform\",\"webkitTransformOrigin\",\"webkitTransformOriginX\",\"webkitTransformOriginY\",\"webkitTransformOriginZ\",\"webkitTransformStyle\",\"webkitTransition\",\"webkitTransitionDelay\",\"webkitTransitionDuration\",\"webkitTransitionProperty\",\"webkitTransitionTimingFunction\",\"webkitURL\",\"webkitUnlockOrientation\",\"webkitUserDrag\",\"webkitUserModify\",\"webkitUserSelect\",\"webkitVideoDecodedByteCount\",\"webkitVisibilityState\",\"webkitWirelessVideoPlaybackDisabled\",\"webkitWritingMode\",\"webkitdirectory\",\"webkitdropzone\",\"webstore\",\"weekday\",\"weight\",\"whatToShow\",\"wheelDelta\",\"wheelDeltaX\",\"wheelDeltaY\",\"whenDefined\",\"which\",\"white-space\",\"whiteSpace\",\"wholeText\",\"widows\",\"width\",\"will-change\",\"willChange\",\"willValidate\",\"window\",\"withCredentials\",\"word-break\",\"word-spacing\",\"word-wrap\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"workerStart\",\"wrap\",\"wrapKey\",\"writable\",\"writableAuxiliaries\",\"write\",\"writeText\",\"writeValue\",\"writeWithoutResponse\",\"writeln\",\"writing-mode\",\"writingMode\",\"x\",\"x1\",\"x2\",\"xChannelSelector\",\"xmlEncoding\",\"xmlStandalone\",\"xmlVersion\",\"xmlbase\",\"xmllang\",\"xmlspace\",\"xor\",\"xr\",\"y\",\"y1\",\"y2\",\"yChannelSelector\",\"yandex\",\"year\",\"z\",\"z-index\",\"zIndex\",\"zoom\",\"zoomAndPan\",\"zoomRectScreen\"]");

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	(function (exports$1) {
		var fs = require$$0$4;
		exports$1.FILES = [
		  require.resolve("../lib/utils.js"),
		  require.resolve("../lib/ast.js"),
		  require.resolve("../lib/transform.js"),
		  require.resolve("../lib/parse.js"),
		  require.resolve("../lib/scope.js"),
		  require.resolve("../lib/compress.js"),
		  require.resolve("../lib/output.js"),
		  require.resolve("../lib/sourcemap.js"),
		  require.resolve("../lib/mozilla-ast.js"),
		  require.resolve("../lib/propmangle.js"),
		  require.resolve("../lib/minify.js"),
		  require.resolve("./exports.js")
		];
		new Function("domprops", "exports", (function() {
		  var code = exports$1.FILES.map(function(file) {
		    return fs.readFileSync(file, "utf8");
		  });
		  code.push("exports.describe_ast = " + describe_ast.toString());
		  return code.join("\n\n");
		})())(require$$1, exports$1);
		function to_comment(value) {
		  if (typeof value != "string") value = JSON.stringify(value, function(key, value2) {
		    return typeof value2 == "function" ? "<[ " + value2 + " ]>" : value2;
		  }, 2);
		  return "// " + value.replace(/\n/g, "\n// ");
		}
		if (+process.env["UGLIFY_BUG_REPORT"]) exports$1.minify = function(files, options) {
		  if (typeof options == "undefined") options = "<<undefined>>";
		  var code = [
		    "// UGLIFY_BUG_REPORT",
		    to_comment(options)
		  ];
		  if (typeof files == "string") {
		    code.push("");
		    code.push("//-------------------------------------------------------------");
		    code.push("// INPUT CODE", files);
		  } else for (var name in files) {
		    code.push("");
		    code.push("//-------------------------------------------------------------");
		    code.push(to_comment(name), files[name]);
		  }
		  if (options.sourceMap && options.sourceMap.url) {
		    code.push("");
		    code.push("//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9");
		  }
		  var result = { code: code.join("\n") };
		  if (options.sourceMap) result.map = '{"version":3,"sources":[],"names":[],"mappings":""}';
		  return result;
		};
		function describe_ast() {
		  var out = OutputStream({ beautify: true });
		  doitem(AST_Node);
		  return out.get() + "\n";
		  function doitem(ctor) {
		    out.print("AST_" + ctor.TYPE);
		    var props = ctor.SELF_PROPS.filter(function(prop) {
		      return !/^\$/.test(prop);
		    });
		    if (props.length > 0) {
		      out.space();
		      out.with_parens(function() {
		        props.forEach(function(prop, i) {
		          if (i) out.space();
		          out.print(prop);
		        });
		      });
		    }
		    if (ctor.documentation) {
		      out.space();
		      out.print_string(ctor.documentation);
		    }
		    if (ctor.SUBCLASSES.length > 0) {
		      out.space();
		      out.with_block(function() {
		        ctor.SUBCLASSES.sort(function(a, b) {
		          return a.TYPE < b.TYPE ? -1 : 1;
		        }).forEach(function(ctor2, i) {
		          out.indent();
		          doitem(ctor2);
		          out.newline();
		        });
		      });
		    }
		  }
		}
		function infer_options(options) {
		  var result = exports$1.minify("", options);
		  return result.error && result.error.defs;
		}
		exports$1.default_options = function(component) {
		  if (component) {
		    var options = { module: false };
		    options[component] = { 0: 0 };
		    return infer_options(options);
		  }
		  var defs = infer_options({ 0: 0 });
		  Object.keys(defs).forEach(function(component2) {
		    var options2 = { module: false };
		    options2[component2] = { 0: 0 };
		    if (options2 = infer_options(options2)) {
		      defs[component2] = options2;
		    }
		  });
		  return defs;
		}; 
	} (node));
	return node;
}

var hasRequiredHtmlminifier;

function requireHtmlminifier () {
	if (hasRequiredHtmlminifier) return htmlminifier;
	hasRequiredHtmlminifier = 1;

	var CleanCSS = requireCleanCss();
	var decode = requireHe().decode;
	var HTMLParser = requireHtmlparser().HTMLParser;
	var RelateUrl = requireLib$v();
	var TokenChain = requireTokenchain();
	var UglifyJS = requireNode();
	var utils = requireUtils();

	function trimWhitespace(str) {
	  return str && str.replace(/^[ \n\r\t\f]+/, '').replace(/[ \n\r\t\f]+$/, '');
	}

	function collapseWhitespaceAll(str) {
	  // Non-breaking space is specifically handled inside the replacer function here:
	  return str && str.replace(/[ \n\r\t\f\xA0]+/g, function(spaces) {
	    return spaces === '\t' ? '\t' : spaces.replace(/(^|\xA0+)[^\xA0]+/g, '$1 ');
	  });
	}

	function collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {
	  var lineBreakBefore = '', lineBreakAfter = '';

	  if (options.preserveLineBreaks) {
	    str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function() {
	      lineBreakBefore = '\n';
	      return '';
	    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function() {
	      lineBreakAfter = '\n';
	      return '';
	    });
	  }

	  if (trimLeft) {
	    // Non-breaking space is specifically handled inside the replacer function here:
	    str = str.replace(/^[ \n\r\t\f\xA0]+/, function(spaces) {
	      var conservative = !lineBreakBefore && options.conservativeCollapse;
	      if (conservative && spaces === '\t') {
	        return '\t';
	      }
	      return spaces.replace(/^[^\xA0]+/, '').replace(/(\xA0+)[^\xA0]+/g, '$1 ') || (conservative ? ' ' : '');
	    });
	  }

	  if (trimRight) {
	    // Non-breaking space is specifically handled inside the replacer function here:
	    str = str.replace(/[ \n\r\t\f\xA0]+$/, function(spaces) {
	      var conservative = !lineBreakAfter && options.conservativeCollapse;
	      if (conservative && spaces === '\t') {
	        return '\t';
	      }
	      return spaces.replace(/[^\xA0]+(\xA0+)/g, ' $1').replace(/[^\xA0]+$/, '') || (conservative ? ' ' : '');
	    });
	  }

	  if (collapseAll) {
	    // strip non space whitespace then compress spaces to one
	    str = collapseWhitespaceAll(str);
	  }

	  return lineBreakBefore + str + lineBreakAfter;
	}

	var createMapFromString = utils.createMapFromString;
	// non-empty tags that will maintain whitespace around them
	var inlineTags = createMapFromString('a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var');
	// non-empty tags that will maintain whitespace within them
	var inlineTextTags = createMapFromString('a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var');
	// self-closing tags that will maintain whitespace around them
	var selfClosingInlineTags = createMapFromString('comment,img,input,wbr');

	function collapseWhitespaceSmart(str, prevTag, nextTag, options) {
	  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);
	  if (trimLeft && !options.collapseInlineTagWhitespace) {
	    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);
	  }
	  var trimRight = nextTag && !selfClosingInlineTags(nextTag);
	  if (trimRight && !options.collapseInlineTagWhitespace) {
	    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);
	  }
	  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
	}

	function isConditionalComment(text) {
	  return /^\[if\s[^\]]+]|\[endif]$/.test(text);
	}

	function isIgnoredComment(text, options) {
	  for (var i = 0, len = options.ignoreCustomComments.length; i < len; i++) {
	    if (options.ignoreCustomComments[i].test(text)) {
	      return true;
	    }
	  }
	  return false;
	}

	function isEventAttribute(attrName, options) {
	  var patterns = options.customEventAttributes;
	  if (patterns) {
	    for (var i = patterns.length; i--;) {
	      if (patterns[i].test(attrName)) {
	        return true;
	      }
	    }
	    return false;
	  }
	  return /^on[a-z]{3,}$/.test(attrName);
	}

	function canRemoveAttributeQuotes(value) {
	  // https://mathiasbynens.be/notes/unquoted-attribute-values
	  return /^[^ \t\n\f\r"'`=<>]+$/.test(value);
	}

	function attributesInclude(attributes, attribute) {
	  for (var i = attributes.length; i--;) {
	    if (attributes[i].name.toLowerCase() === attribute) {
	      return true;
	    }
	  }
	  return false;
	}

	function isAttributeRedundant(tag, attrName, attrValue, attrs) {
	  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';

	  return (
	    tag === 'script' &&
	    attrName === 'language' &&
	    attrValue === 'javascript' ||

	    tag === 'form' &&
	    attrName === 'method' &&
	    attrValue === 'get' ||

	    tag === 'input' &&
	    attrName === 'type' &&
	    attrValue === 'text' ||

	    tag === 'script' &&
	    attrName === 'charset' &&
	    !attributesInclude(attrs, 'src') ||

	    tag === 'a' &&
	    attrName === 'name' &&
	    attributesInclude(attrs, 'id') ||

	    tag === 'area' &&
	    attrName === 'shape' &&
	    attrValue === 'rect'
	  );
	}

	// https://mathiasbynens.be/demo/javascript-mime-type
	// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type
	var executableScriptsMimetypes = utils.createMap([
	  'text/javascript',
	  'text/ecmascript',
	  'text/jscript',
	  'application/javascript',
	  'application/x-javascript',
	  'application/ecmascript'
	]);

	function isScriptTypeAttribute(attrValue) {
	  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
	  return attrValue === '' || executableScriptsMimetypes(attrValue);
	}

	function isExecutableScript(tag, attrs) {
	  if (tag !== 'script') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    var attrName = attrs[i].name.toLowerCase();
	    if (attrName === 'type') {
	      return isScriptTypeAttribute(attrs[i].value);
	    }
	  }
	  return true;
	}

	function isStyleLinkTypeAttribute(attrValue) {
	  attrValue = trimWhitespace(attrValue).toLowerCase();
	  return attrValue === '' || attrValue === 'text/css';
	}

	function isStyleSheet(tag, attrs) {
	  if (tag !== 'style') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    var attrName = attrs[i].name.toLowerCase();
	    if (attrName === 'type') {
	      return isStyleLinkTypeAttribute(attrs[i].value);
	    }
	  }
	  return true;
	}

	var isSimpleBoolean = createMapFromString('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible');
	var isBooleanValue = createMapFromString('true,false');

	function isBooleanAttribute(attrName, attrValue) {
	  return isSimpleBoolean(attrName) || attrName === 'draggable' && !isBooleanValue(attrValue);
	}

	function isUriTypeAttribute(attrName, tag) {
	  return (
	    /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' ||
	    tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) ||
	    tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) ||
	    tag === 'q' && attrName === 'cite' ||
	    tag === 'blockquote' && attrName === 'cite' ||
	    (tag === 'ins' || tag === 'del') && attrName === 'cite' ||
	    tag === 'form' && attrName === 'action' ||
	    tag === 'input' && (attrName === 'src' || attrName === 'usemap') ||
	    tag === 'head' && attrName === 'profile' ||
	    tag === 'script' && (attrName === 'src' || attrName === 'for')
	  );
	}

	function isNumberTypeAttribute(attrName, tag) {
	  return (
	    /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' ||
	    tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') ||
	    tag === 'select' && (attrName === 'size' || attrName === 'tabindex') ||
	    tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) ||
	    tag === 'colgroup' && attrName === 'span' ||
	    tag === 'col' && attrName === 'span' ||
	    (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan')
	  );
	}

	function isLinkType(tag, attrs, value) {
	  if (tag !== 'link') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name === 'rel' && attrs[i].value === value) {
	      return true;
	    }
	  }
	}

	function isMediaQuery(tag, attrs, attrName) {
	  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));
	}

	var srcsetTags = createMapFromString('img,source');

	function isSrcset(attrName, tag) {
	  return attrName === 'srcset' && srcsetTags(tag);
	}

	function cleanAttributeValue(tag, attrName, attrValue, options, attrs) {
	  if (isEventAttribute(attrName, options)) {
	    attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, '');
	    return options.minifyJS(attrValue, true);
	  }
	  else if (attrName === 'class') {
	    attrValue = trimWhitespace(attrValue);
	    if (options.sortClassName) {
	      attrValue = options.sortClassName(attrValue);
	    }
	    else {
	      attrValue = collapseWhitespaceAll(attrValue);
	    }
	    return attrValue;
	  }
	  else if (isUriTypeAttribute(attrName, tag)) {
	    attrValue = trimWhitespace(attrValue);
	    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);
	  }
	  else if (isNumberTypeAttribute(attrName, tag)) {
	    return trimWhitespace(attrValue);
	  }
	  else if (attrName === 'style') {
	    attrValue = trimWhitespace(attrValue);
	    if (attrValue) {
	      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
	        attrValue = attrValue.replace(/\s*;$/, ';');
	      }
	      attrValue = options.minifyCSS(attrValue, 'inline');
	    }
	    return attrValue;
	  }
	  else if (isSrcset(attrName, tag)) {
	    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset
	    attrValue = trimWhitespace(attrValue).split(/\s+,\s*|\s*,\s+/).map(function(candidate) {
	      var url = candidate;
	      var descriptor = '';
	      var match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
	      if (match) {
	        url = url.slice(0, -match[0].length);
	        var num = +match[1].slice(0, -1);
	        var suffix = match[1].slice(-1);
	        if (num !== 1 || suffix !== 'x') {
	          descriptor = ' ' + num + suffix;
	        }
	      }
	      return options.minifyURLs(url) + descriptor;
	    }).join(', ');
	  }
	  else if (isMetaViewport(tag, attrs) && attrName === 'content') {
	    attrValue = attrValue.replace(/\s+/g, '').replace(/[0-9]+\.[0-9]+/g, function(numString) {
	      // "0.90000" -> "0.9"
	      // "1.0" -> "1"
	      // "1.0001" -> "1.0001" (unchanged)
	      return (+numString).toString();
	    });
	  }
	  else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {
	    return collapseWhitespaceAll(attrValue);
	  }
	  else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
	    attrValue = attrValue.replace(/\n+|\r+|\s{2,}/g, '');
	  }
	  else if (tag === 'script' && attrName === 'type') {
	    attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ';'));
	  }
	  else if (isMediaQuery(tag, attrs, attrName)) {
	    attrValue = trimWhitespace(attrValue);
	    return options.minifyCSS(attrValue, 'media');
	  }
	  return attrValue;
	}

	function isMetaViewport(tag, attrs) {
	  if (tag !== 'meta') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {
	      return true;
	    }
	  }
	}

	function isContentSecurityPolicy(tag, attrs) {
	  if (tag !== 'meta') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {
	      return true;
	    }
	  }
	}

	function ignoreCSS(id) {
	  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';
	}

	// Wrap CSS declarations for CleanCSS > 3.x
	// See https://github.com/jakubpawlowicz/clean-css/issues/418
	function wrapCSS(text, type) {
	  switch (type) {
	    case 'inline':
	      return '*{' + text + '}';
	    case 'media':
	      return '@media ' + text + '{a{top:0}}';
	    default:
	      return text;
	  }
	}

	function unwrapCSS(text, type) {
	  var matches;
	  switch (type) {
	    case 'inline':
	      matches = text.match(/^\*\{([\s\S]*)\}$/);
	      break;
	    case 'media':
	      matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
	      break;
	  }
	  return matches ? matches[1] : text;
	}

	function cleanConditionalComment(comment, options) {
	  return options.processConditionalComments ? comment.replace(/^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, function(match, prefix, text, suffix) {
	    return prefix + minify(text, options, true) + suffix;
	  }) : comment;
	}

	function processScript(text, options, currentAttrs) {
	  for (var i = 0, len = currentAttrs.length; i < len; i++) {
	    if (currentAttrs[i].name.toLowerCase() === 'type' &&
	        options.processScripts.indexOf(currentAttrs[i].value) > -1) {
	      return minify(text, options);
	    }
	  }
	  return text;
	}

	// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags
	// with the following deviations:
	// - retain <body> if followed by <noscript>
	// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags
	// - retain all tags which are adjacent to non-standard HTML tags
	var optionalStartTags = createMapFromString('html,head,body,colgroup,tbody');
	var optionalEndTags = createMapFromString('html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th');
	var headerTags = createMapFromString('meta,link,script,style,template,noscript');
	var descriptionTags = createMapFromString('dt,dd');
	var pBlockTags = createMapFromString('address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul');
	var pInlineTags = createMapFromString('a,audio,del,ins,map,noscript,video');
	var rubyTags = createMapFromString('rb,rt,rtc,rp');
	var rtcTag = createMapFromString('rb,rtc,rp');
	var optionTag = createMapFromString('option,optgroup');
	var tableContentTags = createMapFromString('tbody,tfoot');
	var tableSectionTags = createMapFromString('thead,tbody,tfoot');
	var cellTags = createMapFromString('td,th');
	var topLevelTags = createMapFromString('html,head,body');
	var compactTags = createMapFromString('html,body');
	var looseTags = createMapFromString('head,colgroup,caption');
	var trailingTags = createMapFromString('dt,thead');
	var htmlTags = createMapFromString('a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp');

	function canRemoveParentTag(optionalStartTag, tag) {
	  switch (optionalStartTag) {
	    case 'html':
	    case 'head':
	      return true;
	    case 'body':
	      return !headerTags(tag);
	    case 'colgroup':
	      return tag === 'col';
	    case 'tbody':
	      return tag === 'tr';
	  }
	  return false;
	}

	function isStartTagMandatory(optionalEndTag, tag) {
	  switch (tag) {
	    case 'colgroup':
	      return optionalEndTag === 'colgroup';
	    case 'tbody':
	      return tableSectionTags(optionalEndTag);
	  }
	  return false;
	}

	function canRemovePrecedingTag(optionalEndTag, tag) {
	  switch (optionalEndTag) {
	    case 'html':
	    case 'head':
	    case 'body':
	    case 'colgroup':
	    case 'caption':
	      return true;
	    case 'li':
	    case 'optgroup':
	    case 'tr':
	      return tag === optionalEndTag;
	    case 'dt':
	    case 'dd':
	      return descriptionTags(tag);
	    case 'p':
	      return pBlockTags(tag);
	    case 'rb':
	    case 'rt':
	    case 'rp':
	      return rubyTags(tag);
	    case 'rtc':
	      return rtcTag(tag);
	    case 'option':
	      return optionTag(tag);
	    case 'thead':
	    case 'tbody':
	      return tableContentTags(tag);
	    case 'tfoot':
	      return tag === 'tbody';
	    case 'td':
	    case 'th':
	      return cellTags(tag);
	  }
	  return false;
	}

	var reEmptyAttribute = new RegExp(
	  '^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' +
	    '?:down|up|over|move|out)|key(?:press|down|up)))$');

	function canDeleteEmptyAttribute(tag, attrName, attrValue, options) {
	  var isValueEmpty = !attrValue || /^\s*$/.test(attrValue);
	  if (!isValueEmpty) {
	    return false;
	  }
	  if (typeof options.removeEmptyAttributes === 'function') {
	    return options.removeEmptyAttributes(attrName, tag);
	  }
	  return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);
	}

	function hasAttrName(name, attrs) {
	  for (var i = attrs.length - 1; i >= 0; i--) {
	    if (attrs[i].name === name) {
	      return true;
	    }
	  }
	  return false;
	}

	function canRemoveElement(tag, attrs) {
	  switch (tag) {
	    case 'textarea':
	      return false;
	    case 'audio':
	    case 'script':
	    case 'video':
	      if (hasAttrName('src', attrs)) {
	        return false;
	      }
	      break;
	    case 'iframe':
	      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {
	        return false;
	      }
	      break;
	    case 'object':
	      if (hasAttrName('data', attrs)) {
	        return false;
	      }
	      break;
	    case 'applet':
	      if (hasAttrName('code', attrs)) {
	        return false;
	      }
	      break;
	  }
	  return true;
	}

	function canCollapseWhitespace(tag) {
	  return !/^(?:script|style|pre|textarea)$/.test(tag);
	}

	function canTrimWhitespace(tag) {
	  return !/^(?:pre|textarea)$/.test(tag);
	}

	function normalizeAttr(attr, attrs, tag, options) {
	  var attrName = options.name(attr.name),
	      attrValue = attr.value;

	  if (options.decodeEntities && attrValue) {
	    attrValue = decode(attrValue, { isAttributeValue: true });
	  }

	  if (options.removeRedundantAttributes &&
	    isAttributeRedundant(tag, attrName, attrValue, attrs) ||
	    options.removeScriptTypeAttributes && tag === 'script' &&
	    attrName === 'type' && isScriptTypeAttribute(attrValue) ||
	    options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') &&
	    attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {
	    return;
	  }

	  if (attrValue) {
	    attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);
	  }

	  if (options.removeEmptyAttributes &&
	      canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
	    return;
	  }

	  if (options.decodeEntities && attrValue) {
	    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');
	  }

	  return {
	    attr: attr,
	    name: attrName,
	    value: attrValue
	  };
	}

	function buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {
	  var attrName = normalized.name,
	      attrValue = normalized.value,
	      attr = normalized.attr,
	      attrQuote = attr.quote,
	      attrFragment,
	      emittedAttrValue;

	  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes ||
	      ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {
	    if (!options.preventAttributesEscaping) {
	      if (typeof options.quoteCharacter === 'undefined') {
	        var apos = (attrValue.match(/'/g) || []).length;
	        var quot = (attrValue.match(/"/g) || []).length;
	        attrQuote = apos < quot ? '\'' : '"';
	      }
	      else {
	        attrQuote = options.quoteCharacter === '\'' ? '\'' : '"';
	      }
	      if (attrQuote === '"') {
	        attrValue = attrValue.replace(/"/g, '&#34;');
	      }
	      else {
	        attrValue = attrValue.replace(/'/g, '&#39;');
	      }
	    }
	    emittedAttrValue = attrQuote + attrValue + attrQuote;
	    if (!isLast && !options.removeTagWhitespace) {
	      emittedAttrValue += ' ';
	    }
	  }
	  // make sure trailing slash is not interpreted as HTML self-closing tag
	  else if (isLast && !hasUnarySlash && !/\/$/.test(attrValue)) {
	    emittedAttrValue = attrValue;
	  }
	  else {
	    emittedAttrValue = attrValue + ' ';
	  }

	  if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes &&
	      isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {
	    attrFragment = attrName;
	    if (!isLast) {
	      attrFragment += ' ';
	    }
	  }
	  else {
	    attrFragment = attrName + attr.customAssign + emittedAttrValue;
	  }

	  return attr.customOpen + attrFragment + attr.customClose;
	}

	function identity(value) {
	  return value;
	}

	function processOptions(values) {
	  var options = {
	    name: function(name) {
	      return name.toLowerCase();
	    },
	    canCollapseWhitespace: canCollapseWhitespace,
	    canTrimWhitespace: canTrimWhitespace,
	    html5: true,
	    ignoreCustomComments: [/^!/],
	    ignoreCustomFragments: [
	      /<%[\s\S]*?%>/,
	      /<\?[\s\S]*?\?>/
	    ],
	    includeAutoGeneratedTags: true,
	    log: identity,
	    minifyCSS: identity,
	    minifyJS: identity,
	    minifyURLs: identity
	  };
	  Object.keys(values).forEach(function(key) {
	    var value = values[key];
	    if (key === 'caseSensitive') {
	      if (value) {
	        options.name = identity;
	      }
	    }
	    else if (key === 'log') {
	      if (typeof value === 'function') {
	        options.log = value;
	      }
	    }
	    else if (key === 'minifyCSS' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value !== 'object') {
	        value = {};
	      }
	      options.minifyCSS = function(text, type) {
	        text = text.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function(match, prefix, quote, url, suffix) {
	          return prefix + quote + options.minifyURLs(url) + quote + suffix;
	        });
	        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));
	        if (cleanCssOutput.errors.length > 0) {
	          cleanCssOutput.errors.forEach(options.log);
	          return text;
	        }
	        return unwrapCSS(cleanCssOutput.styles, type);
	      };
	    }
	    else if (key === 'minifyJS' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value !== 'object') {
	        value = {};
	      }
	      (value.parse || (value.parse = {})).bare_returns = false;
	      options.minifyJS = function(text, inline) {
	        var start = text.match(/^\s*<!--.*/);
	        var code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;
	        value.parse.bare_returns = inline;
	        var result = UglifyJS.minify(code, value);
	        if (result.error) {
	          options.log(result.error);
	          return text;
	        }
	        return result.code.replace(/;$/, '');
	      };
	    }
	    else if (key === 'minifyURLs' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value === 'string') {
	        value = { site: value };
	      }
	      else if (typeof value !== 'object') {
	        value = {};
	      }
	      options.minifyURLs = function(text) {
	        try {
	          return RelateUrl.relate(text, value);
	        }
	        catch (err) {
	          options.log(err);
	          return text;
	        }
	      };
	    }
	    else {
	      options[key] = value;
	    }
	  });
	  return options;
	}

	function uniqueId(value) {
	  var id;
	  do {
	    id = Math.random().toString(36).replace(/^0\.[0-9]*/, '');
	  } while (~value.indexOf(id));
	  return id;
	}

	var specialContentTags = createMapFromString('script,style');

	function createSortFns(value, options, uidIgnore, uidAttr) {
	  var attrChains = options.sortAttributes && Object.create(null);
	  var classChain = options.sortClassName && new TokenChain();

	  function attrNames(attrs) {
	    return attrs.map(function(attr) {
	      return options.name(attr.name);
	    });
	  }

	  function shouldSkipUID(token, uid) {
	    return !uid || token.indexOf(uid) === -1;
	  }

	  function shouldSkipUIDs(token) {
	    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
	  }

	  function scan(input) {
	    var currentTag, currentType;
	    new HTMLParser(input, {
	      start: function(tag, attrs) {
	        if (attrChains) {
	          if (!attrChains[tag]) {
	            attrChains[tag] = new TokenChain();
	          }
	          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));
	        }
	        for (var i = 0, len = attrs.length; i < len; i++) {
	          var attr = attrs[i];
	          if (classChain && attr.value && options.name(attr.name) === 'class') {
	            classChain.add(trimWhitespace(attr.value).split(/[ \t\n\f\r]+/).filter(shouldSkipUIDs));
	          }
	          else if (options.processScripts && attr.name.toLowerCase() === 'type') {
	            currentTag = tag;
	            currentType = attr.value;
	          }
	        }
	      },
	      end: function() {
	        currentTag = '';
	      },
	      chars: function(text) {
	        if (options.processScripts && specialContentTags(currentTag) &&
	            options.processScripts.indexOf(currentType) > -1) {
	          scan(text);
	        }
	      }
	    });
	  }

	  var log = options.log;
	  options.log = identity;
	  options.sortAttributes = false;
	  options.sortClassName = false;
	  scan(minify(value, options));
	  options.log = log;
	  if (attrChains) {
	    var attrSorters = Object.create(null);
	    for (var tag in attrChains) {
	      attrSorters[tag] = attrChains[tag].createSorter();
	    }
	    options.sortAttributes = function(tag, attrs) {
	      var sorter = attrSorters[tag];
	      if (sorter) {
	        var attrMap = Object.create(null);
	        var names = attrNames(attrs);
	        names.forEach(function(name, index) {
	          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
	        });
	        sorter.sort(names).forEach(function(name, index) {
	          attrs[index] = attrMap[name].shift();
	        });
	      }
	    };
	  }
	  if (classChain) {
	    var sorter = classChain.createSorter();
	    options.sortClassName = function(value) {
	      return sorter.sort(value.split(/[ \n\f\r]+/)).join(' ');
	    };
	  }
	}

	function minify(value, options, partialMarkup) {
	  if (options.collapseWhitespace) {
	    value = collapseWhitespace(value, options, true, true);
	  }

	  var buffer = [],
	      charsPrevTag,
	      currentChars = '',
	      hasChars,
	      currentTag = '',
	      currentAttrs = [],
	      stackNoTrimWhitespace = [],
	      stackNoCollapseWhitespace = [],
	      optionalStartTag = '',
	      optionalEndTag = '',
	      ignoredMarkupChunks = [],
	      ignoredCustomMarkupChunks = [],
	      uidIgnore,
	      uidAttr,
	      uidPattern;

	  // temporarily replace ignored chunks with comments,
	  // so that we don't have to worry what's there.
	  // for all we care there might be
	  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content
	  value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function(match, group1) {
	    if (!uidIgnore) {
	      uidIgnore = uniqueId(value);
	      var pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');
	      if (options.ignoreCustomComments) {
	        options.ignoreCustomComments = options.ignoreCustomComments.slice();
	      }
	      else {
	        options.ignoreCustomComments = [];
	      }
	      options.ignoreCustomComments.push(pattern);
	    }
	    var token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';
	    ignoredMarkupChunks.push(group1);
	    return token;
	  });

	  var customFragments = options.ignoreCustomFragments.map(function(re) {
	    return re.source;
	  });
	  if (customFragments.length) {
	    var reCustomIgnore = new RegExp('\\s*(?:' + customFragments.join('|') + ')+\\s*', 'g');
	    // temporarily replace custom ignored fragments with unique attributes
	    value = value.replace(reCustomIgnore, function(match) {
	      if (!uidAttr) {
	        uidAttr = uniqueId(value);
	        uidPattern = new RegExp('(\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\s*)', 'g');
	        if (options.minifyCSS) {
	          options.minifyCSS = (function(fn) {
	            return function(text, type) {
	              text = text.replace(uidPattern, function(match, prefix, index) {
	                var chunks = ignoredCustomMarkupChunks[+index];
	                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
	              });
	              var ids = [];
	              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function(warning) {
	                var match = uidPattern.exec(warning);
	                if (match) {
	                  var id = uidAttr + match[2] + uidAttr;
	                  text = text.replace(id, ignoreCSS(id));
	                  ids.push(id);
	                }
	              });
	              text = fn(text, type);
	              ids.forEach(function(id) {
	                text = text.replace(ignoreCSS(id), id);
	              });
	              return text;
	            };
	          })(options.minifyCSS);
	        }
	        if (options.minifyJS) {
	          options.minifyJS = (function(fn) {
	            return function(text, type) {
	              return fn(text.replace(uidPattern, function(match, prefix, index) {
	                var chunks = ignoredCustomMarkupChunks[+index];
	                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
	              }), type);
	            };
	          })(options.minifyJS);
	        }
	      }
	      var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
	      ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
	      return '\t' + token + '\t';
	    });
	  }

	  if (options.sortAttributes && typeof options.sortAttributes !== 'function' ||
	      options.sortClassName && typeof options.sortClassName !== 'function') {
	    createSortFns(value, options, uidIgnore, uidAttr);
	  }

	  function _canCollapseWhitespace(tag, attrs) {
	    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
	  }

	  function _canTrimWhitespace(tag, attrs) {
	    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
	  }

	  function removeStartTag() {
	    var index = buffer.length - 1;
	    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {
	      index--;
	    }
	    buffer.length = Math.max(0, index);
	  }

	  function removeEndTag() {
	    var index = buffer.length - 1;
	    while (index > 0 && !/^<\//.test(buffer[index])) {
	      index--;
	    }
	    buffer.length = Math.max(0, index);
	  }

	  // look for trailing whitespaces, bypass any inline tags
	  function trimTrailingWhitespace(index, nextTag) {
	    for (var endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {
	      var str = buffer[index];
	      var match = str.match(/^<\/([\w:-]+)>$/);
	      if (match) {
	        endTag = match[1];
	      }
	      else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {
	        break;
	      }
	    }
	  }

	  // look for trailing whitespaces from previously processed text
	  // which may not be trimmed due to a following comment or an empty
	  // element which has now been removed
	  function squashTrailingWhitespace(nextTag) {
	    var charsIndex = buffer.length - 1;
	    if (buffer.length > 1) {
	      var item = buffer[buffer.length - 1];
	      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
	        charsIndex--;
	      }
	    }
	    trimTrailingWhitespace(charsIndex, nextTag);
	  }

	  new HTMLParser(value, {
	    partialMarkup: partialMarkup,
	    continueOnParseError: options.continueOnParseError,
	    customAttrAssign: options.customAttrAssign,
	    customAttrSurround: options.customAttrSurround,
	    html5: options.html5,

	    start: function(tag, attrs, unary, unarySlash, autoGenerated) {
	      if (tag.toLowerCase() === 'svg') {
	        options = Object.create(options);
	        options.caseSensitive = true;
	        options.keepClosingSlash = true;
	        options.name = identity;
	      }
	      tag = options.name(tag);
	      currentTag = tag;
	      charsPrevTag = tag;
	      if (!inlineTextTags(tag)) {
	        currentChars = '';
	      }
	      hasChars = false;
	      currentAttrs = attrs;

	      var optional = options.removeOptionalTags;
	      if (optional) {
	        var htmlTag = htmlTags(tag);
	        // <html> may be omitted if first thing inside is not comment
	        // <head> may be omitted if first thing inside is an element
	        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
	        // <colgroup> may be omitted if first thing inside is <col>
	        // <tbody> may be omitted if first thing inside is <tr>
	        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // end-tag-followed-by-start-tag omission rules
	        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
	          removeEndTag();
	          // <colgroup> cannot be omitted if preceding </colgroup> is omitted
	          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted
	          optional = !isStartTagMandatory(optionalEndTag, tag);
	        }
	        optionalEndTag = '';
	      }

	      // set whitespace flags for nested tags (eg. <code> within a <pre>)
	      if (options.collapseWhitespace) {
	        if (!stackNoTrimWhitespace.length) {
	          squashTrailingWhitespace(tag);
	        }
	        if (!unary) {
	          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {
	            stackNoTrimWhitespace.push(tag);
	          }
	          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {
	            stackNoCollapseWhitespace.push(tag);
	          }
	        }
	      }

	      var openTag = '<' + tag;
	      var hasUnarySlash = unarySlash && options.keepClosingSlash;

	      buffer.push(openTag);

	      if (options.sortAttributes) {
	        options.sortAttributes(tag, attrs);
	      }

	      var parts = [];
	      for (var i = attrs.length, isLast = true; --i >= 0;) {
	        var normalized = normalizeAttr(attrs[i], attrs, tag, options);
	        if (normalized) {
	          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
	          isLast = false;
	        }
	      }
	      if (parts.length > 0) {
	        buffer.push(' ');
	        buffer.push.apply(buffer, parts);
	      }
	      // start tag must never be omitted if it has any attributes
	      else if (optional && optionalStartTags(tag)) {
	        optionalStartTag = tag;
	      }

	      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');

	      if (autoGenerated && !options.includeAutoGeneratedTags) {
	        removeStartTag();
	        optionalStartTag = '';
	      }
	    },
	    end: function(tag, attrs, autoGenerated) {
	      if (tag.toLowerCase() === 'svg') {
	        options = Object.getPrototypeOf(options);
	      }
	      tag = options.name(tag);

	      // check if current tag is in a whitespace stack
	      if (options.collapseWhitespace) {
	        if (stackNoTrimWhitespace.length) {
	          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
	            stackNoTrimWhitespace.pop();
	          }
	        }
	        else {
	          squashTrailingWhitespace('/' + tag);
	        }
	        if (stackNoCollapseWhitespace.length &&
	          tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
	          stackNoCollapseWhitespace.pop();
	        }
	      }

	      var isElementEmpty = false;
	      if (tag === currentTag) {
	        currentTag = '';
	        isElementEmpty = !hasChars;
	      }

	      if (options.removeOptionalTags) {
	        // <html>, <head> or <body> may be omitted if the element is empty
	        if (isElementEmpty && topLevelTags(optionalStartTag)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // </html> or </body> may be omitted if not followed by comment
	        // </head> may be omitted if not followed by space or comment
	        // </p> may be omitted if no more content in non-</a> parent
	        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
	        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags(tag))) {
	          removeEndTag();
	        }
	        optionalEndTag = optionalEndTags(tag) ? tag : '';
	      }

	      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
	        // remove last "element" from buffer
	        removeStartTag();
	        optionalStartTag = '';
	        optionalEndTag = '';
	      }
	      else {
	        if (autoGenerated && !options.includeAutoGeneratedTags) {
	          optionalEndTag = '';
	        }
	        else {
	          buffer.push('</' + tag + '>');
	        }
	        charsPrevTag = '/' + tag;
	        if (!inlineTags(tag)) {
	          currentChars = '';
	        }
	        else if (isElementEmpty) {
	          currentChars += '|';
	        }
	      }
	    },
	    chars: function(text, prevTag, nextTag) {
	      prevTag = prevTag === '' ? 'comment' : prevTag;
	      nextTag = nextTag === '' ? 'comment' : nextTag;
	      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
	        text = decode(text);
	      }
	      if (options.collapseWhitespace) {
	        if (!stackNoTrimWhitespace.length) {
	          if (prevTag === 'comment') {
	            var prevComment = buffer[buffer.length - 1];
	            if (prevComment.indexOf(uidIgnore) === -1) {
	              if (!prevComment) {
	                prevTag = charsPrevTag;
	              }
	              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {
	                var charsIndex = buffer.length - 2;
	                buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function(trailingSpaces) {
	                  text = trailingSpaces + text;
	                  return '';
	                });
	              }
	            }
	          }
	          if (prevTag) {
	            if (prevTag === '/nobr' || prevTag === 'wbr') {
	              if (/^\s/.test(text)) {
	                var tagIndex = buffer.length - 1;
	                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {
	                  tagIndex--;
	                }
	                trimTrailingWhitespace(tagIndex - 1, 'br');
	              }
	            }
	            else if (inlineTextTags(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {
	              text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
	            }
	          }
	          if (prevTag || nextTag) {
	            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);
	          }
	          else {
	            text = collapseWhitespace(text, options, true, true);
	          }
	          if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {
	            trimTrailingWhitespace(buffer.length - 1, nextTag);
	          }
	        }
	        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {
	          text = collapseWhitespace(text, options, false, false, true);
	        }
	      }
	      if (options.processScripts && specialContentTags(currentTag)) {
	        text = processScript(text, options, currentAttrs);
	      }
	      if (isExecutableScript(currentTag, currentAttrs)) {
	        text = options.minifyJS(text);
	      }
	      if (isStyleSheet(currentTag, currentAttrs)) {
	        text = options.minifyCSS(text);
	      }
	      if (options.removeOptionalTags && text) {
	        // <html> may be omitted if first thing inside is not comment
	        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
	        if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\s/.test(text)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // </html> or </body> may be omitted if not followed by comment
	        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment
	        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\s/.test(text)) {
	          removeEndTag();
	        }
	        optionalEndTag = '';
	      }
	      charsPrevTag = /^\s*$/.test(text) ? prevTag : 'comment';
	      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
	        // Escape any `&` symbols that start either:
	        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)
	        // 2) or any other character reference (i.e. one that does end with `;`)
	        // Note that `&` can be escaped as `&amp`, without the semi-colon.
	        // https://mathiasbynens.be/notes/ambiguous-ampersands
	        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');
	      }
	      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
	        text = text.replace(uidPattern, function(match, prefix, index) {
	          return ignoredCustomMarkupChunks[+index][0];
	        });
	      }
	      currentChars += text;
	      if (text) {
	        hasChars = true;
	      }
	      buffer.push(text);
	    },
	    comment: function(text, nonStandard) {
	      var prefix = nonStandard ? '<!' : '<!--';
	      var suffix = nonStandard ? '>' : '-->';
	      if (isConditionalComment(text)) {
	        text = prefix + cleanConditionalComment(text, options) + suffix;
	      }
	      else if (options.removeComments) {
	        if (isIgnoredComment(text, options)) {
	          text = '<!--' + text + '-->';
	        }
	        else {
	          text = '';
	        }
	      }
	      else {
	        text = prefix + text + suffix;
	      }
	      if (options.removeOptionalTags && text) {
	        // preceding comments suppress tag omissions
	        optionalStartTag = '';
	        optionalEndTag = '';
	      }
	      buffer.push(text);
	    },
	    doctype: function(doctype) {
	      buffer.push(options.useShortDoctype ? '<!doctype' +
	        (options.removeTagWhitespace ? '' : ' ') + 'html>' :
	        collapseWhitespaceAll(doctype));
	    }
	  });

	  if (options.removeOptionalTags) {
	    // <html> may be omitted if first thing inside is not comment
	    // <head> or <body> may be omitted if empty
	    if (topLevelTags(optionalStartTag)) {
	      removeStartTag();
	    }
	    // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
	    if (optionalEndTag && !trailingTags(optionalEndTag)) {
	      removeEndTag();
	    }
	  }
	  if (options.collapseWhitespace) {
	    squashTrailingWhitespace('br');
	  }

	  return joinResultSegments(buffer, options, uidPattern ? function(str) {
	    return str.replace(uidPattern, function(match, prefix, index, suffix) {
	      var chunk = ignoredCustomMarkupChunks[+index][0];
	      if (options.collapseWhitespace) {
	        if (prefix !== '\t') {
	          chunk = prefix + chunk;
	        }
	        if (suffix !== '\t') {
	          chunk += suffix;
	        }
	        return collapseWhitespace(chunk, {
	          preserveLineBreaks: options.preserveLineBreaks,
	          conservativeCollapse: !options.trimCustomFragments
	        }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
	      }
	      return chunk;
	    });
	  } : identity, uidIgnore ? function(str) {
	    return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function(match, index) {
	      return ignoredMarkupChunks[+index];
	    });
	  } : identity);
	}

	function joinResultSegments(results, options, restoreCustom, restoreIgnore) {
	  var str;
	  var maxLineLength = options.maxLineLength;
	  if (maxLineLength) {
	    var line = '', lines = [];
	    while (results.length) {
	      var len = line.length;
	      var end = results[0].indexOf('\n');
	      if (end < 0) {
	        line += restoreIgnore(restoreCustom(results.shift()));
	      }
	      else {
	        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
	        results[0] = results[0].slice(end + 1);
	      }
	      if (len > 0 && line.length > maxLineLength) {
	        lines.push(line.slice(0, len));
	        line = line.slice(len);
	      }
	      else if (end >= 0) {
	        lines.push(line);
	        line = '';
	      }
	    }
	    if (line) {
	      lines.push(line);
	    }
	    str = lines.join('\n');
	  }
	  else {
	    str = restoreIgnore(restoreCustom(results.join('')));
	  }
	  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
	}

	htmlminifier.minify = function(value, options) {
	  var start = Date.now();
	  options = processOptions(options || {});
	  var result = minify(value, options);
	  options.log('minified in: ' + (Date.now() - start) + 'ms');
	  return result;
	};
	return htmlminifier;
}

var lib$s = {exports: {}};

var _mapping = {};

/** Used to map aliases to their real names. */

var hasRequired_mapping;

function require_mapping () {
	if (hasRequired_mapping) return _mapping;
	hasRequired_mapping = 1;
	(function (exports$1) {
		exports$1.aliasToReal = {

		  // Lodash aliases.
		  'each': 'forEach',
		  'eachRight': 'forEachRight',
		  'entries': 'toPairs',
		  'entriesIn': 'toPairsIn',
		  'extend': 'assignIn',
		  'extendAll': 'assignInAll',
		  'extendAllWith': 'assignInAllWith',
		  'extendWith': 'assignInWith',
		  'first': 'head',

		  // Methods that are curried variants of others.
		  'conforms': 'conformsTo',
		  'matches': 'isMatch',
		  'property': 'get',

		  // Ramda aliases.
		  '__': 'placeholder',
		  'F': 'stubFalse',
		  'T': 'stubTrue',
		  'all': 'every',
		  'allPass': 'overEvery',
		  'always': 'constant',
		  'any': 'some',
		  'anyPass': 'overSome',
		  'apply': 'spread',
		  'assoc': 'set',
		  'assocPath': 'set',
		  'complement': 'negate',
		  'compose': 'flowRight',
		  'contains': 'includes',
		  'dissoc': 'unset',
		  'dissocPath': 'unset',
		  'dropLast': 'dropRight',
		  'dropLastWhile': 'dropRightWhile',
		  'equals': 'isEqual',
		  'identical': 'eq',
		  'indexBy': 'keyBy',
		  'init': 'initial',
		  'invertObj': 'invert',
		  'juxt': 'over',
		  'omitAll': 'omit',
		  'nAry': 'ary',
		  'path': 'get',
		  'pathEq': 'matchesProperty',
		  'pathOr': 'getOr',
		  'paths': 'at',
		  'pickAll': 'pick',
		  'pipe': 'flow',
		  'pluck': 'map',
		  'prop': 'get',
		  'propEq': 'matchesProperty',
		  'propOr': 'getOr',
		  'props': 'at',
		  'symmetricDifference': 'xor',
		  'symmetricDifferenceBy': 'xorBy',
		  'symmetricDifferenceWith': 'xorWith',
		  'takeLast': 'takeRight',
		  'takeLastWhile': 'takeRightWhile',
		  'unapply': 'rest',
		  'unnest': 'flatten',
		  'useWith': 'overArgs',
		  'where': 'conformsTo',
		  'whereEq': 'isMatch',
		  'zipObj': 'zipObject'
		};

		/** Used to map ary to method names. */
		exports$1.aryMethod = {
		  '1': [
		    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',
		    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',
		    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',
		    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',
		    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',
		    'uniqueId', 'words', 'zipAll'
		  ],
		  '2': [
		    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',
		    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',
		    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',
		    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',
		    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',
		    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',
		    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',
		    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',
		    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',
		    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',
		    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',
		    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',
		    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',
		    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',
		    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',
		    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',
		    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',
		    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',
		    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',
		    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',
		    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',
		    'zipObjectDeep'
		  ],
		  '3': [
		    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',
		    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',
		    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',
		    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',
		    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',
		    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',
		    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',
		    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',
		    'xorWith', 'zipWith'
		  ],
		  '4': [
		    'fill', 'setWith', 'updateWith'
		  ]
		};

		/** Used to map ary to rearg configs. */
		exports$1.aryRearg = {
		  '2': [1, 0],
		  '3': [2, 0, 1],
		  '4': [3, 2, 0, 1]
		};

		/** Used to map method names to their iteratee ary. */
		exports$1.iterateeAry = {
		  'dropRightWhile': 1,
		  'dropWhile': 1,
		  'every': 1,
		  'filter': 1,
		  'find': 1,
		  'findFrom': 1,
		  'findIndex': 1,
		  'findIndexFrom': 1,
		  'findKey': 1,
		  'findLast': 1,
		  'findLastFrom': 1,
		  'findLastIndex': 1,
		  'findLastIndexFrom': 1,
		  'findLastKey': 1,
		  'flatMap': 1,
		  'flatMapDeep': 1,
		  'flatMapDepth': 1,
		  'forEach': 1,
		  'forEachRight': 1,
		  'forIn': 1,
		  'forInRight': 1,
		  'forOwn': 1,
		  'forOwnRight': 1,
		  'map': 1,
		  'mapKeys': 1,
		  'mapValues': 1,
		  'partition': 1,
		  'reduce': 2,
		  'reduceRight': 2,
		  'reject': 1,
		  'remove': 1,
		  'some': 1,
		  'takeRightWhile': 1,
		  'takeWhile': 1,
		  'times': 1,
		  'transform': 2
		};

		/** Used to map method names to iteratee rearg configs. */
		exports$1.iterateeRearg = {
		  'mapKeys': [1],
		  'reduceRight': [1, 0]
		};

		/** Used to map method names to rearg configs. */
		exports$1.methodRearg = {
		  'assignInAllWith': [1, 0],
		  'assignInWith': [1, 2, 0],
		  'assignAllWith': [1, 0],
		  'assignWith': [1, 2, 0],
		  'differenceBy': [1, 2, 0],
		  'differenceWith': [1, 2, 0],
		  'getOr': [2, 1, 0],
		  'intersectionBy': [1, 2, 0],
		  'intersectionWith': [1, 2, 0],
		  'isEqualWith': [1, 2, 0],
		  'isMatchWith': [2, 1, 0],
		  'mergeAllWith': [1, 0],
		  'mergeWith': [1, 2, 0],
		  'padChars': [2, 1, 0],
		  'padCharsEnd': [2, 1, 0],
		  'padCharsStart': [2, 1, 0],
		  'pullAllBy': [2, 1, 0],
		  'pullAllWith': [2, 1, 0],
		  'rangeStep': [1, 2, 0],
		  'rangeStepRight': [1, 2, 0],
		  'setWith': [3, 1, 2, 0],
		  'sortedIndexBy': [2, 1, 0],
		  'sortedLastIndexBy': [2, 1, 0],
		  'unionBy': [1, 2, 0],
		  'unionWith': [1, 2, 0],
		  'updateWith': [3, 1, 2, 0],
		  'xorBy': [1, 2, 0],
		  'xorWith': [1, 2, 0],
		  'zipWith': [1, 2, 0]
		};

		/** Used to map method names to spread configs. */
		exports$1.methodSpread = {
		  'assignAll': { 'start': 0 },
		  'assignAllWith': { 'start': 0 },
		  'assignInAll': { 'start': 0 },
		  'assignInAllWith': { 'start': 0 },
		  'defaultsAll': { 'start': 0 },
		  'defaultsDeepAll': { 'start': 0 },
		  'invokeArgs': { 'start': 2 },
		  'invokeArgsMap': { 'start': 2 },
		  'mergeAll': { 'start': 0 },
		  'mergeAllWith': { 'start': 0 },
		  'partial': { 'start': 1 },
		  'partialRight': { 'start': 1 },
		  'without': { 'start': 1 },
		  'zipAll': { 'start': 0 }
		};

		/** Used to identify methods which mutate arrays or objects. */
		exports$1.mutate = {
		  'array': {
		    'fill': true,
		    'pull': true,
		    'pullAll': true,
		    'pullAllBy': true,
		    'pullAllWith': true,
		    'pullAt': true,
		    'remove': true,
		    'reverse': true
		  },
		  'object': {
		    'assign': true,
		    'assignAll': true,
		    'assignAllWith': true,
		    'assignIn': true,
		    'assignInAll': true,
		    'assignInAllWith': true,
		    'assignInWith': true,
		    'assignWith': true,
		    'defaults': true,
		    'defaultsAll': true,
		    'defaultsDeep': true,
		    'defaultsDeepAll': true,
		    'merge': true,
		    'mergeAll': true,
		    'mergeAllWith': true,
		    'mergeWith': true,
		  },
		  'set': {
		    'set': true,
		    'setWith': true,
		    'unset': true,
		    'update': true,
		    'updateWith': true
		  }
		};

		/** Used to map real names to their aliases. */
		exports$1.realToAlias = (function() {
		  var hasOwnProperty = Object.prototype.hasOwnProperty,
		      object = exports$1.aliasToReal,
		      result = {};

		  for (var key in object) {
		    var value = object[key];
		    if (hasOwnProperty.call(result, value)) {
		      result[value].push(key);
		    } else {
		      result[value] = [key];
		    }
		  }
		  return result;
		}());

		/** Used to map method names to other names. */
		exports$1.remap = {
		  'assignAll': 'assign',
		  'assignAllWith': 'assignWith',
		  'assignInAll': 'assignIn',
		  'assignInAllWith': 'assignInWith',
		  'curryN': 'curry',
		  'curryRightN': 'curryRight',
		  'defaultsAll': 'defaults',
		  'defaultsDeepAll': 'defaultsDeep',
		  'findFrom': 'find',
		  'findIndexFrom': 'findIndex',
		  'findLastFrom': 'findLast',
		  'findLastIndexFrom': 'findLastIndex',
		  'getOr': 'get',
		  'includesFrom': 'includes',
		  'indexOfFrom': 'indexOf',
		  'invokeArgs': 'invoke',
		  'invokeArgsMap': 'invokeMap',
		  'lastIndexOfFrom': 'lastIndexOf',
		  'mergeAll': 'merge',
		  'mergeAllWith': 'mergeWith',
		  'padChars': 'pad',
		  'padCharsEnd': 'padEnd',
		  'padCharsStart': 'padStart',
		  'propertyOf': 'get',
		  'rangeStep': 'range',
		  'rangeStepRight': 'rangeRight',
		  'restFrom': 'rest',
		  'spreadFrom': 'spread',
		  'trimChars': 'trim',
		  'trimCharsEnd': 'trimEnd',
		  'trimCharsStart': 'trimStart',
		  'zipAll': 'zip'
		};

		/** Used to track methods that skip fixing their arity. */
		exports$1.skipFixed = {
		  'castArray': true,
		  'flow': true,
		  'flowRight': true,
		  'iteratee': true,
		  'mixin': true,
		  'rearg': true,
		  'runInContext': true
		};

		/** Used to track methods that skip rearranging arguments. */
		exports$1.skipRearg = {
		  'add': true,
		  'assign': true,
		  'assignIn': true,
		  'bind': true,
		  'bindKey': true,
		  'concat': true,
		  'difference': true,
		  'divide': true,
		  'eq': true,
		  'gt': true,
		  'gte': true,
		  'isEqual': true,
		  'lt': true,
		  'lte': true,
		  'matchesProperty': true,
		  'merge': true,
		  'multiply': true,
		  'overArgs': true,
		  'partial': true,
		  'partialRight': true,
		  'propertyOf': true,
		  'random': true,
		  'range': true,
		  'rangeRight': true,
		  'subtract': true,
		  'zip': true,
		  'zipObject': true,
		  'zipObjectDeep': true
		}; 
	} (_mapping));
	return _mapping;
}

/**
 * The default argument placeholder value for methods.
 *
 * @type {Object}
 */

var placeholder;
var hasRequiredPlaceholder;

function requirePlaceholder () {
	if (hasRequiredPlaceholder) return placeholder;
	hasRequiredPlaceholder = 1;
	placeholder = {};
	return placeholder;
}

var _baseConvert;
var hasRequired_baseConvert;

function require_baseConvert () {
	if (hasRequired_baseConvert) return _baseConvert;
	hasRequired_baseConvert = 1;
	var mapping = require_mapping(),
	    fallbackHolder = requirePlaceholder();

	/** Built-in value reference. */
	var push = Array.prototype.push;

	/**
	 * Creates a function, with an arity of `n`, that invokes `func` with the
	 * arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} n The arity of the new function.
	 * @returns {Function} Returns the new function.
	 */
	function baseArity(func, n) {
	  return n == 2
	    ? function(a, b) { return func.apply(undefined, arguments); }
	    : function(a) { return func.apply(undefined, arguments); };
	}

	/**
	 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
	 * any additional arguments.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @param {number} n The arity cap.
	 * @returns {Function} Returns the new function.
	 */
	function baseAry(func, n) {
	  return n == 2
	    ? function(a, b) { return func(a, b); }
	    : function(a) { return func(a); };
	}

	/**
	 * Creates a clone of `array`.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the cloned array.
	 */
	function cloneArray(array) {
	  var length = array ? array.length : 0,
	      result = Array(length);

	  while (length--) {
	    result[length] = array[length];
	  }
	  return result;
	}

	/**
	 * Creates a function that clones a given object using the assignment `func`.
	 *
	 * @private
	 * @param {Function} func The assignment function.
	 * @returns {Function} Returns the new cloner function.
	 */
	function createCloner(func) {
	  return function(object) {
	    return func({}, object);
	  };
	}

	/**
	 * A specialized version of `_.spread` which flattens the spread array into
	 * the arguments of the invoked `func`.
	 *
	 * @private
	 * @param {Function} func The function to spread arguments over.
	 * @param {number} start The start position of the spread.
	 * @returns {Function} Returns the new function.
	 */
	function flatSpread(func, start) {
	  return function() {
	    var length = arguments.length,
	        lastIndex = length - 1,
	        args = Array(length);

	    while (length--) {
	      args[length] = arguments[length];
	    }
	    var array = args[start],
	        otherArgs = args.slice(0, start);

	    if (array) {
	      push.apply(otherArgs, array);
	    }
	    if (start != lastIndex) {
	      push.apply(otherArgs, args.slice(start + 1));
	    }
	    return func.apply(this, otherArgs);
	  };
	}

	/**
	 * Creates a function that wraps `func` and uses `cloner` to clone the first
	 * argument it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} cloner The function to clone arguments.
	 * @returns {Function} Returns the new immutable function.
	 */
	function wrapImmutable(func, cloner) {
	  return function() {
	    var length = arguments.length;
	    if (!length) {
	      return;
	    }
	    var args = Array(length);
	    while (length--) {
	      args[length] = arguments[length];
	    }
	    var result = args[0] = cloner.apply(undefined, args);
	    func.apply(undefined, args);
	    return result;
	  };
	}

	/**
	 * The base implementation of `convert` which accepts a `util` object of methods
	 * required to perform conversions.
	 *
	 * @param {Object} util The util object.
	 * @param {string} name The name of the function to convert.
	 * @param {Function} func The function to convert.
	 * @param {Object} [options] The options object.
	 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
	 * @param {boolean} [options.curry=true] Specify currying.
	 * @param {boolean} [options.fixed=true] Specify fixed arity.
	 * @param {boolean} [options.immutable=true] Specify immutable operations.
	 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
	 * @returns {Function|Object} Returns the converted function or object.
	 */
	function baseConvert(util, name, func, options) {
	  var isLib = typeof name == 'function',
	      isObj = name === Object(name);

	  if (isObj) {
	    options = func;
	    func = name;
	    name = undefined;
	  }
	  if (func == null) {
	    throw new TypeError;
	  }
	  options || (options = {});

	  var config = {
	    'cap': 'cap' in options ? options.cap : true,
	    'curry': 'curry' in options ? options.curry : true,
	    'fixed': 'fixed' in options ? options.fixed : true,
	    'immutable': 'immutable' in options ? options.immutable : true,
	    'rearg': 'rearg' in options ? options.rearg : true
	  };

	  var defaultHolder = isLib ? func : fallbackHolder,
	      forceCurry = ('curry' in options) && options.curry,
	      forceFixed = ('fixed' in options) && options.fixed,
	      forceRearg = ('rearg' in options) && options.rearg,
	      pristine = isLib ? func.runInContext() : undefined;

	  var helpers = isLib ? func : {
	    'ary': util.ary,
	    'assign': util.assign,
	    'clone': util.clone,
	    'curry': util.curry,
	    'forEach': util.forEach,
	    'isArray': util.isArray,
	    'isError': util.isError,
	    'isFunction': util.isFunction,
	    'isWeakMap': util.isWeakMap,
	    'iteratee': util.iteratee,
	    'keys': util.keys,
	    'rearg': util.rearg,
	    'toInteger': util.toInteger,
	    'toPath': util.toPath
	  };

	  var ary = helpers.ary,
	      assign = helpers.assign,
	      clone = helpers.clone,
	      curry = helpers.curry,
	      each = helpers.forEach,
	      isArray = helpers.isArray,
	      isError = helpers.isError,
	      isFunction = helpers.isFunction,
	      isWeakMap = helpers.isWeakMap,
	      keys = helpers.keys,
	      rearg = helpers.rearg,
	      toInteger = helpers.toInteger,
	      toPath = helpers.toPath;

	  var aryMethodKeys = keys(mapping.aryMethod);

	  var wrappers = {
	    'castArray': function(castArray) {
	      return function() {
	        var value = arguments[0];
	        return isArray(value)
	          ? castArray(cloneArray(value))
	          : castArray.apply(undefined, arguments);
	      };
	    },
	    'iteratee': function(iteratee) {
	      return function() {
	        var func = arguments[0],
	            arity = arguments[1],
	            result = iteratee(func, arity),
	            length = result.length;

	        if (config.cap && typeof arity == 'number') {
	          arity = arity > 2 ? (arity - 2) : 1;
	          return (length && length <= arity) ? result : baseAry(result, arity);
	        }
	        return result;
	      };
	    },
	    'mixin': function(mixin) {
	      return function(source) {
	        var func = this;
	        if (!isFunction(func)) {
	          return mixin(func, Object(source));
	        }
	        var pairs = [];
	        each(keys(source), function(key) {
	          if (isFunction(source[key])) {
	            pairs.push([key, func.prototype[key]]);
	          }
	        });

	        mixin(func, Object(source));

	        each(pairs, function(pair) {
	          var value = pair[1];
	          if (isFunction(value)) {
	            func.prototype[pair[0]] = value;
	          } else {
	            delete func.prototype[pair[0]];
	          }
	        });
	        return func;
	      };
	    },
	    'nthArg': function(nthArg) {
	      return function(n) {
	        var arity = n < 0 ? 1 : (toInteger(n) + 1);
	        return curry(nthArg(n), arity);
	      };
	    },
	    'rearg': function(rearg) {
	      return function(func, indexes) {
	        var arity = indexes ? indexes.length : 0;
	        return curry(rearg(func, indexes), arity);
	      };
	    },
	    'runInContext': function(runInContext) {
	      return function(context) {
	        return baseConvert(util, runInContext(context), options);
	      };
	    }
	  };

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Casts `func` to a function with an arity capped iteratee if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @returns {Function} Returns the cast function.
	   */
	  function castCap(name, func) {
	    if (config.cap) {
	      var indexes = mapping.iterateeRearg[name];
	      if (indexes) {
	        return iterateeRearg(func, indexes);
	      }
	      var n = !isLib && mapping.iterateeAry[name];
	      if (n) {
	        return iterateeAry(func, n);
	      }
	    }
	    return func;
	  }

	  /**
	   * Casts `func` to a curried function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity of `func`.
	   * @returns {Function} Returns the cast function.
	   */
	  function castCurry(name, func, n) {
	    return (forceCurry || (config.curry && n > 1))
	      ? curry(func, n)
	      : func;
	  }

	  /**
	   * Casts `func` to a fixed arity function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity cap.
	   * @returns {Function} Returns the cast function.
	   */
	  function castFixed(name, func, n) {
	    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
	      var data = mapping.methodSpread[name],
	          start = data && data.start;

	      return start  === undefined ? ary(func, n) : flatSpread(func, start);
	    }
	    return func;
	  }

	  /**
	   * Casts `func` to an rearged function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity of `func`.
	   * @returns {Function} Returns the cast function.
	   */
	  function castRearg(name, func, n) {
	    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))
	      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])
	      : func;
	  }

	  /**
	   * Creates a clone of `object` by `path`.
	   *
	   * @private
	   * @param {Object} object The object to clone.
	   * @param {Array|string} path The path to clone by.
	   * @returns {Object} Returns the cloned object.
	   */
	  function cloneByPath(object, path) {
	    path = toPath(path);

	    var index = -1,
	        length = path.length,
	        lastIndex = length - 1,
	        result = clone(Object(object)),
	        nested = result;

	    while (nested != null && ++index < length) {
	      var key = path[index],
	          value = nested[key];

	      if (value != null &&
	          !(isFunction(value) || isError(value) || isWeakMap(value))) {
	        nested[key] = clone(index == lastIndex ? value : Object(value));
	      }
	      nested = nested[key];
	    }
	    return result;
	  }

	  /**
	   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
	   * version with conversion `options` applied.
	   *
	   * @param {Object} [options] The options object. See `baseConvert` for more details.
	   * @returns {Function} Returns the converted `lodash`.
	   */
	  function convertLib(options) {
	    return _.runInContext.convert(options)(undefined);
	  }

	  /**
	   * Create a converter function for `func` of `name`.
	   *
	   * @param {string} name The name of the function to convert.
	   * @param {Function} func The function to convert.
	   * @returns {Function} Returns the new converter function.
	   */
	  function createConverter(name, func) {
	    var realName = mapping.aliasToReal[name] || name,
	        methodName = mapping.remap[realName] || realName,
	        oldOptions = options;

	    return function(options) {
	      var newUtil = isLib ? pristine : helpers,
	          newFunc = isLib ? pristine[methodName] : func,
	          newOptions = assign(assign({}, oldOptions), options);

	      return baseConvert(newUtil, realName, newFunc, newOptions);
	    };
	  }

	  /**
	   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
	   * arguments, ignoring any additional arguments.
	   *
	   * @private
	   * @param {Function} func The function to cap iteratee arguments for.
	   * @param {number} n The arity cap.
	   * @returns {Function} Returns the new function.
	   */
	  function iterateeAry(func, n) {
	    return overArg(func, function(func) {
	      return typeof func == 'function' ? baseAry(func, n) : func;
	    });
	  }

	  /**
	   * Creates a function that wraps `func` to invoke its iteratee with arguments
	   * arranged according to the specified `indexes` where the argument value at
	   * the first index is provided as the first argument, the argument value at
	   * the second index is provided as the second argument, and so on.
	   *
	   * @private
	   * @param {Function} func The function to rearrange iteratee arguments for.
	   * @param {number[]} indexes The arranged argument indexes.
	   * @returns {Function} Returns the new function.
	   */
	  function iterateeRearg(func, indexes) {
	    return overArg(func, function(func) {
	      var n = indexes.length;
	      return baseArity(rearg(baseAry(func, n), indexes), n);
	    });
	  }

	  /**
	   * Creates a function that invokes `func` with its first argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function() {
	      var length = arguments.length;
	      if (!length) {
	        return func();
	      }
	      var args = Array(length);
	      while (length--) {
	        args[length] = arguments[length];
	      }
	      var index = config.rearg ? 0 : (length - 1);
	      args[index] = transform(args[index]);
	      return func.apply(undefined, args);
	    };
	  }

	  /**
	   * Creates a function that wraps `func` and applys the conversions
	   * rules by `name`.
	   *
	   * @private
	   * @param {string} name The name of the function to wrap.
	   * @param {Function} func The function to wrap.
	   * @returns {Function} Returns the converted function.
	   */
	  function wrap(name, func, placeholder) {
	    var result,
	        realName = mapping.aliasToReal[name] || name,
	        wrapped = func,
	        wrapper = wrappers[realName];

	    if (wrapper) {
	      wrapped = wrapper(func);
	    }
	    else if (config.immutable) {
	      if (mapping.mutate.array[realName]) {
	        wrapped = wrapImmutable(func, cloneArray);
	      }
	      else if (mapping.mutate.object[realName]) {
	        wrapped = wrapImmutable(func, createCloner(func));
	      }
	      else if (mapping.mutate.set[realName]) {
	        wrapped = wrapImmutable(func, cloneByPath);
	      }
	    }
	    each(aryMethodKeys, function(aryKey) {
	      each(mapping.aryMethod[aryKey], function(otherName) {
	        if (realName == otherName) {
	          var data = mapping.methodSpread[realName],
	              afterRearg = data && data.afterRearg;

	          result = afterRearg
	            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)
	            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);

	          result = castCap(realName, result);
	          result = castCurry(realName, result, aryKey);
	          return false;
	        }
	      });
	      return !result;
	    });

	    result || (result = wrapped);
	    if (result == func) {
	      result = forceCurry ? curry(result, 1) : function() {
	        return func.apply(this, arguments);
	      };
	    }
	    result.convert = createConverter(realName, func);
	    result.placeholder = func.placeholder = placeholder;

	    return result;
	  }

	  /*--------------------------------------------------------------------------*/

	  if (!isObj) {
	    return wrap(name, func, defaultHolder);
	  }
	  var _ = func;

	  // Convert methods by ary cap.
	  var pairs = [];
	  each(aryMethodKeys, function(aryKey) {
	    each(mapping.aryMethod[aryKey], function(key) {
	      var func = _[mapping.remap[key] || key];
	      if (func) {
	        pairs.push([key, wrap(key, func, _)]);
	      }
	    });
	  });

	  // Convert remaining methods.
	  each(keys(_), function(key) {
	    var func = _[key];
	    if (typeof func == 'function') {
	      var length = pairs.length;
	      while (length--) {
	        if (pairs[length][0] == key) {
	          return;
	        }
	      }
	      func.convert = createConverter(key, func);
	      pairs.push([key, func]);
	    }
	  });

	  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.
	  each(pairs, function(pair) {
	    _[pair[0]] = pair[1];
	  });

	  _.convert = convertLib;
	  _.placeholder = _;

	  // Assign aliases.
	  each(keys(_), function(key) {
	    each(mapping.realToAlias[key] || [], function(alias) {
	      _[alias] = _[key];
	    });
	  });

	  return _;
	}

	_baseConvert = baseConvert;
	return _baseConvert;
}

var _metaMap;
var hasRequired_metaMap;

function require_metaMap () {
	if (hasRequired_metaMap) return _metaMap;
	hasRequired_metaMap = 1;
	var WeakMap = require_WeakMap();

	/** Used to store function metadata. */
	var metaMap = WeakMap && new WeakMap;

	_metaMap = metaMap;
	return _metaMap;
}

var _baseSetData;
var hasRequired_baseSetData;

function require_baseSetData () {
	if (hasRequired_baseSetData) return _baseSetData;
	hasRequired_baseSetData = 1;
	var identity = requireIdentity$1(),
	    metaMap = require_metaMap();

	/**
	 * The base implementation of `setData` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetData = !metaMap ? identity : function(func, data) {
	  metaMap.set(func, data);
	  return func;
	};

	_baseSetData = baseSetData;
	return _baseSetData;
}

var _createCtor;
var hasRequired_createCtor;

function require_createCtor () {
	if (hasRequired_createCtor) return _createCtor;
	hasRequired_createCtor = 1;
	var baseCreate = require_baseCreate(),
	    isObject = requireIsObject();

	/**
	 * Creates a function that produces an instance of `Ctor` regardless of
	 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	 *
	 * @private
	 * @param {Function} Ctor The constructor to wrap.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCtor(Ctor) {
	  return function() {
	    // Use a `switch` statement to work with class constructors. See
	    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	    // for more details.
	    var args = arguments;
	    switch (args.length) {
	      case 0: return new Ctor;
	      case 1: return new Ctor(args[0]);
	      case 2: return new Ctor(args[0], args[1]);
	      case 3: return new Ctor(args[0], args[1], args[2]);
	      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	    }
	    var thisBinding = baseCreate(Ctor.prototype),
	        result = Ctor.apply(thisBinding, args);

	    // Mimic the constructor's `return` behavior.
	    // See https://es5.github.io/#x13.2.2 for more details.
	    return isObject(result) ? result : thisBinding;
	  };
	}

	_createCtor = createCtor;
	return _createCtor;
}

var _createBind;
var hasRequired_createBind;

function require_createBind () {
	if (hasRequired_createBind) return _createBind;
	hasRequired_createBind = 1;
	var createCtor = require_createCtor(),
	    root = require_root();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the optional `this`
	 * binding of `thisArg`.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createBind(func, bitmask, thisArg) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return fn.apply(isBind ? thisArg : this, arguments);
	  }
	  return wrapper;
	}

	_createBind = createBind;
	return _createBind;
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var _composeArgs;
var hasRequired_composeArgs;

function require_composeArgs () {
	if (hasRequired_composeArgs) return _composeArgs;
	hasRequired_composeArgs = 1;
	var nativeMax = Math.max;

	/**
	 * Creates an array that is the composition of partially applied arguments,
	 * placeholders, and provided arguments into a single array of arguments.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to prepend to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgs(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersLength = holders.length,
	      leftIndex = -1,
	      leftLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(leftLength + rangeLength),
	      isUncurried = !isCurried;

	  while (++leftIndex < leftLength) {
	    result[leftIndex] = partials[leftIndex];
	  }
	  while (++argsIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[holders[argsIndex]] = args[argsIndex];
	    }
	  }
	  while (rangeLength--) {
	    result[leftIndex++] = args[argsIndex++];
	  }
	  return result;
	}

	_composeArgs = composeArgs;
	return _composeArgs;
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var _composeArgsRight;
var hasRequired_composeArgsRight;

function require_composeArgsRight () {
	if (hasRequired_composeArgsRight) return _composeArgsRight;
	hasRequired_composeArgsRight = 1;
	var nativeMax = Math.max;

	/**
	 * This function is like `composeArgs` except that the arguments composition
	 * is tailored for `_.partialRight`.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to append to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgsRight(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersIndex = -1,
	      holdersLength = holders.length,
	      rightIndex = -1,
	      rightLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(rangeLength + rightLength),
	      isUncurried = !isCurried;

	  while (++argsIndex < rangeLength) {
	    result[argsIndex] = args[argsIndex];
	  }
	  var offset = argsIndex;
	  while (++rightIndex < rightLength) {
	    result[offset + rightIndex] = partials[rightIndex];
	  }
	  while (++holdersIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[offset + holders[holdersIndex]] = args[argsIndex++];
	    }
	  }
	  return result;
	}

	_composeArgsRight = composeArgsRight;
	return _composeArgsRight;
}

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */

var _countHolders;
var hasRequired_countHolders;

function require_countHolders () {
	if (hasRequired_countHolders) return _countHolders;
	hasRequired_countHolders = 1;
	function countHolders(array, placeholder) {
	  var length = array.length,
	      result = 0;

	  while (length--) {
	    if (array[length] === placeholder) {
	      ++result;
	    }
	  }
	  return result;
	}

	_countHolders = countHolders;
	return _countHolders;
}

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */

var _baseLodash;
var hasRequired_baseLodash;

function require_baseLodash () {
	if (hasRequired_baseLodash) return _baseLodash;
	hasRequired_baseLodash = 1;
	function baseLodash() {
	  // No operation performed.
	}

	_baseLodash = baseLodash;
	return _baseLodash;
}

var _LazyWrapper;
var hasRequired_LazyWrapper;

function require_LazyWrapper () {
	if (hasRequired_LazyWrapper) return _LazyWrapper;
	hasRequired_LazyWrapper = 1;
	var baseCreate = require_baseCreate(),
	    baseLodash = require_baseLodash();

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/**
	 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	 *
	 * @private
	 * @constructor
	 * @param {*} value The value to wrap.
	 */
	function LazyWrapper(value) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__dir__ = 1;
	  this.__filtered__ = false;
	  this.__iteratees__ = [];
	  this.__takeCount__ = MAX_ARRAY_LENGTH;
	  this.__views__ = [];
	}

	// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;

	_LazyWrapper = LazyWrapper;
	return _LazyWrapper;
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */

var noop_1;
var hasRequiredNoop;

function requireNoop () {
	if (hasRequiredNoop) return noop_1;
	hasRequiredNoop = 1;
	function noop() {
	  // No operation performed.
	}

	noop_1 = noop;
	return noop_1;
}

var _getData;
var hasRequired_getData;

function require_getData () {
	if (hasRequired_getData) return _getData;
	hasRequired_getData = 1;
	var metaMap = require_metaMap(),
	    noop = requireNoop();

	/**
	 * Gets metadata for `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {*} Returns the metadata for `func`.
	 */
	var getData = !metaMap ? noop : function(func) {
	  return metaMap.get(func);
	};

	_getData = getData;
	return _getData;
}

/** Used to lookup unminified function names. */

var _realNames;
var hasRequired_realNames;

function require_realNames () {
	if (hasRequired_realNames) return _realNames;
	hasRequired_realNames = 1;
	var realNames = {};

	_realNames = realNames;
	return _realNames;
}

var _getFuncName;
var hasRequired_getFuncName;

function require_getFuncName () {
	if (hasRequired_getFuncName) return _getFuncName;
	hasRequired_getFuncName = 1;
	var realNames = require_realNames();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the name of `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {string} Returns the function name.
	 */
	function getFuncName(func) {
	  var result = (func.name + ''),
	      array = realNames[result],
	      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	  while (length--) {
	    var data = array[length],
	        otherFunc = data.func;
	    if (otherFunc == null || otherFunc == func) {
	      return data.name;
	    }
	  }
	  return result;
	}

	_getFuncName = getFuncName;
	return _getFuncName;
}

var _LodashWrapper;
var hasRequired_LodashWrapper;

function require_LodashWrapper () {
	if (hasRequired_LodashWrapper) return _LodashWrapper;
	hasRequired_LodashWrapper = 1;
	var baseCreate = require_baseCreate(),
	    baseLodash = require_baseLodash();

	/**
	 * The base constructor for creating `lodash` wrapper objects.
	 *
	 * @private
	 * @param {*} value The value to wrap.
	 * @param {boolean} [chainAll] Enable explicit method chain sequences.
	 */
	function LodashWrapper(value, chainAll) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__chain__ = !!chainAll;
	  this.__index__ = 0;
	  this.__values__ = undefined;
	}

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;

	_LodashWrapper = LodashWrapper;
	return _LodashWrapper;
}

var _wrapperClone;
var hasRequired_wrapperClone;

function require_wrapperClone () {
	if (hasRequired_wrapperClone) return _wrapperClone;
	hasRequired_wrapperClone = 1;
	var LazyWrapper = require_LazyWrapper(),
	    LodashWrapper = require_LodashWrapper(),
	    copyArray = require_copyArray();

	/**
	 * Creates a clone of `wrapper`.
	 *
	 * @private
	 * @param {Object} wrapper The wrapper to clone.
	 * @returns {Object} Returns the cloned wrapper.
	 */
	function wrapperClone(wrapper) {
	  if (wrapper instanceof LazyWrapper) {
	    return wrapper.clone();
	  }
	  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	  result.__actions__ = copyArray(wrapper.__actions__);
	  result.__index__  = wrapper.__index__;
	  result.__values__ = wrapper.__values__;
	  return result;
	}

	_wrapperClone = wrapperClone;
	return _wrapperClone;
}

var wrapperLodash;
var hasRequiredWrapperLodash;

function requireWrapperLodash () {
	if (hasRequiredWrapperLodash) return wrapperLodash;
	hasRequiredWrapperLodash = 1;
	var LazyWrapper = require_LazyWrapper(),
	    LodashWrapper = require_LodashWrapper(),
	    baseLodash = require_baseLodash(),
	    isArray = requireIsArray(),
	    isObjectLike = requireIsObjectLike(),
	    wrapperClone = require_wrapperClone();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates a `lodash` object which wraps `value` to enable implicit method
	 * chain sequences. Methods that operate on and return arrays, collections,
	 * and functions can be chained together. Methods that retrieve a single value
	 * or may return a primitive value will automatically end the chain sequence
	 * and return the unwrapped value. Otherwise, the value must be unwrapped
	 * with `_#value`.
	 *
	 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	 * enabled using `_.chain`.
	 *
	 * The execution of chained methods is lazy, that is, it's deferred until
	 * `_#value` is implicitly or explicitly called.
	 *
	 * Lazy evaluation allows several methods to support shortcut fusion.
	 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	 * the creation of intermediate arrays and can greatly reduce the number of
	 * iteratee executions. Sections of a chain sequence qualify for shortcut
	 * fusion if the section is applied to an array and iteratees accept only
	 * one argument. The heuristic for whether a section qualifies for shortcut
	 * fusion is subject to change.
	 *
	 * Chaining is supported in custom builds as long as the `_#value` method is
	 * directly or indirectly included in the build.
	 *
	 * In addition to lodash methods, wrappers have `Array` and `String` methods.
	 *
	 * The wrapper `Array` methods are:
	 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	 *
	 * The wrapper `String` methods are:
	 * `replace` and `split`
	 *
	 * The wrapper methods that support shortcut fusion are:
	 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	 *
	 * The chainable wrapper methods are:
	 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	 * `zipObject`, `zipObjectDeep`, and `zipWith`
	 *
	 * The wrapper methods that are **not** chainable by default are:
	 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	 * `upperFirst`, `value`, and `words`
	 *
	 * @name _
	 * @constructor
	 * @category Seq
	 * @param {*} value The value to wrap in a `lodash` instance.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var wrapped = _([1, 2, 3]);
	 *
	 * // Returns an unwrapped value.
	 * wrapped.reduce(_.add);
	 * // => 6
	 *
	 * // Returns a wrapped value.
	 * var squares = wrapped.map(square);
	 *
	 * _.isArray(squares);
	 * // => false
	 *
	 * _.isArray(squares.value());
	 * // => true
	 */
	function lodash(value) {
	  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	    if (value instanceof LodashWrapper) {
	      return value;
	    }
	    if (hasOwnProperty.call(value, '__wrapped__')) {
	      return wrapperClone(value);
	    }
	  }
	  return new LodashWrapper(value);
	}

	// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	wrapperLodash = lodash;
	return wrapperLodash;
}

var _isLaziable;
var hasRequired_isLaziable;

function require_isLaziable () {
	if (hasRequired_isLaziable) return _isLaziable;
	hasRequired_isLaziable = 1;
	var LazyWrapper = require_LazyWrapper(),
	    getData = require_getData(),
	    getFuncName = require_getFuncName(),
	    lodash = requireWrapperLodash();

	/**
	 * Checks if `func` has a lazy counterpart.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	 *  else `false`.
	 */
	function isLaziable(func) {
	  var funcName = getFuncName(func),
	      other = lodash[funcName];

	  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	    return false;
	  }
	  if (func === other) {
	    return true;
	  }
	  var data = getData(other);
	  return !!data && func === data[0];
	}

	_isLaziable = isLaziable;
	return _isLaziable;
}

var _setData;
var hasRequired_setData;

function require_setData () {
	if (hasRequired_setData) return _setData;
	hasRequired_setData = 1;
	var baseSetData = require_baseSetData(),
	    shortOut = require_shortOut();

	/**
	 * Sets metadata for `func`.
	 *
	 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	 * period of time, it will trip its breaker and transition to an identity
	 * function to avoid garbage collection pauses in V8. See
	 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	 * for more details.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var setData = shortOut(baseSetData);

	_setData = setData;
	return _setData;
}

/** Used to match wrap detail comments. */

var _getWrapDetails;
var hasRequired_getWrapDetails;

function require_getWrapDetails () {
	if (hasRequired_getWrapDetails) return _getWrapDetails;
	hasRequired_getWrapDetails = 1;
	var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	    reSplitDetails = /,? & /;

	/**
	 * Extracts wrapper details from the `source` body comment.
	 *
	 * @private
	 * @param {string} source The source to inspect.
	 * @returns {Array} Returns the wrapper details.
	 */
	function getWrapDetails(source) {
	  var match = source.match(reWrapDetails);
	  return match ? match[1].split(reSplitDetails) : [];
	}

	_getWrapDetails = getWrapDetails;
	return _getWrapDetails;
}

/** Used to match wrap detail comments. */

var _insertWrapDetails;
var hasRequired_insertWrapDetails;

function require_insertWrapDetails () {
	if (hasRequired_insertWrapDetails) return _insertWrapDetails;
	hasRequired_insertWrapDetails = 1;
	var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

	/**
	 * Inserts wrapper `details` in a comment at the top of the `source` body.
	 *
	 * @private
	 * @param {string} source The source to modify.
	 * @returns {Array} details The details to insert.
	 * @returns {string} Returns the modified source.
	 */
	function insertWrapDetails(source, details) {
	  var length = details.length;
	  if (!length) {
	    return source;
	  }
	  var lastIndex = length - 1;
	  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	  details = details.join(length > 2 ? ', ' : ' ');
	  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}

	_insertWrapDetails = insertWrapDetails;
	return _insertWrapDetails;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

var _baseIsNaN;
var hasRequired_baseIsNaN;

function require_baseIsNaN () {
	if (hasRequired_baseIsNaN) return _baseIsNaN;
	hasRequired_baseIsNaN = 1;
	function baseIsNaN(value) {
	  return value !== value;
	}

	_baseIsNaN = baseIsNaN;
	return _baseIsNaN;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

var _strictIndexOf;
var hasRequired_strictIndexOf;

function require_strictIndexOf () {
	if (hasRequired_strictIndexOf) return _strictIndexOf;
	hasRequired_strictIndexOf = 1;
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	_strictIndexOf = strictIndexOf;
	return _strictIndexOf;
}

var _baseIndexOf;
var hasRequired_baseIndexOf;

function require_baseIndexOf () {
	if (hasRequired_baseIndexOf) return _baseIndexOf;
	hasRequired_baseIndexOf = 1;
	var baseFindIndex = require_baseFindIndex(),
	    baseIsNaN = require_baseIsNaN(),
	    strictIndexOf = require_strictIndexOf();

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	_baseIndexOf = baseIndexOf;
	return _baseIndexOf;
}

var _arrayIncludes;
var hasRequired_arrayIncludes;

function require_arrayIncludes () {
	if (hasRequired_arrayIncludes) return _arrayIncludes;
	hasRequired_arrayIncludes = 1;
	var baseIndexOf = require_baseIndexOf();

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	_arrayIncludes = arrayIncludes;
	return _arrayIncludes;
}

var _updateWrapDetails;
var hasRequired_updateWrapDetails;

function require_updateWrapDetails () {
	if (hasRequired_updateWrapDetails) return _updateWrapDetails;
	hasRequired_updateWrapDetails = 1;
	var arrayEach = require_arrayEach(),
	    arrayIncludes = require_arrayIncludes();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256,
	    WRAP_FLIP_FLAG = 512;

	/** Used to associate wrap methods with their bit flags. */
	var wrapFlags = [
	  ['ary', WRAP_ARY_FLAG],
	  ['bind', WRAP_BIND_FLAG],
	  ['bindKey', WRAP_BIND_KEY_FLAG],
	  ['curry', WRAP_CURRY_FLAG],
	  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	  ['flip', WRAP_FLIP_FLAG],
	  ['partial', WRAP_PARTIAL_FLAG],
	  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	  ['rearg', WRAP_REARG_FLAG]
	];

	/**
	 * Updates wrapper `details` based on `bitmask` flags.
	 *
	 * @private
	 * @returns {Array} details The details to modify.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Array} Returns `details`.
	 */
	function updateWrapDetails(details, bitmask) {
	  arrayEach(wrapFlags, function(pair) {
	    var value = '_.' + pair[0];
	    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	      details.push(value);
	    }
	  });
	  return details.sort();
	}

	_updateWrapDetails = updateWrapDetails;
	return _updateWrapDetails;
}

var _setWrapToString;
var hasRequired_setWrapToString;

function require_setWrapToString () {
	if (hasRequired_setWrapToString) return _setWrapToString;
	hasRequired_setWrapToString = 1;
	var getWrapDetails = require_getWrapDetails(),
	    insertWrapDetails = require_insertWrapDetails(),
	    setToString = require_setToString(),
	    updateWrapDetails = require_updateWrapDetails();

	/**
	 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	 * with wrapper details in a comment at the top of the source body.
	 *
	 * @private
	 * @param {Function} wrapper The function to modify.
	 * @param {Function} reference The reference function.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Function} Returns `wrapper`.
	 */
	function setWrapToString(wrapper, reference, bitmask) {
	  var source = (reference + '');
	  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}

	_setWrapToString = setWrapToString;
	return _setWrapToString;
}

var _createRecurry;
var hasRequired_createRecurry;

function require_createRecurry () {
	if (hasRequired_createRecurry) return _createRecurry;
	hasRequired_createRecurry = 1;
	var isLaziable = require_isLaziable(),
	    setData = require_setData(),
	    setWrapToString = require_setWrapToString();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_BOUND_FLAG = 4,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64;

	/**
	 * Creates a function that wraps `func` to continue currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {Function} wrapFunc The function to create the `func` wrapper.
	 * @param {*} placeholder The placeholder value.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	  var isCurry = bitmask & WRAP_CURRY_FLAG,
	      newHolders = isCurry ? holders : undefined,
	      newHoldersRight = isCurry ? undefined : holders,
	      newPartials = isCurry ? partials : undefined,
	      newPartialsRight = isCurry ? undefined : partials;

	  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	    bitmask &= -4;
	  }
	  var newData = [
	    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	    newHoldersRight, argPos, ary, arity
	  ];

	  var result = wrapFunc.apply(undefined, newData);
	  if (isLaziable(func)) {
	    setData(result, newData);
	  }
	  result.placeholder = placeholder;
	  return setWrapToString(result, func, bitmask);
	}

	_createRecurry = createRecurry;
	return _createRecurry;
}

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */

var _getHolder;
var hasRequired_getHolder;

function require_getHolder () {
	if (hasRequired_getHolder) return _getHolder;
	hasRequired_getHolder = 1;
	function getHolder(func) {
	  var object = func;
	  return object.placeholder;
	}

	_getHolder = getHolder;
	return _getHolder;
}

var _reorder;
var hasRequired_reorder;

function require_reorder () {
	if (hasRequired_reorder) return _reorder;
	hasRequired_reorder = 1;
	var copyArray = require_copyArray(),
	    isIndex = require_isIndex();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Reorder `array` according to the specified indexes where the element at
	 * the first index is assigned as the first element, the element at
	 * the second index is assigned as the second element, and so on.
	 *
	 * @private
	 * @param {Array} array The array to reorder.
	 * @param {Array} indexes The arranged array indexes.
	 * @returns {Array} Returns `array`.
	 */
	function reorder(array, indexes) {
	  var arrLength = array.length,
	      length = nativeMin(indexes.length, arrLength),
	      oldArray = copyArray(array);

	  while (length--) {
	    var index = indexes[length];
	    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	  }
	  return array;
	}

	_reorder = reorder;
	return _reorder;
}

/** Used as the internal argument placeholder. */

var _replaceHolders;
var hasRequired_replaceHolders;

function require_replaceHolders () {
	if (hasRequired_replaceHolders) return _replaceHolders;
	hasRequired_replaceHolders = 1;
	var PLACEHOLDER = '__lodash_placeholder__';

	/**
	 * Replaces all `placeholder` elements in `array` with an internal placeholder
	 * and returns an array of their indexes.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {*} placeholder The placeholder to replace.
	 * @returns {Array} Returns the new array of placeholder indexes.
	 */
	function replaceHolders(array, placeholder) {
	  var index = -1,
	      length = array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value === placeholder || value === PLACEHOLDER) {
	      array[index] = PLACEHOLDER;
	      result[resIndex++] = index;
	    }
	  }
	  return result;
	}

	_replaceHolders = replaceHolders;
	return _replaceHolders;
}

var _createHybrid;
var hasRequired_createHybrid;

function require_createHybrid () {
	if (hasRequired_createHybrid) return _createHybrid;
	hasRequired_createHybrid = 1;
	var composeArgs = require_composeArgs(),
	    composeArgsRight = require_composeArgsRight(),
	    countHolders = require_countHolders(),
	    createCtor = require_createCtor(),
	    createRecurry = require_createRecurry(),
	    getHolder = require_getHolder(),
	    reorder = require_reorder(),
	    replaceHolders = require_replaceHolders(),
	    root = require_root();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_ARY_FLAG = 128,
	    WRAP_FLIP_FLAG = 512;

	/**
	 * Creates a function that wraps `func` to invoke it with optional `this`
	 * binding of `thisArg`, partial application, and currying.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [partialsRight] The arguments to append to those provided
	 *  to the new function.
	 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	  var isAry = bitmask & WRAP_ARY_FLAG,
	      isBind = bitmask & WRAP_BIND_FLAG,
	      isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	      isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	      isFlip = bitmask & WRAP_FLIP_FLAG,
	      Ctor = isBindKey ? undefined : createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length;

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    if (isCurried) {
	      var placeholder = getHolder(wrapper),
	          holdersCount = countHolders(args, placeholder);
	    }
	    if (partials) {
	      args = composeArgs(args, partials, holders, isCurried);
	    }
	    if (partialsRight) {
	      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	    }
	    length -= holdersCount;
	    if (isCurried && length < arity) {
	      var newHolders = replaceHolders(args, placeholder);
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	        args, newHolders, argPos, ary, arity - length
	      );
	    }
	    var thisBinding = isBind ? thisArg : this,
	        fn = isBindKey ? thisBinding[func] : func;

	    length = args.length;
	    if (argPos) {
	      args = reorder(args, argPos);
	    } else if (isFlip && length > 1) {
	      args.reverse();
	    }
	    if (isAry && ary < length) {
	      args.length = ary;
	    }
	    if (this && this !== root && this instanceof wrapper) {
	      fn = Ctor || createCtor(fn);
	    }
	    return fn.apply(thisBinding, args);
	  }
	  return wrapper;
	}

	_createHybrid = createHybrid;
	return _createHybrid;
}

var _createCurry;
var hasRequired_createCurry;

function require_createCurry () {
	if (hasRequired_createCurry) return _createCurry;
	hasRequired_createCurry = 1;
	var apply = require_apply(),
	    createCtor = require_createCtor(),
	    createHybrid = require_createHybrid(),
	    createRecurry = require_createRecurry(),
	    getHolder = require_getHolder(),
	    replaceHolders = require_replaceHolders(),
	    root = require_root();

	/**
	 * Creates a function that wraps `func` to enable currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {number} arity The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCurry(func, bitmask, arity) {
	  var Ctor = createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length,
	        placeholder = getHolder(wrapper);

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	      ? []
	      : replaceHolders(args, placeholder);

	    length -= holders.length;
	    if (length < arity) {
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, undefined,
	        args, holders, undefined, undefined, arity - length);
	    }
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return apply(fn, this, args);
	  }
	  return wrapper;
	}

	_createCurry = createCurry;
	return _createCurry;
}

var _createPartial;
var hasRequired_createPartial;

function require_createPartial () {
	if (hasRequired_createPartial) return _createPartial;
	hasRequired_createPartial = 1;
	var apply = require_apply(),
	    createCtor = require_createCtor(),
	    root = require_root();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the `this` binding
	 * of `thisArg` and `partials` prepended to the arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} partials The arguments to prepend to those provided to
	 *  the new function.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createPartial(func, bitmask, thisArg, partials) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var argsIndex = -1,
	        argsLength = arguments.length,
	        leftIndex = -1,
	        leftLength = partials.length,
	        args = Array(leftLength + argsLength),
	        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	    while (++leftIndex < leftLength) {
	      args[leftIndex] = partials[leftIndex];
	    }
	    while (argsLength--) {
	      args[leftIndex++] = arguments[++argsIndex];
	    }
	    return apply(fn, isBind ? thisArg : this, args);
	  }
	  return wrapper;
	}

	_createPartial = createPartial;
	return _createPartial;
}

var _mergeData;
var hasRequired_mergeData;

function require_mergeData () {
	if (hasRequired_mergeData) return _mergeData;
	hasRequired_mergeData = 1;
	var composeArgs = require_composeArgs(),
	    composeArgsRight = require_composeArgsRight(),
	    replaceHolders = require_replaceHolders();

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_BOUND_FLAG = 4,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Merges the function metadata of `source` into `data`.
	 *
	 * Merging metadata reduces the number of wrappers used to invoke a function.
	 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	 * may be applied regardless of execution order. Methods like `_.ary` and
	 * `_.rearg` modify function arguments, making the order in which they are
	 * executed important, preventing the merging of metadata. However, we make
	 * an exception for a safe combined case where curried functions have `_.ary`
	 * and or `_.rearg` applied.
	 *
	 * @private
	 * @param {Array} data The destination metadata.
	 * @param {Array} source The source metadata.
	 * @returns {Array} Returns `data`.
	 */
	function mergeData(data, source) {
	  var bitmask = data[1],
	      srcBitmask = source[1],
	      newBitmask = bitmask | srcBitmask,
	      isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	  var isCombo =
	    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	  // Exit early if metadata can't be merged.
	  if (!(isCommon || isCombo)) {
	    return data;
	  }
	  // Use source `thisArg` if available.
	  if (srcBitmask & WRAP_BIND_FLAG) {
	    data[2] = source[2];
	    // Set when currying a bound function.
	    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	  }
	  // Compose partial arguments.
	  var value = source[3];
	  if (value) {
	    var partials = data[3];
	    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	  }
	  // Compose partial right arguments.
	  value = source[5];
	  if (value) {
	    partials = data[5];
	    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	  }
	  // Use source `argPos` if available.
	  value = source[7];
	  if (value) {
	    data[7] = value;
	  }
	  // Use source `ary` if it's smaller.
	  if (srcBitmask & WRAP_ARY_FLAG) {
	    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	  }
	  // Use source `arity` if one is not provided.
	  if (data[9] == null) {
	    data[9] = source[9];
	  }
	  // Use source `func` and merge bitmasks.
	  data[0] = source[0];
	  data[1] = newBitmask;

	  return data;
	}

	_mergeData = mergeData;
	return _mergeData;
}

var _createWrap;
var hasRequired_createWrap;

function require_createWrap () {
	if (hasRequired_createWrap) return _createWrap;
	hasRequired_createWrap = 1;
	var baseSetData = require_baseSetData(),
	    createBind = require_createBind(),
	    createCurry = require_createCurry(),
	    createHybrid = require_createHybrid(),
	    createPartial = require_createPartial(),
	    getData = require_getData(),
	    mergeData = require_mergeData(),
	    setData = require_setData(),
	    setWrapToString = require_setWrapToString(),
	    toInteger = requireToInteger();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that either curries or invokes `func` with optional
	 * `this` binding and partially applied arguments.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags.
	 *    1 - `_.bind`
	 *    2 - `_.bindKey`
	 *    4 - `_.curry` or `_.curryRight` of a bound function
	 *    8 - `_.curry`
	 *   16 - `_.curryRight`
	 *   32 - `_.partial`
	 *   64 - `_.partialRight`
	 *  128 - `_.rearg`
	 *  256 - `_.ary`
	 *  512 - `_.flip`
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to be partially applied.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	  if (!isBindKey && typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var length = partials ? partials.length : 0;
	  if (!length) {
	    bitmask &= -97;
	    partials = holders = undefined;
	  }
	  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	  arity = arity === undefined ? arity : toInteger(arity);
	  length -= holders ? holders.length : 0;

	  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	    var partialsRight = partials,
	        holdersRight = holders;

	    partials = holders = undefined;
	  }
	  var data = isBindKey ? undefined : getData(func);

	  var newData = [
	    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	    argPos, ary, arity
	  ];

	  if (data) {
	    mergeData(newData, data);
	  }
	  func = newData[0];
	  bitmask = newData[1];
	  thisArg = newData[2];
	  partials = newData[3];
	  holders = newData[4];
	  arity = newData[9] = newData[9] === undefined
	    ? (isBindKey ? 0 : func.length)
	    : nativeMax(newData[9] - length, 0);

	  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	    bitmask &= -25;
	  }
	  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	    var result = createBind(func, bitmask, thisArg);
	  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	    result = createCurry(func, bitmask, arity);
	  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	    result = createPartial(func, bitmask, thisArg, partials);
	  } else {
	    result = createHybrid.apply(undefined, newData);
	  }
	  var setter = data ? baseSetData : setData;
	  return setWrapToString(setter(result, newData), func, bitmask);
	}

	_createWrap = createWrap;
	return _createWrap;
}

var ary_1;
var hasRequiredAry;

function requireAry () {
	if (hasRequiredAry) return ary_1;
	hasRequiredAry = 1;
	var createWrap = require_createWrap();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_ARY_FLAG = 128;

	/**
	 * Creates a function that invokes `func`, with up to `n` arguments,
	 * ignoring any additional arguments.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} func The function to cap arguments for.
	 * @param {number} [n=func.length] The arity cap.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new capped function.
	 * @example
	 *
	 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	 * // => [6, 8, 10]
	 */
	function ary(func, n, guard) {
	  n = guard ? undefined : n;
	  n = (func && n == null) ? func.length : n;
	  return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	}

	ary_1 = ary;
	return ary_1;
}

var clone_1;
var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone_1;
	hasRequiredClone = 1;
	var baseClone = require_baseClone();

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG);
	}

	clone_1 = clone;
	return clone_1;
}

var curry_1;
var hasRequiredCurry;

function requireCurry () {
	if (hasRequiredCurry) return curry_1;
	hasRequiredCurry = 1;
	var createWrap = require_createWrap();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG = 8;

	/**
	 * Creates a function that accepts arguments of `func` and either invokes
	 * `func` returning its result, if at least `arity` number of arguments have
	 * been provided, or returns a function that accepts the remaining `func`
	 * arguments, and so on. The arity of `func` may be specified if `func.length`
	 * is not sufficient.
	 *
	 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for provided arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of curried functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Function
	 * @param {Function} func The function to curry.
	 * @param {number} [arity=func.length] The arity of `func`.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new curried function.
	 * @example
	 *
	 * var abc = function(a, b, c) {
	 *   return [a, b, c];
	 * };
	 *
	 * var curried = _.curry(abc);
	 *
	 * curried(1)(2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2, 3);
	 * // => [1, 2, 3]
	 *
	 * // Curried with placeholders.
	 * curried(1)(_, 3)(2);
	 * // => [1, 2, 3]
	 */
	function curry(func, arity, guard) {
	  arity = guard ? undefined : arity;
	  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	  result.placeholder = curry.placeholder;
	  return result;
	}

	// Assign default placeholders.
	curry.placeholder = {};

	curry_1 = curry;
	return curry_1;
}

var isError_1;
var hasRequiredIsError;

function requireIsError () {
	if (hasRequiredIsError) return isError_1;
	hasRequiredIsError = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike(),
	    isPlainObject = requireIsPlainObject();

	/** `Object#toString` result references. */
	var domExcTag = '[object DOMException]',
	    errorTag = '[object Error]';

	/**
	 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	 * `SyntaxError`, `TypeError`, or `URIError` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	 * @example
	 *
	 * _.isError(new Error);
	 * // => true
	 *
	 * _.isError(Error);
	 * // => false
	 */
	function isError(value) {
	  if (!isObjectLike(value)) {
	    return false;
	  }
	  var tag = baseGetTag(value);
	  return tag == errorTag || tag == domExcTag ||
	    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	}

	isError_1 = isError;
	return isError_1;
}

var isWeakMap_1;
var hasRequiredIsWeakMap;

function requireIsWeakMap () {
	if (hasRequiredIsWeakMap) return isWeakMap_1;
	hasRequiredIsWeakMap = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var weakMapTag = '[object WeakMap]';

	/**
	 * Checks if `value` is classified as a `WeakMap` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	 * @example
	 *
	 * _.isWeakMap(new WeakMap);
	 * // => true
	 *
	 * _.isWeakMap(new Map);
	 * // => false
	 */
	function isWeakMap(value) {
	  return isObjectLike(value) && getTag(value) == weakMapTag;
	}

	isWeakMap_1 = isWeakMap;
	return isWeakMap_1;
}

var iteratee_1;
var hasRequiredIteratee;

function requireIteratee () {
	if (hasRequiredIteratee) return iteratee_1;
	hasRequiredIteratee = 1;
	var baseClone = require_baseClone(),
	    baseIteratee = require_baseIteratee();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1;

	/**
	 * Creates a function that invokes `func` with the arguments of the created
	 * function. If `func` is a property name, the created function returns the
	 * property value for a given element. If `func` is an array or object, the
	 * created function returns `true` for elements that contain the equivalent
	 * source properties, otherwise it returns `false`.
	 *
	 * @static
	 * @since 4.0.0
	 * @memberOf _
	 * @category Util
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @returns {Function} Returns the callback.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, _.iteratee(['user', 'fred']));
	 * // => [{ 'user': 'fred', 'age': 40 }]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, _.iteratee('user'));
	 * // => ['barney', 'fred']
	 *
	 * // Create custom iteratee shorthands.
	 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	 *     return func.test(string);
	 *   };
	 * });
	 *
	 * _.filter(['abc', 'def'], /ef/);
	 * // => ['def']
	 */
	function iteratee(func) {
	  return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	}

	iteratee_1 = iteratee;
	return iteratee_1;
}

var rearg_1;
var hasRequiredRearg;

function requireRearg () {
	if (hasRequiredRearg) return rearg_1;
	hasRequiredRearg = 1;
	var createWrap = require_createWrap(),
	    flatRest = require_flatRest();

	/** Used to compose bitmasks for function metadata. */
	var WRAP_REARG_FLAG = 256;

	/**
	 * Creates a function that invokes `func` with arguments arranged according
	 * to the specified `indexes` where the argument value at the first index is
	 * provided as the first argument, the argument value at the second index is
	 * provided as the second argument, and so on.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} func The function to rearrange arguments for.
	 * @param {...(number|number[])} indexes The arranged argument indexes.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var rearged = _.rearg(function(a, b, c) {
	 *   return [a, b, c];
	 * }, [2, 0, 1]);
	 *
	 * rearged('b', 'c', 'a')
	 * // => ['a', 'b', 'c']
	 */
	var rearg = flatRest(function(func, indexes) {
	  return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	});

	rearg_1 = rearg;
	return rearg_1;
}

var toPath_1;
var hasRequiredToPath;

function requireToPath () {
	if (hasRequiredToPath) return toPath_1;
	hasRequiredToPath = 1;
	var arrayMap = require_arrayMap(),
	    copyArray = require_copyArray(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol(),
	    stringToPath = require_stringToPath(),
	    toKey = require_toKey(),
	    toString = requireToString();

	/**
	 * Converts `value` to a property path array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {*} value The value to convert.
	 * @returns {Array} Returns the new property path array.
	 * @example
	 *
	 * _.toPath('a.b.c');
	 * // => ['a', 'b', 'c']
	 *
	 * _.toPath('a[0].b.c');
	 * // => ['a', '0', 'b', 'c']
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return arrayMap(value, toKey);
	  }
	  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	}

	toPath_1 = toPath;
	return toPath_1;
}

var _util;
var hasRequired_util;

function require_util () {
	if (hasRequired_util) return _util;
	hasRequired_util = 1;
	_util = {
	  'ary': requireAry(),
	  'assign': require_baseAssign(),
	  'clone': requireClone(),
	  'curry': requireCurry(),
	  'forEach': require_arrayEach(),
	  'isArray': requireIsArray(),
	  'isError': requireIsError(),
	  'isFunction': requireIsFunction(),
	  'isWeakMap': requireIsWeakMap(),
	  'iteratee': requireIteratee(),
	  'keys': require_baseKeys(),
	  'rearg': requireRearg(),
	  'toInteger': requireToInteger(),
	  'toPath': requireToPath()
	};
	return _util;
}

var convert_1;
var hasRequiredConvert;

function requireConvert () {
	if (hasRequiredConvert) return convert_1;
	hasRequiredConvert = 1;
	var baseConvert = require_baseConvert(),
	    util = require_util();

	/**
	 * Converts `func` of `name` to an immutable auto-curried iteratee-first data-last
	 * version with conversion `options` applied. If `name` is an object its methods
	 * will be converted.
	 *
	 * @param {string} name The name of the function to wrap.
	 * @param {Function} [func] The function to wrap.
	 * @param {Object} [options] The options object. See `baseConvert` for more details.
	 * @returns {Function|Object} Returns the converted function or object.
	 */
	function convert(name, func, options) {
	  return baseConvert(util, name, func, options);
	}

	convert_1 = convert;
	return convert_1;
}

var _createFlow;
var hasRequired_createFlow;

function require_createFlow () {
	if (hasRequired_createFlow) return _createFlow;
	hasRequired_createFlow = 1;
	var LodashWrapper = require_LodashWrapper(),
	    flatRest = require_flatRest(),
	    getData = require_getData(),
	    getFuncName = require_getFuncName(),
	    isArray = requireIsArray(),
	    isLaziable = require_isLaziable();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG = 8,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256;

	/**
	 * Creates a `_.flow` or `_.flowRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new flow function.
	 */
	function createFlow(fromRight) {
	  return flatRest(function(funcs) {
	    var length = funcs.length,
	        index = length,
	        prereq = LodashWrapper.prototype.thru;

	    if (fromRight) {
	      funcs.reverse();
	    }
	    while (index--) {
	      var func = funcs[index];
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	        var wrapper = new LodashWrapper([], true);
	      }
	    }
	    index = wrapper ? index : length;
	    while (++index < length) {
	      func = funcs[index];

	      var funcName = getFuncName(func),
	          data = funcName == 'wrapper' ? getData(func) : undefined;

	      if (data && isLaziable(data[0]) &&
	            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	            !data[4].length && data[9] == 1
	          ) {
	        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	      } else {
	        wrapper = (func.length == 1 && isLaziable(func))
	          ? wrapper[funcName]()
	          : wrapper.thru(func);
	      }
	    }
	    return function() {
	      var args = arguments,
	          value = args[0];

	      if (wrapper && args.length == 1 && isArray(value)) {
	        return wrapper.plant(value).value();
	      }
	      var index = 0,
	          result = length ? funcs[index].apply(this, args) : value;

	      while (++index < length) {
	        result = funcs[index].call(this, result);
	      }
	      return result;
	    };
	  });
	}

	_createFlow = createFlow;
	return _createFlow;
}

var flow_1;
var hasRequiredFlow$1;

function requireFlow$1 () {
	if (hasRequiredFlow$1) return flow_1;
	hasRequiredFlow$1 = 1;
	var createFlow = require_createFlow();

	/**
	 * Creates a function that returns the result of invoking the given functions
	 * with the `this` binding of the created function, where each successive
	 * invocation is supplied the return value of the previous.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {...(Function|Function[])} [funcs] The functions to invoke.
	 * @returns {Function} Returns the new composite function.
	 * @see _.flowRight
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var addSquare = _.flow([_.add, square]);
	 * addSquare(1, 2);
	 * // => 9
	 */
	var flow = createFlow();

	flow_1 = flow;
	return flow_1;
}

var flow;
var hasRequiredFlow;

function requireFlow () {
	if (hasRequiredFlow) return flow;
	hasRequiredFlow = 1;
	var convert = requireConvert(),
	    func = convert('flow', requireFlow$1());

	func.placeholder = requirePlaceholder();
	flow = func;
	return flow;
}

var map;
var hasRequiredMap;

function requireMap () {
	if (hasRequiredMap) return map;
	hasRequiredMap = 1;
	var convert = requireConvert(),
	    func = convert('map', requireMap$1());

	func.placeholder = requirePlaceholder();
	map = func;
	return map;
}

var filter;
var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	var convert = requireConvert(),
	    func = convert('filter', requireFilter$1());

	func.placeholder = requirePlaceholder();
	filter = func;
	return filter;
}

var findLastIndex_1;
var hasRequiredFindLastIndex;

function requireFindLastIndex () {
	if (hasRequiredFindLastIndex) return findLastIndex_1;
	hasRequiredFindLastIndex = 1;
	var baseFindIndex = require_baseFindIndex(),
	    baseIteratee = require_baseIteratee(),
	    toInteger = requireToInteger();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * This method is like `_.findIndex` except that it iterates over elements
	 * of `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=array.length-1] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': true },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': false }
	 * ];
	 *
	 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	 * // => 2
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	 * // => 0
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findLastIndex(users, ['active', false]);
	 * // => 2
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findLastIndex(users, 'active');
	 * // => 0
	 */
	function findLastIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = length - 1;
	  if (fromIndex !== undefined) {
	    index = toInteger(fromIndex);
	    index = fromIndex < 0
	      ? nativeMax(length + index, 0)
	      : nativeMin(index, length - 1);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
	}

	findLastIndex_1 = findLastIndex;
	return findLastIndex_1;
}

var lib$r = {};

var Parser = {};

var Tokenizer = {};

var decode = {};

var decodeDataHtml = {};

var hasRequiredDecodeDataHtml;

function requireDecodeDataHtml () {
	if (hasRequiredDecodeDataHtml) return decodeDataHtml;
	hasRequiredDecodeDataHtml = 1;
	// Generated using scripts/write-decode-map.ts
	Object.defineProperty(decodeDataHtml, "__esModule", { value: true });
	decodeDataHtml.default = new Uint16Array(
	// prettier-ignore
	"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
	    .split("")
	    .map(function (c) { return c.charCodeAt(0); }));
	
	return decodeDataHtml;
}

var decodeDataXml = {};

var hasRequiredDecodeDataXml;

function requireDecodeDataXml () {
	if (hasRequiredDecodeDataXml) return decodeDataXml;
	hasRequiredDecodeDataXml = 1;
	// Generated using scripts/write-decode-map.ts
	Object.defineProperty(decodeDataXml, "__esModule", { value: true });
	decodeDataXml.default = new Uint16Array(
	// prettier-ignore
	"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
	    .split("")
	    .map(function (c) { return c.charCodeAt(0); }));
	
	return decodeDataXml;
}

var decode_codepoint = {};

var hasRequiredDecode_codepoint;

function requireDecode_codepoint () {
	if (hasRequiredDecode_codepoint) return decode_codepoint;
	hasRequiredDecode_codepoint = 1;
	(function (exports$1) {
		// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
		var _a;
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.replaceCodePoint = exports$1.fromCodePoint = void 0;
		var decodeMap = new Map([
		    [0, 65533],
		    // C1 Unicode control character reference replacements
		    [128, 8364],
		    [130, 8218],
		    [131, 402],
		    [132, 8222],
		    [133, 8230],
		    [134, 8224],
		    [135, 8225],
		    [136, 710],
		    [137, 8240],
		    [138, 352],
		    [139, 8249],
		    [140, 338],
		    [142, 381],
		    [145, 8216],
		    [146, 8217],
		    [147, 8220],
		    [148, 8221],
		    [149, 8226],
		    [150, 8211],
		    [151, 8212],
		    [152, 732],
		    [153, 8482],
		    [154, 353],
		    [155, 8250],
		    [156, 339],
		    [158, 382],
		    [159, 376],
		]);
		/**
		 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
		 */
		exports$1.fromCodePoint = 
		// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
		(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
		    var output = "";
		    if (codePoint > 0xffff) {
		        codePoint -= 0x10000;
		        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
		        codePoint = 0xdc00 | (codePoint & 0x3ff);
		    }
		    output += String.fromCharCode(codePoint);
		    return output;
		};
		/**
		 * Replace the given code point with a replacement character if it is a
		 * surrogate or is outside the valid range. Otherwise return the code
		 * point unchanged.
		 */
		function replaceCodePoint(codePoint) {
		    var _a;
		    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
		        return 0xfffd;
		    }
		    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
		}
		exports$1.replaceCodePoint = replaceCodePoint;
		/**
		 * Replace the code point if relevant, then convert it to a string.
		 *
		 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
		 * @param codePoint The code point to decode.
		 * @returns The decoded code point.
		 */
		function decodeCodePoint(codePoint) {
		    return (0, exports$1.fromCodePoint)(replaceCodePoint(codePoint));
		}
		exports$1.default = decodeCodePoint;
		
	} (decode_codepoint));
	return decode_codepoint;
}

var hasRequiredDecode;

function requireDecode () {
	if (hasRequiredDecode) return decode;
	hasRequiredDecode = 1;
	(function (exports$1) {
		var __createBinding = (decode && decode.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (decode && decode.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (decode && decode.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __importDefault = (decode && decode.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.decodeXML = exports$1.decodeHTMLStrict = exports$1.decodeHTMLAttribute = exports$1.decodeHTML = exports$1.determineBranch = exports$1.EntityDecoder = exports$1.DecodingMode = exports$1.BinTrieFlags = exports$1.fromCodePoint = exports$1.replaceCodePoint = exports$1.decodeCodePoint = exports$1.xmlDecodeTree = exports$1.htmlDecodeTree = void 0;
		var decode_data_html_js_1 = __importDefault(/*@__PURE__*/ requireDecodeDataHtml());
		exports$1.htmlDecodeTree = decode_data_html_js_1.default;
		var decode_data_xml_js_1 = __importDefault(/*@__PURE__*/ requireDecodeDataXml());
		exports$1.xmlDecodeTree = decode_data_xml_js_1.default;
		var decode_codepoint_js_1 = __importStar(/*@__PURE__*/ requireDecode_codepoint());
		exports$1.decodeCodePoint = decode_codepoint_js_1.default;
		var decode_codepoint_js_2 = /*@__PURE__*/ requireDecode_codepoint();
		Object.defineProperty(exports$1, "replaceCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });
		Object.defineProperty(exports$1, "fromCodePoint", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });
		var CharCodes;
		(function (CharCodes) {
		    CharCodes[CharCodes["NUM"] = 35] = "NUM";
		    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
		    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
		    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
		    CharCodes[CharCodes["NINE"] = 57] = "NINE";
		    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
		    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
		    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
		    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
		    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
		    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
		    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
		})(CharCodes || (CharCodes = {}));
		/** Bit that needs to be set to convert an upper case ASCII character to lower case */
		var TO_LOWER_BIT = 32;
		var BinTrieFlags;
		(function (BinTrieFlags) {
		    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
		    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
		    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
		})(BinTrieFlags = exports$1.BinTrieFlags || (exports$1.BinTrieFlags = {}));
		function isNumber(code) {
		    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
		}
		function isHexadecimalCharacter(code) {
		    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
		        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
		}
		function isAsciiAlphaNumeric(code) {
		    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
		        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
		        isNumber(code));
		}
		/**
		 * Checks if the given character is a valid end character for an entity in an attribute.
		 *
		 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
		 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
		 */
		function isEntityInAttributeInvalidEnd(code) {
		    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
		}
		var EntityDecoderState;
		(function (EntityDecoderState) {
		    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
		    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
		    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
		    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
		    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
		})(EntityDecoderState || (EntityDecoderState = {}));
		var DecodingMode;
		(function (DecodingMode) {
		    /** Entities in text nodes that can end with any character. */
		    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
		    /** Only allow entities terminated with a semicolon. */
		    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
		    /** Entities in attributes have limitations on ending characters. */
		    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
		})(DecodingMode = exports$1.DecodingMode || (exports$1.DecodingMode = {}));
		/**
		 * Token decoder with support of writing partial entities.
		 */
		var EntityDecoder = /** @class */ (function () {
		    function EntityDecoder(
		    /** The tree used to decode entities. */
		    decodeTree, 
		    /**
		     * The function that is called when a codepoint is decoded.
		     *
		     * For multi-byte named entities, this will be called multiple times,
		     * with the second codepoint, and the same `consumed` value.
		     *
		     * @param codepoint The decoded codepoint.
		     * @param consumed The number of bytes consumed by the decoder.
		     */
		    emitCodePoint, 
		    /** An object that is used to produce errors. */
		    errors) {
		        this.decodeTree = decodeTree;
		        this.emitCodePoint = emitCodePoint;
		        this.errors = errors;
		        /** The current state of the decoder. */
		        this.state = EntityDecoderState.EntityStart;
		        /** Characters that were consumed while parsing an entity. */
		        this.consumed = 1;
		        /**
		         * The result of the entity.
		         *
		         * Either the result index of a numeric entity, or the codepoint of a
		         * numeric entity.
		         */
		        this.result = 0;
		        /** The current index in the decode tree. */
		        this.treeIndex = 0;
		        /** The number of characters that were consumed in excess. */
		        this.excess = 1;
		        /** The mode in which the decoder is operating. */
		        this.decodeMode = DecodingMode.Strict;
		    }
		    /** Resets the instance to make it reusable. */
		    EntityDecoder.prototype.startEntity = function (decodeMode) {
		        this.decodeMode = decodeMode;
		        this.state = EntityDecoderState.EntityStart;
		        this.result = 0;
		        this.treeIndex = 0;
		        this.excess = 1;
		        this.consumed = 1;
		    };
		    /**
		     * Write an entity to the decoder. This can be called multiple times with partial entities.
		     * If the entity is incomplete, the decoder will return -1.
		     *
		     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
		     * entity is incomplete, and resume when the next string is written.
		     *
		     * @param string The string containing the entity (or a continuation of the entity).
		     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    EntityDecoder.prototype.write = function (str, offset) {
		        switch (this.state) {
		            case EntityDecoderState.EntityStart: {
		                if (str.charCodeAt(offset) === CharCodes.NUM) {
		                    this.state = EntityDecoderState.NumericStart;
		                    this.consumed += 1;
		                    return this.stateNumericStart(str, offset + 1);
		                }
		                this.state = EntityDecoderState.NamedEntity;
		                return this.stateNamedEntity(str, offset);
		            }
		            case EntityDecoderState.NumericStart: {
		                return this.stateNumericStart(str, offset);
		            }
		            case EntityDecoderState.NumericDecimal: {
		                return this.stateNumericDecimal(str, offset);
		            }
		            case EntityDecoderState.NumericHex: {
		                return this.stateNumericHex(str, offset);
		            }
		            case EntityDecoderState.NamedEntity: {
		                return this.stateNamedEntity(str, offset);
		            }
		        }
		    };
		    /**
		     * Switches between the numeric decimal and hexadecimal states.
		     *
		     * Equivalent to the `Numeric character reference state` in the HTML spec.
		     *
		     * @param str The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    EntityDecoder.prototype.stateNumericStart = function (str, offset) {
		        if (offset >= str.length) {
		            return -1;
		        }
		        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
		            this.state = EntityDecoderState.NumericHex;
		            this.consumed += 1;
		            return this.stateNumericHex(str, offset + 1);
		        }
		        this.state = EntityDecoderState.NumericDecimal;
		        return this.stateNumericDecimal(str, offset);
		    };
		    EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {
		        if (start !== end) {
		            var digitCount = end - start;
		            this.result =
		                this.result * Math.pow(base, digitCount) +
		                    parseInt(str.substr(start, digitCount), base);
		            this.consumed += digitCount;
		        }
		    };
		    /**
		     * Parses a hexadecimal numeric entity.
		     *
		     * Equivalent to the `Hexademical character reference state` in the HTML spec.
		     *
		     * @param str The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    EntityDecoder.prototype.stateNumericHex = function (str, offset) {
		        var startIdx = offset;
		        while (offset < str.length) {
		            var char = str.charCodeAt(offset);
		            if (isNumber(char) || isHexadecimalCharacter(char)) {
		                offset += 1;
		            }
		            else {
		                this.addToNumericResult(str, startIdx, offset, 16);
		                return this.emitNumericEntity(char, 3);
		            }
		        }
		        this.addToNumericResult(str, startIdx, offset, 16);
		        return -1;
		    };
		    /**
		     * Parses a decimal numeric entity.
		     *
		     * Equivalent to the `Decimal character reference state` in the HTML spec.
		     *
		     * @param str The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {
		        var startIdx = offset;
		        while (offset < str.length) {
		            var char = str.charCodeAt(offset);
		            if (isNumber(char)) {
		                offset += 1;
		            }
		            else {
		                this.addToNumericResult(str, startIdx, offset, 10);
		                return this.emitNumericEntity(char, 2);
		            }
		        }
		        this.addToNumericResult(str, startIdx, offset, 10);
		        return -1;
		    };
		    /**
		     * Validate and emit a numeric entity.
		     *
		     * Implements the logic from the `Hexademical character reference start
		     * state` and `Numeric character reference end state` in the HTML spec.
		     *
		     * @param lastCp The last code point of the entity. Used to see if the
		     *               entity was terminated with a semicolon.
		     * @param expectedLength The minimum number of characters that should be
		     *                       consumed. Used to validate that at least one digit
		     *                       was consumed.
		     * @returns The number of characters that were consumed.
		     */
		    EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {
		        var _a;
		        // Ensure we consumed at least one digit.
		        if (this.consumed <= expectedLength) {
		            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
		            return 0;
		        }
		        // Figure out if this is a legit end of the entity
		        if (lastCp === CharCodes.SEMI) {
		            this.consumed += 1;
		        }
		        else if (this.decodeMode === DecodingMode.Strict) {
		            return 0;
		        }
		        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
		        if (this.errors) {
		            if (lastCp !== CharCodes.SEMI) {
		                this.errors.missingSemicolonAfterCharacterReference();
		            }
		            this.errors.validateNumericCharacterReference(this.result);
		        }
		        return this.consumed;
		    };
		    /**
		     * Parses a named entity.
		     *
		     * Equivalent to the `Named character reference state` in the HTML spec.
		     *
		     * @param str The string containing the entity (or a continuation of the entity).
		     * @param offset The current offset.
		     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
		     */
		    EntityDecoder.prototype.stateNamedEntity = function (str, offset) {
		        var decodeTree = this.decodeTree;
		        var current = decodeTree[this.treeIndex];
		        // The mask is the number of bytes of the value, including the current byte.
		        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		        for (; offset < str.length; offset++, this.excess++) {
		            var char = str.charCodeAt(offset);
		            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
		            if (this.treeIndex < 0) {
		                return this.result === 0 ||
		                    // If we are parsing an attribute
		                    (this.decodeMode === DecodingMode.Attribute &&
		                        // We shouldn't have consumed any characters after the entity,
		                        (valueLength === 0 ||
		                            // And there should be no invalid characters.
		                            isEntityInAttributeInvalidEnd(char)))
		                    ? 0
		                    : this.emitNotTerminatedNamedEntity();
		            }
		            current = decodeTree[this.treeIndex];
		            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		            // If the branch is a value, store it and continue
		            if (valueLength !== 0) {
		                // If the entity is terminated by a semicolon, we are done.
		                if (char === CharCodes.SEMI) {
		                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
		                }
		                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
		                if (this.decodeMode !== DecodingMode.Strict) {
		                    this.result = this.treeIndex;
		                    this.consumed += this.excess;
		                    this.excess = 0;
		                }
		            }
		        }
		        return -1;
		    };
		    /**
		     * Emit a named entity that was not terminated with a semicolon.
		     *
		     * @returns The number of characters consumed.
		     */
		    EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {
		        var _a;
		        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
		        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		        this.emitNamedEntityData(result, valueLength, this.consumed);
		        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
		        return this.consumed;
		    };
		    /**
		     * Emit a named entity.
		     *
		     * @param result The index of the entity in the decode tree.
		     * @param valueLength The number of bytes in the entity.
		     * @param consumed The number of characters consumed.
		     *
		     * @returns The number of characters consumed.
		     */
		    EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {
		        var decodeTree = this.decodeTree;
		        this.emitCodePoint(valueLength === 1
		            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
		            : decodeTree[result + 1], consumed);
		        if (valueLength === 3) {
		            // For multi-byte values, we need to emit the second byte.
		            this.emitCodePoint(decodeTree[result + 2], consumed);
		        }
		        return consumed;
		    };
		    /**
		     * Signal to the parser that the end of the input was reached.
		     *
		     * Remaining data will be emitted and relevant errors will be produced.
		     *
		     * @returns The number of characters consumed.
		     */
		    EntityDecoder.prototype.end = function () {
		        var _a;
		        switch (this.state) {
		            case EntityDecoderState.NamedEntity: {
		                // Emit a named entity if we have one.
		                return this.result !== 0 &&
		                    (this.decodeMode !== DecodingMode.Attribute ||
		                        this.result === this.treeIndex)
		                    ? this.emitNotTerminatedNamedEntity()
		                    : 0;
		            }
		            // Otherwise, emit a numeric entity if we have one.
		            case EntityDecoderState.NumericDecimal: {
		                return this.emitNumericEntity(0, 2);
		            }
		            case EntityDecoderState.NumericHex: {
		                return this.emitNumericEntity(0, 3);
		            }
		            case EntityDecoderState.NumericStart: {
		                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
		                return 0;
		            }
		            case EntityDecoderState.EntityStart: {
		                // Return 0 if we have no entity.
		                return 0;
		            }
		        }
		    };
		    return EntityDecoder;
		}());
		exports$1.EntityDecoder = EntityDecoder;
		/**
		 * Creates a function that decodes entities in a string.
		 *
		 * @param decodeTree The decode tree.
		 * @returns A function that decodes entities in a string.
		 */
		function getDecoder(decodeTree) {
		    var ret = "";
		    var decoder = new EntityDecoder(decodeTree, function (str) { return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str)); });
		    return function decodeWithTrie(str, decodeMode) {
		        var lastIndex = 0;
		        var offset = 0;
		        while ((offset = str.indexOf("&", offset)) >= 0) {
		            ret += str.slice(lastIndex, offset);
		            decoder.startEntity(decodeMode);
		            var len = decoder.write(str, 
		            // Skip the "&"
		            offset + 1);
		            if (len < 0) {
		                lastIndex = offset + decoder.end();
		                break;
		            }
		            lastIndex = offset + len;
		            // If `len` is 0, skip the current `&` and continue.
		            offset = len === 0 ? lastIndex + 1 : lastIndex;
		        }
		        var result = ret + str.slice(lastIndex);
		        // Make sure we don't keep a reference to the final string.
		        ret = "";
		        return result;
		    };
		}
		/**
		 * Determines the branch of the current node that is taken given the current
		 * character. This function is used to traverse the trie.
		 *
		 * @param decodeTree The trie.
		 * @param current The current node.
		 * @param nodeIdx The index right after the current node and its value.
		 * @param char The current character.
		 * @returns The index of the next node, or -1 if no branch is taken.
		 */
		function determineBranch(decodeTree, current, nodeIdx, char) {
		    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
		    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
		    // Case 1: Single branch encoded in jump offset
		    if (branchCount === 0) {
		        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
		    }
		    // Case 2: Multiple branches encoded in jump table
		    if (jumpOffset) {
		        var value = char - jumpOffset;
		        return value < 0 || value >= branchCount
		            ? -1
		            : decodeTree[nodeIdx + value] - 1;
		    }
		    // Case 3: Multiple branches encoded in dictionary
		    // Binary search for the character.
		    var lo = nodeIdx;
		    var hi = lo + branchCount - 1;
		    while (lo <= hi) {
		        var mid = (lo + hi) >>> 1;
		        var midVal = decodeTree[mid];
		        if (midVal < char) {
		            lo = mid + 1;
		        }
		        else if (midVal > char) {
		            hi = mid - 1;
		        }
		        else {
		            return decodeTree[mid + branchCount];
		        }
		    }
		    return -1;
		}
		exports$1.determineBranch = determineBranch;
		var htmlDecoder = getDecoder(decode_data_html_js_1.default);
		var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
		/**
		 * Decodes an HTML string.
		 *
		 * @param str The string to decode.
		 * @param mode The decoding mode.
		 * @returns The decoded string.
		 */
		function decodeHTML(str, mode) {
		    if (mode === void 0) { mode = DecodingMode.Legacy; }
		    return htmlDecoder(str, mode);
		}
		exports$1.decodeHTML = decodeHTML;
		/**
		 * Decodes an HTML string in an attribute.
		 *
		 * @param str The string to decode.
		 * @returns The decoded string.
		 */
		function decodeHTMLAttribute(str) {
		    return htmlDecoder(str, DecodingMode.Attribute);
		}
		exports$1.decodeHTMLAttribute = decodeHTMLAttribute;
		/**
		 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
		 *
		 * @param str The string to decode.
		 * @returns The decoded string.
		 */
		function decodeHTMLStrict(str) {
		    return htmlDecoder(str, DecodingMode.Strict);
		}
		exports$1.decodeHTMLStrict = decodeHTMLStrict;
		/**
		 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
		 *
		 * @param str The string to decode.
		 * @returns The decoded string.
		 */
		function decodeXML(str) {
		    return xmlDecoder(str, DecodingMode.Strict);
		}
		exports$1.decodeXML = decodeXML;
		
	} (decode));
	return decode;
}

var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return Tokenizer;
	hasRequiredTokenizer = 1;
	Object.defineProperty(Tokenizer, "__esModule", { value: true });
	Tokenizer.QuoteType = void 0;
	var decode_js_1 = /*@__PURE__*/ requireDecode();
	var CharCodes;
	(function (CharCodes) {
	    CharCodes[CharCodes["Tab"] = 9] = "Tab";
	    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
	    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
	    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
	    CharCodes[CharCodes["Space"] = 32] = "Space";
	    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
	    CharCodes[CharCodes["Number"] = 35] = "Number";
	    CharCodes[CharCodes["Amp"] = 38] = "Amp";
	    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
	    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
	    CharCodes[CharCodes["Dash"] = 45] = "Dash";
	    CharCodes[CharCodes["Slash"] = 47] = "Slash";
	    CharCodes[CharCodes["Zero"] = 48] = "Zero";
	    CharCodes[CharCodes["Nine"] = 57] = "Nine";
	    CharCodes[CharCodes["Semi"] = 59] = "Semi";
	    CharCodes[CharCodes["Lt"] = 60] = "Lt";
	    CharCodes[CharCodes["Eq"] = 61] = "Eq";
	    CharCodes[CharCodes["Gt"] = 62] = "Gt";
	    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
	    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
	    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
	    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
	    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
	    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
	    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
	    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
	    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
	})(CharCodes || (CharCodes = {}));
	/** All the states the tokenizer can be in. */
	var State;
	(function (State) {
	    State[State["Text"] = 1] = "Text";
	    State[State["BeforeTagName"] = 2] = "BeforeTagName";
	    State[State["InTagName"] = 3] = "InTagName";
	    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
	    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
	    State[State["InClosingTagName"] = 6] = "InClosingTagName";
	    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
	    // Attributes
	    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
	    State[State["InAttributeName"] = 9] = "InAttributeName";
	    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
	    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
	    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
	    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
	    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
	    // Declarations
	    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
	    State[State["InDeclaration"] = 16] = "InDeclaration";
	    // Processing instructions
	    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
	    // Comments & CDATA
	    State[State["BeforeComment"] = 18] = "BeforeComment";
	    State[State["CDATASequence"] = 19] = "CDATASequence";
	    State[State["InSpecialComment"] = 20] = "InSpecialComment";
	    State[State["InCommentLike"] = 21] = "InCommentLike";
	    // Special tags
	    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
	    State[State["BeforeSpecialT"] = 23] = "BeforeSpecialT";
	    State[State["SpecialStartSequence"] = 24] = "SpecialStartSequence";
	    State[State["InSpecialTag"] = 25] = "InSpecialTag";
	    State[State["InEntity"] = 26] = "InEntity";
	})(State || (State = {}));
	function isWhitespace(c) {
	    return (c === CharCodes.Space ||
	        c === CharCodes.NewLine ||
	        c === CharCodes.Tab ||
	        c === CharCodes.FormFeed ||
	        c === CharCodes.CarriageReturn);
	}
	function isEndOfTagSection(c) {
	    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
	}
	function isASCIIAlpha(c) {
	    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
	        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
	}
	var QuoteType;
	(function (QuoteType) {
	    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
	    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
	    QuoteType[QuoteType["Single"] = 2] = "Single";
	    QuoteType[QuoteType["Double"] = 3] = "Double";
	})(QuoteType || (Tokenizer.QuoteType = QuoteType = {}));
	/**
	 * Sequences used to match longer strings.
	 *
	 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
	 * sequences with an increased offset.
	 */
	var Sequences = {
	    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[
	    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>
	    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`
	    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`
	    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`
	    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
	    TextareaEnd: new Uint8Array([
	        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,
	    ]), // `</textarea`
	};
	var Tokenizer$1 = /** @class */ (function () {
	    function Tokenizer(_a, cbs) {
	        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
	        var _this = this;
	        this.cbs = cbs;
	        /** The current state the tokenizer is in. */
	        this.state = State.Text;
	        /** The read buffer. */
	        this.buffer = "";
	        /** The beginning of the section that is currently being read. */
	        this.sectionStart = 0;
	        /** The index within the buffer that we are currently looking at. */
	        this.index = 0;
	        /** The start of the last entity. */
	        this.entityStart = 0;
	        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
	        this.baseState = State.Text;
	        /** For special parsing behavior inside of script and style tags. */
	        this.isSpecial = false;
	        /** Indicates whether the tokenizer has been paused. */
	        this.running = true;
	        /** The offset of the current buffer. */
	        this.offset = 0;
	        this.currentSequence = undefined;
	        this.sequenceIndex = 0;
	        this.xmlMode = xmlMode;
	        this.decodeEntities = decodeEntities;
	        this.entityDecoder = new decode_js_1.EntityDecoder(xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree, function (cp, consumed) { return _this.emitCodePoint(cp, consumed); });
	    }
	    Tokenizer.prototype.reset = function () {
	        this.state = State.Text;
	        this.buffer = "";
	        this.sectionStart = 0;
	        this.index = 0;
	        this.baseState = State.Text;
	        this.currentSequence = undefined;
	        this.running = true;
	        this.offset = 0;
	    };
	    Tokenizer.prototype.write = function (chunk) {
	        this.offset += this.buffer.length;
	        this.buffer = chunk;
	        this.parse();
	    };
	    Tokenizer.prototype.end = function () {
	        if (this.running)
	            this.finish();
	    };
	    Tokenizer.prototype.pause = function () {
	        this.running = false;
	    };
	    Tokenizer.prototype.resume = function () {
	        this.running = true;
	        if (this.index < this.buffer.length + this.offset) {
	            this.parse();
	        }
	    };
	    Tokenizer.prototype.stateText = function (c) {
	        if (c === CharCodes.Lt ||
	            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
	            if (this.index > this.sectionStart) {
	                this.cbs.ontext(this.sectionStart, this.index);
	            }
	            this.state = State.BeforeTagName;
	            this.sectionStart = this.index;
	        }
	        else if (this.decodeEntities && c === CharCodes.Amp) {
	            this.startEntity();
	        }
	    };
	    Tokenizer.prototype.stateSpecialStartSequence = function (c) {
	        var isEnd = this.sequenceIndex === this.currentSequence.length;
	        var isMatch = isEnd
	            ? // If we are at the end of the sequence, make sure the tag name has ended
	                isEndOfTagSection(c)
	            : // Otherwise, do a case-insensitive comparison
	                (c | 0x20) === this.currentSequence[this.sequenceIndex];
	        if (!isMatch) {
	            this.isSpecial = false;
	        }
	        else if (!isEnd) {
	            this.sequenceIndex++;
	            return;
	        }
	        this.sequenceIndex = 0;
	        this.state = State.InTagName;
	        this.stateInTagName(c);
	    };
	    /** Look for an end tag. For <title> tags, also decode entities. */
	    Tokenizer.prototype.stateInSpecialTag = function (c) {
	        if (this.sequenceIndex === this.currentSequence.length) {
	            if (c === CharCodes.Gt || isWhitespace(c)) {
	                var endOfText = this.index - this.currentSequence.length;
	                if (this.sectionStart < endOfText) {
	                    // Spoof the index so that reported locations match up.
	                    var actualIndex = this.index;
	                    this.index = endOfText;
	                    this.cbs.ontext(this.sectionStart, endOfText);
	                    this.index = actualIndex;
	                }
	                this.isSpecial = false;
	                this.sectionStart = endOfText + 2; // Skip over the `</`
	                this.stateInClosingTagName(c);
	                return; // We are done; skip the rest of the function.
	            }
	            this.sequenceIndex = 0;
	        }
	        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
	            this.sequenceIndex += 1;
	        }
	        else if (this.sequenceIndex === 0) {
	            if (this.currentSequence === Sequences.TitleEnd) {
	                // We have to parse entities in <title> tags.
	                if (this.decodeEntities && c === CharCodes.Amp) {
	                    this.startEntity();
	                }
	            }
	            else if (this.fastForwardTo(CharCodes.Lt)) {
	                // Outside of <title> tags, we can fast-forward.
	                this.sequenceIndex = 1;
	            }
	        }
	        else {
	            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
	            this.sequenceIndex = Number(c === CharCodes.Lt);
	        }
	    };
	    Tokenizer.prototype.stateCDATASequence = function (c) {
	        if (c === Sequences.Cdata[this.sequenceIndex]) {
	            if (++this.sequenceIndex === Sequences.Cdata.length) {
	                this.state = State.InCommentLike;
	                this.currentSequence = Sequences.CdataEnd;
	                this.sequenceIndex = 0;
	                this.sectionStart = this.index + 1;
	            }
	        }
	        else {
	            this.sequenceIndex = 0;
	            this.state = State.InDeclaration;
	            this.stateInDeclaration(c); // Reconsume the character
	        }
	    };
	    /**
	     * When we wait for one specific character, we can speed things up
	     * by skipping through the buffer until we find it.
	     *
	     * @returns Whether the character was found.
	     */
	    Tokenizer.prototype.fastForwardTo = function (c) {
	        while (++this.index < this.buffer.length + this.offset) {
	            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
	                return true;
	            }
	        }
	        /*
	         * We increment the index at the end of the `parse` loop,
	         * so set it to `buffer.length - 1` here.
	         *
	         * TODO: Refactor `parse` to increment index before calling states.
	         */
	        this.index = this.buffer.length + this.offset - 1;
	        return false;
	    };
	    /**
	     * Comments and CDATA end with `-->` and `]]>`.
	     *
	     * Their common qualities are:
	     * - Their end sequences have a distinct character they start with.
	     * - That character is then repeated, so we have to check multiple repeats.
	     * - All characters but the start character of the sequence can be skipped.
	     */
	    Tokenizer.prototype.stateInCommentLike = function (c) {
	        if (c === this.currentSequence[this.sequenceIndex]) {
	            if (++this.sequenceIndex === this.currentSequence.length) {
	                if (this.currentSequence === Sequences.CdataEnd) {
	                    this.cbs.oncdata(this.sectionStart, this.index, 2);
	                }
	                else {
	                    this.cbs.oncomment(this.sectionStart, this.index, 2);
	                }
	                this.sequenceIndex = 0;
	                this.sectionStart = this.index + 1;
	                this.state = State.Text;
	            }
	        }
	        else if (this.sequenceIndex === 0) {
	            // Fast-forward to the first character of the sequence
	            if (this.fastForwardTo(this.currentSequence[0])) {
	                this.sequenceIndex = 1;
	            }
	        }
	        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
	            // Allow long sequences, eg. --->, ]]]>
	            this.sequenceIndex = 0;
	        }
	    };
	    /**
	     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
	     *
	     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
	     * We allow anything that wouldn't end the tag.
	     */
	    Tokenizer.prototype.isTagStartChar = function (c) {
	        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
	    };
	    Tokenizer.prototype.startSpecial = function (sequence, offset) {
	        this.isSpecial = true;
	        this.currentSequence = sequence;
	        this.sequenceIndex = offset;
	        this.state = State.SpecialStartSequence;
	    };
	    Tokenizer.prototype.stateBeforeTagName = function (c) {
	        if (c === CharCodes.ExclamationMark) {
	            this.state = State.BeforeDeclaration;
	            this.sectionStart = this.index + 1;
	        }
	        else if (c === CharCodes.Questionmark) {
	            this.state = State.InProcessingInstruction;
	            this.sectionStart = this.index + 1;
	        }
	        else if (this.isTagStartChar(c)) {
	            var lower = c | 0x20;
	            this.sectionStart = this.index;
	            if (this.xmlMode) {
	                this.state = State.InTagName;
	            }
	            else if (lower === Sequences.ScriptEnd[2]) {
	                this.state = State.BeforeSpecialS;
	            }
	            else if (lower === Sequences.TitleEnd[2]) {
	                this.state = State.BeforeSpecialT;
	            }
	            else {
	                this.state = State.InTagName;
	            }
	        }
	        else if (c === CharCodes.Slash) {
	            this.state = State.BeforeClosingTagName;
	        }
	        else {
	            this.state = State.Text;
	            this.stateText(c);
	        }
	    };
	    Tokenizer.prototype.stateInTagName = function (c) {
	        if (isEndOfTagSection(c)) {
	            this.cbs.onopentagname(this.sectionStart, this.index);
	            this.sectionStart = -1;
	            this.state = State.BeforeAttributeName;
	            this.stateBeforeAttributeName(c);
	        }
	    };
	    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
	        if (isWhitespace(c)) ;
	        else if (c === CharCodes.Gt) {
	            this.state = State.Text;
	        }
	        else {
	            this.state = this.isTagStartChar(c)
	                ? State.InClosingTagName
	                : State.InSpecialComment;
	            this.sectionStart = this.index;
	        }
	    };
	    Tokenizer.prototype.stateInClosingTagName = function (c) {
	        if (c === CharCodes.Gt || isWhitespace(c)) {
	            this.cbs.onclosetag(this.sectionStart, this.index);
	            this.sectionStart = -1;
	            this.state = State.AfterClosingTagName;
	            this.stateAfterClosingTagName(c);
	        }
	    };
	    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
	        // Skip everything until ">"
	        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
	            this.state = State.Text;
	            this.sectionStart = this.index + 1;
	        }
	    };
	    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
	        if (c === CharCodes.Gt) {
	            this.cbs.onopentagend(this.index);
	            if (this.isSpecial) {
	                this.state = State.InSpecialTag;
	                this.sequenceIndex = 0;
	            }
	            else {
	                this.state = State.Text;
	            }
	            this.sectionStart = this.index + 1;
	        }
	        else if (c === CharCodes.Slash) {
	            this.state = State.InSelfClosingTag;
	        }
	        else if (!isWhitespace(c)) {
	            this.state = State.InAttributeName;
	            this.sectionStart = this.index;
	        }
	    };
	    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
	        if (c === CharCodes.Gt) {
	            this.cbs.onselfclosingtag(this.index);
	            this.state = State.Text;
	            this.sectionStart = this.index + 1;
	            this.isSpecial = false; // Reset special state, in case of self-closing special tags
	        }
	        else if (!isWhitespace(c)) {
	            this.state = State.BeforeAttributeName;
	            this.stateBeforeAttributeName(c);
	        }
	    };
	    Tokenizer.prototype.stateInAttributeName = function (c) {
	        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
	            this.cbs.onattribname(this.sectionStart, this.index);
	            this.sectionStart = this.index;
	            this.state = State.AfterAttributeName;
	            this.stateAfterAttributeName(c);
	        }
	    };
	    Tokenizer.prototype.stateAfterAttributeName = function (c) {
	        if (c === CharCodes.Eq) {
	            this.state = State.BeforeAttributeValue;
	        }
	        else if (c === CharCodes.Slash || c === CharCodes.Gt) {
	            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
	            this.sectionStart = -1;
	            this.state = State.BeforeAttributeName;
	            this.stateBeforeAttributeName(c);
	        }
	        else if (!isWhitespace(c)) {
	            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
	            this.state = State.InAttributeName;
	            this.sectionStart = this.index;
	        }
	    };
	    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
	        if (c === CharCodes.DoubleQuote) {
	            this.state = State.InAttributeValueDq;
	            this.sectionStart = this.index + 1;
	        }
	        else if (c === CharCodes.SingleQuote) {
	            this.state = State.InAttributeValueSq;
	            this.sectionStart = this.index + 1;
	        }
	        else if (!isWhitespace(c)) {
	            this.sectionStart = this.index;
	            this.state = State.InAttributeValueNq;
	            this.stateInAttributeValueNoQuotes(c); // Reconsume token
	        }
	    };
	    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
	        if (c === quote ||
	            (!this.decodeEntities && this.fastForwardTo(quote))) {
	            this.cbs.onattribdata(this.sectionStart, this.index);
	            this.sectionStart = -1;
	            this.cbs.onattribend(quote === CharCodes.DoubleQuote
	                ? QuoteType.Double
	                : QuoteType.Single, this.index + 1);
	            this.state = State.BeforeAttributeName;
	        }
	        else if (this.decodeEntities && c === CharCodes.Amp) {
	            this.startEntity();
	        }
	    };
	    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
	        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
	    };
	    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
	        this.handleInAttributeValue(c, CharCodes.SingleQuote);
	    };
	    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
	        if (isWhitespace(c) || c === CharCodes.Gt) {
	            this.cbs.onattribdata(this.sectionStart, this.index);
	            this.sectionStart = -1;
	            this.cbs.onattribend(QuoteType.Unquoted, this.index);
	            this.state = State.BeforeAttributeName;
	            this.stateBeforeAttributeName(c);
	        }
	        else if (this.decodeEntities && c === CharCodes.Amp) {
	            this.startEntity();
	        }
	    };
	    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
	        if (c === CharCodes.OpeningSquareBracket) {
	            this.state = State.CDATASequence;
	            this.sequenceIndex = 0;
	        }
	        else {
	            this.state =
	                c === CharCodes.Dash
	                    ? State.BeforeComment
	                    : State.InDeclaration;
	        }
	    };
	    Tokenizer.prototype.stateInDeclaration = function (c) {
	        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
	            this.cbs.ondeclaration(this.sectionStart, this.index);
	            this.state = State.Text;
	            this.sectionStart = this.index + 1;
	        }
	    };
	    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
	        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
	            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
	            this.state = State.Text;
	            this.sectionStart = this.index + 1;
	        }
	    };
	    Tokenizer.prototype.stateBeforeComment = function (c) {
	        if (c === CharCodes.Dash) {
	            this.state = State.InCommentLike;
	            this.currentSequence = Sequences.CommentEnd;
	            // Allow short comments (eg. <!-->)
	            this.sequenceIndex = 2;
	            this.sectionStart = this.index + 1;
	        }
	        else {
	            this.state = State.InDeclaration;
	        }
	    };
	    Tokenizer.prototype.stateInSpecialComment = function (c) {
	        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
	            this.cbs.oncomment(this.sectionStart, this.index, 0);
	            this.state = State.Text;
	            this.sectionStart = this.index + 1;
	        }
	    };
	    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
	        var lower = c | 0x20;
	        if (lower === Sequences.ScriptEnd[3]) {
	            this.startSpecial(Sequences.ScriptEnd, 4);
	        }
	        else if (lower === Sequences.StyleEnd[3]) {
	            this.startSpecial(Sequences.StyleEnd, 4);
	        }
	        else {
	            this.state = State.InTagName;
	            this.stateInTagName(c); // Consume the token again
	        }
	    };
	    Tokenizer.prototype.stateBeforeSpecialT = function (c) {
	        var lower = c | 0x20;
	        if (lower === Sequences.TitleEnd[3]) {
	            this.startSpecial(Sequences.TitleEnd, 4);
	        }
	        else if (lower === Sequences.TextareaEnd[3]) {
	            this.startSpecial(Sequences.TextareaEnd, 4);
	        }
	        else {
	            this.state = State.InTagName;
	            this.stateInTagName(c); // Consume the token again
	        }
	    };
	    Tokenizer.prototype.startEntity = function () {
	        this.baseState = this.state;
	        this.state = State.InEntity;
	        this.entityStart = this.index;
	        this.entityDecoder.startEntity(this.xmlMode
	            ? decode_js_1.DecodingMode.Strict
	            : this.baseState === State.Text ||
	                this.baseState === State.InSpecialTag
	                ? decode_js_1.DecodingMode.Legacy
	                : decode_js_1.DecodingMode.Attribute);
	    };
	    Tokenizer.prototype.stateInEntity = function () {
	        var length = this.entityDecoder.write(this.buffer, this.index - this.offset);
	        // If `length` is positive, we are done with the entity.
	        if (length >= 0) {
	            this.state = this.baseState;
	            if (length === 0) {
	                this.index = this.entityStart;
	            }
	        }
	        else {
	            // Mark buffer as consumed.
	            this.index = this.offset + this.buffer.length - 1;
	        }
	    };
	    /**
	     * Remove data that has already been consumed from the buffer.
	     */
	    Tokenizer.prototype.cleanup = function () {
	        // If we are inside of text or attributes, emit what we already have.
	        if (this.running && this.sectionStart !== this.index) {
	            if (this.state === State.Text ||
	                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
	                this.cbs.ontext(this.sectionStart, this.index);
	                this.sectionStart = this.index;
	            }
	            else if (this.state === State.InAttributeValueDq ||
	                this.state === State.InAttributeValueSq ||
	                this.state === State.InAttributeValueNq) {
	                this.cbs.onattribdata(this.sectionStart, this.index);
	                this.sectionStart = this.index;
	            }
	        }
	    };
	    Tokenizer.prototype.shouldContinue = function () {
	        return this.index < this.buffer.length + this.offset && this.running;
	    };
	    /**
	     * Iterates through the buffer, calling the function corresponding to the current state.
	     *
	     * States that are more likely to be hit are higher up, as a performance improvement.
	     */
	    Tokenizer.prototype.parse = function () {
	        while (this.shouldContinue()) {
	            var c = this.buffer.charCodeAt(this.index - this.offset);
	            switch (this.state) {
	                case State.Text: {
	                    this.stateText(c);
	                    break;
	                }
	                case State.SpecialStartSequence: {
	                    this.stateSpecialStartSequence(c);
	                    break;
	                }
	                case State.InSpecialTag: {
	                    this.stateInSpecialTag(c);
	                    break;
	                }
	                case State.CDATASequence: {
	                    this.stateCDATASequence(c);
	                    break;
	                }
	                case State.InAttributeValueDq: {
	                    this.stateInAttributeValueDoubleQuotes(c);
	                    break;
	                }
	                case State.InAttributeName: {
	                    this.stateInAttributeName(c);
	                    break;
	                }
	                case State.InCommentLike: {
	                    this.stateInCommentLike(c);
	                    break;
	                }
	                case State.InSpecialComment: {
	                    this.stateInSpecialComment(c);
	                    break;
	                }
	                case State.BeforeAttributeName: {
	                    this.stateBeforeAttributeName(c);
	                    break;
	                }
	                case State.InTagName: {
	                    this.stateInTagName(c);
	                    break;
	                }
	                case State.InClosingTagName: {
	                    this.stateInClosingTagName(c);
	                    break;
	                }
	                case State.BeforeTagName: {
	                    this.stateBeforeTagName(c);
	                    break;
	                }
	                case State.AfterAttributeName: {
	                    this.stateAfterAttributeName(c);
	                    break;
	                }
	                case State.InAttributeValueSq: {
	                    this.stateInAttributeValueSingleQuotes(c);
	                    break;
	                }
	                case State.BeforeAttributeValue: {
	                    this.stateBeforeAttributeValue(c);
	                    break;
	                }
	                case State.BeforeClosingTagName: {
	                    this.stateBeforeClosingTagName(c);
	                    break;
	                }
	                case State.AfterClosingTagName: {
	                    this.stateAfterClosingTagName(c);
	                    break;
	                }
	                case State.BeforeSpecialS: {
	                    this.stateBeforeSpecialS(c);
	                    break;
	                }
	                case State.BeforeSpecialT: {
	                    this.stateBeforeSpecialT(c);
	                    break;
	                }
	                case State.InAttributeValueNq: {
	                    this.stateInAttributeValueNoQuotes(c);
	                    break;
	                }
	                case State.InSelfClosingTag: {
	                    this.stateInSelfClosingTag(c);
	                    break;
	                }
	                case State.InDeclaration: {
	                    this.stateInDeclaration(c);
	                    break;
	                }
	                case State.BeforeDeclaration: {
	                    this.stateBeforeDeclaration(c);
	                    break;
	                }
	                case State.BeforeComment: {
	                    this.stateBeforeComment(c);
	                    break;
	                }
	                case State.InProcessingInstruction: {
	                    this.stateInProcessingInstruction(c);
	                    break;
	                }
	                case State.InEntity: {
	                    this.stateInEntity();
	                    break;
	                }
	            }
	            this.index++;
	        }
	        this.cleanup();
	    };
	    Tokenizer.prototype.finish = function () {
	        if (this.state === State.InEntity) {
	            this.entityDecoder.end();
	            this.state = this.baseState;
	        }
	        this.handleTrailingData();
	        this.cbs.onend();
	    };
	    /** Handle any trailing data. */
	    Tokenizer.prototype.handleTrailingData = function () {
	        var endIndex = this.buffer.length + this.offset;
	        // If there is no remaining data, we are done.
	        if (this.sectionStart >= endIndex) {
	            return;
	        }
	        if (this.state === State.InCommentLike) {
	            if (this.currentSequence === Sequences.CdataEnd) {
	                this.cbs.oncdata(this.sectionStart, endIndex, 0);
	            }
	            else {
	                this.cbs.oncomment(this.sectionStart, endIndex, 0);
	            }
	        }
	        else if (this.state === State.InTagName ||
	            this.state === State.BeforeAttributeName ||
	            this.state === State.BeforeAttributeValue ||
	            this.state === State.AfterAttributeName ||
	            this.state === State.InAttributeName ||
	            this.state === State.InAttributeValueSq ||
	            this.state === State.InAttributeValueDq ||
	            this.state === State.InAttributeValueNq ||
	            this.state === State.InClosingTagName) ;
	        else {
	            this.cbs.ontext(this.sectionStart, endIndex);
	        }
	    };
	    Tokenizer.prototype.emitCodePoint = function (cp, consumed) {
	        if (this.baseState !== State.Text &&
	            this.baseState !== State.InSpecialTag) {
	            if (this.sectionStart < this.entityStart) {
	                this.cbs.onattribdata(this.sectionStart, this.entityStart);
	            }
	            this.sectionStart = this.entityStart + consumed;
	            this.index = this.sectionStart - 1;
	            this.cbs.onattribentity(cp);
	        }
	        else {
	            if (this.sectionStart < this.entityStart) {
	                this.cbs.ontext(this.sectionStart, this.entityStart);
	            }
	            this.sectionStart = this.entityStart + consumed;
	            this.index = this.sectionStart - 1;
	            this.cbs.ontextentity(cp, this.sectionStart);
	        }
	    };
	    return Tokenizer;
	}());
	Tokenizer.default = Tokenizer$1;
	
	return Tokenizer;
}

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return Parser;
	hasRequiredParser = 1;
	var __createBinding = (Parser && Parser.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (Parser && Parser.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (Parser && Parser.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(Parser, "__esModule", { value: true });
	Parser.Parser = void 0;
	var Tokenizer_js_1 = __importStar(/*@__PURE__*/ requireTokenizer());
	var decode_js_1 = /*@__PURE__*/ requireDecode();
	var formTags = new Set([
	    "input",
	    "option",
	    "optgroup",
	    "select",
	    "button",
	    "datalist",
	    "textarea",
	]);
	var pTag = new Set(["p"]);
	var tableSectionTags = new Set(["thead", "tbody"]);
	var ddtTags = new Set(["dd", "dt"]);
	var rtpTags = new Set(["rt", "rp"]);
	var openImpliesClose = new Map([
	    ["tr", new Set(["tr", "th", "td"])],
	    ["th", new Set(["th"])],
	    ["td", new Set(["thead", "th", "td"])],
	    ["body", new Set(["head", "link", "script"])],
	    ["li", new Set(["li"])],
	    ["p", pTag],
	    ["h1", pTag],
	    ["h2", pTag],
	    ["h3", pTag],
	    ["h4", pTag],
	    ["h5", pTag],
	    ["h6", pTag],
	    ["select", formTags],
	    ["input", formTags],
	    ["output", formTags],
	    ["button", formTags],
	    ["datalist", formTags],
	    ["textarea", formTags],
	    ["option", new Set(["option"])],
	    ["optgroup", new Set(["optgroup", "option"])],
	    ["dd", ddtTags],
	    ["dt", ddtTags],
	    ["address", pTag],
	    ["article", pTag],
	    ["aside", pTag],
	    ["blockquote", pTag],
	    ["details", pTag],
	    ["div", pTag],
	    ["dl", pTag],
	    ["fieldset", pTag],
	    ["figcaption", pTag],
	    ["figure", pTag],
	    ["footer", pTag],
	    ["form", pTag],
	    ["header", pTag],
	    ["hr", pTag],
	    ["main", pTag],
	    ["nav", pTag],
	    ["ol", pTag],
	    ["pre", pTag],
	    ["section", pTag],
	    ["table", pTag],
	    ["ul", pTag],
	    ["rt", rtpTags],
	    ["rp", rtpTags],
	    ["tbody", tableSectionTags],
	    ["tfoot", tableSectionTags],
	]);
	var voidElements = new Set([
	    "area",
	    "base",
	    "basefont",
	    "br",
	    "col",
	    "command",
	    "embed",
	    "frame",
	    "hr",
	    "img",
	    "input",
	    "isindex",
	    "keygen",
	    "link",
	    "meta",
	    "param",
	    "source",
	    "track",
	    "wbr",
	]);
	var foreignContextElements = new Set(["math", "svg"]);
	var htmlIntegrationElements = new Set([
	    "mi",
	    "mo",
	    "mn",
	    "ms",
	    "mtext",
	    "annotation-xml",
	    "foreignobject",
	    "desc",
	    "title",
	]);
	var reNameEnd = /\s|\//;
	var Parser$1 = /** @class */ (function () {
	    function Parser(cbs, options) {
	        if (options === void 0) { options = {}; }
	        var _a, _b, _c, _d, _e, _f;
	        this.options = options;
	        /** The start index of the last event. */
	        this.startIndex = 0;
	        /** The end index of the last event. */
	        this.endIndex = 0;
	        /**
	         * Store the start index of the current open tag,
	         * so we can update the start index for attributes.
	         */
	        this.openTagStart = 0;
	        this.tagname = "";
	        this.attribname = "";
	        this.attribvalue = "";
	        this.attribs = null;
	        this.stack = [];
	        this.buffers = [];
	        this.bufferOffset = 0;
	        /** The index of the last written buffer. Used when resuming after a `pause()`. */
	        this.writeIndex = 0;
	        /** Indicates whether the parser has finished running / `.end` has been called. */
	        this.ended = false;
	        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
	        this.htmlMode = !this.options.xmlMode;
	        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;
	        this.lowerCaseAttributeNames =
	            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
	        this.recognizeSelfClosing =
	            (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
	        this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer_js_1.default)(this.options, this);
	        this.foreignContext = [!this.htmlMode];
	        (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
	    }
	    // Tokenizer event handlers
	    /** @internal */
	    Parser.prototype.ontext = function (start, endIndex) {
	        var _a, _b;
	        var data = this.getSlice(start, endIndex);
	        this.endIndex = endIndex - 1;
	        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
	        this.startIndex = endIndex;
	    };
	    /** @internal */
	    Parser.prototype.ontextentity = function (cp, endIndex) {
	        var _a, _b;
	        this.endIndex = endIndex - 1;
	        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
	        this.startIndex = endIndex;
	    };
	    /**
	     * Checks if the current tag is a void element. Override this if you want
	     * to specify your own additional void elements.
	     */
	    Parser.prototype.isVoidElement = function (name) {
	        return this.htmlMode && voidElements.has(name);
	    };
	    /** @internal */
	    Parser.prototype.onopentagname = function (start, endIndex) {
	        this.endIndex = endIndex;
	        var name = this.getSlice(start, endIndex);
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        this.emitOpenTag(name);
	    };
	    Parser.prototype.emitOpenTag = function (name) {
	        var _a, _b, _c, _d;
	        this.openTagStart = this.startIndex;
	        this.tagname = name;
	        var impliesClose = this.htmlMode && openImpliesClose.get(name);
	        if (impliesClose) {
	            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
	                var element = this.stack.shift();
	                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
	            }
	        }
	        if (!this.isVoidElement(name)) {
	            this.stack.unshift(name);
	            if (this.htmlMode) {
	                if (foreignContextElements.has(name)) {
	                    this.foreignContext.unshift(true);
	                }
	                else if (htmlIntegrationElements.has(name)) {
	                    this.foreignContext.unshift(false);
	                }
	            }
	        }
	        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
	        if (this.cbs.onopentag)
	            this.attribs = {};
	    };
	    Parser.prototype.endOpenTag = function (isImplied) {
	        var _a, _b;
	        this.startIndex = this.openTagStart;
	        if (this.attribs) {
	            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
	            this.attribs = null;
	        }
	        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
	            this.cbs.onclosetag(this.tagname, true);
	        }
	        this.tagname = "";
	    };
	    /** @internal */
	    Parser.prototype.onopentagend = function (endIndex) {
	        this.endIndex = endIndex;
	        this.endOpenTag(false);
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.onclosetag = function (start, endIndex) {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this.endIndex = endIndex;
	        var name = this.getSlice(start, endIndex);
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        if (this.htmlMode &&
	            (foreignContextElements.has(name) ||
	                htmlIntegrationElements.has(name))) {
	            this.foreignContext.shift();
	        }
	        if (!this.isVoidElement(name)) {
	            var pos = this.stack.indexOf(name);
	            if (pos !== -1) {
	                for (var index = 0; index <= pos; index++) {
	                    var element = this.stack.shift();
	                    // We know the stack has sufficient elements.
	                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);
	                }
	            }
	            else if (this.htmlMode && name === "p") {
	                // Implicit open before close
	                this.emitOpenTag("p");
	                this.closeCurrentTag(true);
	            }
	        }
	        else if (this.htmlMode && name === "br") {
	            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
	            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
	            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
	            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
	        }
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.onselfclosingtag = function (endIndex) {
	        this.endIndex = endIndex;
	        if (this.recognizeSelfClosing || this.foreignContext[0]) {
	            this.closeCurrentTag(false);
	            // Set `startIndex` for next node
	            this.startIndex = endIndex + 1;
	        }
	        else {
	            // Ignore the fact that the tag is self-closing.
	            this.onopentagend(endIndex);
	        }
	    };
	    Parser.prototype.closeCurrentTag = function (isOpenImplied) {
	        var _a, _b;
	        var name = this.tagname;
	        this.endOpenTag(isOpenImplied);
	        // Self-closing tags will be on the top of the stack
	        if (this.stack[0] === name) {
	            // If the opening tag isn't implied, the closing tag has to be implied.
	            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
	            this.stack.shift();
	        }
	    };
	    /** @internal */
	    Parser.prototype.onattribname = function (start, endIndex) {
	        this.startIndex = start;
	        var name = this.getSlice(start, endIndex);
	        this.attribname = this.lowerCaseAttributeNames
	            ? name.toLowerCase()
	            : name;
	    };
	    /** @internal */
	    Parser.prototype.onattribdata = function (start, endIndex) {
	        this.attribvalue += this.getSlice(start, endIndex);
	    };
	    /** @internal */
	    Parser.prototype.onattribentity = function (cp) {
	        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
	    };
	    /** @internal */
	    Parser.prototype.onattribend = function (quote, endIndex) {
	        var _a, _b;
	        this.endIndex = endIndex;
	        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double
	            ? '"'
	            : quote === Tokenizer_js_1.QuoteType.Single
	                ? "'"
	                : quote === Tokenizer_js_1.QuoteType.NoValue
	                    ? undefined
	                    : null);
	        if (this.attribs &&
	            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
	            this.attribs[this.attribname] = this.attribvalue;
	        }
	        this.attribvalue = "";
	    };
	    Parser.prototype.getInstructionName = function (value) {
	        var index = value.search(reNameEnd);
	        var name = index < 0 ? value : value.substr(0, index);
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        return name;
	    };
	    /** @internal */
	    Parser.prototype.ondeclaration = function (start, endIndex) {
	        this.endIndex = endIndex;
	        var value = this.getSlice(start, endIndex);
	        if (this.cbs.onprocessinginstruction) {
	            var name = this.getInstructionName(value);
	            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
	        }
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.onprocessinginstruction = function (start, endIndex) {
	        this.endIndex = endIndex;
	        var value = this.getSlice(start, endIndex);
	        if (this.cbs.onprocessinginstruction) {
	            var name = this.getInstructionName(value);
	            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
	        }
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.oncomment = function (start, endIndex, offset) {
	        var _a, _b, _c, _d;
	        this.endIndex = endIndex;
	        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
	        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.oncdata = function (start, endIndex, offset) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
	        this.endIndex = endIndex;
	        var value = this.getSlice(start, endIndex - offset);
	        if (!this.htmlMode || this.options.recognizeCDATA) {
	            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
	            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
	            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
	        }
	        else {
	            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
	            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
	        }
	        // Set `startIndex` for next node
	        this.startIndex = endIndex + 1;
	    };
	    /** @internal */
	    Parser.prototype.onend = function () {
	        var _a, _b;
	        if (this.cbs.onclosetag) {
	            // Set the end index for all remaining tags
	            this.endIndex = this.startIndex;
	            for (var index = 0; index < this.stack.length; index++) {
	                this.cbs.onclosetag(this.stack[index], true);
	            }
	        }
	        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
	    };
	    /**
	     * Resets the parser to a blank state, ready to parse a new HTML document
	     */
	    Parser.prototype.reset = function () {
	        var _a, _b, _c, _d;
	        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
	        this.tokenizer.reset();
	        this.tagname = "";
	        this.attribname = "";
	        this.attribs = null;
	        this.stack.length = 0;
	        this.startIndex = 0;
	        this.endIndex = 0;
	        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
	        this.buffers.length = 0;
	        this.foreignContext.length = 0;
	        this.foreignContext.unshift(!this.htmlMode);
	        this.bufferOffset = 0;
	        this.writeIndex = 0;
	        this.ended = false;
	    };
	    /**
	     * Resets the parser, then parses a complete document and
	     * pushes it to the handler.
	     *
	     * @param data Document to parse.
	     */
	    Parser.prototype.parseComplete = function (data) {
	        this.reset();
	        this.end(data);
	    };
	    Parser.prototype.getSlice = function (start, end) {
	        while (start - this.bufferOffset >= this.buffers[0].length) {
	            this.shiftBuffer();
	        }
	        var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
	        while (end - this.bufferOffset > this.buffers[0].length) {
	            this.shiftBuffer();
	            slice += this.buffers[0].slice(0, end - this.bufferOffset);
	        }
	        return slice;
	    };
	    Parser.prototype.shiftBuffer = function () {
	        this.bufferOffset += this.buffers[0].length;
	        this.writeIndex--;
	        this.buffers.shift();
	    };
	    /**
	     * Parses a chunk of data and calls the corresponding callbacks.
	     *
	     * @param chunk Chunk to parse.
	     */
	    Parser.prototype.write = function (chunk) {
	        var _a, _b;
	        if (this.ended) {
	            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
	            return;
	        }
	        this.buffers.push(chunk);
	        if (this.tokenizer.running) {
	            this.tokenizer.write(chunk);
	            this.writeIndex++;
	        }
	    };
	    /**
	     * Parses the end of the buffer and clears the stack, calls onend.
	     *
	     * @param chunk Optional final chunk to parse.
	     */
	    Parser.prototype.end = function (chunk) {
	        var _a, _b;
	        if (this.ended) {
	            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
	            return;
	        }
	        if (chunk)
	            this.write(chunk);
	        this.ended = true;
	        this.tokenizer.end();
	    };
	    /**
	     * Pauses parsing. The parser won't emit events until `resume` is called.
	     */
	    Parser.prototype.pause = function () {
	        this.tokenizer.pause();
	    };
	    /**
	     * Resumes parsing after `pause` was called.
	     */
	    Parser.prototype.resume = function () {
	        this.tokenizer.resume();
	        while (this.tokenizer.running &&
	            this.writeIndex < this.buffers.length) {
	            this.tokenizer.write(this.buffers[this.writeIndex++]);
	        }
	        if (this.ended)
	            this.tokenizer.end();
	    };
	    /**
	     * Alias of `write`, for backwards compatibility.
	     *
	     * @param chunk Chunk to parse.
	     * @deprecated
	     */
	    Parser.prototype.parseChunk = function (chunk) {
	        this.write(chunk);
	    };
	    /**
	     * Alias of `end`, for backwards compatibility.
	     *
	     * @param chunk Optional final chunk to parse.
	     * @deprecated
	     */
	    Parser.prototype.done = function (chunk) {
	        this.end(chunk);
	    };
	    return Parser;
	}());
	Parser.Parser = Parser$1;
	
	return Parser;
}

var hasRequiredLib$u;

function requireLib$u () {
	if (hasRequiredLib$u) return lib$r;
	hasRequiredLib$u = 1;
	(function (exports$1) {
		var __createBinding = (lib$r && lib$r.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$r && lib$r.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$r && lib$r.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __importDefault = (lib$r && lib$r.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.DomUtils = exports$1.parseFeed = exports$1.getFeed = exports$1.ElementType = exports$1.QuoteType = exports$1.Tokenizer = exports$1.createDomStream = exports$1.createDocumentStream = exports$1.parseDOM = exports$1.parseDocument = exports$1.DefaultHandler = exports$1.DomHandler = exports$1.Parser = void 0;
		var Parser_js_1 = /*@__PURE__*/ requireParser();
		var Parser_js_2 = /*@__PURE__*/ requireParser();
		Object.defineProperty(exports$1, "Parser", { enumerable: true, get: function () { return Parser_js_2.Parser; } });
		var domhandler_1 = /*@__PURE__*/ requireLib$B();
		var domhandler_2 = /*@__PURE__*/ requireLib$B();
		Object.defineProperty(exports$1, "DomHandler", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });
		// Old name for DomHandler
		Object.defineProperty(exports$1, "DefaultHandler", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });
		// Helper methods
		/**
		 * Parses the data, returns the resulting document.
		 *
		 * @param data The data that should be parsed.
		 * @param options Optional options for the parser and DOM handler.
		 */
		function parseDocument(data, options) {
		    var handler = new domhandler_1.DomHandler(undefined, options);
		    new Parser_js_1.Parser(handler, options).end(data);
		    return handler.root;
		}
		exports$1.parseDocument = parseDocument;
		/**
		 * Parses data, returns an array of the root nodes.
		 *
		 * Note that the root nodes still have a `Document` node as their parent.
		 * Use `parseDocument` to get the `Document` node instead.
		 *
		 * @param data The data that should be parsed.
		 * @param options Optional options for the parser and DOM handler.
		 * @deprecated Use `parseDocument` instead.
		 */
		function parseDOM(data, options) {
		    return parseDocument(data, options).children;
		}
		exports$1.parseDOM = parseDOM;
		/**
		 * Creates a parser instance, with an attached DOM handler.
		 *
		 * @param callback A callback that will be called once parsing has been completed, with the resulting document.
		 * @param options Optional options for the parser and DOM handler.
		 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
		 */
		function createDocumentStream(callback, options, elementCallback) {
		    var handler = new domhandler_1.DomHandler(function (error) { return callback(error, handler.root); }, options, elementCallback);
		    return new Parser_js_1.Parser(handler, options);
		}
		exports$1.createDocumentStream = createDocumentStream;
		/**
		 * Creates a parser instance, with an attached DOM handler.
		 *
		 * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.
		 * @param options Optional options for the parser and DOM handler.
		 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
		 * @deprecated Use `createDocumentStream` instead.
		 */
		function createDomStream(callback, options, elementCallback) {
		    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
		    return new Parser_js_1.Parser(handler, options);
		}
		exports$1.createDomStream = createDomStream;
		var Tokenizer_js_1 = /*@__PURE__*/ requireTokenizer();
		Object.defineProperty(exports$1, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } });
		Object.defineProperty(exports$1, "QuoteType", { enumerable: true, get: function () { return Tokenizer_js_1.QuoteType; } });
		/*
		 * All of the following exports exist for backwards-compatibility.
		 * They should probably be removed eventually.
		 */
		exports$1.ElementType = __importStar(/*@__PURE__*/ requireLib$E());
		var domutils_1 = /*@__PURE__*/ requireLib$A();
		var domutils_2 = /*@__PURE__*/ requireLib$A();
		Object.defineProperty(exports$1, "getFeed", { enumerable: true, get: function () { return domutils_2.getFeed; } });
		var parseFeedDefaultOptions = { xmlMode: true };
		/**
		 * Parse a feed.
		 *
		 * @param feed The feed that should be parsed, as a string.
		 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
		 */
		function parseFeed(feed, options) {
		    if (options === void 0) { options = parseFeedDefaultOptions; }
		    return (0, domutils_1.getFeed)(parseDOM(feed, options));
		}
		exports$1.parseFeed = parseFeed;
		exports$1.DomUtils = __importStar(/*@__PURE__*/ requireLib$A());
		
	} (lib$r));
	return lib$r;
}

var cleanNode = {exports: {}};

var hasRequiredCleanNode;

function requireCleanNode () {
	if (hasRequiredCleanNode) return cleanNode.exports;
	hasRequiredCleanNode = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = cleanNode;
		var _forEach2 = _interopRequireDefault(requireForEach());
		function cleanNode(node) {
		  delete node.parent;

		  // Delete children if needed
		  if (node.children && node.children.length) {
		    (0, _forEach2.default)(node.children, cleanNode);
		  } else {
		    delete node.children;
		  }

		  // Delete attributes if needed
		  if (node.attributes && Object.keys(node.attributes).length === 0) {
		    delete node.attributes;
		  }
		}
		module.exports = exports$1.default; 
	} (cleanNode, cleanNode.exports));
	return cleanNode.exports;
}

var convertBooleansOnAttrs = {exports: {}};

var mapValues_1;
var hasRequiredMapValues;

function requireMapValues () {
	if (hasRequiredMapValues) return mapValues_1;
	hasRequiredMapValues = 1;
	var baseAssignValue = require_baseAssignValue(),
	    baseForOwn = require_baseForOwn(),
	    baseIteratee = require_baseIteratee();

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	mapValues_1 = mapValues;
	return mapValues_1;
}

var hasRequiredConvertBooleansOnAttrs;

function requireConvertBooleansOnAttrs () {
	if (hasRequiredConvertBooleansOnAttrs) return convertBooleansOnAttrs.exports;
	hasRequiredConvertBooleansOnAttrs = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = convertBooleansOnAttrs;
		var _mapValues2 = _interopRequireDefault(requireMapValues());
		/**
		 * Convert "true" and "false" string attributes values
		 * to corresponding Booleans
		 */

		function convertBooleansOnAttrs(attrs) {
		  return (0, _mapValues2.default)(attrs, val => {
		    if (val === 'true') {
		      return true;
		    }
		    if (val === 'false') {
		      return false;
		    }
		    return val;
		  });
		}
		module.exports = exports$1.default; 
	} (convertBooleansOnAttrs, convertBooleansOnAttrs.exports));
	return convertBooleansOnAttrs.exports;
}

var setEmptyAttributes = {exports: {}};

var hasRequiredSetEmptyAttributes;

function requireSetEmptyAttributes () {
	if (hasRequiredSetEmptyAttributes) return setEmptyAttributes.exports;
	hasRequiredSetEmptyAttributes = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = setEmptyAttributes;
		var _forEach2 = _interopRequireDefault(requireForEach());
		function setEmptyAttributes(node) {
		  if (!node.attributes) {
		    node.attributes = {};
		  }
		  if (node.children) {
		    (0, _forEach2.default)(node.children, setEmptyAttributes);
		  }
		}
		module.exports = exports$1.default; 
	} (setEmptyAttributes, setEmptyAttributes.exports));
	return setEmptyAttributes.exports;
}

var browser;
var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;
	browser = false;
	return browser;
}

var hasRequiredLib$t;

function requireLib$t () {
	if (hasRequiredLib$t) return lib$s.exports;
	hasRequiredLib$t = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = MJMLParser;
		var _flow2 = _interopRequireDefault(requireFlow());
		var _map2 = _interopRequireDefault(requireMap());
		var _filter2 = _interopRequireDefault(requireFilter());
		var _find2 = _interopRequireDefault(requireFind());
		var _findLastIndex2 = _interopRequireDefault(requireFindLastIndex());
		var _isObject2 = _interopRequireDefault(requireIsObject());
		var _htmlparser = /*@__PURE__*/ requireLib$u();
		var _path = _interopRequireDefault(require$$0$3);
		var _fs = _interopRequireDefault(require$$0$4);
		var _cleanNode = _interopRequireDefault(requireCleanNode());
		var _convertBooleansOnAttrs = _interopRequireDefault(requireConvertBooleansOnAttrs());
		var _setEmptyAttributes = _interopRequireDefault(requireSetEmptyAttributes());
		const isNode = requireBrowser();
		const indexesForNewLine = xml => {
		  const regex = /\n/gi;
		  const indexes = [0];
		  while (regex.exec(xml)) {
		    indexes.push(regex.lastIndex);
		  }
		  return indexes;
		};
		const isSelfClosing = (indexes, parser) => indexes.startIndex === parser.startIndex && indexes.endIndex === parser.endIndex;
		function MJMLParser(xml, options = {}, includedIn = []) {
		  const {
		    addEmptyAttributes = true,
		    components = {},
		    convertBooleans = true,
		    keepComments = true,
		    filePath = '.',
		    actualPath = '.',
		    ignoreIncludes = false,
		    preprocessors = []
		  } = options;
		  const endingTags = (0, _flow2.default)((0, _filter2.default)(component => component.endingTag), (0, _map2.default)(component => component.getTagName()))({
		    ...components
		  });
		  let cwd = process.cwd();
		  if (isNode && filePath) {
		    try {
		      const isDir = _fs.default.lstatSync(filePath).isDirectory();
		      cwd = isDir ? filePath : _path.default.dirname(filePath);
		    } catch (e) {
		      throw new Error('Specified filePath does not exist');
		    }
		  }
		  let mjml = null;
		  let cur = null;
		  !!includedIn.length;
		  let inEndingTag = 0;
		  const cssIncludes = [];
		  const currentEndingTagIndexes = {
		    startIndex: 0,
		    endIndex: 0
		  };
		  const findTag = (tagName, tree) => (0, _find2.default)(tree.children, {
		    tagName
		  });
		  const lineIndexes = indexesForNewLine(xml);
		  const handleCssHtmlInclude = (file, attrs, line) => {
		    const partialPath = _path.default.resolve(cwd, file);
		    let content;
		    try {
		      content = _fs.default.readFileSync(partialPath, 'utf8');
		    } catch (e) {
		      const newNode = {
		        line,
		        file,
		        absoluteFilePath: _path.default.resolve(cwd, actualPath),
		        parent: cur,
		        tagName: 'mj-raw',
		        content: `<!-- mj-include fails to read file : ${file} at ${partialPath} -->`,
		        children: [],
		        errors: [{
		          type: 'include',
		          params: {
		            file,
		            partialPath
		          }
		        }]
		      };
		      cur.children.push(newNode);
		      return;
		    }
		    if (attrs.type === 'html') {
		      const newNode = {
		        line,
		        file,
		        absoluteFilePath: _path.default.resolve(cwd, actualPath),
		        parent: cur,
		        tagName: 'mj-raw',
		        content
		      };
		      cur.children.push(newNode);
		      return;
		    }
		    const attributes = attrs['css-inline'] === 'inline' ? {
		      inline: 'inline'
		    } : {};
		    const newNode = {
		      line,
		      file,
		      absoluteFilePath: _path.default.resolve(cwd, actualPath),
		      tagName: 'mj-style',
		      content,
		      children: [],
		      attributes
		    };
		    cssIncludes.push(newNode);
		  };
		  const handleInclude = (file, line) => {
		    const partialPath = _path.default.resolve(cwd, file);
		    const curBeforeInclude = cur;
		    if ((0, _find2.default)(cur.includedIn, {
		      file: partialPath
		    })) throw new Error(`Circular inclusion detected on file : ${partialPath}`);
		    let content;
		    try {
		      content = _fs.default.readFileSync(partialPath, 'utf8');
		    } catch (e) {
		      const newNode = {
		        line,
		        file,
		        absoluteFilePath: _path.default.resolve(cwd, actualPath),
		        parent: cur,
		        tagName: 'mj-raw',
		        content: `<!-- mj-include fails to read file : ${file} at ${partialPath} -->`,
		        children: [],
		        errors: [{
		          type: 'include',
		          params: {
		            file,
		            partialPath
		          }
		        }]
		      };
		      cur.children.push(newNode);
		      return;
		    }
		    content = content.indexOf('<mjml>') === -1 ? `<mjml><mj-body>${content}</mj-body></mjml>` : content;
		    const partialMjml = MJMLParser(content, {
		      ...options,
		      filePath: partialPath,
		      actualPath: partialPath
		    }, [...cur.includedIn, {
		      file: cur.absoluteFilePath,
		      line
		    }]);
		    const bindToTree = (children, tree = cur) => children.map(c => ({
		      ...c,
		      parent: tree
		    }));
		    if (partialMjml.tagName !== 'mjml') {
		      return;
		    }
		    const body = findTag('mj-body', partialMjml);
		    const head = findTag('mj-head', partialMjml);
		    if (body) {
		      const boundChildren = bindToTree(body.children);
		      cur.children = [...cur.children, ...boundChildren];
		    }
		    if (head) {
		      let curHead = findTag('mj-head', mjml);
		      if (!curHead) {
		        mjml.children.push({
		          file: actualPath,
		          absoluteFilePath: _path.default.resolve(cwd, actualPath),
		          parent: mjml,
		          tagName: 'mj-head',
		          children: [],
		          includedIn: []
		        });
		        curHead = findTag('mj-head', mjml);
		      }
		      const boundChildren = bindToTree(head.children, curHead);
		      curHead.children = [...curHead.children, ...boundChildren];
		    }

		    // must restore cur to the cur before include started
		    cur = curBeforeInclude;
		  };
		  const parser = new _htmlparser.Parser({
		    onopentag: (name, attrs) => {
		      const isAnEndingTag = endingTags.indexOf(name) !== -1;
		      if (inEndingTag > 0) {
		        if (isAnEndingTag) inEndingTag += 1;
		        return;
		      }
		      if (isAnEndingTag) {
		        inEndingTag += 1;
		        if (inEndingTag === 1) {
		          // we're entering endingTag
		          currentEndingTagIndexes.startIndex = parser.startIndex;
		          currentEndingTagIndexes.endIndex = parser.endIndex;
		        }
		      }
		      const line = (0, _findLastIndex2.default)(lineIndexes, i => i <= parser.startIndex) + 1;
		      if (name === 'mj-include') {
		        if (ignoreIncludes || !isNode) return;
		        if (attrs.type === 'css' || attrs.type === 'html') {
		          handleCssHtmlInclude(decodeURIComponent(attrs.path), attrs, line);
		          return;
		        }
		        handleInclude(decodeURIComponent(attrs.path), line);
		        return;
		      }
		      if (convertBooleans) {
		        // "true" and "false" will be converted to bools
		        attrs = (0, _convertBooleansOnAttrs.default)(attrs);
		      }
		      const newNode = {
		        file: actualPath,
		        absoluteFilePath: isNode ? _path.default.resolve(cwd, actualPath) : actualPath,
		        line,
		        includedIn,
		        parent: cur,
		        tagName: name,
		        attributes: attrs,
		        children: []
		      };
		      if (cur) {
		        cur.children.push(newNode);
		      } else {
		        mjml = newNode;
		      }
		      cur = newNode;
		    },
		    onclosetag: name => {
		      if (endingTags.indexOf(name) !== -1) {
		        inEndingTag -= 1;
		        if (!inEndingTag) {
		          // we're getting out of endingTag
		          // if self-closing tag we don't get the content
		          if (!isSelfClosing(currentEndingTagIndexes, parser)) {
		            const partialVal = xml.substring(currentEndingTagIndexes.endIndex + 1, parser.endIndex).trim();
		            const val = partialVal.substring(0, partialVal.lastIndexOf(`</${name}`));
		            if (val) cur.content = val.trim();
		          }
		        }
		      }
		      if (inEndingTag > 0) return;

		      // for includes, setting cur is handled in handleInclude because when there is
		      // only mj-head in include it doesn't create any elements, so setting back to parent is wrong
		      if (name !== 'mj-include') cur = cur && cur.parent || null;
		    },
		    ontext: text => {
		      if (inEndingTag > 0) return;
		      if (text && text.trim() && cur) {
		        cur.content = `${cur && cur.content || ''}${text.trim()}`.trim();
		      }
		    },
		    oncomment: data => {
		      if (inEndingTag > 0) return;
		      if (cur && keepComments) {
		        cur.children.push({
		          line: (0, _findLastIndex2.default)(lineIndexes, i => i <= parser.startIndex) + 1,
		          tagName: 'mj-raw',
		          content: `<!--${data}-->`,
		          includedIn
		        });
		      }
		    }
		  }, {
		    recognizeCDATA: true,
		    decodeEntities: false,
		    recognizeSelfClosing: true,
		    lowerCaseAttributeNames: false
		  });

		  // Apply preprocessors to raw xml
		  xml = (0, _flow2.default)(preprocessors)(xml);
		  parser.write(xml);
		  parser.end();
		  if (!(0, _isObject2.default)(mjml)) {
		    throw new Error('Parsing failed. Check your mjml.');
		  }
		  (0, _cleanNode.default)(mjml);

		  // Assign "attributes" property if not set
		  if (addEmptyAttributes) {
		    (0, _setEmptyAttributes.default)(mjml);
		  }
		  if (cssIncludes.length) {
		    const head = (0, _find2.default)(mjml.children, {
		      tagName: 'mj-head'
		    });
		    if (head) {
		      if (head.children) {
		        head.children = [...head.children, ...cssIncludes];
		      } else {
		        head.children = cssIncludes;
		      }
		    } else {
		      mjml.children.push({
		        file: filePath,
		        line: 0,
		        tagName: 'mj-head',
		        children: cssIncludes
		      });
		    }
		  }
		  return mjml;
		}
		module.exports = exports$1.default; 
	} (lib$s, lib$s.exports));
	return lib$s.exports;
}

var lib$q = {};

var ruleError = {exports: {}};

var hasRequiredRuleError;

function requireRuleError () {
	if (hasRequiredRuleError) return ruleError.exports;
	hasRequiredRuleError = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = ruleError;
		function formatInclude(element) {
		  const {
		    includedIn
		  } = element;
		  if (!(includedIn && includedIn.length)) return '';
		  const formattedIncluded = includedIn.slice().reverse().map(({
		    line,
		    file
		  }) => `line ${line} of file ${file}`).join(', itself included at ');
		  return `, included at ${formattedIncluded}`;
		}
		function ruleError(message, element) {
		  const {
		    line,
		    tagName,
		    absoluteFilePath
		  } = element;
		  return {
		    line,
		    message,
		    tagName,
		    formattedMessage: `Line ${line} of ${absoluteFilePath}${formatInclude(element)} (${tagName})  ${message}`
		  };
		}
		module.exports = exports$1.default; 
	} (ruleError, ruleError.exports));
	return ruleError.exports;
}

var MJMLRulesCollection = {};

var validAttributes = {exports: {}};

var hasRequiredValidAttributes;

function requireValidAttributes () {
	if (hasRequiredValidAttributes) return validAttributes.exports;
	hasRequiredValidAttributes = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = validateAttribute;
		var _ruleError = _interopRequireDefault(requireRuleError());
		const WHITELIST = ['mj-class', 'css-class'];
		function validateAttribute(element, {
		  components
		}) {
		  const {
		    attributes,
		    tagName
		  } = element;
		  const Component = components[tagName];
		  if (!Component) {
		    return null;
		  }
		  const availableAttributes = [...Object.keys(Component.allowedAttributes || {}), ...WHITELIST];
		  const unknownAttributes = Object.keys(attributes || {}).filter(attribute => !availableAttributes.includes(attribute));
		  if (unknownAttributes.length === 0) {
		    return null;
		  }
		  const {
		    attribute,
		    illegal
		  } = {
		    attribute: unknownAttributes.length > 1 ? 'Attributes' : 'Attribute',
		    illegal: unknownAttributes.length > 1 ? 'are illegal' : 'is illegal'
		  };
		  return (0, _ruleError.default)(`${attribute} ${unknownAttributes.join(', ')} ${illegal}`, element);
		}
		module.exports = exports$1.default; 
	} (validAttributes, validAttributes.exports));
	return validAttributes.exports;
}

var validChildren = {exports: {}};

var hasRequiredValidChildren;

function requireValidChildren () {
	if (hasRequiredValidChildren) return validChildren.exports;
	hasRequiredValidChildren = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = validChildren;
		var _ruleError = _interopRequireDefault(requireRuleError());
		function validChildren(element, {
		  components,
		  dependencies,
		  skipElements
		}) {
		  const {
		    children,
		    tagName
		  } = element;
		  const Component = components[tagName];
		  if (!Component || !children || !children.length) {
		    return null;
		  }
		  const errors = [];
		  for (const child of children) {
		    const childTagName = child.tagName;
		    const ChildComponent = components[childTagName];
		    const parentDependencies = dependencies[tagName] || [];
		    const childIsValid = !ChildComponent || skipElements.includes(childTagName) || parentDependencies.includes(childTagName) || parentDependencies.some(dep => dep instanceof RegExp && dep.test(childTagName));
		    if (childIsValid === false) {
		      const allowedDependencies = Object.keys(dependencies).filter(key => dependencies[key].includes(childTagName) || dependencies[key].some(dep => dep instanceof RegExp && dep.test(childTagName)));
		      errors.push((0, _ruleError.default)(`${childTagName} cannot be used inside ${tagName}, only inside: ${allowedDependencies.join(', ')}`, child));
		    }
		  }
		  return errors;
		}
		module.exports = exports$1.default; 
	} (validChildren, validChildren.exports));
	return validChildren.exports;
}

var validTag = {exports: {}};

var hasRequiredValidTag;

function requireValidTag () {
	if (hasRequiredValidTag) return validTag.exports;
	hasRequiredValidTag = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = validateTag;
		var _ruleError = _interopRequireDefault(requireRuleError());
		// Tags that have no associated components but are allowed even so
		const componentLessTags = ['mj-all', 'mj-class', 'mj-selector', 'mj-html-attribute'];
		function validateTag(element, {
		  components
		}) {
		  const {
		    tagName
		  } = element;
		  if (componentLessTags.includes(tagName)) return null;
		  const Component = components[tagName];
		  if (!Component) {
		    return (0, _ruleError.default)(`Element ${tagName} doesn't exist or is not registered`, element);
		  }
		  return null;
		}
		module.exports = exports$1.default; 
	} (validTag, validTag.exports));
	return validTag.exports;
}

var validTypes = {exports: {}};

var hasRequiredValidTypes;

function requireValidTypes () {
	if (hasRequiredValidTypes) return validTypes.exports;
	hasRequiredValidTypes = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = validateType;
		var _ruleError = _interopRequireDefault(requireRuleError());
		function validateType(element, {
		  components,
		  initializeType
		}) {
		  const {
		    attributes,
		    tagName
		  } = element;
		  const Component = components[tagName];
		  if (!Component) {
		    return null;
		  }
		  const errors = [];
		  for (const [attr, value] of Object.entries(attributes || {})) {
		    const attrType = Component.allowedAttributes && Component.allowedAttributes[attr];
		    if (attrType) {
		      const TypeChecker = initializeType(attrType);
		      const result = new TypeChecker(value);
		      if (result.isValid() === false) {
		        errors.push((0, _ruleError.default)(`Attribute ${attr} ${result.getErrorMessage()}`, element));
		      }
		    }
		  }
		  return errors;
		}
		module.exports = exports$1.default; 
	} (validTypes, validTypes.exports));
	return validTypes.exports;
}

var errorAttr = {exports: {}};

var hasRequiredErrorAttr;

function requireErrorAttr () {
	if (hasRequiredErrorAttr) return errorAttr.exports;
	hasRequiredErrorAttr = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = errorAttr;
		var _ruleError = _interopRequireDefault(requireRuleError());
		function errorAttr(element) {
		  const {
		    errors
		  } = element;
		  if (!errors) return null;
		  return errors.map(error => {
		    switch (error.type) {
		      case 'include':
		        {
		          const {
		            file,
		            partialPath
		          } = error.params;
		          return (0, _ruleError.default)(`mj-include fails to read file : ${file} at ${partialPath}`, element);
		        }
		      default:
		        return null;
		    }
		  });
		}
		module.exports = exports$1.default; 
	} (errorAttr, errorAttr.exports));
	return errorAttr.exports;
}

var hasRequiredMJMLRulesCollection;

function requireMJMLRulesCollection () {
	if (hasRequiredMJMLRulesCollection) return MJMLRulesCollection;
	hasRequiredMJMLRulesCollection = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(MJMLRulesCollection, "__esModule", {
	  value: true
	});
	MJMLRulesCollection.default = void 0;
	MJMLRulesCollection.registerRule = registerRule;
	var _validAttributes = _interopRequireDefault(requireValidAttributes());
	var _validChildren = _interopRequireDefault(requireValidChildren());
	var _validTag = _interopRequireDefault(requireValidTag());
	var _validTypes = _interopRequireDefault(requireValidTypes());
	var _errorAttr = _interopRequireDefault(requireErrorAttr());
	const MJMLRulesCollection$1 = {
	  validAttributes: _validAttributes.default,
	  validChildren: _validChildren.default,
	  validTag: _validTag.default,
	  validTypes: _validTypes.default,
	  errorAttr: _errorAttr.default
	};
	function registerRule(rule, name) {
	  if (typeof rule !== 'function') {
	    return console.error('Your rule must be a function');
	  }
	  if (name) {
	    MJMLRulesCollection$1[name] = rule;
	  } else {
	    MJMLRulesCollection$1[rule.name] = rule;
	  }
	  return true;
	}
	MJMLRulesCollection.default = MJMLRulesCollection$1;
	return MJMLRulesCollection;
}

var dependencies$1 = {};

var hasRequiredDependencies$1;

function requireDependencies$1 () {
	if (hasRequiredDependencies$1) return dependencies$1;
	hasRequiredDependencies$1 = 1;

	Object.defineProperty(dependencies$1, "__esModule", {
	  value: true
	});
	dependencies$1.registerDependencies = dependencies$1.default = dependencies$1.assignDependencies = void 0;
	const assignDependencies = (target, ...sources) => {
	  if (sources.length === 0) {
	    return target;
	  }
	  for (const source of sources) {
	    if (typeof source === 'object' && source !== null) {
	      for (const tag of Object.keys(source)) {
	        if (typeof tag === 'string') {
	          const list = [];
	          if (target[tag]) {
	            list.push(...target[tag]);
	          }
	          if (source[tag]) {
	            list.push(...source[tag]);
	          }
	          target[tag] = Array.from(new Set(list));
	        } else {
	          console.warn('dependency "tag" must be of type string');
	        }
	      }
	    } else {
	      console.warn('"dependencies" must be an object.');
	    }
	  }
	  return target;
	};
	dependencies$1.assignDependencies = assignDependencies;
	const dependencies = {};
	const registerDependencies = dep => {
	  assignDependencies(dependencies, dep);
	};
	dependencies$1.registerDependencies = registerDependencies;
	dependencies$1.default = dependencies;
	return dependencies$1;
}

var hasRequiredLib$s;

function requireLib$s () {
	if (hasRequiredLib$s) return lib$q;
	hasRequiredLib$s = 1;
	(function (exports$1) {

		var _interopRequireWildcard = requireInteropRequireWildcard().default;
		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "assignDependencies", {
		  enumerable: true,
		  get: function () {
		    return _dependencies.assignDependencies;
		  }
		});
		exports$1.default = MJMLValidator;
		Object.defineProperty(exports$1, "dependencies", {
		  enumerable: true,
		  get: function () {
		    return _dependencies.default;
		  }
		});
		exports$1.formatValidationError = void 0;
		Object.defineProperty(exports$1, "registerDependencies", {
		  enumerable: true,
		  get: function () {
		    return _dependencies.registerDependencies;
		  }
		});
		Object.defineProperty(exports$1, "registerRule", {
		  enumerable: true,
		  get: function () {
		    return _MJMLRulesCollection.registerRule;
		  }
		});
		Object.defineProperty(exports$1, "rulesCollection", {
		  enumerable: true,
		  get: function () {
		    return _MJMLRulesCollection.default;
		  }
		});
		var _ruleError = _interopRequireDefault(requireRuleError());
		var _MJMLRulesCollection = _interopRequireWildcard(requireMJMLRulesCollection());
		var _dependencies = _interopRequireWildcard(requireDependencies$1());
		const SKIP_ELEMENTS = ['mjml'];
		exports$1.formatValidationError = _ruleError.default;
		function MJMLValidator(element, options = {}) {
		  const {
		    children,
		    tagName
		  } = element;
		  const errors = [];
		  const skipElements = options.skipElements || SKIP_ELEMENTS;
		  if (options.dependencies == null) {
		    console.warn('"dependencies" option should be provided to mjml validator');
		  }
		  if (!skipElements.includes(tagName)) {
		    for (const rule of Object.values(_MJMLRulesCollection.default)) {
		      const ruleError = rule(element, {
		        dependencies: _dependencies.default,
		        skipElements,
		        ...options
		      });
		      if (Array.isArray(ruleError)) {
		        errors.push(...ruleError);
		      } else if (ruleError) {
		        errors.push(ruleError);
		      }
		    }
		  }
		  if (children && children.length > 0) {
		    for (const child of children) {
		      errors.push(...MJMLValidator(child, options));
		    }
		  }
		  return errors;
		} 
	} (lib$q));
	return lib$q;
}

var migrate = {};

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */

var isNil_1;
var hasRequiredIsNil;

function requireIsNil () {
	if (hasRequiredIsNil) return isNil_1;
	hasRequiredIsNil = 1;
	function isNil(value) {
	  return value == null;
	}

	isNil_1 = isNil;
	return isNil_1;
}

var config;
var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;

	const unavailableTags = ['mj-html', 'mj-invoice', 'mj-list', 'mj-location'];
	const attributesWithUnit = ['background-size', 'border-radius', 'border-width', 'cellpadding', 'cellspacing', 'font-size', 'height', 'icon-height', 'ico-padding', 'ico-padding-bottom', 'ico-font-size', 'ico-line-height', 'ico-padding-left', 'ico-padding-right', 'ico-padding-top', 'icon-size', 'icon-width', 'inner-padding', 'letter-spacing', 'padding', 'padding-bottom', 'padding-left', 'padding-right', 'padding-left', 'tb-border-radius', 'tb-width', 'width'];
	config = {
	  unavailableTags,
	  attributesWithUnit
	};
	return config;
}

var hasRequiredMigrate;

function requireMigrate () {
	if (hasRequiredMigrate) return migrate;
	hasRequiredMigrate = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(migrate, "__esModule", {
	  value: true
	});
	migrate.default = migrate$1;
	migrate.handleMjml3 = handleMjml3;
	var _isNil2 = _interopRequireDefault(requireIsNil());
	var _find2 = _interopRequireDefault(requireFind());
	var _keys2 = _interopRequireDefault(requireKeys());
	var _mjmlParserXml = _interopRequireDefault(requireLib$t());
	var _mjmlCore = requireLib$r();
	var _jsBeautify = requireJs();
	var _config = requireConfig();
	/* eslint-disable no-console */

	const beautifyOptions = {
	  indent_size: 2,
	  wrap_attributes_indent_size: 2,
	  max_preserve_newline: 0,
	  preserve_newlines: false
	};
	function removeContainerTag(bodyTag) {
	  if (bodyTag.children[0].tagName === 'mj-container') {
	    bodyTag.attributes = bodyTag.children[0].attributes;
	    bodyTag.children = bodyTag.children[0].children;
	  }
	  return bodyTag;
	}
	const listAttributes = tag => tag.attributes;
	function addPx(value) {
	  // eslint-disable-next-line no-restricted-globals
	  if (!isNaN(value) && !(0, _isNil2.default)(value)) {
	    return `${value}px`;
	  }
	  return value;
	}
	function fixUnits(attribute, value) {
	  const {
	    length
	  } = _config.attributesWithUnit;
	  for (let i = 0; i < length; i += 1) {
	    if (_config.attributesWithUnit[i] === attribute) {
	      return addPx(value);
	    }
	  }
	  return value;
	}
	function cleanAttributes(attributes) {
	  (0, _keys2.default)(attributes).forEach(key => {
	    attributes[key] = fixUnits(key, attributes[key]);
	  });
	  return attributes;
	}
	const DEFAULT_SOCIAL_DISPLAY = 'facebook twitter google';
	function migrateSocialSyntax(socialTag) {
	  const listAllNetworks = tag => {
	    const attributes = (tag.attributes.display || DEFAULT_SOCIAL_DISPLAY).split(' ');
	    delete tag.attributes.display;
	    return attributes;
	  };
	  const attributes = listAttributes(socialTag);
	  const networks = listAllNetworks(socialTag);
	  socialTag.children = [];

	  // migrate all attributes to their child attributes
	  (0, _keys2.default)(networks).forEach(network => {
	    const nameMigrated = networks[network].replace(':url', '-noshare').replace(':share', '');
	    const nameWithoutOpts = nameMigrated.replace('-noshare', '');
	    socialTag.children.push({
	      tagName: `mj-social-element`,
	      attributes: {
	        name: nameMigrated
	      },
	      content: attributes[`${nameWithoutOpts}-content`] || ''
	    });
	    (0, _keys2.default)(attributes).forEach(attribute => {
	      if (attribute.match(nameWithoutOpts) && !attribute.match('content')) {
	        socialTag.children[network].attributes[attribute.replace(`${nameWithoutOpts}-`, '')] = socialTag.attributes[attribute];
	        delete socialTag.attributes[attribute];
	      }
	    });
	  });

	  // delete all content attributes from the root tag after they've been migrated
	  (0, _keys2.default)(attributes).forEach(attribute => {
	    if (attribute.match('content')) {
	      delete attributes[attribute];
	    }
	  });
	  return socialTag;
	}
	function migrateNavbarSyntax(navbarTag) {
	  navbarTag.tagName = 'mj-section';
	  navbarTag.attributes['full-width'] = 'full-width';
	  return navbarTag;
	}
	function migrateHeroSyntax(heroTag) {
	  const child = (0, _find2.default)(heroTag.children, {
	    tagName: 'mj-hero-content'
	  });
	  return {
	    ...heroTag,
	    children: child.children,
	    attributes: {
	      ...heroTag.attributes,
	      ...child.attributes
	    }
	  };
	}
	function isSupportedTag(tag) {
	  return _config.unavailableTags.indexOf(tag) === -1;
	}
	function loopThrough(tree) {
	  (0, _keys2.default)(tree).forEach(key => {
	    if (key === 'children') {
	      for (let i = 0; i < tree.children.length; i += 1) {
	        if (isSupportedTag(tree.children[i].tagName)) {
	          switch (tree.children[i].tagName) {
	            case 'mj-body':
	              tree.children[i] = removeContainerTag(tree.children[i]);
	              break;
	            case 'mj-social':
	              tree.children[i] = migrateSocialSyntax(tree.children[i]);
	              break;
	            case 'mj-navbar':
	              tree.children[i] = migrateNavbarSyntax(tree.children[i]);
	              break;
	            case 'mj-inline-links':
	              tree.children[i].tagName = 'mj-navbar';
	              break;
	            case 'mj-link':
	              tree.children[i].tagName = 'mj-navbar-link';
	              break;
	            case 'mj-hero':
	              tree.children[i] = migrateHeroSyntax(tree.children[i]);
	              break;
	            // no default
	          }
	          tree.children[i].attributes = cleanAttributes(tree.children[i].attributes);
	          loopThrough(tree.children[i]);
	        } else {
	          console.error(`Ignoring unsupported tag : ${tree.children[i].tagName} on line ${tree.children[i].line}`);
	          delete tree.children[i];
	        }
	      }
	    }
	  });
	  return tree;
	}
	function checkV3Through(node) {
	  if (node.tagName === 'mj-container') return true;
	  if (!node.children || !node.children.length) return false;
	  return node.children.some(checkV3Through);
	}
	const jsonToXML = ({
	  tagName,
	  attributes,
	  children,
	  content
	}) => {
	  const subNode = children && children.length > 0 ? children.map(jsonToXML).join('\n') : content || '';
	  const stringAttrs = Object.keys(attributes).map(attr => `${attr}="${attributes[attr]}"`).join(' ');
	  return `<${tagName}${stringAttrs === '' ? '>' : ` ${stringAttrs}>`}${subNode}</${tagName}>`;
	};
	function migrate$1(input, options = {}) {
	  console.warn('mjml-migrate is deprecated and will be removed in mjml 5');
	  const {
	    beautify
	  } = options;
	  if (typeof input === 'object') return loopThrough(input);
	  const mjmlJson = (0, _mjmlParserXml.default)(input, {
	    components: _mjmlCore.components,
	    ignoreIncludes: true
	  });
	  loopThrough(mjmlJson);
	  return beautify ? (0, _jsBeautify.html)(jsonToXML(mjmlJson), beautifyOptions) : jsonToXML(mjmlJson);
	}
	function handleMjml3(mjml, options = {}) {
	  const isV3Synthax = checkV3Through(mjml);
	  if (!isV3Synthax) return mjml;
	  if (!options.noMigrateWarn) console.log('MJML v3 syntax detected, migrating to MJML v4 syntax. Use mjml -m to get the migrated MJML.');
	  return migrate$1(mjml);
	}

	/* eslint-enable no-console */
	return migrate;
}

var createComponent = {};

var defineProperty = {exports: {}};

var hasRequiredDefineProperty;

function requireDefineProperty () {
	if (hasRequiredDefineProperty) return defineProperty.exports;
	hasRequiredDefineProperty = 1;
	(function (module) {
		var toPropertyKey = requireToPropertyKey();
		function _defineProperty(e, r, t) {
		  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		    value: t,
		    enumerable: true,
		    configurable: true,
		    writable: true
		  }) : e[r] = t, e;
		}
		module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (defineProperty));
	return defineProperty.exports;
}

/** Error message constants. */

var negate_1;
var hasRequiredNegate;

function requireNegate () {
	if (hasRequiredNegate) return negate_1;
	hasRequiredNegate = 1;
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that negates the result of the predicate `func`. The
	 * `func` predicate is invoked with the `this` binding and arguments of the
	 * created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} predicate The predicate to negate.
	 * @returns {Function} Returns the new negated function.
	 * @example
	 *
	 * function isEven(n) {
	 *   return n % 2 == 0;
	 * }
	 *
	 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	 * // => [1, 3, 5]
	 */
	function negate(predicate) {
	  if (typeof predicate != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  return function() {
	    var args = arguments;
	    switch (args.length) {
	      case 0: return !predicate.call(this);
	      case 1: return !predicate.call(this, args[0]);
	      case 2: return !predicate.call(this, args[0], args[1]);
	      case 3: return !predicate.call(this, args[0], args[1], args[2]);
	    }
	    return !predicate.apply(this, args);
	  };
	}

	negate_1 = negate;
	return negate_1;
}

var _baseSet;
var hasRequired_baseSet;

function require_baseSet () {
	if (hasRequired_baseSet) return _baseSet;
	hasRequired_baseSet = 1;
	var assignValue = require_assignValue(),
	    castPath = require_castPath(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	      return object;
	    }

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	_baseSet = baseSet;
	return _baseSet;
}

var _basePickBy;
var hasRequired_basePickBy;

function require_basePickBy () {
	if (hasRequired_basePickBy) return _basePickBy;
	hasRequired_basePickBy = 1;
	var baseGet = require_baseGet(),
	    baseSet = require_baseSet(),
	    castPath = require_castPath();

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, paths, predicate) {
	  var index = -1,
	      length = paths.length,
	      result = {};

	  while (++index < length) {
	    var path = paths[index],
	        value = baseGet(object, path);

	    if (predicate(value, path)) {
	      baseSet(result, castPath(path, object), value);
	    }
	  }
	  return result;
	}

	_basePickBy = basePickBy;
	return _basePickBy;
}

var pickBy_1;
var hasRequiredPickBy;

function requirePickBy () {
	if (hasRequiredPickBy) return pickBy_1;
	hasRequiredPickBy = 1;
	var arrayMap = require_arrayMap(),
	    baseIteratee = require_baseIteratee(),
	    basePickBy = require_basePickBy(),
	    getAllKeysIn = require_getAllKeysIn();

	/**
	 * Creates an object composed of the `object` properties `predicate` returns
	 * truthy for. The predicate is invoked with two arguments: (value, key).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {Function} [predicate=_.identity] The function invoked per property.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pickBy(object, _.isNumber);
	 * // => { 'a': 1, 'c': 3 }
	 */
	function pickBy(object, predicate) {
	  if (object == null) {
	    return {};
	  }
	  var props = arrayMap(getAllKeysIn(object), function(prop) {
	    return [prop];
	  });
	  predicate = baseIteratee(predicate);
	  return basePickBy(object, props, function(value, path) {
	    return predicate(value, path[0]);
	  });
	}

	pickBy_1 = pickBy;
	return pickBy_1;
}

var omitBy_1;
var hasRequiredOmitBy;

function requireOmitBy () {
	if (hasRequiredOmitBy) return omitBy_1;
	hasRequiredOmitBy = 1;
	var baseIteratee = require_baseIteratee(),
	    negate = requireNegate(),
	    pickBy = requirePickBy();

	/**
	 * The opposite of `_.pickBy`; this method creates an object composed of
	 * the own and inherited enumerable string keyed properties of `object` that
	 * `predicate` doesn't return truthy for. The predicate is invoked with two
	 * arguments: (value, key).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {Function} [predicate=_.identity] The function invoked per property.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omitBy(object, _.isNumber);
	 * // => { 'b': '2' }
	 */
	function omitBy(object, predicate) {
	  return pickBy(object, negate(baseIteratee(predicate)));
	}

	omitBy_1 = omitBy;
	return omitBy_1;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */

var _basePropertyOf;
var hasRequired_basePropertyOf;

function require_basePropertyOf () {
	if (hasRequired_basePropertyOf) return _basePropertyOf;
	hasRequired_basePropertyOf = 1;
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	_basePropertyOf = basePropertyOf;
	return _basePropertyOf;
}

var _deburrLetter;
var hasRequired_deburrLetter;

function require_deburrLetter () {
	if (hasRequired_deburrLetter) return _deburrLetter;
	hasRequired_deburrLetter = 1;
	var basePropertyOf = require_basePropertyOf();

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 's'
	};

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter = basePropertyOf(deburredLetters);

	_deburrLetter = deburrLetter;
	return _deburrLetter;
}

var deburr_1;
var hasRequiredDeburr;

function requireDeburr () {
	if (hasRequiredDeburr) return deburr_1;
	hasRequiredDeburr = 1;
	var deburrLetter = require_deburrLetter(),
	    toString = requireToString();

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

	/** Used to compose unicode capture groups. */
	var rsCombo = '[' + rsComboRange + ']';

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo, 'g');

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('dj vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	deburr_1 = deburr;
	return deburr_1;
}

/** Used to match words composed of alphanumeric characters. */

var _asciiWords;
var hasRequired_asciiWords;

function require_asciiWords () {
	if (hasRequired_asciiWords) return _asciiWords;
	hasRequired_asciiWords = 1;
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	/**
	 * Splits an ASCII `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function asciiWords(string) {
	  return string.match(reAsciiWord) || [];
	}

	_asciiWords = asciiWords;
	return _asciiWords;
}

/** Used to detect strings that need a more robust regexp to match words. */

var _hasUnicodeWord;
var hasRequired_hasUnicodeWord;

function require_hasUnicodeWord () {
	if (hasRequired_hasUnicodeWord) return _hasUnicodeWord;
	hasRequired_hasUnicodeWord = 1;
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	/**
	 * Checks if `string` contains a word composed of Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a word is found, else `false`.
	 */
	function hasUnicodeWord(string) {
	  return reHasUnicodeWord.test(string);
	}

	_hasUnicodeWord = hasUnicodeWord;
	return _hasUnicodeWord;
}

/** Used to compose unicode character classes. */

var _unicodeWords;
var hasRequired_unicodeWords;

function require_unicodeWords () {
	if (hasRequired_unicodeWords) return _unicodeWords;
	hasRequired_unicodeWords = 1;
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	    rsDingbatRange = '\\u2700-\\u27bf',
	    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	    rsPunctuationRange = '\\u2000-\\u206f',
	    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	    rsVarRange = '\\ufe0e\\ufe0f',
	    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]",
	    rsBreak = '[' + rsBreakRange + ']',
	    rsCombo = '[' + rsComboRange + ']',
	    rsDigits = '\\d+',
	    rsDingbat = '[' + rsDingbatRange + ']',
	    rsLower = '[' + rsLowerRange + ']',
	    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsUpper = '[' + rsUpperRange + ']',
	    rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	    reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

	/** Used to match complex or compound words. */
	var reUnicodeWord = RegExp([
	  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	  rsUpper + '+' + rsOptContrUpper,
	  rsOrdUpper,
	  rsOrdLower,
	  rsDigits,
	  rsEmoji
	].join('|'), 'g');

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWord) || [];
	}

	_unicodeWords = unicodeWords;
	return _unicodeWords;
}

var words_1;
var hasRequiredWords;

function requireWords () {
	if (hasRequiredWords) return words_1;
	hasRequiredWords = 1;
	var asciiWords = require_asciiWords(),
	    hasUnicodeWord = require_hasUnicodeWord(),
	    toString = requireToString(),
	    unicodeWords = require_unicodeWords();

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * _.words('fred, barney, & pebbles');
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * _.words('fred, barney, & pebbles', /[^, ]+/g);
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern, guard) {
	  string = toString(string);
	  pattern = guard ? undefined : pattern;

	  if (pattern === undefined) {
	    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	  }
	  return string.match(pattern) || [];
	}

	words_1 = words;
	return words_1;
}

var _createCompounder;
var hasRequired_createCompounder;

function require_createCompounder () {
	if (hasRequired_createCompounder) return _createCompounder;
	hasRequired_createCompounder = 1;
	var arrayReduce = require_arrayReduce(),
	    deburr = requireDeburr(),
	    words = requireWords();

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]";

	/** Used to match apostrophes. */
	var reApos = RegExp(rsApos, 'g');

	/**
	 * Creates a function like `_.camelCase`.
	 *
	 * @private
	 * @param {Function} callback The function to combine each word.
	 * @returns {Function} Returns the new compounder function.
	 */
	function createCompounder(callback) {
	  return function(string) {
	    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	  };
	}

	_createCompounder = createCompounder;
	return _createCompounder;
}

var kebabCase_1;
var hasRequiredKebabCase;

function requireKebabCase () {
	if (hasRequiredKebabCase) return kebabCase_1;
	hasRequiredKebabCase = 1;
	var createCompounder = require_createCompounder();

	/**
	 * Converts `string` to
	 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the kebab cased string.
	 * @example
	 *
	 * _.kebabCase('Foo Bar');
	 * // => 'foo-bar'
	 *
	 * _.kebabCase('fooBar');
	 * // => 'foo-bar'
	 *
	 * _.kebabCase('__FOO_BAR__');
	 * // => 'foo-bar'
	 */
	var kebabCase = createCompounder(function(result, word, index) {
	  return result + (index ? '-' : '') + word.toLowerCase();
	});

	kebabCase_1 = kebabCase;
	return kebabCase_1;
}

var shorthandParser = {};

var hasRequiredShorthandParser;

function requireShorthandParser () {
	if (hasRequiredShorthandParser) return shorthandParser;
	hasRequiredShorthandParser = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(shorthandParser, "__esModule", {
	  value: true
	});
	shorthandParser.borderParser = borderParser;
	shorthandParser.default = _default;
	var _get2 = _interopRequireDefault(requireGet());
	function _default(cssValue, direction) {
	  const splittedCssValue = cssValue.trim().replace(/\s+/g, ' ').split(' ', 4);
	  let directions = {};
	  switch (splittedCssValue.length) {
	    case 2:
	      directions = {
	        top: 0,
	        bottom: 0,
	        left: 1,
	        right: 1
	      };
	      break;
	    case 3:
	      directions = {
	        top: 0,
	        left: 1,
	        right: 1,
	        bottom: 2
	      };
	      break;
	    case 4:
	      directions = {
	        top: 0,
	        right: 1,
	        bottom: 2,
	        left: 3
	      };
	      break;
	    case 1:
	    default:
	      return parseInt(cssValue, 10);
	  }
	  return parseInt(splittedCssValue[directions[direction]] || 0, 10);
	}
	function borderParser(border) {
	  return parseInt((0, _get2.default)(border.match(/(?:(?:^| )(\d+))/), 1), 10) || 0;
	}
	return shorthandParser;
}

var formatAttributes = {exports: {}};

var type = {};

var _baseSome;
var hasRequired_baseSome;

function require_baseSome () {
	if (hasRequired_baseSome) return _baseSome;
	hasRequired_baseSome = 1;
	var baseEach = require_baseEach();

	/**
	 * The base implementation of `_.some` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function baseSome(collection, predicate) {
	  var result;

	  baseEach(collection, function(value, index, collection) {
	    result = predicate(value, index, collection);
	    return !result;
	  });
	  return !!result;
	}

	_baseSome = baseSome;
	return _baseSome;
}

var _isIterateeCall;
var hasRequired_isIterateeCall;

function require_isIterateeCall () {
	if (hasRequired_isIterateeCall) return _isIterateeCall;
	hasRequired_isIterateeCall = 1;
	var eq = requireEq(),
	    isArrayLike = requireIsArrayLike(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject();

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	_isIterateeCall = isIterateeCall;
	return _isIterateeCall;
}

var some_1;
var hasRequiredSome;

function requireSome () {
	if (hasRequiredSome) return some_1;
	hasRequiredSome = 1;
	var arraySome = require_arraySome(),
	    baseIteratee = require_baseIteratee(),
	    baseSome = require_baseSome(),
	    isArray = requireIsArray(),
	    isIterateeCall = require_isIterateeCall();

	/**
	 * Checks if `predicate` returns truthy for **any** element of `collection`.
	 * Iteration is stopped once `predicate` returns truthy. The predicate is
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.some([null, 0, 'yes', false], Boolean);
	 * // => true
	 *
	 * var users = [
	 *   { 'user': 'barney', 'active': true },
	 *   { 'user': 'fred',   'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.some(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.some(users, ['active', false]);
	 * // => true
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.some(users, 'active');
	 * // => true
	 */
	function some(collection, predicate, guard) {
	  var func = isArray(collection) ? arraySome : baseSome;
	  if (guard && isIterateeCall(collection, predicate, guard)) {
	    predicate = undefined;
	  }
	  return func(collection, baseIteratee(predicate, 3));
	}

	some_1 = some;
	return some_1;
}

var types = {exports: {}};

var boolean = {};

var hasRequiredBoolean;

function requireBoolean () {
	if (hasRequiredBoolean) return boolean;
	hasRequiredBoolean = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(boolean, "__esModule", {
	  value: true
	});
	boolean.matcher = boolean.default = void 0;
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _type = _interopRequireDefault(requireType());
	boolean.matcher = /^boolean/gim;
	var _default = () => /*#__PURE__*/function (_Type) {
	  function Boolean(boolean) {
	    var _this;
	    (0, _classCallCheck2.default)(this, Boolean);
	    _this = (0, _callSuper2.default)(this, Boolean, [boolean]);
	    _this.matchers = [/^true$/i, /^false$/i];
	    return _this;
	  }
	  (0, _inherits2.default)(Boolean, _Type);
	  return (0, _createClass2.default)(Boolean, [{
	    key: "isValid",
	    value: function isValid() {
	      return this.value === true || this.value === false;
	    }
	  }]);
	}(_type.default);
	boolean.default = _default;
	return boolean;
}

var color = {};

var colors = {exports: {}};

var hasRequiredColors;

function requireColors () {
	if (hasRequiredColors) return colors.exports;
	hasRequiredColors = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		exports$1.default = ['aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'inherit', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'transparent', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'];
		module.exports = exports$1.default; 
	} (colors, colors.exports));
	return colors.exports;
}

var hasRequiredColor;

function requireColor () {
	if (hasRequiredColor) return color;
	hasRequiredColor = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(color, "__esModule", {
	  value: true
	});
	color.matcher = color.default = void 0;
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _type = _interopRequireDefault(requireType());
	var _colors = _interopRequireDefault(requireColors());
	color.matcher = /^color/gim;
	const shorthandRegex = /^#\w{3}$/;
	const replaceInputRegex = /^#(\w)(\w)(\w)$/;
	const replaceOutput = '#$1$1$2$2$3$3';
	var _default = () => /*#__PURE__*/function (_Type) {
	  function Color(color) {
	    var _this;
	    (0, _classCallCheck2.default)(this, Color);
	    _this = (0, _callSuper2.default)(this, Color, [color]);
	    _this.matchers = [/rgba\(\d{1,3},\s?\d{1,3},\s?\d{1,3},\s?\d(\.\d{1,3})?\)/gi, /rgb\(\d{1,3},\s?\d{1,3},\s?\d{1,3}\)/gi, /^#([0-9a-f]{3}){1,2}$/gi, new RegExp(`^(${_colors.default.join('|')})$`)];
	    return _this;
	  }
	  (0, _inherits2.default)(Color, _Type);
	  return (0, _createClass2.default)(Color, [{
	    key: "getValue",
	    value: function getValue() {
	      if (typeof this.value === 'string' && this.value.match(shorthandRegex)) {
	        return this.value.replace(replaceInputRegex, replaceOutput);
	      }
	      return this.value;
	    }
	  }]);
	}(_type.default);
	color.default = _default;
	return color;
}

var _enum = {};

var escapeRegExp_1;
var hasRequiredEscapeRegExp;

function requireEscapeRegExp () {
	if (hasRequiredEscapeRegExp) return escapeRegExp_1;
	hasRequiredEscapeRegExp = 1;
	var toString = requireToString();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar.source);

	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar, '\\$&')
	    : string;
	}

	escapeRegExp_1 = escapeRegExp;
	return escapeRegExp_1;
}

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(_enum, "__esModule", {
	  value: true
	});
	_enum.matcher = _enum.default = void 0;
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
	var _escapeRegExp2 = _interopRequireDefault(requireEscapeRegExp());
	var _type = _interopRequireDefault(requireType());
	_enum.matcher = /^enum/gim;
	var _default = params => {
	  var _Enum;
	  const matchers = params.match(/\(([^)]+)\)/)[1].split(',');
	  return _Enum = /*#__PURE__*/function (_Type) {
	    function Enum(value) {
	      var _this;
	      (0, _classCallCheck2.default)(this, Enum);
	      _this = (0, _callSuper2.default)(this, Enum, [value]);
	      _this.matchers = matchers.map(m => new RegExp(`^${(0, _escapeRegExp2.default)(m)}$`));
	      return _this;
	    }
	    (0, _inherits2.default)(Enum, _Type);
	    return (0, _createClass2.default)(Enum);
	  }(_type.default), (0, _defineProperty2.default)(_Enum, "errorMessage", `has invalid value: $value for type Enum, only accepts ${matchers.join(', ')}`), _Enum;
	};
	_enum.default = _default;
	return _enum;
}

var unit = {};

var hasRequiredUnit;

function requireUnit () {
	if (hasRequiredUnit) return unit;
	hasRequiredUnit = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(unit, "__esModule", {
	  value: true
	});
	unit.matcher = unit.default = void 0;
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
	var _escapeRegExp2 = _interopRequireDefault(requireEscapeRegExp());
	var _type = _interopRequireDefault(requireType());
	unit.matcher = /^(unit|unitWithNegative)\(.*\)/gim;
	var _default = params => {
	  var _Unit;
	  const allowNeg = params.match(/^unitWithNegative/) ? '-|' : '';
	  const units = params.match(/\(([^)]+)\)/)[1].split(',');
	  const argsMatch = params.match(/\{([^}]+)\}/);
	  const args = argsMatch && argsMatch[1] && argsMatch[1].split(',') || ['1']; // defaults to 1

	  const allowAuto = units.includes('auto') ? '|auto' : '';
	  const filteredUnits = units.filter(u => u !== 'auto');
	  return _Unit = /*#__PURE__*/function (_Type) {
	    function Unit(value) {
	      var _this;
	      (0, _classCallCheck2.default)(this, Unit);
	      _this = (0, _callSuper2.default)(this, Unit, [value]);
	      _this.matchers = [new RegExp(`^(((${allowNeg}\\d|,|\\.){1,}(${filteredUnits.map(_escapeRegExp2.default).join('|')})|0${allowAuto})( )?){${args.join(',')}}$`)];
	      return _this;
	    }
	    (0, _inherits2.default)(Unit, _Type);
	    return (0, _createClass2.default)(Unit);
	  }(_type.default), (0, _defineProperty2.default)(_Unit, "errorMessage", `has invalid value: $value for type Unit, only accepts (${units.join(', ')}) units and ${args.join(' to ')} value(s)`), _Unit;
	};
	unit.default = _default;
	return unit;
}

var string = {};

var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(string, "__esModule", {
	  value: true
	});
	string.matcher = string.default = void 0;
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _type = _interopRequireDefault(requireType());
	string.matcher = /^string/gim;
	var _default = () => /*#__PURE__*/function (_Type) {
	  function NString(value) {
	    var _this;
	    (0, _classCallCheck2.default)(this, NString);
	    _this = (0, _callSuper2.default)(this, NString, [value]);
	    _this.matchers = [/.*/];
	    return _this;
	  }
	  (0, _inherits2.default)(NString, _Type);
	  return (0, _createClass2.default)(NString);
	}(_type.default);
	string.default = _default;
	return string;
}

var integer = {};

var hasRequiredInteger;

function requireInteger () {
	if (hasRequiredInteger) return integer;
	hasRequiredInteger = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(integer, "__esModule", {
	  value: true
	});
	integer.matcher = integer.default = void 0;
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _type = _interopRequireDefault(requireType());
	integer.matcher = /^integer/gim;
	var _default = () => /*#__PURE__*/function (_Type) {
	  function NInteger(value) {
	    var _this;
	    (0, _classCallCheck2.default)(this, NInteger);
	    _this = (0, _callSuper2.default)(this, NInteger, [value]);
	    _this.matchers = [/\d+/];
	    return _this;
	  }
	  (0, _inherits2.default)(NInteger, _Type);
	  return (0, _createClass2.default)(NInteger);
	}(_type.default);
	integer.default = _default;
	return integer;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types.exports;
	hasRequiredTypes = 1;
	(function (module, exports$1) {

		var _interopRequireWildcard = requireInteropRequireWildcard().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _boolean = _interopRequireWildcard(requireBoolean());
		var _color = _interopRequireWildcard(requireColor());
		var _enum = _interopRequireWildcard(require_enum());
		var _unit = _interopRequireWildcard(requireUnit());
		var _string = _interopRequireWildcard(requireString());
		var _integer = _interopRequireWildcard(requireInteger());
		exports$1.default = {
		  boolean: {
		    matcher: _boolean.matcher,
		    typeConstructor: _boolean.default
		  },
		  enum: {
		    matcher: _enum.matcher,
		    typeConstructor: _enum.default
		  },
		  color: {
		    matcher: _color.matcher,
		    typeConstructor: _color.default
		  },
		  unit: {
		    matcher: _unit.matcher,
		    typeConstructor: _unit.default
		  },
		  string: {
		    matcher: _string.matcher,
		    typeConstructor: _string.default
		  },
		  integer: {
		    matcher: _integer.matcher,
		    typeConstructor: _integer.default
		  }
		};
		module.exports = exports$1.default; 
	} (types, types.exports));
	return types.exports;
}

var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(type, "__esModule", {
	  value: true
	});
	type.types = type.initializeType = type.default = void 0;
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _find2 = _interopRequireDefault(requireFind());
	var _some2 = _interopRequireDefault(requireSome());
	var _index = _interopRequireDefault(requireTypes());
	// Avoid recreate existing types
	const types = type.types = {};
	const initializeType = typeConfig => {
	  if (types[typeConfig]) {
	    return types[typeConfig];
	  }
	  const {
	    typeConstructor
	  } = (0, _find2.default)(_index.default, type => !!typeConfig.match(type.matcher)) || {};
	  if (!typeConstructor) {
	    throw new Error(`No type found for ${typeConfig}`);
	  }
	  types[typeConfig] = typeConstructor(typeConfig);
	  return types[typeConfig];
	};
	type.initializeType = initializeType;
	type.default = /*#__PURE__*/function () {
	  function Type(value) {
	    (0, _classCallCheck2.default)(this, Type);
	    this.value = value;
	  }
	  return (0, _createClass2.default)(Type, [{
	    key: "isValid",
	    value: function isValid() {
	      return (0, _some2.default)(this.matchers, matcher => `${this.value}`.match(matcher));
	    }
	  }, {
	    key: "getErrorMessage",
	    value: function getErrorMessage() {
	      if (this.isValid()) {
	        return;
	      }
	      const errorMessage = this.constructor.errorMessage || `has invalid value: ${this.value} for type ${this.constructor.name} `;
	      return errorMessage.replace(/\$value/g, this.value);
	    }
	  }, {
	    key: "getValue",
	    value: function getValue() {
	      return this.value;
	    }
	  }], [{
	    key: "check",
	    value: function check(type) {
	      return !!type.match(this.constructor.typeChecker);
	    }
	  }]);
	}();
	return type;
}

var hasRequiredFormatAttributes;

function requireFormatAttributes () {
	if (hasRequiredFormatAttributes) return formatAttributes.exports;
	hasRequiredFormatAttributes = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _reduce2 = _interopRequireDefault(requireReduce());
		var _type = requireType();
		var _default = (attributes, allowedAttributes) => (0, _reduce2.default)(attributes, (acc, val, attrName) => {
		  if (allowedAttributes && allowedAttributes[attrName]) {
		    const TypeConstructor = (0, _type.initializeType)(allowedAttributes[attrName]);
		    if (TypeConstructor) {
		      const type = new TypeConstructor(val);
		      return {
		        ...acc,
		        [attrName]: type.getValue()
		      };
		    }
		  }
		  return {
		    ...acc,
		    [attrName]: val
		  };
		}, {});
		exports$1.default = _default;
		module.exports = exports$1.default; 
	} (formatAttributes, formatAttributes.exports));
	return formatAttributes.exports;
}

var jsonToXML = {exports: {}};

var hasRequiredJsonToXML;

function requireJsonToXML () {
	if (hasRequiredJsonToXML) return jsonToXML.exports;
	hasRequiredJsonToXML = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const jsonToXML = ({
		  tagName,
		  attributes,
		  children,
		  content
		}) => {
		  const subNode = children && children.length > 0 ? children.map(jsonToXML).join('\n') : content || '';
		  const stringAttrs = Object.keys(attributes).map(attr => `${attr}="${attributes[attr]}"`).join(' ');
		  return `<${tagName}${stringAttrs === '' ? '>' : ` ${stringAttrs}>`}${subNode}</${tagName}>`;
		};
		exports$1.default = jsonToXML;
		module.exports = exports$1.default; 
	} (jsonToXML, jsonToXML.exports));
	return jsonToXML.exports;
}

var hasRequiredCreateComponent;

function requireCreateComponent () {
	if (hasRequiredCreateComponent) return createComponent;
	hasRequiredCreateComponent = 1;

	var _interopRequireWildcard = requireInteropRequireWildcard().default;
	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(createComponent, "__esModule", {
	  value: true
	});
	createComponent.HeadComponent = createComponent.BodyComponent = void 0;
	createComponent.initComponent = initComponent;
	var _callSuper2 = _interopRequireDefault(requireCallSuper());
	var _inherits2 = _interopRequireDefault(requireInherits());
	var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
	var _createClass2 = _interopRequireDefault(requireCreateClass());
	var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
	var _omitBy2 = _interopRequireDefault(requireOmitBy());
	var _isNil2 = _interopRequireDefault(requireIsNil());
	var _filter2 = _interopRequireDefault(requireFilter$1());
	var _find2 = _interopRequireDefault(requireFind());
	var _kebabCase2 = _interopRequireDefault(requireKebabCase());
	var _reduce2 = _interopRequireDefault(requireReduce());
	var _identity2 = _interopRequireDefault(requireIdentity$1());
	var _forEach2 = _interopRequireDefault(requireForEach());
	var _get2 = _interopRequireDefault(requireGet());
	var _mjmlParserXml = _interopRequireDefault(requireLib$t());
	var _shorthandParser = _interopRequireWildcard(requireShorthandParser());
	var _formatAttributes = _interopRequireDefault(requireFormatAttributes());
	var _jsonToXML = _interopRequireDefault(requireJsonToXML());
	// eslint-disable-next-line max-classes-per-file

	function initComponent({
	  initialDatas,
	  name
	}) {
	  const Component = initialDatas.context.components[name];
	  if (Component) {
	    const component = new Component(initialDatas);
	    if (component.headStyle) {
	      component.context.addHeadStyle(name, component.headStyle);
	    }
	    if (component.componentHeadStyle) {
	      component.context.addComponentHeadSyle(component.componentHeadStyle);
	    }
	    return component;
	  }
	  return null;
	}
	let Component = /*#__PURE__*/function () {
	  function Component(initialDatas = {}) {
	    (0, _classCallCheck2.default)(this, Component);
	    const {
	      attributes = {},
	      children = [],
	      content = '',
	      context = {},
	      props = {},
	      globalAttributes = {},
	      absoluteFilePath = null,
	      rawAttrs = {}
	    } = initialDatas;
	    this.props = {
	      absoluteFilePath,
	      ...props,
	      children,
	      content,
	      rawAttrs
	    };
	    this.attributes = (0, _formatAttributes.default)({
	      ...this.constructor.defaultAttributes,
	      ...globalAttributes,
	      ...attributes
	    }, this.constructor.allowedAttributes);
	    this.context = context;
	    return this;
	  }
	  return (0, _createClass2.default)(Component, [{
	    key: "getChildContext",
	    value: function getChildContext() {
	      return this.context;
	    }
	  }, {
	    key: "getAttribute",
	    value: function getAttribute(name) {
	      return this.attributes[name];
	    }
	  }, {
	    key: "getContent",
	    value: function getContent() {
	      return this.props.content.trim();
	    }
	  }, {
	    key: "renderMJML",
	    value: function renderMJML(mjml, options = {}) {
	      if (typeof mjml === 'string') {
	        // supports returning siblings elements from a custom component
	        const partialMjml = (0, _mjmlParserXml.default)(`<fragment>${mjml}</fragment>`, {
	          ...options,
	          components: this.context.components,
	          ignoreIncludes: true
	        });
	        return partialMjml.children.map(child => this.context.processing(child, this.context)).join('');
	      }
	      return this.context.processing(mjml, this.context);
	    }
	  }], [{
	    key: "getTagName",
	    value: function getTagName() {
	      return this.componentName || (0, _kebabCase2.default)(this.name);
	    }
	  }, {
	    key: "isRawElement",
	    value: function isRawElement() {
	      return !!this.rawElement;
	    }
	  }]);
	}();
	(0, _defineProperty2.default)(Component, "defaultAttributes", {});
	createComponent.BodyComponent = /*#__PURE__*/function (_Component2) {
	  function BodyComponent() {
	    (0, _classCallCheck2.default)(this, BodyComponent);
	    return (0, _callSuper2.default)(this, BodyComponent, arguments);
	  }
	  (0, _inherits2.default)(BodyComponent, _Component2);
	  return (0, _createClass2.default)(BodyComponent, [{
	    key: "getStyles",
	    value:
	    // eslint-disable-next-line class-methods-use-this
	    function getStyles() {
	      return {};
	    }
	  }, {
	    key: "getShorthandAttrValue",
	    value: function getShorthandAttrValue(attribute, direction) {
	      const mjAttributeDirection = this.getAttribute(`${attribute}-${direction}`);
	      const mjAttribute = this.getAttribute(attribute);
	      if (mjAttributeDirection) {
	        return parseInt(mjAttributeDirection, 10);
	      }
	      if (!mjAttribute) {
	        return 0;
	      }
	      return (0, _shorthandParser.default)(mjAttribute, direction);
	    }
	  }, {
	    key: "getShorthandBorderValue",
	    value: function getShorthandBorderValue(direction, attribute = 'border') {
	      const borderDirection = direction && this.getAttribute(`${attribute}-${direction}`);
	      const border = this.getAttribute(attribute);
	      return (0, _shorthandParser.borderParser)(borderDirection || border || '0');
	    }
	  }, {
	    key: "getBoxWidths",
	    value: function getBoxWidths() {
	      const {
	        containerWidth
	      } = this.context;
	      const parsedWidth = parseInt(containerWidth, 10);
	      const paddings = this.getShorthandAttrValue('padding', 'right') + this.getShorthandAttrValue('padding', 'left');
	      const borders = this.getShorthandBorderValue('right') + this.getShorthandBorderValue('left');
	      return {
	        totalWidth: parsedWidth,
	        borders,
	        paddings,
	        box: parsedWidth - paddings - borders
	      };
	    }
	  }, {
	    key: "htmlAttributes",
	    value: function htmlAttributes(attributes) {
	      const specialAttributes = {
	        style: v => this.styles(v),
	        default: _identity2.default
	      };
	      return (0, _reduce2.default)((0, _omitBy2.default)(attributes, _isNil2.default), (output, v, name) => {
	        const value = (specialAttributes[name] || specialAttributes.default)(v);
	        return `${output} ${name}="${value}"`;
	      }, '');
	    }
	  }, {
	    key: "styles",
	    value: function styles(_styles) {
	      let stylesObject;
	      if (_styles) {
	        if (typeof _styles === 'string') {
	          stylesObject = (0, _get2.default)(this.getStyles(), _styles);
	        } else {
	          stylesObject = _styles;
	        }
	      }
	      return (0, _reduce2.default)(stylesObject, (output, value, name) => {
	        if (!(0, _isNil2.default)(value)) {
	          return `${output}${name}:${value};`;
	        }
	        return output;
	      }, '');
	    }
	  }, {
	    key: "renderChildren",
	    value: function renderChildren(children, options = {}) {
	      const {
	        props = {},
	        renderer = component => component.render(),
	        attributes = {},
	        rawXML = false
	      } = options;
	      children = children || this.props.children;
	      if (rawXML) {
	        return children.map(child => {
	          child.attributes = {
	            ...attributes,
	            ...child.attributes
	          };
	          return (0, _jsonToXML.default)(child);
	        }).join('\n');
	      }
	      const sibling = children.length;
	      const rawComponents = (0, _filter2.default)(this.context.components, c => c.isRawElement());
	      const nonRawSiblings = children.filter(child => !(0, _find2.default)(rawComponents, c => c.getTagName() === child.tagName)).length;
	      let output = '';
	      let index = 0;
	      (0, _forEach2.default)(children, children => {
	        const component = initComponent({
	          name: children.tagName,
	          initialDatas: {
	            ...children,
	            attributes: {
	              ...attributes,
	              ...children.attributes
	            },
	            context: this.getChildContext(),
	            props: {
	              ...props,
	              first: index === 0,
	              index,
	              last: index + 1 === sibling,
	              sibling,
	              nonRawSiblings
	            }
	          }
	        });
	        if (component !== null) {
	          output += renderer(component);
	        }
	        index++; // eslint-disable-line no-plusplus
	      });
	      return output;
	    }
	  }]);
	}(Component);
	createComponent.HeadComponent = /*#__PURE__*/function (_Component3) {
	  function HeadComponent() {
	    (0, _classCallCheck2.default)(this, HeadComponent);
	    return (0, _callSuper2.default)(this, HeadComponent, arguments);
	  }
	  (0, _inherits2.default)(HeadComponent, _Component3);
	  return (0, _createClass2.default)(HeadComponent, [{
	    key: "handlerChildren",
	    value: function handlerChildren() {
	      const {
	        children
	      } = this.props;
	      return children.map(children => {
	        const component = initComponent({
	          name: children.tagName,
	          initialDatas: {
	            ...children,
	            context: this.getChildContext()
	          }
	        });
	        if (!component) {
	          // eslint-disable-next-line no-console
	          console.error(`No matching component for tag : ${children.tagName}`);
	          return null;
	        }
	        if (component.handler) {
	          component.handler();
	        }
	        if (component.render) {
	          return component.render();
	        }
	        return null;
	      });
	    }
	  }], [{
	    key: "getTagName",
	    value: function getTagName() {
	      return this.componentName || (0, _kebabCase2.default)(this.name);
	    }
	  }]);
	}(Component);
	return createComponent;
}

var components = {};

var hasRequiredComponents;

function requireComponents () {
	if (hasRequiredComponents) return components;
	hasRequiredComponents = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(components, "__esModule", {
	  value: true
	});
	components.assignComponents = assignComponents;
	components.default = void 0;
	components.registerComponent = registerComponent;
	var _kebabCase2 = _interopRequireDefault(requireKebabCase());
	var _mjmlValidator = requireLib$s();
	const components$1 = {};
	function assignComponents(target, source) {
	  for (const component of source) {
	    target[component.componentName || (0, _kebabCase2.default)(component.name)] = component;
	  }
	}
	function registerComponent(Component, options = {}) {
	  assignComponents(components$1, [Component]);
	  if (Component.dependencies && options.registerDependencies) {
	    (0, _mjmlValidator.registerDependencies)(Component.dependencies);
	  }
	}
	components.default = components$1;
	return components;
}

var makeLowerBreakpoint = {exports: {}};

var hasRequiredMakeLowerBreakpoint;

function requireMakeLowerBreakpoint () {
	if (hasRequiredMakeLowerBreakpoint) return makeLowerBreakpoint.exports;
	hasRequiredMakeLowerBreakpoint = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = makeLowerBreakpoint;
		function makeLowerBreakpoint(breakpoint) {
		  try {
		    const pixels = Number.parseInt(breakpoint.match('[0-9]+')[0], 10);
		    return `${pixels - 1}px`;
		  } catch (e) {
		    return breakpoint;
		  }
		}
		module.exports = exports$1.default; 
	} (makeLowerBreakpoint, makeLowerBreakpoint.exports));
	return makeLowerBreakpoint.exports;
}

var suffixCssClasses = {exports: {}};

var hasRequiredSuffixCssClasses;

function requireSuffixCssClasses () {
	if (hasRequiredSuffixCssClasses) return suffixCssClasses.exports;
	hasRequiredSuffixCssClasses = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _default = (classes, suffix) => classes ? classes.split(' ').map(c => `${c}-${suffix}`).join(' ') : '';
		exports$1.default = _default;
		module.exports = exports$1.default; 
	} (suffixCssClasses, suffixCssClasses.exports));
	return suffixCssClasses.exports;
}

var mergeOutlookConditionnals = {exports: {}};

var hasRequiredMergeOutlookConditionnals;

function requireMergeOutlookConditionnals () {
	if (hasRequiredMergeOutlookConditionnals) return mergeOutlookConditionnals.exports;
	hasRequiredMergeOutlookConditionnals = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		// # OPTIMIZE ME:  check if previous conditionnal is `<!--[if mso | I`]>` too
		var _default = content => content.replace(/(<!\[endif]-->\s*?<!--\[if mso \| IE]>)/gm, '');
		exports$1.default = _default;
		module.exports = exports$1.default; 
	} (mergeOutlookConditionnals, mergeOutlookConditionnals.exports));
	return mergeOutlookConditionnals.exports;
}

var minifyOutlookConditionnals = {exports: {}};

var hasRequiredMinifyOutlookConditionnals;

function requireMinifyOutlookConditionnals () {
	if (hasRequiredMinifyOutlookConditionnals) return minifyOutlookConditionnals.exports;
	hasRequiredMinifyOutlookConditionnals = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _default = content =>
		// find conditionnal comment blocks
		content.replace(/(<!--\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif]-->)/gm, (match, prefix, content, suffix) => {
		  // find spaces between tags
		  const processedContent = content.replace(/(^|>)(\s+)(<|$)/gm, (match, prefix, content, suffix) => `${prefix}${suffix}`).replace(/\s{2,}/gm, ' ');
		  return `${prefix}${processedContent}${suffix}`;
		});
		exports$1.default = _default;
		module.exports = exports$1.default; 
	} (minifyOutlookConditionnals, minifyOutlookConditionnals.exports));
	return minifyOutlookConditionnals.exports;
}

var skeleton = {exports: {}};

var preview = {exports: {}};

var hasRequiredPreview;

function requirePreview () {
	if (hasRequiredPreview) return preview.exports;
	hasRequiredPreview = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = _default;
		function _default(content) {
		  if (content === '') {
		    return '';
		  }
		  return `
    <div style="display:none;font-size:1px;color:#ffffff;line-height:1px;max-height:0px;max-width:0px;opacity:0;overflow:hidden;">${content}</div>
  `;
		}
		module.exports = exports$1.default; 
	} (preview, preview.exports));
	return preview.exports;
}

var fonts = {};

var hasRequiredFonts;

function requireFonts () {
	if (hasRequiredFonts) return fonts;
	hasRequiredFonts = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(fonts, "__esModule", {
	  value: true
	});
	fonts.buildFontsTags = buildFontsTags;
	var _map2 = _interopRequireDefault(requireMap$1());
	var _forEach2 = _interopRequireDefault(requireForEach());
	// eslint-disable-next-line import/prefer-default-export
	function buildFontsTags(content, inlineStyle, fonts = {}) {
	  const toImport = [];
	  (0, _forEach2.default)(fonts, (url, name) => {
	    const regex = new RegExp(`"[^"]*font-family:[^"]*${name}[^"]*"`, 'gmi');
	    const inlineRegex = new RegExp(`font-family:[^;}]*${name}`, 'gmi');
	    if (content.match(regex) || inlineStyle.some(s => s.match(inlineRegex))) {
	      toImport.push(url);
	    }
	  });
	  if (toImport.length > 0) {
	    return `
      <!--[if !mso]><!-->
        ${(0, _map2.default)(toImport, url => `<link href="${url}" rel="stylesheet" type="text/css">`).join('\n')}
        <style type="text/css">
          ${(0, _map2.default)(toImport, url => `@import url(${url});`).join('\n')}
        </style>
      <!--<![endif]-->\n
    `;
	  }
	  return '';
	}
	return fonts;
}

var mediaQueries = {exports: {}};

var hasRequiredMediaQueries;

function requireMediaQueries () {
	if (hasRequiredMediaQueries) return mediaQueries.exports;
	hasRequiredMediaQueries = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = buildMediaQueriesTags;
		var _isEmpty2 = _interopRequireDefault(requireIsEmpty());
		var _map2 = _interopRequireDefault(requireMap$1());
		// eslint-disable-next-line import/prefer-default-export
		function buildMediaQueriesTags(breakpoint, mediaQueries = {}, options = {}) {
		  if ((0, _isEmpty2.default)(mediaQueries)) {
		    return '';
		  }
		  const {
		    forceOWADesktop = false,
		    printerSupport = false
		  } = options;
		  const baseMediaQueries = (0, _map2.default)(mediaQueries, (mediaQuery, className) => `.${className} ${mediaQuery}`);
		  const thunderbirdMediaQueries = (0, _map2.default)(mediaQueries, (mediaQuery, className) => `.moz-text-html .${className} ${mediaQuery}`);
		  const owaQueries = (0, _map2.default)(baseMediaQueries, mq => `[owa] ${mq}`);
		  return `
    <style type="text/css">
      @media only screen and (min-width:${breakpoint}) {
        ${baseMediaQueries.join('\n')}
      }
    </style>
    <style media="screen and (min-width:${breakpoint})">
      ${thunderbirdMediaQueries.join('\n')}
    </style>
    ${printerSupport ? `<style type="text/css">
            @media only print {
              ${baseMediaQueries.join('\n')}
            }
          </style>` : ``}
    ${forceOWADesktop ? `<style type="text/css">\n${owaQueries.join('\n')}\n</style>` : ``}
  `;
		}
		module.exports = exports$1.default; 
	} (mediaQueries, mediaQueries.exports));
	return mediaQueries.exports;
}

var styles = {};

var hasRequiredStyles;

function requireStyles () {
	if (hasRequiredStyles) return styles;
	hasRequiredStyles = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(styles, "__esModule", {
	  value: true
	});
	styles.buildStyleFromComponents = buildStyleFromComponents;
	styles.buildStyleFromTags = buildStyleFromTags;
	var _isFunction2 = _interopRequireDefault(requireIsFunction());
	function buildStyleFromComponents(breakpoint, componentsHeadStyles, headStylesObject) {
	  const headStyles = Object.values(headStylesObject);
	  if (componentsHeadStyles.length === 0 && headStyles.length === 0) {
	    return '';
	  }
	  return `
    <style type="text/css">${[...componentsHeadStyles, ...headStyles].reduce((result, styleFunction) => `${result}\n${styleFunction(breakpoint)}`, '')}
    </style>`;
	}
	function buildStyleFromTags(breakpoint, styles) {
	  if (styles.length === 0) {
	    return '';
	  }
	  return ` 
    <style type="text/css">${styles.reduce((result, style) => `${result}\n${(0, _isFunction2.default)(style) ? style(breakpoint) : style}`, '')}
    </style>`;
	}
	return styles;
}

var hasRequiredSkeleton;

function requireSkeleton () {
	if (hasRequiredSkeleton) return skeleton.exports;
	hasRequiredSkeleton = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = skeleton;
		var _isNil2 = _interopRequireDefault(requireIsNil());
		var _negate2 = _interopRequireDefault(requireNegate());
		var _preview = _interopRequireDefault(requirePreview());
		var _fonts = requireFonts();
		var _mediaQueries = _interopRequireDefault(requireMediaQueries());
		var _styles = requireStyles();
		function skeleton(options) {
		  const {
		    backgroundColor = '',
		    beforeDoctype = '',
		    breakpoint = '480px',
		    content = '',
		    fonts = {},
		    mediaQueries = {},
		    headStyle = {},
		    componentsHeadStyle = [],
		    headRaw = [],
		    preview,
		    title = '',
		    style = [],
		    forceOWADesktop,
		    printerSupport,
		    inlineStyle,
		    lang,
		    dir
		  } = options;
		  return `${beforeDoctype ? `${beforeDoctype}\n` : ''}<!doctype html>
<html lang="${lang}" dir="${dir}" xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
  <head>
    <title>${title}</title>
    <!--[if !mso]><!-->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--<![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
      #outlook a { padding:0; }
      body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }
      table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }
      img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }
      p { display:block;margin:13px 0; }
    </style>
    <!--[if mso]>
    <noscript>
    <xml>
    <o:OfficeDocumentSettings>
      <o:AllowPNG/>
      <o:PixelsPerInch>96</o:PixelsPerInch>
    </o:OfficeDocumentSettings>
    </xml>
    </noscript>
    <![endif]-->
    <!--[if lte mso 11]>
    <style type="text/css">
      .mj-outlook-group-fix { width:100% !important; }
    </style>
    <![endif]-->
    ${(0, _fonts.buildFontsTags)(content, inlineStyle, fonts)}
    ${(0, _mediaQueries.default)(breakpoint, mediaQueries, {
		    forceOWADesktop,
		    printerSupport
		  })}
    ${(0, _styles.buildStyleFromComponents)(breakpoint, componentsHeadStyle, headStyle)}
    ${(0, _styles.buildStyleFromTags)(breakpoint, style)}
    ${headRaw.filter((0, _negate2.default)(_isNil2.default)).join('\n')}
  </head>
  <body style="word-spacing:normal;${backgroundColor ? `background-color:${backgroundColor};` : ''}">
    ${(0, _preview.default)(preview)}
    ${content}
  </body>
</html>
  `;
		}
		module.exports = exports$1.default; 
	} (skeleton, skeleton.exports));
	return skeleton.exports;
}

var mjmlconfig = {};

var hasRequiredMjmlconfig;

function requireMjmlconfig () {
	if (hasRequiredMjmlconfig) return mjmlconfig;
	hasRequiredMjmlconfig = 1;

	var _interopRequireDefault = requireInteropRequireDefault().default;
	Object.defineProperty(mjmlconfig, "__esModule", {
	  value: true
	});
	mjmlconfig.default = handleMjmlConfig;
	mjmlconfig.handleMjmlConfigComponents = handleMjmlConfigComponents;
	mjmlconfig.readMjmlConfig = readMjmlConfig;
	mjmlconfig.registerCustomComponent = registerCustomComponent;
	mjmlconfig.resolveComponentPath = resolveComponentPath;
	var _path = _interopRequireDefault(require$$0$3);
	var _fs = _interopRequireDefault(require$$0$4);
	var _mjmlValidator = requireLib$s();
	var _components = requireComponents();
	function readMjmlConfig(configPathOrDir = process.cwd()) {
	  let componentRootPath = process.cwd();
	  let mjmlConfigPath = configPathOrDir;
	  try {
	    mjmlConfigPath = _path.default.basename(configPathOrDir).match(/^\.mjmlconfig(\.js)?$/) ? _path.default.resolve(configPathOrDir) : _path.default.resolve(configPathOrDir, '.mjmlconfig');
	    componentRootPath = _path.default.dirname(mjmlConfigPath);
	    const fullPath = _path.default.resolve(mjmlConfigPath);
	    let mjmlConfig;
	    if (_path.default.extname(mjmlConfigPath) === '.js') {
	      delete require.cache[fullPath];
	      mjmlConfig = commonjsRequire(fullPath); // eslint-disable-line global-require, import/no-dynamic-require
	    } else {
	      mjmlConfig = JSON.parse(_fs.default.readFileSync(fullPath, 'utf8'));
	    }
	    return {
	      mjmlConfig,
	      componentRootPath
	    };
	  } catch (e) {
	    if (e.code !== 'ENOENT') {
	      console.error('Error reading mjmlconfig : ', e); // eslint-disable-line no-console
	    }
	    return {
	      mjmlConfig: {
	        packages: [],
	        options: {}
	      },
	      mjmlConfigPath,
	      componentRootPath,
	      error: e
	    };
	  }
	}
	function resolveComponentPath(compPath, componentRootPath) {
	  if (!compPath) {
	    return null;
	  }
	  if (!compPath.startsWith('.') && !_path.default.isAbsolute(compPath)) {
	    try {
	      return require.resolve(compPath);
	    } catch (e) {
	      if (e.code !== 'MODULE_NOT_FOUND') {
	        console.error('Error resolving custom component path : ', e); // eslint-disable-line no-console
	        return null;
	      }
	      // we got a 'MODULE_NOT_FOUND' error
	      try {
	        // try again as relative path to node_modules: (this may be necessary if mjml is installed globally or by npm link)
	        return resolveComponentPath(`./node_modules/${compPath}`, componentRootPath);
	      } catch (e) {
	        //  try again as a plain local path:
	        return resolveComponentPath(`./${compPath}`, componentRootPath);
	      }
	    }
	  }
	  return require.resolve(_path.default.resolve(componentRootPath, compPath));
	}
	function registerCustomComponent(comp, registerCompFn = _components.registerComponent) {
	  if (comp instanceof Function) {
	    registerCompFn(comp);
	  } else {
	    const compNames = Object.keys(comp); // this approach handles both an array and an object (like the mjml-accordion default export)
	    compNames.forEach(compName => {
	      registerCustomComponent(comp[compName], registerCompFn);
	    });
	  }
	}
	function handleMjmlConfigComponents(packages, componentRootPath, registerCompFn) {
	  const result = {
	    success: [],
	    failures: []
	  };
	  packages.forEach(compPath => {
	    let resolvedPath = compPath;
	    try {
	      resolvedPath = resolveComponentPath(compPath, componentRootPath);
	      if (resolvedPath) {
	        const requiredComp = commonjsRequire(resolvedPath); // eslint-disable-line global-require, import/no-dynamic-require
	        registerCustomComponent(requiredComp.default || requiredComp, registerCompFn);
	        (0, _mjmlValidator.registerDependencies)((requiredComp.default || requiredComp).dependencies || {});
	        result.success.push(compPath);
	      }
	    } catch (e) {
	      result.failures.push({
	        error: e,
	        compPath
	      });
	      if (e.code === 'ENOENT' || e.code === 'MODULE_NOT_FOUND') {
	        console.error('Missing or unreadable custom component : ', resolvedPath); // eslint-disable-line no-console
	      } else {
	        // eslint-disable-next-line no-console
	        console.error('Error when registering custom component : ', resolvedPath, e);
	      }
	    }
	  });
	  return result;
	}
	function handleMjmlConfig(configPathOrDir = process.cwd(), registerCompFn = _components.registerComponent) {
	  const {
	    mjmlConfig: {
	      packages
	    },
	    componentRootPath,
	    error
	  } = readMjmlConfig(configPathOrDir);
	  if (error) return {
	    error
	  };
	  return handleMjmlConfigComponents(packages, componentRootPath, registerCompFn);
	}
	return mjmlconfig;
}

var hasRequiredLib$r;

function requireLib$r () {
	if (hasRequiredLib$r) return lib$y;
	hasRequiredLib$r = 1;
	(function (exports$1) {

		var _interopRequireWildcard = requireInteropRequireWildcard().default;
		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "BodyComponent", {
		  enumerable: true,
		  get: function () {
		    return _createComponent.BodyComponent;
		  }
		});
		Object.defineProperty(exports$1, "HeadComponent", {
		  enumerable: true,
		  get: function () {
		    return _createComponent.HeadComponent;
		  }
		});
		Object.defineProperty(exports$1, "assignComponents", {
		  enumerable: true,
		  get: function () {
		    return _components.assignComponents;
		  }
		});
		Object.defineProperty(exports$1, "components", {
		  enumerable: true,
		  get: function () {
		    return _components.default;
		  }
		});
		exports$1.default = mjml2html;
		Object.defineProperty(exports$1, "handleMjmlConfig", {
		  enumerable: true,
		  get: function () {
		    return _mjmlconfig.default;
		  }
		});
		Object.defineProperty(exports$1, "initComponent", {
		  enumerable: true,
		  get: function () {
		    return _createComponent.initComponent;
		  }
		});
		Object.defineProperty(exports$1, "initializeType", {
		  enumerable: true,
		  get: function () {
		    return _type.initializeType;
		  }
		});
		Object.defineProperty(exports$1, "makeLowerBreakpoint", {
		  enumerable: true,
		  get: function () {
		    return _makeLowerBreakpoint.default;
		  }
		});
		Object.defineProperty(exports$1, "registerComponent", {
		  enumerable: true,
		  get: function () {
		    return _components.registerComponent;
		  }
		});
		Object.defineProperty(exports$1, "suffixCssClasses", {
		  enumerable: true,
		  get: function () {
		    return _suffixCssClasses.default;
		  }
		});
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _wrapNativeSuper2 = _interopRequireDefault(requireWrapNativeSuper());
		var _isEmpty2 = _interopRequireDefault(requireIsEmpty());
		var _each2 = _interopRequireDefault(requireEach());
		var _isObject2 = _interopRequireDefault(requireIsObject());
		var _reduce2 = _interopRequireDefault(requireReduce());
		var _omit2 = _interopRequireDefault(requireOmit());
		var _map2 = _interopRequireDefault(requireMap$1());
		var _identity2 = _interopRequireDefault(requireIdentity$1());
		var _get2 = _interopRequireDefault(requireGet());
		var _filter2 = _interopRequireDefault(requireFilter$1());
		var _find2 = _interopRequireDefault(requireFind());
		var _path = _interopRequireDefault(require$$0$3);
		var _juice = _interopRequireDefault(requireClient());
		var _jsBeautify = requireJs();
		var _htmlMinifier = requireHtmlminifier();
		var _cheerio = requireLib$w();
		var _mjmlParserXml = _interopRequireDefault(requireLib$t());
		var _mjmlValidator = _interopRequireWildcard(requireLib$s());
		var _mjmlMigrate = requireMigrate();
		var _createComponent = requireCreateComponent();
		var _components = _interopRequireWildcard(requireComponents());
		var _makeLowerBreakpoint = _interopRequireDefault(requireMakeLowerBreakpoint());
		var _suffixCssClasses = _interopRequireDefault(requireSuffixCssClasses());
		var _mergeOutlookConditionnals = _interopRequireDefault(requireMergeOutlookConditionnals());
		var _minifyOutlookConditionnals = _interopRequireDefault(requireMinifyOutlookConditionnals());
		var _skeleton = _interopRequireDefault(requireSkeleton());
		var _type = requireType();
		var _mjmlconfig = _interopRequireWildcard(requireMjmlconfig());
		const isNode = requireBrowser();
		let ValidationError = /*#__PURE__*/function (_Error) {
		  function ValidationError(message, errors) {
		    var _this;
		    (0, _classCallCheck2.default)(this, ValidationError);
		    _this = (0, _callSuper2.default)(this, ValidationError, [message]);
		    _this.errors = errors;
		    return _this;
		  }
		  (0, _inherits2.default)(ValidationError, _Error);
		  return (0, _createClass2.default)(ValidationError);
		}(/*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
		function mjml2html(mjml, options = {}) {
		  let content = '';
		  let errors = [];
		  if (isNode && typeof options.skeleton === 'string') {
		    /* eslint-disable global-require */
		    /* eslint-disable import/no-dynamic-require */
		    options.skeleton = commonjsRequire(options.skeleton.charAt(0) === '.' ? _path.default.resolve(process.cwd(), options.skeleton) : options.skeleton);
		    /* eslint-enable global-require */
		    /* eslint-enable import/no-dynamic-require */
		  }
		  let packages = {};
		  let confOptions = {};
		  let mjmlConfigOptions = {};
		  let confPreprocessors = [];
		  let error = null;
		  let componentRootPath = null;
		  if (isNode && options.useMjmlConfigOptions || options.mjmlConfigPath) {
		    const mjmlConfigContent = (0, _mjmlconfig.readMjmlConfig)(options.mjmlConfigPath);
		    ({
		      mjmlConfig: {
		        packages,
		        options: confOptions,
		        preprocessors: confPreprocessors
		      },
		      componentRootPath,
		      error
		    } = mjmlConfigContent);
		    if (options.useMjmlConfigOptions) {
		      mjmlConfigOptions = confOptions;
		    }
		  }

		  // if mjmlConfigPath is specified then we need to register components it on each call
		  if (isNode && !error && options.mjmlConfigPath) {
		    (0, _mjmlconfig.handleMjmlConfigComponents)(packages, componentRootPath, _components.registerComponent);
		  }
		  const {
		    beautify = false,
		    fonts = {
		      'Open Sans': 'https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,700',
		      'Droid Sans': 'https://fonts.googleapis.com/css?family=Droid+Sans:300,400,500,700',
		      Lato: 'https://fonts.googleapis.com/css?family=Lato:300,400,500,700',
		      Roboto: 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700',
		      Ubuntu: 'https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700'
		    },
		    keepComments,
		    minify = false,
		    minifyOptions = {},
		    ignoreIncludes = false,
		    juiceOptions = {},
		    juicePreserveTags = null,
		    skeleton = _skeleton.default,
		    validationLevel = 'soft',
		    filePath = '.',
		    actualPath = '.',
		    noMigrateWarn = false,
		    preprocessors,
		    presets = [],
		    printerSupport = false
		  } = {
		    ...mjmlConfigOptions,
		    ...options,
		    preprocessors: options.preprocessors ? [...confPreprocessors, ...options.preprocessors] : confPreprocessors
		  };
		  const components = {
		    ..._components.default
		  };
		  const dependencies = (0, _mjmlValidator.assignDependencies)({}, _mjmlValidator.dependencies);
		  for (const preset of presets) {
		    (0, _components.assignComponents)(components, preset.components);
		    (0, _mjmlValidator.assignDependencies)(dependencies, preset.dependencies);
		  }
		  if (typeof mjml === 'string') {
		    mjml = (0, _mjmlParserXml.default)(mjml, {
		      keepComments,
		      components,
		      filePath,
		      actualPath,
		      preprocessors,
		      ignoreIncludes
		    });
		  }
		  mjml = (0, _mjmlMigrate.handleMjml3)(mjml, {
		    noMigrateWarn
		  });
		  const globalData = {
		    backgroundColor: '',
		    beforeDoctype: '',
		    breakpoint: '480px',
		    classes: {},
		    classesDefault: {},
		    defaultAttributes: {},
		    htmlAttributes: {},
		    fonts,
		    inlineStyle: [],
		    headStyle: {},
		    componentsHeadStyle: [],
		    headRaw: [],
		    mediaQueries: {},
		    preview: '',
		    style: [],
		    title: '',
		    forceOWADesktop: (0, _get2.default)(mjml, 'attributes.owa', 'mobile') === 'desktop',
		    lang: (0, _get2.default)(mjml, 'attributes.lang') || 'und',
		    dir: (0, _get2.default)(mjml, 'attributes.dir') || 'auto'
		  };
		  const validatorOptions = {
		    components,
		    dependencies,
		    initializeType: _type.initializeType
		  };
		  switch (validationLevel) {
		    case 'skip':
		      break;
		    case 'strict':
		      errors = (0, _mjmlValidator.default)(mjml, validatorOptions);
		      if (errors.length > 0) {
		        throw new ValidationError(`ValidationError: \n ${errors.map(e => e.formattedMessage).join('\n')}`, errors);
		      }
		      break;
		    case 'soft':
		    default:
		      errors = (0, _mjmlValidator.default)(mjml, validatorOptions);
		      break;
		  }
		  const mjBody = (0, _find2.default)(mjml.children, {
		    tagName: 'mj-body'
		  });
		  const mjHead = (0, _find2.default)(mjml.children, {
		    tagName: 'mj-head'
		  });
		  const mjOutsideRaws = (0, _filter2.default)(mjml.children, {
		    tagName: 'mj-raw'
		  });
		  const processing = (node, context, parseMJML = _identity2.default) => {
		    if (!node) {
		      return;
		    }
		    const component = (0, _createComponent.initComponent)({
		      name: node.tagName,
		      initialDatas: {
		        ...parseMJML(node),
		        context
		      }
		    });
		    if (component !== null) {
		      if ('handler' in component) {
		        return component.handler(); // eslint-disable-line consistent-return
		      }
		      if ('render' in component) {
		        return component.render(); // eslint-disable-line consistent-return
		      }
		    }
		  };
		  const applyAttributes = mjml => {
		    const parse = (mjml, parentMjClass = '') => {
		      const {
		        attributes,
		        tagName,
		        children
		      } = mjml;
		      const classes = (0, _get2.default)(mjml.attributes, 'mj-class', '').split(' ');
		      const attributesClasses = (0, _reduce2.default)(classes, (acc, value) => {
		        const mjClassValues = globalData.classes[value];
		        let multipleClasses = {};
		        if (acc['css-class'] && (0, _get2.default)(mjClassValues, 'css-class')) {
		          multipleClasses = {
		            'css-class': `${acc['css-class']} ${mjClassValues['css-class']}`
		          };
		        }
		        return {
		          ...acc,
		          ...mjClassValues,
		          ...multipleClasses
		        };
		      }, {});
		      const defaultAttributesForClasses = (0, _reduce2.default)(parentMjClass.split(' '), (acc, value) => ({
		        ...acc,
		        ...(0, _get2.default)(globalData.classesDefault, `${value}.${tagName}`)
		      }), {});
		      const nextParentMjClass = (0, _get2.default)(attributes, 'mj-class', parentMjClass);
		      return {
		        ...mjml,
		        attributes: {
		          ...globalData.defaultAttributes[tagName],
		          ...attributesClasses,
		          ...defaultAttributesForClasses,
		          ...(0, _omit2.default)(attributes, ['mj-class'])
		        },
		        rawAttrs: {
		          ...(0, _omit2.default)(attributes, ['mj-class'])
		        },
		        globalAttributes: {
		          ...globalData.defaultAttributes['mj-all']
		        },
		        children: (0, _map2.default)(children, mjml => parse(mjml, nextParentMjClass))
		      };
		    };
		    return parse(mjml);
		  };
		  const bodyHelpers = {
		    components,
		    globalData,
		    addMediaQuery(className, {
		      parsedWidth,
		      unit
		    }) {
		      globalData.mediaQueries[className] = `{ width:${parsedWidth}${unit} !important; max-width: ${parsedWidth}${unit}; }`;
		    },
		    addHeadStyle(identifier, headStyle) {
		      globalData.headStyle[identifier] = headStyle;
		    },
		    addComponentHeadSyle(headStyle) {
		      globalData.componentsHeadStyle.push(headStyle);
		    },
		    setBackgroundColor: color => {
		      globalData.backgroundColor = color;
		    },
		    processing: (node, context) => processing(node, context, applyAttributes)
		  };
		  const headHelpers = {
		    components,
		    globalData,
		    add(attr, ...params) {
		      if (Array.isArray(globalData[attr])) {
		        globalData[attr].push(...params);
		      } else if (Object.prototype.hasOwnProperty.call(globalData, attr)) {
		        if (params.length > 1) {
		          if ((0, _isObject2.default)(globalData[attr][params[0]])) {
		            globalData[attr][params[0]] = {
		              ...globalData[attr][params[0]],
		              ...params[1]
		            };
		          } else {
		            // eslint-disable-next-line prefer-destructuring
		            globalData[attr][params[0]] = params[1];
		          }
		        } else {
		          // eslint-disable-next-line prefer-destructuring
		          globalData[attr] = params[0];
		        }
		      } else {
		        throw Error(`An mj-head element add an unkown head attribute : ${attr} with params ${Array.isArray(params) ? params.join('') : params}`);
		      }
		    }
		  };
		  globalData.headRaw = processing(mjHead, headHelpers);
		  content = processing(mjBody, bodyHelpers, applyAttributes);
		  if (!content) {
		    throw new Error('Malformed MJML. Check that your structure is correct and enclosed in <mjml> tags.');
		  }
		  content = (0, _minifyOutlookConditionnals.default)(content);
		  if (mjOutsideRaws.length) {
		    const toAddBeforeDoctype = mjOutsideRaws.filter(elt => elt.attributes.position && elt.attributes.position === 'file-start');
		    if (toAddBeforeDoctype.length) {
		      globalData.beforeDoctype = toAddBeforeDoctype.map(elt => elt.content).join('\n');
		    }
		  }
		  if (!(0, _isEmpty2.default)(globalData.htmlAttributes)) {
		    const $ = (0, _cheerio.load)(content, {
		      xmlMode: true,
		      // otherwise it may move contents that aren't in any tag
		      decodeEntities: false // won't escape special characters
		    });
		    (0, _each2.default)(globalData.htmlAttributes, (data, selector) => {
		      (0, _each2.default)(data, (value, attrName) => {
		        $(selector).each(function getAttr() {
		          $(this).attr(attrName, value || '');
		        });
		      });
		    });
		    content = $.root().html();
		  }
		  content = skeleton({
		    content,
		    ...globalData,
		    printerSupport
		  });
		  if (globalData.inlineStyle.length > 0) {
		    if (juicePreserveTags) {
		      (0, _each2.default)(juicePreserveTags, (val, key) => {
		        _juice.default.codeBlocks[key] = val;
		      });
		    }
		    content = (0, _juice.default)(content, {
		      applyStyleTags: false,
		      extraCss: globalData.inlineStyle.join(''),
		      insertPreservedExtraCss: false,
		      removeStyleTags: false,
		      ...juiceOptions
		    });
		  }
		  content = (0, _mergeOutlookConditionnals.default)(content);
		  if (beautify) {
		    // eslint-disable-next-line no-console
		    console.warn('"beautify" option is deprecated in mjml-core and only available in mjml cli.');
		    content = (0, _jsBeautify.html)(content, {
		      indent_size: 2,
		      wrap_attributes_indent_size: 2,
		      max_preserve_newline: 0,
		      preserve_newlines: false
		    });
		  }
		  if (minify) {
		    // eslint-disable-next-line no-console
		    console.warn('"minify" option is deprecated in mjml-core and only available in mjml cli.');
		    content = (0, _htmlMinifier.minify)(content, {
		      collapseWhitespace: true,
		      minifyCSS: false,
		      caseSensitive: true,
		      removeEmptyAttributes: true,
		      ...minifyOptions
		    });
		  }
		  return {
		    html: content,
		    json: mjml,
		    errors
		  };
		}
		if (isNode) {
		  (0, _mjmlconfig.default)(process.cwd(), _components.registerComponent);
		} 
	} (lib$y));
	return lib$y;
}

var lib$p = {exports: {}};

var lib$o = {};

var Social = {exports: {}};

var hasRequiredSocial;

function requireSocial () {
	if (hasRequiredSocial) return Social.exports;
	hasRequiredSocial = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _isNil2 = _interopRequireDefault(requireIsNil());
		var _mjmlCore = requireLib$r();
		let MjSocial = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjSocial() {
		    (0, _classCallCheck2.default)(this, MjSocial);
		    return (0, _callSuper2.default)(this, MjSocial, arguments);
		  }
		  (0, _inherits2.default)(MjSocial, _BodyComponent);
		  return (0, _createClass2.default)(MjSocial, [{
		    key: "getStyles",
		    value:
		    // eslint-disable-next-line class-methods-use-this
		    function getStyles() {
		      return {
		        tableVertical: {
		          margin: '0px'
		        }
		      };
		    }
		  }, {
		    key: "getSocialElementAttributes",
		    value: function getSocialElementAttributes() {
		      const base = {};
		      if (this.getAttribute('inner-padding')) {
		        base.padding = this.getAttribute('inner-padding');
		      }
		      return ['border-radius', 'color', 'font-family', 'font-size', 'font-weight', 'font-style', 'icon-size', 'icon-height', 'icon-padding', 'text-padding', 'line-height', 'text-decoration'].filter(e => !(0, _isNil2.default)(this.getAttribute(e))).reduce((res, attr) => {
		        res[attr] = this.getAttribute(attr);
		        return res;
		      }, base);
		    }
		  }, {
		    key: "renderHorizontal",
		    value: function renderHorizontal() {
		      const {
		        children
		      } = this.props;
		      return `
     <!--[if mso | IE]>
      <table
        ${this.htmlAttributes({
		        align: this.getAttribute('align'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation'
		      })}
      >
        <tr>
      <![endif]-->
      ${this.renderChildren(children, {
		        attributes: this.getSocialElementAttributes(),
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
            <!--[if mso | IE]>
              <td>
            <![endif]-->
              <table
                ${component.htmlAttributes({
		          align: this.getAttribute('align'),
		          border: '0',
		          cellpadding: '0',
		          cellspacing: '0',
		          role: 'presentation',
		          style: {
		            float: 'none',
		            display: 'inline-table'
		          }
		        })}
              >
                <tbody>
                  ${component.render()}
                </tbody>
              </table>
            <!--[if mso | IE]>
              </td>
            <![endif]-->
          `
		      })}
      <!--[if mso | IE]>
          </tr>
        </table>
      <![endif]-->
    `;
		    }
		  }, {
		    key: "renderVertical",
		    value: function renderVertical() {
		      const {
		        children
		      } = this.props;
		      return `
      <table
        ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'tableVertical'
		      })}
      >
        <tbody>
          ${this.renderChildren(children, {
		        attributes: this.getSocialElementAttributes()
		      })}
        </tbody>
      </table>
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      ${this.getAttribute('mode') === 'horizontal' ? this.renderHorizontal() : this.renderVertical()}
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjSocial, "componentName", 'mj-social');
		(0, _defineProperty2.default)(MjSocial, "allowedAttributes", {
		  align: 'enum(left,right,center)',
		  'border-radius': 'unit(px,%)',
		  'container-background-color': 'color',
		  color: 'color',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-style': 'string',
		  'font-weight': 'string',
		  'icon-size': 'unit(px,%)',
		  'icon-height': 'unit(px,%)',
		  'icon-padding': 'unit(px,%){1,4}',
		  'inner-padding': 'unit(px,%){1,4}',
		  'line-height': 'unit(px,%,)',
		  mode: 'enum(horizontal,vertical)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'table-layout': 'enum(auto,fixed)',
		  'text-padding': 'unit(px,%){1,4}',
		  'text-decoration': 'string',
		  'vertical-align': 'enum(top,bottom,middle)'
		});
		(0, _defineProperty2.default)(MjSocial, "defaultAttributes", {
		  align: 'center',
		  'border-radius': '3px',
		  color: '#333333',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'icon-size': '20px',
		  'inner-padding': null,
		  'line-height': '22px',
		  mode: 'horizontal',
		  padding: '10px 25px',
		  'text-decoration': 'none'
		});
		module.exports = exports$1.default; 
	} (Social, Social.exports));
	return Social.exports;
}

var SocialElement = {exports: {}};

var hasRequiredSocialElement;

function requireSocialElement () {
	if (hasRequiredSocialElement) return SocialElement.exports;
	hasRequiredSocialElement = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _each2 = _interopRequireDefault(requireEach());
		var _get2 = _interopRequireDefault(requireGet());
		var _mjmlCore = requireLib$r();
		const IMG_BASE_URL = 'https://www.mailjet.com/images/theme/v1/icons/ico-social/';
		const defaultSocialNetworks = {
		  facebook: {
		    'share-url': 'https://www.facebook.com/sharer/sharer.php?u=[[URL]]',
		    'background-color': '#3b5998',
		    src: `${IMG_BASE_URL}facebook.png`
		  },
		  twitter: {
		    'share-url': 'https://twitter.com/intent/tweet?url=[[URL]]',
		    'background-color': '#55acee',
		    src: `${IMG_BASE_URL}twitter.png`
		  },
		  x: {
		    'share-url': 'https://twitter.com/intent/tweet?url=[[URL]]',
		    'background-color': '#000000',
		    src: `${IMG_BASE_URL}twitter-x.png`
		  },
		  google: {
		    'share-url': 'https://plus.google.com/share?url=[[URL]]',
		    'background-color': '#dc4e41',
		    src: `${IMG_BASE_URL}google-plus.png`
		  },
		  pinterest: {
		    'share-url': 'https://pinterest.com/pin/create/button/?url=[[URL]]&media=&description=',
		    'background-color': '#bd081c',
		    src: `${IMG_BASE_URL}pinterest.png`
		  },
		  linkedin: {
		    'share-url': 'https://www.linkedin.com/shareArticle?mini=true&url=[[URL]]&title=&summary=&source=',
		    'background-color': '#0077b5',
		    src: `${IMG_BASE_URL}linkedin.png`
		  },
		  instagram: {
		    'background-color': '#3f729b',
		    src: `${IMG_BASE_URL}instagram.png`
		  },
		  web: {
		    src: `${IMG_BASE_URL}web.png`,
		    'background-color': '#4BADE9'
		  },
		  snapchat: {
		    src: `${IMG_BASE_URL}snapchat.png`,
		    'background-color': '#FFFA54'
		  },
		  youtube: {
		    src: `${IMG_BASE_URL}youtube.png`,
		    'background-color': '#EB3323'
		  },
		  tumblr: {
		    src: `${IMG_BASE_URL}tumblr.png`,
		    'share-url': 'https://www.tumblr.com/widgets/share/tool?canonicalUrl=[[URL]]',
		    'background-color': '#344356'
		  },
		  github: {
		    src: `${IMG_BASE_URL}github.png`,
		    'background-color': '#000000'
		  },
		  xing: {
		    src: `${IMG_BASE_URL}xing.png`,
		    'share-url': 'https://www.xing.com/app/user?op=share&url=[[URL]]',
		    'background-color': '#296366'
		  },
		  vimeo: {
		    src: `${IMG_BASE_URL}vimeo.png`,
		    'background-color': '#53B4E7'
		  },
		  medium: {
		    src: `${IMG_BASE_URL}medium.png`,
		    'background-color': '#000000'
		  },
		  soundcloud: {
		    src: `${IMG_BASE_URL}soundcloud.png`,
		    'background-color': '#EF7F31'
		  },
		  dribbble: {
		    src: `${IMG_BASE_URL}dribbble.png`,
		    'background-color': '#D95988'
		  }
		};
		(0, _each2.default)(defaultSocialNetworks, (val, key) => {
		  defaultSocialNetworks[`${key}-noshare`] = {
		    ...val,
		    'share-url': '[[URL]]'
		  };
		});
		let MjSocialElement = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjSocialElement() {
		    (0, _classCallCheck2.default)(this, MjSocialElement);
		    return (0, _callSuper2.default)(this, MjSocialElement, arguments);
		  }
		  (0, _inherits2.default)(MjSocialElement, _BodyComponent);
		  return (0, _createClass2.default)(MjSocialElement, [{
		    key: "getStyles",
		    value: function getStyles() {
		      const {
		        'icon-size': iconSize,
		        'icon-height': iconHeight,
		        'background-color': backgroundColor
		      } = this.getSocialAttributes();
		      return {
		        td: {
		          padding: this.getAttribute('padding'),
		          'padding-top': this.getAttribute('padding-top'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'padding-left': this.getAttribute('padding-left'),
		          'vertical-align': this.getAttribute('vertical-align')
		        },
		        table: {
		          background: backgroundColor,
		          'border-radius': this.getAttribute('border-radius'),
		          width: iconSize
		        },
		        icon: {
		          padding: this.getAttribute('icon-padding'),
		          'font-size': '0',
		          height: iconHeight || iconSize,
		          'vertical-align': 'middle',
		          width: iconSize
		        },
		        img: {
		          'border-radius': this.getAttribute('border-radius'),
		          display: 'block'
		        },
		        tdText: {
		          'vertical-align': 'middle',
		          padding: this.getAttribute('text-padding'),
		          'text-align': this.getAttribute('align')
		        },
		        text: {
		          color: this.getAttribute('color'),
		          'font-size': this.getAttribute('font-size'),
		          'font-weight': this.getAttribute('font-weight'),
		          'font-style': this.getAttribute('font-style'),
		          'font-family': this.getAttribute('font-family'),
		          'line-height': this.getAttribute('line-height'),
		          'text-decoration': this.getAttribute('text-decoration')
		        }
		      };
		    }
		  }, {
		    key: "getSocialAttributes",
		    value: function getSocialAttributes() {
		      const socialNetwork = defaultSocialNetworks[this.getAttribute('name')] || {};
		      let href = this.getAttribute('href');
		      if (href && (0, _get2.default)(socialNetwork, 'share-url')) {
		        href = socialNetwork['share-url'].replace('[[URL]]', href);
		      }
		      const attrs = ['icon-size', 'icon-height', 'srcset', 'sizes', 'src', 'background-color'].reduce((r, attr) => ({
		        ...r,
		        [attr]: this.getAttribute(attr) || socialNetwork[attr]
		      }), {});
		      return {
		        href,
		        ...attrs
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const {
		        src,
		        srcset,
		        sizes,
		        href,
		        'icon-size': iconSize
		      } = this.getSocialAttributes();
		      const hasLink = !!this.getAttribute('href');
		      const iconPosition = this.getAttribute('icon-position');
		      const makeIcon = () => `
        <td ${this.htmlAttributes({
		        style: 'td'
		      })}>
          <table
            ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table'
		      })}
          >
            <tbody>
              <tr>
                <td ${this.htmlAttributes({
		        style: 'icon'
		      })}>
                  ${hasLink ? `<a ${this.htmlAttributes({
		        href,
		        rel: this.getAttribute('rel'),
		        target: this.getAttribute('target')
		      })}>` : ''}
                    <img
                      ${this.htmlAttributes({
		        alt: this.getAttribute('alt'),
		        title: this.getAttribute('title'),
		        src,
		        style: 'img',
		        width: parseInt(iconSize, 10),
		        sizes,
		        srcset
		      })}
                    />
                  ${hasLink ? `</a>` : ''}
                </td>
              </tr>
            </tbody>
          </table>
        </td>
      `;
		      const makeContent = () => `
        ${this.getContent() ? `
          <td ${this.htmlAttributes({
		        style: 'tdText'
		      })}>
            ${hasLink ? `<a
                ${this.htmlAttributes({
		        href,
		        style: 'text',
		        rel: this.getAttribute('rel'),
		        target: this.getAttribute('target')
		      })}>` : `<span
                    ${this.htmlAttributes({
		        style: 'text'
		      })}>`}
              ${this.getContent()}
            ${hasLink ? `</a>` : '</span>'}
          </td>
          ` : ''}
      `;
		      const renderLeft = () => `${makeIcon()} ${makeContent()}`;
		      const renderRight = () => `${makeContent()} ${makeIcon()}`;
		      return `
      <tr
        ${this.htmlAttributes({
		        class: this.getAttribute('css-class')
		      })}
      >
        ${iconPosition === 'left' ? renderLeft() : renderRight()}
      </tr>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjSocialElement, "componentName", 'mj-social-element');
		(0, _defineProperty2.default)(MjSocialElement, "endingTag", true);
		(0, _defineProperty2.default)(MjSocialElement, "allowedAttributes", {
		  align: 'enum(left,center,right)',
		  'icon-position': 'enum(left,right)',
		  'background-color': 'color',
		  color: 'color',
		  'border-radius': 'unit(px)',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-style': 'string',
		  'font-weight': 'string',
		  href: 'string',
		  'icon-size': 'unit(px,%)',
		  'icon-height': 'unit(px,%)',
		  'icon-padding': 'unit(px,%){1,4}',
		  'line-height': 'unit(px,%,)',
		  name: 'string',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'text-padding': 'unit(px,%){1,4}',
		  rel: 'string',
		  src: 'string',
		  srcset: 'string',
		  sizes: 'string',
		  alt: 'string',
		  title: 'string',
		  target: 'string',
		  'text-decoration': 'string',
		  'vertical-align': 'enum(top,middle,bottom)'
		});
		(0, _defineProperty2.default)(MjSocialElement, "defaultAttributes", {
		  alt: '',
		  align: 'left',
		  'icon-position': 'left',
		  color: '#000',
		  'border-radius': '3px',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'line-height': '1',
		  padding: '4px',
		  'text-padding': '4px 4px 4px 0',
		  target: '_blank',
		  'text-decoration': 'none',
		  'vertical-align': 'middle'
		});
		module.exports = exports$1.default; 
	} (SocialElement, SocialElement.exports));
	return SocialElement.exports;
}

var hasRequiredLib$q;

function requireLib$q () {
	if (hasRequiredLib$q) return lib$o;
	hasRequiredLib$q = 1;
	(function (exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "Social", {
		  enumerable: true,
		  get: function () {
		    return _Social.default;
		  }
		});
		Object.defineProperty(exports$1, "SocialElement", {
		  enumerable: true,
		  get: function () {
		    return _SocialElement.default;
		  }
		});
		var _Social = _interopRequireDefault(requireSocial());
		var _SocialElement = _interopRequireDefault(requireSocialElement()); 
	} (lib$o));
	return lib$o;
}

var lib$n = {};

var Navbar = {exports: {}};

var conditionalTag = {};

var hasRequiredConditionalTag;

function requireConditionalTag () {
	if (hasRequiredConditionalTag) return conditionalTag;
	hasRequiredConditionalTag = 1;

	Object.defineProperty(conditionalTag, "__esModule", {
	  value: true
	});
	conditionalTag.default = conditionalTag$1;
	conditionalTag.endNegationConditionalTag = conditionalTag.endConditionalTag = void 0;
	conditionalTag.msoConditionalTag = msoConditionalTag;
	conditionalTag.startNegationConditionalTag = conditionalTag.startMsoNegationConditionalTag = conditionalTag.startMsoConditionalTag = conditionalTag.startConditionalTag = void 0;
	const startConditionalTag = conditionalTag.startConditionalTag = '<!--[if mso | IE]>';
	const startMsoConditionalTag = conditionalTag.startMsoConditionalTag = '<!--[if mso]>';
	const endConditionalTag = conditionalTag.endConditionalTag = '<![endif]-->';
	const startNegationConditionalTag = conditionalTag.startNegationConditionalTag = '<!--[if !mso | IE]><!-->';
	const startMsoNegationConditionalTag = conditionalTag.startMsoNegationConditionalTag = '<!--[if !mso]><!-->';
	const endNegationConditionalTag = conditionalTag.endNegationConditionalTag = '<!--<![endif]-->';
	function conditionalTag$1(content, negation = false) {
	  return `
    ${negation ? startNegationConditionalTag : startConditionalTag}
    ${content}
    ${negation ? endNegationConditionalTag : endConditionalTag}
  `;
	}
	function msoConditionalTag(content, negation = false) {
	  return `
    ${negation ? startMsoNegationConditionalTag : startMsoConditionalTag}
    ${content}
    ${negation ? endNegationConditionalTag : endConditionalTag}
  `;
	}
	return conditionalTag;
}

var genRandomHexString = {exports: {}};

var hasRequiredGenRandomHexString;

function requireGenRandomHexString () {
	if (hasRequiredGenRandomHexString) return genRandomHexString.exports;
	hasRequiredGenRandomHexString = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = genRandomHexString;
		function genRandomHexString(length) {
		  let str = '';
		  for (let i = 0; i < length; i += 1) {
		    str += Math.floor(Math.random() * 16).toString(16);
		  }
		  return str;
		}
		module.exports = exports$1.default; 
	} (genRandomHexString, genRandomHexString.exports));
	return genRandomHexString.exports;
}

var hasRequiredNavbar;

function requireNavbar () {
	if (hasRequiredNavbar) return Navbar.exports;
	hasRequiredNavbar = 1;
	(function (module, exports$1) {

		var _interopRequireWildcard = requireInteropRequireWildcard().default;
		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = _interopRequireWildcard(requireConditionalTag());
		var _genRandomHexString = _interopRequireDefault(requireGenRandomHexString());
		let MjNavbar = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjNavbar(...args) {
		    var _this;
		    (0, _classCallCheck2.default)(this, MjNavbar);
		    _this = (0, _callSuper2.default)(this, MjNavbar, [...args]);
		    (0, _defineProperty2.default)(_this, "headStyle", breakpoint => `
      noinput.mj-menu-checkbox { display:block!important; max-height:none!important; visibility:visible!important; }

      @media only screen and (max-width:${(0, _mjmlCore.makeLowerBreakpoint)(breakpoint)}) {
        .mj-menu-checkbox[type="checkbox"] ~ .mj-inline-links { display:none!important; }
        .mj-menu-checkbox[type="checkbox"]:checked ~ .mj-inline-links,
        .mj-menu-checkbox[type="checkbox"] ~ .mj-menu-trigger { display:block!important; max-width:none!important; max-height:none!important; font-size:inherit!important; }
        .mj-menu-checkbox[type="checkbox"] ~ .mj-inline-links > a { display:block!important; }
        .mj-menu-checkbox[type="checkbox"]:checked ~ .mj-menu-trigger .mj-menu-icon-close { display:block!important; }
        .mj-menu-checkbox[type="checkbox"]:checked ~ .mj-menu-trigger .mj-menu-icon-open { display:none!important; }
      }
    `);
		    return _this;
		  }
		  (0, _inherits2.default)(MjNavbar, _BodyComponent);
		  return (0, _createClass2.default)(MjNavbar, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        div: {
		          align: this.getAttribute('align'),
		          width: '100%'
		        },
		        label: {
		          display: 'block',
		          cursor: 'pointer',
		          'mso-hide': 'all',
		          '-moz-user-select': 'none',
		          'user-select': 'none',
		          color: this.getAttribute('ico-color'),
		          'font-size': this.getAttribute('ico-font-size'),
		          'font-family': this.getAttribute('ico-font-family'),
		          'text-transform': this.getAttribute('ico-text-transform'),
		          'text-decoration': this.getAttribute('ico-text-decoration'),
		          'line-height': this.getAttribute('ico-line-height'),
		          padding: this.getAttribute('ico-padding'),
		          'padding-top': this.getAttribute('ico-padding-top'),
		          'padding-right': this.getAttribute('ico-padding-right'),
		          'padding-bottom': this.getAttribute('ico-padding-bottom'),
		          'padding-left': this.getAttribute('ico-padding-left')
		        },
		        trigger: {
		          display: 'none',
		          'max-height': '0px',
		          'max-width': '0px',
		          'font-size': '0px',
		          overflow: 'hidden'
		        },
		        icoOpen: {
		          'mso-hide': 'all'
		        },
		        icoClose: {
		          display: 'none',
		          'mso-hide': 'all'
		        }
		      };
		    }
		  }, {
		    key: "renderHamburger",
		    value: function renderHamburger() {
		      const labelKey = (0, _genRandomHexString.default)(16);
		      return `
      ${(0, _conditionalTag.msoConditionalTag)(`
        <input type="checkbox" id="${labelKey}" class="mj-menu-checkbox" style="display:none !important; max-height:0; visibility:hidden;" />
      `, true)}
      <div
        ${this.htmlAttributes({
		        class: 'mj-menu-trigger',
		        style: 'trigger'
		      })}
      >
        <label
          ${this.htmlAttributes({
		        for: labelKey,
		        class: 'mj-menu-label',
		        style: 'label',
		        align: this.getAttribute('ico-align')
		      })}
        >
          <span
            ${this.htmlAttributes({
		        class: 'mj-menu-icon-open',
		        style: 'icoOpen'
		      })}
          >
            ${this.getAttribute('ico-open')}
          </span>
          <span
            ${this.htmlAttributes({
		        class: 'mj-menu-icon-close',
		        style: 'icoClose'
		      })}
          >
            ${this.getAttribute('ico-close')}
          </span>
        </label>
      </div>
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
        ${this.getAttribute('hamburger') === 'hamburger' ? this.renderHamburger() : ''}
        <div
          ${this.htmlAttributes({
		        class: 'mj-inline-links',
		        style: this.htmlAttributes('div')
		      })}
        >
        ${(0, _conditionalTag.default)(`
          <table role="presentation" border="0" cellpadding="0" cellspacing="0" align="${this.getAttribute('align')}">
            <tr>
        `)}
          ${this.renderChildren(this.props.children, {
		        attributes: {
		          navbarBaseUrl: this.getAttribute('base-url')
		        }
		      })}
          ${(0, _conditionalTag.default)(`
            </tr></table>
          `)}
        </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjNavbar, "componentName", 'mj-navbar');
		(0, _defineProperty2.default)(MjNavbar, "allowedAttributes", {
		  align: 'enum(left,center,right)',
		  'base-url': 'string',
		  hamburger: 'string',
		  'ico-align': 'enum(left,center,right)',
		  'ico-open': 'string',
		  'ico-close': 'string',
		  'ico-color': 'color',
		  'ico-font-size': 'unit(px,%)',
		  'ico-font-family': 'string',
		  'ico-text-transform': 'string',
		  'ico-padding': 'unit(px,%){1,4}',
		  'ico-padding-left': 'unit(px,%)',
		  'ico-padding-top': 'unit(px,%)',
		  'ico-padding-right': 'unit(px,%)',
		  'ico-padding-bottom': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'padding-left': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-bottom': 'unit(px,%)',
		  'ico-text-decoration': 'string',
		  'ico-line-height': 'unit(px,%,)'
		});
		(0, _defineProperty2.default)(MjNavbar, "defaultAttributes", {
		  align: 'center',
		  'base-url': null,
		  hamburger: null,
		  'ico-align': 'center',
		  'ico-open': '&#9776;',
		  'ico-close': '&#8855;',
		  'ico-color': '#000000',
		  'ico-font-size': '30px',
		  'ico-font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'ico-text-transform': 'uppercase',
		  'ico-padding': '10px',
		  'ico-text-decoration': 'none',
		  'ico-line-height': '30px'
		});
		module.exports = exports$1.default; 
	} (Navbar, Navbar.exports));
	return Navbar.exports;
}

var NavbarLink = {exports: {}};

var hasRequiredNavbarLink;

function requireNavbarLink () {
	if (hasRequiredNavbarLink) return NavbarLink.exports;
	hasRequiredNavbarLink = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = _interopRequireDefault(requireConditionalTag());
		let MjNavbarLink = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjNavbarLink() {
		    (0, _classCallCheck2.default)(this, MjNavbarLink);
		    return (0, _callSuper2.default)(this, MjNavbarLink, arguments);
		  }
		  (0, _inherits2.default)(MjNavbarLink, _BodyComponent);
		  return (0, _createClass2.default)(MjNavbarLink, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        a: {
		          display: 'inline-block',
		          color: this.getAttribute('color'),
		          'font-family': this.getAttribute('font-family'),
		          'font-size': this.getAttribute('font-size'),
		          'font-style': this.getAttribute('font-style'),
		          'font-weight': this.getAttribute('font-weight'),
		          'letter-spacing': this.getAttribute('letter-spacing'),
		          'line-height': this.getAttribute('line-height'),
		          'text-decoration': this.getAttribute('text-decoration'),
		          'text-transform': this.getAttribute('text-transform'),
		          padding: this.getAttribute('padding'),
		          'padding-top': this.getAttribute('padding-top'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-bottom': this.getAttribute('padding-bottom')
		        },
		        td: {
		          padding: this.getAttribute('padding'),
		          'padding-top': this.getAttribute('padding-top'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-bottom': this.getAttribute('padding-bottom')
		        }
		      };
		    }
		  }, {
		    key: "renderContent",
		    value: function renderContent() {
		      const href = this.getAttribute('href');
		      const navbarBaseUrl = this.getAttribute('navbarBaseUrl');
		      const link = navbarBaseUrl ? `${navbarBaseUrl}${href}` : href;
		      const cssClass = this.getAttribute('css-class') ? ` ${this.getAttribute('css-class')}` : '';
		      return `
      <a
        ${this.htmlAttributes({
		        class: `mj-link${cssClass}`,
		        href: link,
		        rel: this.getAttribute('rel'),
		        target: this.getAttribute('target'),
		        name: this.getAttribute('name'),
		        style: 'a'
		      })}
      >
        ${this.getContent()}
      </a>
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
        ${(0, _conditionalTag.default)(`
          <td
            ${this.htmlAttributes({
		        style: 'td',
		        class: (0, _mjmlCore.suffixCssClasses)(this.getAttribute('css-class'), 'outlook')
		      })}
          >
        `)}
        ${this.renderContent()}
        ${(0, _conditionalTag.default)(`
          </td>
        `)}
      `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjNavbarLink, "componentName", 'mj-navbar-link');
		(0, _defineProperty2.default)(MjNavbarLink, "endingTag", true);
		(0, _defineProperty2.default)(MjNavbarLink, "allowedAttributes", {
		  color: 'color',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-style': 'string',
		  'font-weight': 'string',
		  href: 'string',
		  name: 'string',
		  target: 'string',
		  rel: 'string',
		  'letter-spacing': 'unitWithNegative(px,em)',
		  'line-height': 'unit(px,%,)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'text-decoration': 'string',
		  'text-transform': 'string'
		});
		(0, _defineProperty2.default)(MjNavbarLink, "defaultAttributes", {
		  color: '#000000',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'font-weight': 'normal',
		  'line-height': '22px',
		  padding: '15px 10px',
		  target: '_blank',
		  'text-decoration': 'none',
		  'text-transform': 'uppercase'
		});
		module.exports = exports$1.default; 
	} (NavbarLink, NavbarLink.exports));
	return NavbarLink.exports;
}

var hasRequiredLib$p;

function requireLib$p () {
	if (hasRequiredLib$p) return lib$n;
	hasRequiredLib$p = 1;
	(function (exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "Navbar", {
		  enumerable: true,
		  get: function () {
		    return _Navbar.default;
		  }
		});
		Object.defineProperty(exports$1, "NavbarLink", {
		  enumerable: true,
		  get: function () {
		    return _NavbarLink.default;
		  }
		});
		var _Navbar = _interopRequireDefault(requireNavbar());
		var _NavbarLink = _interopRequireDefault(requireNavbarLink()); 
	} (lib$n));
	return lib$n;
}

var lib$m = {};

var Carousel = {exports: {}};

var _baseExtremum;
var hasRequired_baseExtremum;

function require_baseExtremum () {
	if (hasRequired_baseExtremum) return _baseExtremum;
	hasRequired_baseExtremum = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);

	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}

	_baseExtremum = baseExtremum;
	return _baseExtremum;
}

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */

var _baseLt;
var hasRequired_baseLt;

function require_baseLt () {
	if (hasRequired_baseLt) return _baseLt;
	hasRequired_baseLt = 1;
	function baseLt(value, other) {
	  return value < other;
	}

	_baseLt = baseLt;
	return _baseLt;
}

var min_1;
var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min_1;
	hasRequiredMin = 1;
	var baseExtremum = require_baseExtremum(),
	    baseLt = require_baseLt(),
	    identity = requireIdentity$1();

	/**
	 * Computes the minimum value of `array`. If `array` is empty or falsey,
	 * `undefined` is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {*} Returns the minimum value.
	 * @example
	 *
	 * _.min([4, 2, 8, 6]);
	 * // => 2
	 *
	 * _.min([]);
	 * // => undefined
	 */
	function min(array) {
	  return (array && array.length)
	    ? baseExtremum(array, identity, baseLt)
	    : undefined;
	}

	min_1 = min;
	return min_1;
}

/** Used as references for various `Number` constants. */

var _baseRepeat;
var hasRequired_baseRepeat;

function require_baseRepeat () {
	if (hasRequired_baseRepeat) return _baseRepeat;
	hasRequired_baseRepeat = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeFloor = Math.floor;

	/**
	 * The base implementation of `_.repeat` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {string} string The string to repeat.
	 * @param {number} n The number of times to repeat the string.
	 * @returns {string} Returns the repeated string.
	 */
	function baseRepeat(string, n) {
	  var result = '';
	  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	    return result;
	  }
	  // Leverage the exponentiation by squaring algorithm for a faster repeat.
	  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	  do {
	    if (n % 2) {
	      result += string;
	    }
	    n = nativeFloor(n / 2);
	    if (n) {
	      string += string;
	    }
	  } while (n);

	  return result;
	}

	_baseRepeat = baseRepeat;
	return _baseRepeat;
}

var repeat_1;
var hasRequiredRepeat;

function requireRepeat () {
	if (hasRequiredRepeat) return repeat_1;
	hasRequiredRepeat = 1;
	var baseRepeat = require_baseRepeat(),
	    isIterateeCall = require_isIterateeCall(),
	    toInteger = requireToInteger(),
	    toString = requireToString();

	/**
	 * Repeats the given string `n` times.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to repeat.
	 * @param {number} [n=1] The number of times to repeat the string.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the repeated string.
	 * @example
	 *
	 * _.repeat('*', 3);
	 * // => '***'
	 *
	 * _.repeat('abc', 2);
	 * // => 'abcabc'
	 *
	 * _.repeat('abc', 0);
	 * // => ''
	 */
	function repeat(string, n, guard) {
	  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	    n = 1;
	  } else {
	    n = toInteger(n);
	  }
	  return baseRepeat(toString(string), n);
	}

	repeat_1 = repeat;
	return repeat_1;
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var _baseRange;
var hasRequired_baseRange;

function require_baseRange () {
	if (hasRequired_baseRange) return _baseRange;
	hasRequired_baseRange = 1;
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	_baseRange = baseRange;
	return _baseRange;
}

var _createRange;
var hasRequired_createRange;

function require_createRange () {
	if (hasRequired_createRange) return _createRange;
	hasRequired_createRange = 1;
	var baseRange = require_baseRange(),
	    isIterateeCall = require_isIterateeCall(),
	    toFinite = requireToFinite();

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	_createRange = createRange;
	return _createRange;
}

var range_1;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range_1;
	hasRequiredRange = 1;
	var createRange = require_createRange();

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	range_1 = range;
	return range_1;
}

var hasRequiredCarousel;

function requireCarousel () {
	if (hasRequiredCarousel) return Carousel.exports;
	hasRequiredCarousel = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _map2 = _interopRequireDefault(requireMap$1());
		var _min2 = _interopRequireDefault(requireMin());
		var _repeat2 = _interopRequireDefault(requireRepeat());
		var _range2 = _interopRequireDefault(requireRange());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = requireConditionalTag();
		var _genRandomHexString = _interopRequireDefault(requireGenRandomHexString());
		let MjCarousel = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjCarousel(initialDatas = {}) {
		    var _this;
		    (0, _classCallCheck2.default)(this, MjCarousel);
		    _this = (0, _callSuper2.default)(this, MjCarousel, [initialDatas]);
		    (0, _defineProperty2.default)(_this, "componentHeadStyle", () => {
		      const {
		        length
		      } = _this.props.children;
		      const {
		        carouselId
		      } = _this;
		      if (!length) return '';
		      const carouselCss = `
    .mj-carousel {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    .mj-carousel-${carouselId}-icons-cell {
      display: table-cell !important;
      width: ${_this.getAttribute('icon-width')} !important;
    }

    .mj-carousel-radio,
    .mj-carousel-next,
    .mj-carousel-previous {
      display: none !important;
    }

    .mj-carousel-thumbnail,
    .mj-carousel-next,
    .mj-carousel-previous {
      touch-action: manipulation;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio:checked ${(0, _repeat2.default)('+ * ', i)}+ .mj-carousel-content .mj-carousel-image`).join(',')} {
      display: none !important;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio-${i + 1}:checked ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-content .mj-carousel-image-${i + 1}`).join(',')} {
      display: block !important;
    }

    .mj-carousel-previous-icons,
    .mj-carousel-next-icons,
    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio-${i + 1}:checked ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-content .mj-carousel-next-${(i + 1 % length + length) % length + 1}`)},
    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio-${i + 1}:checked ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-content .mj-carousel-previous-${(i - 1 % length + length) % length + 1}`)} {
      display: block !important;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio-${i + 1}:checked ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-content .mj-carousel-${carouselId}-thumbnail-${i + 1}`).join(',')} {
      border-color: ${_this.getAttribute('tb-selected-border-color')} !important;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-radio-${i + 1}:checked ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-content .mj-carousel-${carouselId}-thumbnail
          `).join(',')} {
      display: inline-block !important;
    }

    .mj-carousel-image img + div,
    .mj-carousel-thumbnail img + div {
      display: none !important;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-thumbnail:hover ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-main .mj-carousel-image`).join(',')} {
      display: none !important;
    }

    .mj-carousel-thumbnail:hover {
      border-color: ${_this.getAttribute('tb-hover-border-color')} !important;
    }

    ${(0, _range2.default)(0, length).map(i => `.mj-carousel-${carouselId}-thumbnail-${i + 1}:hover ${(0, _repeat2.default)('+ * ', length - i - 1)}+ .mj-carousel-main .mj-carousel-image-${i + 1}`).join(',')} {
      display: block !important;
    }
    `;
		      const fallback = `
      .mj-carousel noinput { display:block !important; }
      .mj-carousel noinput .mj-carousel-image-1 { display: block !important;  }
      .mj-carousel noinput .mj-carousel-arrows,
      .mj-carousel noinput .mj-carousel-thumbnails { display: none !important; }

      [owa] .mj-carousel-thumbnail { display: none !important; }
      
      @media screen yahoo {
          .mj-carousel-${_this.carouselId}-icons-cell,
          .mj-carousel-previous-icons,
          .mj-carousel-next-icons {
              display: none !important;
          }

          .mj-carousel-${carouselId}-radio-1:checked ${(0, _repeat2.default)('+ *', length - 1)}+ .mj-carousel-content .mj-carousel-${carouselId}-thumbnail-1 {
              border-color: transparent;
          }
      }
    `;
		      return `${carouselCss}\n${fallback}`;
		    });
		    _this.carouselId = (0, _genRandomHexString.default)(16);
		    return _this;
		  }
		  (0, _inherits2.default)(MjCarousel, _BodyComponent);
		  return (0, _createClass2.default)(MjCarousel, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        carousel: {
		          div: {
		            display: 'table',
		            width: '100%',
		            'table-layout': 'fixed',
		            'text-align': 'center',
		            'font-size': '0px'
		          },
		          table: {
		            'caption-side': 'top',
		            display: 'table-caption',
		            'table-layout': 'fixed',
		            width: '100%'
		          }
		        },
		        images: {
		          td: {
		            padding: '0px'
		          }
		        },
		        controls: {
		          div: {
		            display: 'none',
		            'mso-hide': 'all'
		          },
		          img: {
		            display: 'block',
		            width: this.getAttribute('icon-width'),
		            height: 'auto'
		          },
		          td: {
		            'font-size': '0px',
		            display: 'none',
		            'mso-hide': 'all',
		            padding: '0px'
		          }
		        }
		      };
		    }
		  }, {
		    key: "thumbnailsWidth",
		    value: function thumbnailsWidth() {
		      if (!this.props.children.length) return 0;
		      return this.getAttribute('tb-width') || `${(0, _min2.default)([this.context.parentWidth / this.props.children.length, 110])}px`;
		    }
		  }, {
		    key: "imagesAttributes",
		    value: function imagesAttributes() {
		      return (0, _map2.default)(this.children, 'attributes');
		    }
		  }, {
		    key: "generateRadios",
		    value: function generateRadios() {
		      return this.renderChildren(this.props.children, {
		        renderer: component => component.renderRadio(),
		        attributes: {
		          carouselId: this.carouselId
		        }
		      });
		    }
		  }, {
		    key: "generateThumbnails",
		    value: function generateThumbnails() {
		      if (!['visible', 'supported'].includes(this.getAttribute('thumbnails'))) return '';
		      return this.renderChildren(this.props.children, {
		        attributes: {
		          'tb-border': this.getAttribute('tb-border'),
		          'tb-border-radius': this.getAttribute('tb-border-radius'),
		          'tb-width': this.thumbnailsWidth(),
		          carouselId: this.carouselId
		        },
		        renderer: component => component.renderThumbnail()
		      });
		    }
		  }, {
		    key: "generateControls",
		    value: function generateControls(direction, icon) {
		      const iconWidth = parseInt(this.getAttribute('icon-width'), 10);
		      return `
      <td
        ${this.htmlAttributes({
		        class: `mj-carousel-${this.carouselId}-icons-cell`,
		        style: 'controls.td'
		      })}
      >
        <div
          ${this.htmlAttributes({
		        class: `mj-carousel-${direction}-icons`,
		        style: 'controls.div'
		      })}
        >
          ${(0, _range2.default)(1, this.props.children.length + 1).map(i => `
              <label
                ${this.htmlAttributes({
		        for: `mj-carousel-${this.carouselId}-radio-${i}`,
		        class: `mj-carousel-${direction} mj-carousel-${direction}-${i}`
		      })}
              >
                <img
                  ${this.htmlAttributes({
		        src: icon,
		        alt: direction,
		        style: 'controls.img',
		        width: iconWidth
		      })}
                />
              </label>
            `).join('')}
        </div>
      </td>
    `;
		    }
		  }, {
		    key: "generateImages",
		    value: function generateImages() {
		      return `
      <td
        ${this.htmlAttributes({
		        style: 'images.td'
		      })}
      >
        <div
          ${this.htmlAttributes({
		        class: 'mj-carousel-images'
		      })}
        >
          ${this.renderChildren(this.props.children, {
		        attributes: {
		          'border-radius': this.getAttribute('border-radius')
		        }
		      })}
        </div>
      </td>
    `;
		    }
		  }, {
		    key: "generateCarousel",
		    value: function generateCarousel() {
		      return `
      <table
        ${this.htmlAttributes({
		        style: 'carousel.table',
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        width: '100%',
		        role: 'presentation',
		        class: 'mj-carousel-main'
		      })}
      >
        <tbody>
          <tr>
            ${this.generateControls('previous', this.getAttribute('left-icon'))}
            ${this.generateImages()}
            ${this.generateControls('next', this.getAttribute('right-icon'))}
          </tr>
        </tbody>
      </table>
    `;
		    }
		  }, {
		    key: "renderFallback",
		    value: function renderFallback() {
		      const {
		        children
		      } = this.props;
		      if (children.length === 0) return '';
		      return (0, _conditionalTag.msoConditionalTag)(this.renderChildren([children[0]], {
		        attributes: {
		          'border-radius': this.getAttribute('border-radius')
		        }
		      }));
		    }
		  }, {
		    key: "getChildContext",
		    value: function getChildContext() {
		      return {
		        ...this.context,
		        thumbnails: this.getAttribute('thumbnails')
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      ${(0, _conditionalTag.msoConditionalTag)(`
        <div
          ${this.htmlAttributes({
		        class: 'mj-carousel'
		      })}
        >
          ${this.generateRadios()}
          <div
            ${this.htmlAttributes({
		        class: `mj-carousel-content mj-carousel-${this.carouselId}-content`,
		        style: 'carousel.div'
		      })}
          >
            ${this.generateThumbnails()}
            ${this.generateCarousel()}
          </div>
        </div>
      `, true)}
      ${this.renderFallback()}
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjCarousel, "componentName", 'mj-carousel');
		(0, _defineProperty2.default)(MjCarousel, "allowedAttributes", {
		  align: 'enum(left,center,right)',
		  'border-radius': 'unit(px,%){1,4}',
		  'container-background-color': 'color',
		  'icon-width': 'unit(px,%)',
		  'left-icon': 'string',
		  padding: 'unit(px,%){1,4}',
		  'padding-top': 'unit(px,%)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'right-icon': 'string',
		  thumbnails: 'enum(visible,hidden,supported)',
		  'tb-border': 'string',
		  'tb-border-radius': 'unit(px,%)',
		  'tb-hover-border-color': 'color',
		  'tb-selected-border-color': 'color',
		  'tb-width': 'unit(px,%)'
		});
		(0, _defineProperty2.default)(MjCarousel, "defaultAttributes", {
		  align: 'center',
		  'border-radius': '6px',
		  'icon-width': '44px',
		  'left-icon': 'https://i.imgur.com/xTh3hln.png',
		  'right-icon': 'https://i.imgur.com/os7o9kz.png',
		  thumbnails: 'visible',
		  'tb-border': '2px solid transparent',
		  'tb-border-radius': '6px',
		  'tb-hover-border-color': '#fead0d',
		  'tb-selected-border-color': '#ccc'
		});
		module.exports = exports$1.default; 
	} (Carousel, Carousel.exports));
	return Carousel.exports;
}

var CarouselImage = {exports: {}};

var hasRequiredCarouselImage;

function requireCarouselImage () {
	if (hasRequiredCarouselImage) return CarouselImage.exports;
	hasRequiredCarouselImage = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjCarouselImage = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjCarouselImage() {
		    (0, _classCallCheck2.default)(this, MjCarouselImage);
		    return (0, _callSuper2.default)(this, MjCarouselImage, arguments);
		  }
		  (0, _inherits2.default)(MjCarouselImage, _BodyComponent);
		  return (0, _createClass2.default)(MjCarouselImage, [{
		    key: "getStyles",
		    value: function getStyles() {
		      const hasThumbnailsSupported = this.hasThumbnailsSupported();
		      return {
		        images: {
		          img: {
		            'border-radius': this.getAttribute('border-radius'),
		            display: 'block',
		            width: this.context.containerWidth,
		            'max-width': '100%',
		            height: 'auto'
		          },
		          firstImageDiv: {},
		          otherImageDiv: {
		            display: 'none',
		            'mso-hide': 'all'
		          }
		        },
		        radio: {
		          input: {
		            display: 'none',
		            'mso-hide': 'all'
		          }
		        },
		        thumbnails: {
		          a: {
		            border: this.getAttribute('tb-border'),
		            'border-radius': this.getAttribute('tb-border-radius'),
		            display: hasThumbnailsSupported ? 'none' : 'inline-block',
		            overflow: 'hidden',
		            width: this.getAttribute('tb-width')
		          },
		          img: {
		            display: 'block',
		            width: '100%',
		            height: 'auto'
		          }
		        }
		      };
		    }
		  }, {
		    key: "hasThumbnailsSupported",
		    value: function hasThumbnailsSupported() {
		      const thumbnails = this.getAttribute('thumbnails') || this.context.thumbnails;
		      return thumbnails === 'supported';
		    }
		  }, {
		    key: "renderThumbnail",
		    value: function renderThumbnail() {
		      const {
		        carouselId,
		        src,
		        alt,
		        'tb-width': width,
		        target
		      } = this.attributes;
		      const imgIndex = this.props.index + 1;
		      const cssClass = (0, _mjmlCore.suffixCssClasses)(this.getAttribute('css-class'), 'thumbnail');
		      return `
      <a
        ${this.htmlAttributes({
		        style: 'thumbnails.a',
		        href: `#${imgIndex}`,
		        target,
		        class: `mj-carousel-thumbnail mj-carousel-${carouselId}-thumbnail mj-carousel-${carouselId}-thumbnail-${imgIndex} ${cssClass}`
		      })}
      >
        <label ${this.htmlAttributes({
		        for: `mj-carousel-${carouselId}-radio-${imgIndex}`
		      })}>
          <img
            ${this.htmlAttributes({
		        style: 'thumbnails.img',
		        src: this.getAttribute('thumbnails-src') || src,
		        alt,
		        width: parseInt(width, 10)
		      })}
          />
        </label>
      </a>
    `;
		    }
		  }, {
		    key: "renderRadio",
		    value: function renderRadio() {
		      const {
		        index
		      } = this.props;
		      const carouselId = this.getAttribute('carouselId');
		      return `
      <input
        ${this.htmlAttributes({
		        class: `mj-carousel-radio mj-carousel-${carouselId}-radio mj-carousel-${carouselId}-radio-${index + 1}`,
		        checked: index === 0 ? 'checked' : null,
		        type: 'radio',
		        name: `mj-carousel-radio-${carouselId}`,
		        id: `mj-carousel-${carouselId}-radio-${index + 1}`,
		        style: 'radio.input'
		      })}
      />
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const {
		        src,
		        alt,
		        href,
		        rel,
		        title
		      } = this.attributes;
		      const {
		        index
		      } = this.props;
		      const image = `
      <img
        ${this.htmlAttributes({
		        title,
		        src,
		        alt,
		        style: 'images.img',
		        width: parseInt(this.context.containerWidth, 10),
		        border: '0'
		      })} />
    `;
		      const cssClass = this.getAttribute('css-class') || '';
		      return `
      <div
        ${this.htmlAttributes({
		        class: `mj-carousel-image mj-carousel-image-${index + 1} ${cssClass}`,
		        style: index === 0 ? 'images.firstImageDiv' : 'images.otherImageDiv'
		      })}
      >
        ${href ? `<a ${this.htmlAttributes({
		        href,
		        rel,
		        target: '_blank'
		      })}>${image}</a>` : image}
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjCarouselImage, "componentName", 'mj-carousel-image');
		(0, _defineProperty2.default)(MjCarouselImage, "endingTag", true);
		(0, _defineProperty2.default)(MjCarouselImage, "allowedAttributes", {
		  alt: 'string',
		  href: 'string',
		  rel: 'string',
		  target: 'string',
		  title: 'string',
		  src: 'string',
		  'thumbnails-src': 'string',
		  'border-radius': 'unit(px,%){1,4}',
		  'tb-border': 'string',
		  'tb-border-radius': 'unit(px,%){1,4}'
		});
		(0, _defineProperty2.default)(MjCarouselImage, "defaultAttributes", {
		  alt: '',
		  target: '_blank'
		});
		module.exports = exports$1.default; 
	} (CarouselImage, CarouselImage.exports));
	return CarouselImage.exports;
}

var hasRequiredLib$o;

function requireLib$o () {
	if (hasRequiredLib$o) return lib$m;
	hasRequiredLib$o = 1;
	(function (exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "Carousel", {
		  enumerable: true,
		  get: function () {
		    return _Carousel.default;
		  }
		});
		Object.defineProperty(exports$1, "CarouselImage", {
		  enumerable: true,
		  get: function () {
		    return _CarouselImage.default;
		  }
		});
		var _Carousel = _interopRequireDefault(requireCarousel());
		var _CarouselImage = _interopRequireDefault(requireCarouselImage()); 
	} (lib$m));
	return lib$m;
}

var lib$l = {};

var Accordion = {exports: {}};

var hasRequiredAccordion;

function requireAccordion () {
	if (hasRequiredAccordion) return Accordion.exports;
	hasRequiredAccordion = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjAccordion = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjAccordion(...args) {
		    var _this;
		    (0, _classCallCheck2.default)(this, MjAccordion);
		    _this = (0, _callSuper2.default)(this, MjAccordion, [...args]);
		    (0, _defineProperty2.default)(_this, "headStyle", () => `
      noinput.mj-accordion-checkbox { display:block!important; }

      @media yahoo, only screen and (min-width:0) {
        .mj-accordion-element { display:block; }
        input.mj-accordion-checkbox, .mj-accordion-less { display:none!important; }
        input.mj-accordion-checkbox + * .mj-accordion-title { cursor:pointer; touch-action:manipulation; -webkit-user-select:none; -moz-user-select:none; user-select:none; }
        input.mj-accordion-checkbox + * .mj-accordion-content { overflow:hidden; display:none; }
        input.mj-accordion-checkbox + * .mj-accordion-more { display:block!important; }
        input.mj-accordion-checkbox:checked + * .mj-accordion-content { display:block; }
        input.mj-accordion-checkbox:checked + * .mj-accordion-more { display:none!important; }
        input.mj-accordion-checkbox:checked + * .mj-accordion-less { display:block!important; }
      }

      .moz-text-html input.mj-accordion-checkbox + * .mj-accordion-title { cursor: auto; touch-action: auto; -webkit-user-select: auto; -moz-user-select: auto; user-select: auto; }
      .moz-text-html input.mj-accordion-checkbox + * .mj-accordion-content { overflow: hidden; display: block; }
      .moz-text-html input.mj-accordion-checkbox + * .mj-accordion-ico { display: none; }

      @goodbye { @gmail }
    `);
		    return _this;
		  }
		  (0, _inherits2.default)(MjAccordion, _BodyComponent);
		  return (0, _createClass2.default)(MjAccordion, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        table: {
		          width: '100%',
		          'border-collapse': 'collapse',
		          border: this.getAttribute('border'),
		          'border-bottom': 'none',
		          'font-family': this.getAttribute('font-family')
		        }
		      };
		    }
		  }, {
		    key: "getChildContext",
		    value: function getChildContext() {
		      return {
		        ...this.context,
		        accordionFontFamily: this.getAttribute('font-family')
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const childrenAttr = ['border', 'icon-align', 'icon-width', 'icon-height', 'icon-position', 'icon-wrapped-url', 'icon-wrapped-alt', 'icon-unwrapped-url', 'icon-unwrapped-alt'].reduce((res, val) => ({
		        ...res,
		        [val]: this.getAttribute(val)
		      }), {});
		      return `
      <table
        ${this.htmlAttributes({
		        cellspacing: '0',
		        cellpadding: '0',
		        class: 'mj-accordion',
		        style: 'table'
		      })}
      >
        <tbody>
          ${this.renderChildren(this.props.children, {
		        attributes: childrenAttr
		      })}
        </tbody>
      </table>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjAccordion, "componentName", 'mj-accordion');
		(0, _defineProperty2.default)(MjAccordion, "allowedAttributes", {
		  'container-background-color': 'color',
		  border: 'string',
		  'font-family': 'string',
		  'icon-align': 'enum(top,middle,bottom)',
		  'icon-width': 'unit(px,%)',
		  'icon-height': 'unit(px,%)',
		  'icon-wrapped-url': 'string',
		  'icon-wrapped-alt': 'string',
		  'icon-unwrapped-url': 'string',
		  'icon-unwrapped-alt': 'string',
		  'icon-position': 'enum(left,right)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}'
		});
		(0, _defineProperty2.default)(MjAccordion, "defaultAttributes", {
		  border: '2px solid black',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'icon-align': 'middle',
		  'icon-wrapped-url': 'https://i.imgur.com/bIXv1bk.png',
		  'icon-wrapped-alt': '+',
		  'icon-unwrapped-url': 'https://i.imgur.com/w4uTygT.png',
		  'icon-unwrapped-alt': '-',
		  'icon-position': 'right',
		  'icon-height': '32px',
		  'icon-width': '32px',
		  padding: '10px 25px'
		});
		module.exports = exports$1.default; 
	} (Accordion, Accordion.exports));
	return Accordion.exports;
}

var AccordionElement = {exports: {}};

var AccordionText = {exports: {}};

var hasRequiredAccordionText;

function requireAccordionText () {
	if (hasRequiredAccordionText) return AccordionText.exports;
	hasRequiredAccordionText = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjAccordionText = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjAccordionText() {
		    (0, _classCallCheck2.default)(this, MjAccordionText);
		    return (0, _callSuper2.default)(this, MjAccordionText, arguments);
		  }
		  (0, _inherits2.default)(MjAccordionText, _BodyComponent);
		  return (0, _createClass2.default)(MjAccordionText, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        td: {
		          background: this.getAttribute('background-color'),
		          'font-size': this.getAttribute('font-size'),
		          'font-family': this.resolveFontFamily(),
		          'font-weight': this.getAttribute('font-weight'),
		          'letter-spacing': this.getAttribute('letter-spacing'),
		          'line-height': this.getAttribute('line-height'),
		          color: this.getAttribute('color'),
		          padding: this.getAttribute('padding'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-top': this.getAttribute('padding-top')
		        },
		        table: {
		          width: '100%',
		          'border-bottom': this.getAttribute('border')
		        }
		      };
		    }
		  }, {
		    key: "renderContent",
		    value: function renderContent() {
		      return `
      <td
        ${this.htmlAttributes({
		        class: this.getAttribute('css-class'),
		        style: 'td'
		      })}
      >
        ${this.getContent()}
      </td>
    `;
		    }
		  }, {
		    key: "resolveFontFamily",
		    value: function resolveFontFamily() {
		      if (this.props && this.props.rawAttrs && Object.prototype.hasOwnProperty.call(this.props.rawAttrs, 'font-family')) {
		        return this.getAttribute('font-family');
		      }
		      if (this.context && this.context.elementFontFamily) {
		        return this.context.elementFontFamily;
		      }
		      if (this.context && this.context.accordionFontFamily) {
		        return this.context.accordionFontFamily;
		      }
		      return MjAccordionText.defaultAttributes.fontFamily;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      <div
        ${this.htmlAttributes({
		        class: 'mj-accordion-content'
		      })}
      >
        <table
          ${this.htmlAttributes({
		        cellspacing: '0',
		        cellpadding: '0',
		        style: 'table'
		      })}
        >
          <tbody>
            <tr>
              ${this.renderContent()}
            </tr>
          </tbody>
        </table>
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjAccordionText, "componentName", 'mj-accordion-text');
		(0, _defineProperty2.default)(MjAccordionText, "endingTag", true);
		(0, _defineProperty2.default)(MjAccordionText, "allowedAttributes", {
		  'background-color': 'color',
		  'font-size': 'unit(px)',
		  'font-family': 'string',
		  'font-weight': 'string',
		  'letter-spacing': 'unitWithNegative(px,em)',
		  'line-height': 'unit(px,%,)',
		  color: 'color',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}'
		});
		(0, _defineProperty2.default)(MjAccordionText, "defaultAttributes", {
		  'font-size': '13px',
		  'line-height': '1',
		  padding: '16px'
		});
		module.exports = exports$1.default; 
	} (AccordionText, AccordionText.exports));
	return AccordionText.exports;
}

var AccordionTitle = {exports: {}};

var hasRequiredAccordionTitle;

function requireAccordionTitle () {
	if (hasRequiredAccordionTitle) return AccordionTitle.exports;
	hasRequiredAccordionTitle = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = _interopRequireDefault(requireConditionalTag());
		let MjAccordionTitle = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjAccordionTitle() {
		    (0, _classCallCheck2.default)(this, MjAccordionTitle);
		    return (0, _callSuper2.default)(this, MjAccordionTitle, arguments);
		  }
		  (0, _inherits2.default)(MjAccordionTitle, _BodyComponent);
		  return (0, _createClass2.default)(MjAccordionTitle, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        td: {
		          width: '100%',
		          'background-color': this.getAttribute('background-color'),
		          color: this.getAttribute('color'),
		          'font-size': this.getAttribute('font-size'),
		          'font-family': this.resolveFontFamily(),
		          'font-weight': this.getAttribute('font-weight'),
		          padding: this.getAttribute('padding'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-top': this.getAttribute('padding-top')
		        },
		        table: {
		          width: '100%',
		          'border-bottom': this.getAttribute('border')
		        },
		        td2: {
		          padding: '16px',
		          background: this.getAttribute('background-color'),
		          'vertical-align': this.getAttribute('icon-align')
		        },
		        img: {
		          display: 'none',
		          width: this.getAttribute('icon-width'),
		          height: this.getAttribute('icon-height')
		        }
		      };
		    }
		  }, {
		    key: "resolveFontFamily",
		    value: function resolveFontFamily() {
		      if (this.props && this.props.rawAttrs && Object.prototype.hasOwnProperty.call(this.props.rawAttrs, 'font-family')) {
		        return this.getAttribute('font-family');
		      }
		      if (this.context && this.context.elementFontFamily) {
		        return this.context.elementFontFamily;
		      }
		      if (this.context && this.context.accordionFontFamily) {
		        return this.context.accordionFontFamily;
		      }
		      return MjAccordionTitle.defaultAttributes.fontFamily;
		    }
		  }, {
		    key: "renderTitle",
		    value: function renderTitle() {
		      return `
      <td
        ${this.htmlAttributes({
		        class: this.getAttribute('css-class'),
		        style: 'td'
		      })}
      >
        ${this.getContent()}
      </td>
    `;
		    }
		  }, {
		    key: "renderIcons",
		    value: function renderIcons() {
		      return (0, _conditionalTag.default)(`
      <td
        ${this.htmlAttributes({
		        class: 'mj-accordion-ico',
		        style: 'td2'
		      })}
      >
        <img
          ${this.htmlAttributes({
		        src: this.getAttribute('icon-wrapped-url'),
		        alt: this.getAttribute('icon-wrapped-alt'),
		        class: 'mj-accordion-more',
		        style: 'img'
		      })}
        />
        <img
          ${this.htmlAttributes({
		        src: this.getAttribute('icon-unwrapped-url'),
		        alt: this.getAttribute('icon-unwrapped-alt'),
		        class: 'mj-accordion-less',
		        style: 'img'
		      })}
        />
      </td>
    `, true);
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const contentElements = [this.renderTitle(), this.renderIcons()];
		      const content = (this.getAttribute('icon-position') === 'right' ? contentElements : contentElements.reverse()).join('\n');
		      return `
      <div ${this.htmlAttributes({
		        class: 'mj-accordion-title'
		      })}>
        <table
          ${this.htmlAttributes({
		        cellspacing: '0',
		        cellpadding: '0',
		        style: 'table'
		      })}
        >
          <tbody>
            <tr>
              ${content}
            </tr>
          </tbody>
        </table>
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjAccordionTitle, "componentName", 'mj-accordion-title');
		(0, _defineProperty2.default)(MjAccordionTitle, "endingTag", true);
		(0, _defineProperty2.default)(MjAccordionTitle, "allowedAttributes", {
		  'background-color': 'color',
		  color: 'color',
		  'font-size': 'unit(px)',
		  'font-family': 'string',
		  'font-weight': 'string',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}'
		});
		(0, _defineProperty2.default)(MjAccordionTitle, "defaultAttributes", {
		  'font-size': '13px',
		  padding: '16px'
		});
		module.exports = exports$1.default; 
	} (AccordionTitle, AccordionTitle.exports));
	return AccordionTitle.exports;
}

var hasRequiredAccordionElement;

function requireAccordionElement () {
	if (hasRequiredAccordionElement) return AccordionElement.exports;
	hasRequiredAccordionElement = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _find2 = _interopRequireDefault(requireFind());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = _interopRequireDefault(requireConditionalTag());
		var _AccordionText = _interopRequireDefault(requireAccordionText());
		var _AccordionTitle = _interopRequireDefault(requireAccordionTitle());
		let MjAccordionElement = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjAccordionElement() {
		    (0, _classCallCheck2.default)(this, MjAccordionElement);
		    return (0, _callSuper2.default)(this, MjAccordionElement, arguments);
		  }
		  (0, _inherits2.default)(MjAccordionElement, _BodyComponent);
		  return (0, _createClass2.default)(MjAccordionElement, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        td: {
		          padding: '0px',
		          'background-color': this.getAttribute('background-color')
		        },
		        label: {
		          'font-size': '13px',
		          'font-family': this.getAttribute('font-family')
		        },
		        input: {
		          display: 'none'
		        }
		      };
		    }
		  }, {
		    key: "handleMissingChildren",
		    value: function handleMissingChildren() {
		      const {
		        children
		      } = this.props;
		      const childrenAttr = ['border', 'icon-align', 'icon-width', 'icon-height', 'icon-position', 'icon-wrapped-url', 'icon-wrapped-alt', 'icon-unwrapped-url', 'icon-unwrapped-alt'].reduce((res, val) => ({
		        ...res,
		        [val]: this.getAttribute(val)
		      }), {});
		      const result = [];
		      if (!(0, _find2.default)(children, {
		        tagName: 'mj-accordion-title'
		      })) {
		        result.push(new _AccordionTitle.default({
		          attributes: childrenAttr,
		          context: this.getChildContext()
		        }).render());
		      }
		      result.push(this.renderChildren(children, {
		        attributes: childrenAttr
		      }));
		      if (!(0, _find2.default)(children, {
		        tagName: 'mj-accordion-text'
		      })) {
		        result.push(new _AccordionText.default({
		          attributes: childrenAttr,
		          context: this.getChildContext()
		        }).render());
		      }
		      return result.join('\n');
		    }
		  }, {
		    key: "getChildContext",
		    value: function getChildContext() {
		      return {
		        ...this.context,
		        elementFontFamily: this.getAttribute('font-family')
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      <tr
        ${this.htmlAttributes({
		        class: this.getAttribute('css-class')
		      })}
      >
        <td ${this.htmlAttributes({
		        style: 'td'
		      })}>
          <label
            ${this.htmlAttributes({
		        class: 'mj-accordion-element',
		        style: 'label'
		      })}
          >
            ${(0, _conditionalTag.default)(`
              <input
                ${this.htmlAttributes({
		        class: 'mj-accordion-checkbox',
		        type: 'checkbox',
		        style: 'input'
		      })}
              />
            `, true)}
            <div>
              ${this.handleMissingChildren()}
            </div>
          </label>
        </td>
      </tr>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjAccordionElement, "componentName", 'mj-accordion-element');
		(0, _defineProperty2.default)(MjAccordionElement, "allowedAttributes", {
		  'background-color': 'color',
		  border: 'string',
		  'font-family': 'string',
		  'icon-align': 'enum(top,middle,bottom)',
		  'icon-width': 'unit(px,%)',
		  'icon-height': 'unit(px,%)',
		  'icon-wrapped-url': 'string',
		  'icon-wrapped-alt': 'string',
		  'icon-unwrapped-url': 'string',
		  'icon-unwrapped-alt': 'string',
		  'icon-position': 'enum(left,right)'
		});
		(0, _defineProperty2.default)(MjAccordionElement, "defaultAttributes", {
		  title: {
		    img: {
		      width: '32px',
		      height: '32px'
		    }
		  }
		});
		module.exports = exports$1.default; 
	} (AccordionElement, AccordionElement.exports));
	return AccordionElement.exports;
}

var hasRequiredLib$n;

function requireLib$n () {
	if (hasRequiredLib$n) return lib$l;
	hasRequiredLib$n = 1;
	(function (exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "Accordion", {
		  enumerable: true,
		  get: function () {
		    return _Accordion.default;
		  }
		});
		Object.defineProperty(exports$1, "AccordionElement", {
		  enumerable: true,
		  get: function () {
		    return _AccordionElement.default;
		  }
		});
		Object.defineProperty(exports$1, "AccordionText", {
		  enumerable: true,
		  get: function () {
		    return _AccordionText.default;
		  }
		});
		Object.defineProperty(exports$1, "AccordionTitle", {
		  enumerable: true,
		  get: function () {
		    return _AccordionTitle.default;
		  }
		});
		var _Accordion = _interopRequireDefault(requireAccordion());
		var _AccordionElement = _interopRequireDefault(requireAccordionElement());
		var _AccordionText = _interopRequireDefault(requireAccordionText());
		var _AccordionTitle = _interopRequireDefault(requireAccordionTitle()); 
	} (lib$l));
	return lib$l;
}

var lib$k = {exports: {}};

var hasRequiredLib$m;

function requireLib$m () {
	if (hasRequiredLib$m) return lib$k.exports;
	hasRequiredLib$m = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjBody = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjBody() {
		    (0, _classCallCheck2.default)(this, MjBody);
		    return (0, _callSuper2.default)(this, MjBody, arguments);
		  }
		  (0, _inherits2.default)(MjBody, _BodyComponent);
		  return (0, _createClass2.default)(MjBody, [{
		    key: "getChildContext",
		    value: function getChildContext() {
		      return {
		        ...this.context,
		        containerWidth: this.getAttribute('width')
		      };
		    }
		  }, {
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        div: {
		          'background-color': this.getAttribute('background-color')
		        }
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const {
		        setBackgroundColor,
		        globalData: {
		          lang,
		          dir,
		          title
		        }
		      } = this.context;
		      setBackgroundColor(this.getAttribute('background-color'));
		      return `
      <div
        ${this.htmlAttributes({
		        ...(title && {
		          'aria-label': title
		        }),
		        'aria-roledescription': 'email',
		        class: this.getAttribute('css-class'),
		        style: 'div',
		        role: 'article',
		        lang,
		        dir
		      })}
      >
        ${this.renderChildren()}
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjBody, "componentName", 'mj-body');
		(0, _defineProperty2.default)(MjBody, "allowedAttributes", {
		  width: 'unit(px)',
		  'background-color': 'color'
		});
		(0, _defineProperty2.default)(MjBody, "defaultAttributes", {
		  width: '600px'
		});
		module.exports = exports$1.default; 
	} (lib$k, lib$k.exports));
	return lib$k.exports;
}

var lib$j = {exports: {}};

var hasRequiredLib$l;

function requireLib$l () {
	if (hasRequiredLib$l) return lib$j.exports;
	hasRequiredLib$l = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjHead = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjHead() {
		    (0, _classCallCheck2.default)(this, MjHead);
		    return (0, _callSuper2.default)(this, MjHead, arguments);
		  }
		  (0, _inherits2.default)(MjHead, _HeadComponent);
		  return (0, _createClass2.default)(MjHead, [{
		    key: "handler",
		    value: function handler() {
		      return this.handlerChildren();
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjHead, "componentName", 'mj-head');
		module.exports = exports$1.default; 
	} (lib$j, lib$j.exports));
	return lib$j.exports;
}

var lib$i = {exports: {}};

var hasRequiredLib$k;

function requireLib$k () {
	if (hasRequiredLib$k) return lib$i.exports;
	hasRequiredLib$k = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _reduce2 = _interopRequireDefault(requireReduce());
		var _omit2 = _interopRequireDefault(requireOmit());
		var _forEach2 = _interopRequireDefault(requireForEach());
		var _mjmlCore = requireLib$r();
		let MjAttributes = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjAttributes() {
		    (0, _classCallCheck2.default)(this, MjAttributes);
		    return (0, _callSuper2.default)(this, MjAttributes, arguments);
		  }
		  (0, _inherits2.default)(MjAttributes, _HeadComponent);
		  return (0, _createClass2.default)(MjAttributes, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      const {
		        children
		      } = this.props;
		      (0, _forEach2.default)(children, child => {
		        const {
		          tagName,
		          attributes,
		          children
		        } = child;
		        if (tagName === 'mj-class') {
		          add('classes', attributes.name, (0, _omit2.default)(attributes, ['name']));
		          add('classesDefault', attributes.name, (0, _reduce2.default)(children, (acc, {
		            tagName,
		            attributes
		          }) => ({
		            ...acc,
		            [tagName]: attributes
		          }), {}));
		        } else {
		          add('defaultAttributes', tagName, attributes);
		        }
		      });
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjAttributes, "componentName", 'mj-attributes');
		module.exports = exports$1.default; 
	} (lib$i, lib$i.exports));
	return lib$i.exports;
}

var lib$h = {exports: {}};

var hasRequiredLib$j;

function requireLib$j () {
	if (hasRequiredLib$j) return lib$h.exports;
	hasRequiredLib$j = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjBreakpoint = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjBreakpoint() {
		    (0, _classCallCheck2.default)(this, MjBreakpoint);
		    return (0, _callSuper2.default)(this, MjBreakpoint, arguments);
		  }
		  (0, _inherits2.default)(MjBreakpoint, _HeadComponent);
		  return (0, _createClass2.default)(MjBreakpoint, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      add('breakpoint', this.getAttribute('width'));
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjBreakpoint, "componentName", 'mj-breakpoint');
		(0, _defineProperty2.default)(MjBreakpoint, "endingTag", true);
		(0, _defineProperty2.default)(MjBreakpoint, "allowedAttributes", {
		  width: 'unit(px)'
		});
		module.exports = exports$1.default; 
	} (lib$h, lib$h.exports));
	return lib$h.exports;
}

var lib$g = {exports: {}};

var hasRequiredLib$i;

function requireLib$i () {
	if (hasRequiredLib$i) return lib$g.exports;
	hasRequiredLib$i = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _get2 = _interopRequireDefault(requireGet());
		var _mjmlCore = requireLib$r();
		let MjHtmlAttributes = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjHtmlAttributes() {
		    (0, _classCallCheck2.default)(this, MjHtmlAttributes);
		    return (0, _callSuper2.default)(this, MjHtmlAttributes, arguments);
		  }
		  (0, _inherits2.default)(MjHtmlAttributes, _HeadComponent);
		  return (0, _createClass2.default)(MjHtmlAttributes, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      const {
		        children
		      } = this.props;
		      children.filter(c => c.tagName === 'mj-selector').forEach(selector => {
		        const {
		          attributes,
		          children
		        } = selector;
		        const {
		          path
		        } = attributes;
		        const custom = children.filter(c => c.tagName === 'mj-html-attribute' && !!(0, _get2.default)(c, 'attributes.name')).reduce((acc, c) => ({
		          ...acc,
		          [c.attributes.name]: c.content
		        }), {});
		        add('htmlAttributes', path, custom);
		      });
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjHtmlAttributes, "componentName", 'mj-html-attributes');
		module.exports = exports$1.default; 
	} (lib$g, lib$g.exports));
	return lib$g.exports;
}

var lib$f = {exports: {}};

var hasRequiredLib$h;

function requireLib$h () {
	if (hasRequiredLib$h) return lib$f.exports;
	hasRequiredLib$h = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjFont = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjFont() {
		    (0, _classCallCheck2.default)(this, MjFont);
		    return (0, _callSuper2.default)(this, MjFont, arguments);
		  }
		  (0, _inherits2.default)(MjFont, _HeadComponent);
		  return (0, _createClass2.default)(MjFont, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      add('fonts', this.getAttribute('name'), this.getAttribute('href'));
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjFont, "componentName", 'mj-font');
		(0, _defineProperty2.default)(MjFont, "allowedAttributes", {
		  name: 'string',
		  href: 'string'
		});
		module.exports = exports$1.default; 
	} (lib$f, lib$f.exports));
	return lib$f.exports;
}

var lib$e = {exports: {}};

var hasRequiredLib$g;

function requireLib$g () {
	if (hasRequiredLib$g) return lib$e.exports;
	hasRequiredLib$g = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjPreview = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjPreview() {
		    (0, _classCallCheck2.default)(this, MjPreview);
		    return (0, _callSuper2.default)(this, MjPreview, arguments);
		  }
		  (0, _inherits2.default)(MjPreview, _HeadComponent);
		  return (0, _createClass2.default)(MjPreview, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      add('preview', this.getContent());
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjPreview, "componentName", 'mj-preview');
		(0, _defineProperty2.default)(MjPreview, "endingTag", true);
		module.exports = exports$1.default; 
	} (lib$e, lib$e.exports));
	return lib$e.exports;
}

var lib$d = {exports: {}};

var hasRequiredLib$f;

function requireLib$f () {
	if (hasRequiredLib$f) return lib$d.exports;
	hasRequiredLib$f = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjStyle = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjStyle() {
		    (0, _classCallCheck2.default)(this, MjStyle);
		    return (0, _callSuper2.default)(this, MjStyle, arguments);
		  }
		  (0, _inherits2.default)(MjStyle, _HeadComponent);
		  return (0, _createClass2.default)(MjStyle, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      add(this.getAttribute('inline') === 'inline' ? 'inlineStyle' : 'style', this.getContent());
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjStyle, "componentName", 'mj-style');
		(0, _defineProperty2.default)(MjStyle, "endingTag", true);
		(0, _defineProperty2.default)(MjStyle, "allowedAttributes", {
		  inline: 'string'
		});
		module.exports = exports$1.default; 
	} (lib$d, lib$d.exports));
	return lib$d.exports;
}

var lib$c = {exports: {}};

var hasRequiredLib$e;

function requireLib$e () {
	if (hasRequiredLib$e) return lib$c.exports;
	hasRequiredLib$e = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjTitle = exports$1.default = /*#__PURE__*/function (_HeadComponent) {
		  function MjTitle() {
		    (0, _classCallCheck2.default)(this, MjTitle);
		    return (0, _callSuper2.default)(this, MjTitle, arguments);
		  }
		  (0, _inherits2.default)(MjTitle, _HeadComponent);
		  return (0, _createClass2.default)(MjTitle, [{
		    key: "handler",
		    value: function handler() {
		      const {
		        add
		      } = this.context;
		      add('title', this.getContent());
		    }
		  }]);
		}(_mjmlCore.HeadComponent);
		(0, _defineProperty2.default)(MjTitle, "componentName", 'mj-title');
		(0, _defineProperty2.default)(MjTitle, "endingTag", true);
		module.exports = exports$1.default; 
	} (lib$c, lib$c.exports));
	return lib$c.exports;
}

var lib$b = {exports: {}};

/** Used for built-in method references. */

var join_1;
var hasRequiredJoin$1;

function requireJoin$1 () {
	if (hasRequiredJoin$1) return join_1;
	hasRequiredJoin$1 = 1;
	var arrayProto = Array.prototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeJoin = arrayProto.join;

	/**
	 * Converts all elements in `array` into a string separated by `separator`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to convert.
	 * @param {string} [separator=','] The element separator.
	 * @returns {string} Returns the joined string.
	 * @example
	 *
	 * _.join(['a', 'b', 'c'], '~');
	 * // => 'a~b~c'
	 */
	function join(array, separator) {
	  return array == null ? '' : nativeJoin.call(array, separator);
	}

	join_1 = join;
	return join_1;
}

var join;
var hasRequiredJoin;

function requireJoin () {
	if (hasRequiredJoin) return join;
	hasRequiredJoin = 1;
	var convert = requireConvert(),
	    func = convert('join', requireJoin$1());

	func.placeholder = requirePlaceholder();
	join = func;
	return join;
}

var _falseOptions;
var hasRequired_falseOptions;

function require_falseOptions () {
	if (hasRequired_falseOptions) return _falseOptions;
	hasRequired_falseOptions = 1;
	_falseOptions = {
	  'cap': false,
	  'curry': false,
	  'fixed': false,
	  'immutable': false,
	  'rearg': false
	};
	return _falseOptions;
}

var identity;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity;
	hasRequiredIdentity = 1;
	var convert = requireConvert(),
	    func = convert('identity', requireIdentity$1(), require_falseOptions());

	func.placeholder = requirePlaceholder();
	identity = func;
	return identity;
}

var widthParser = {exports: {}};

var hasRequiredWidthParser;

function requireWidthParser () {
	if (hasRequiredWidthParser) return widthParser.exports;
	hasRequiredWidthParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = widthParser;
		const unitRegex = /[\d.,]*(\D*)$/;
		function widthParser(width, options = {}) {
		  const {
		    parseFloatToInt = true
		  } = options;
		  const widthUnit = unitRegex.exec(width.toString())[1];
		  const unitParsers = {
		    default: parseInt,
		    px: parseInt,
		    '%': parseFloatToInt ? parseInt : parseFloat
		  };
		  const parser = unitParsers[widthUnit] || unitParsers.default;
		  return {
		    parsedWidth: parser(width),
		    unit: widthUnit || 'px'
		  };
		}
		module.exports = exports$1.default; 
	} (widthParser, widthParser.exports));
	return widthParser.exports;
}

var hasRequiredLib$d;

function requireLib$d () {
	if (hasRequiredLib$d) return lib$b.exports;
	hasRequiredLib$d = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _filter2 = _interopRequireDefault(requireFilter());
		var _join2 = _interopRequireDefault(requireJoin());
		var _identity2 = _interopRequireDefault(requireIdentity());
		var _flow2 = _interopRequireDefault(requireFlow());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		const makeBackgroundString = (0, _flow2.default)((0, _filter2.default)(_identity2.default), (0, _join2.default)(' '));
		let MjHero = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjHero(...args) {
		    var _this;
		    (0, _classCallCheck2.default)(this, MjHero);
		    _this = (0, _callSuper2.default)(this, MjHero, [...args]);
		    (0, _defineProperty2.default)(_this, "getBackground", () => makeBackgroundString([_this.getAttribute('background-color'), ...(_this.getAttribute('background-url') ? [`url('${_this.getAttribute('background-url')}')`, 'no-repeat', `${_this.getAttribute('background-position')} / cover`] : [])]));
		    return _this;
		  }
		  (0, _inherits2.default)(MjHero, _BodyComponent);
		  return (0, _createClass2.default)(MjHero, [{
		    key: "getChildContext",
		    value: function getChildContext() {
		      // Refactor -- removePaddingFor(width, ['padding', 'inner-padding'])
		      const {
		        containerWidth
		      } = this.context;
		      const paddingSize = this.getShorthandAttrValue('padding', 'left') + this.getShorthandAttrValue('padding', 'right');
		      let currentContainerWidth = `${parseFloat(containerWidth)}px`;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(currentContainerWidth, {
		        parseFloatToInt: false
		      });
		      if (unit === '%') {
		        currentContainerWidth = `${parseFloat(containerWidth) * parsedWidth / 100 - paddingSize}px`;
		      } else {
		        currentContainerWidth = `${parsedWidth - paddingSize}px`;
		      }
		      return {
		        ...this.context,
		        containerWidth: currentContainerWidth
		      };
		    }
		  }, {
		    key: "getStyles",
		    value: function getStyles() {
		      const {
		        containerWidth
		      } = this.context;
		      const backgroundRatio = Math.round(parseInt(this.getAttribute('background-height'), 10) / parseInt(this.getAttribute('background-width'), 10) * 100);
		      const width = this.getAttribute('background-width') || containerWidth;
		      return {
		        div: {
		          margin: '0 auto',
		          'max-width': containerWidth
		        },
		        table: {
		          width: '100%'
		        },
		        tr: {
		          'vertical-align': 'top'
		        },
		        'td-fluid': {
		          width: `0.01%`,
		          'padding-bottom': `${backgroundRatio}%`,
		          'mso-padding-bottom-alt': '0'
		        },
		        'outlook-table': {
		          width: containerWidth
		        },
		        'outlook-td': {
		          'line-height': 0,
		          'font-size': 0,
		          'mso-line-height-rule': 'exactly'
		        },
		        'outlook-inner-table': {
		          width: containerWidth
		        },
		        'outlook-image': {
		          border: '0',
		          height: this.getAttribute('background-height'),
		          'mso-position-horizontal': 'center',
		          position: 'absolute',
		          top: 0,
		          width,
		          'z-index': '-3'
		        },
		        'outlook-inner-td': {
		          'background-color': this.getAttribute('inner-background-color'),
		          padding: this.getAttribute('inner-padding'),
		          'padding-top': this.getAttribute('inner-padding-top'),
		          'padding-left': this.getAttribute('inner-padding-left'),
		          'padding-right': this.getAttribute('inner-padding-right'),
		          'padding-bottom': this.getAttribute('inner-padding-bottom')
		        },
		        'inner-table': {
		          width: '100%',
		          margin: '0px'
		        },
		        'inner-div': {
		          'background-color': this.getAttribute('inner-background-color'),
		          float: this.getAttribute('align'),
		          margin: '0px auto',
		          width: this.getAttribute('width')
		        }
		      };
		    }
		  }, {
		    key: "renderContent",
		    value: function renderContent() {
		      const {
		        containerWidth
		      } = this.context;
		      const {
		        children
		      } = this.props;
		      return `
      <!--[if mso | IE]>
        <table
          ${this.htmlAttributes({
		        align: this.getAttribute('align'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        style: 'outlook-inner-table',
		        width: containerWidth.replace('px', '')
		      })}
        >
          <tr>
            <td ${this.htmlAttributes({
		        style: 'outlook-inner-td'
		      })}>
      <![endif]-->
      <div
        ${this.htmlAttributes({
		        align: this.getAttribute('align'),
		        class: 'mj-hero-content',
		        style: 'inner-div'
		      })}
      >
        <table
          ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'inner-table'
		      })}
        >
          <tbody>
            <tr>
              <td ${this.htmlAttributes({
		        style: 'inner-td'
		      })} >
                <table
                  ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'inner-table'
		      })}
                >
                  <tbody>
                    ${this.renderChildren(children, {
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
                        <tr>
                          <td
                            ${component.htmlAttributes({
		          align: component.getAttribute('align'),
		          background: component.getAttribute('container-background-color'),
		          class: component.getAttribute('css-class'),
		          style: {
		            background: component.getAttribute('container-background-color'),
		            'font-size': '0px',
		            padding: component.getAttribute('padding'),
		            'padding-top': component.getAttribute('padding-top'),
		            'padding-right': component.getAttribute('padding-right'),
		            'padding-bottom': component.getAttribute('padding-bottom'),
		            'padding-left': component.getAttribute('padding-left'),
		            'word-break': 'break-word'
		          }
		        })}
                          >
                            ${component.render()}
                          </td>
                        </tr>
                      `
		      })}
                  </tbody>
                </table>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!--[if mso | IE]>
            </td>
          </tr>
        </table>
      <![endif]-->
    `;
		    }
		  }, {
		    key: "renderMode",
		    value: function renderMode() {
		      const commonAttributes = {
		        background: this.getAttribute('background-url'),
		        style: {
		          background: this.getBackground(),
		          'background-position': this.getAttribute('background-position'),
		          'background-repeat': 'no-repeat',
		          'border-radius': this.getAttribute('border-radius'),
		          padding: this.getAttribute('padding'),
		          'padding-top': this.getAttribute('padding-top'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'vertical-align': this.getAttribute('vertical-align')
		        }
		      };

		      /* eslint-disable no-alert, no-case-declarations */
		      switch (this.getAttribute('mode')) {
		        case 'fluid-height':
		          const magicTd = this.htmlAttributes({
		            style: `td-fluid`
		          });
		          return `
          <td ${magicTd} />
          <td ${this.htmlAttributes({
		            ...commonAttributes
		          })}>
            ${this.renderContent()}
          </td>
          <td ${magicTd} />
        `;
		        case 'fixed-height':
		        default:
		          const height = parseInt(this.getAttribute('height'), 10) - this.getShorthandAttrValue('padding', 'top') - this.getShorthandAttrValue('padding', 'bottom');
		          return `
          <td
            ${this.htmlAttributes({
		            ...commonAttributes,
		            height,
		            style: {
		              ...commonAttributes.style,
		              height: `${height}px`
		            }
		          })}
          >
            ${this.renderContent()}
          </td>
        `;
		      }
		      /* eslint-enable no-alert, no-case-declarations */
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const {
		        containerWidth
		      } = this.context;
		      return `
      <!--[if mso | IE]>
        <table
          ${this.htmlAttributes({
		        align: 'center',
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'outlook-table',
		        width: parseInt(containerWidth, 10)
		      })}
        >
          <tr>
            <td ${this.htmlAttributes({
		        style: 'outlook-td'
		      })}>
              <v:image
                ${this.htmlAttributes({
		        style: 'outlook-image',
		        src: this.getAttribute('background-url'),
		        'xmlns:v': 'urn:schemas-microsoft-com:vml'
		      })}
              />
      <![endif]-->
      <div
        ${this.htmlAttributes({
		        align: this.getAttribute('align'),
		        class: this.getAttribute('css-class'),
		        style: 'div'
		      })}
      >
        <table
          ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table'
		      })}
        >
          <tbody>
            <tr
              ${this.htmlAttributes({
		        style: 'tr'
		      })}
            >
              ${this.renderMode()}
            </tr>
          </tbody>
      </table>
    </div>
    <!--[if mso | IE]>
          </td>
        </tr>
      </table>
    <![endif]-->
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjHero, "componentName", 'mj-hero');
		(0, _defineProperty2.default)(MjHero, "allowedAttributes", {
		  mode: 'string',
		  height: 'unit(px,%)',
		  'background-url': 'string',
		  'background-width': 'unit(px,%)',
		  'background-height': 'unit(px,%)',
		  'background-position': 'string',
		  'border-radius': 'string',
		  'container-background-color': 'color',
		  'inner-background-color': 'color',
		  'inner-padding': 'unit(px,%){1,4}',
		  'inner-padding-top': 'unit(px,%)',
		  'inner-padding-left': 'unit(px,%)',
		  'inner-padding-right': 'unit(px,%)',
		  'inner-padding-bottom': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  'background-color': 'color',
		  'vertical-align': 'enum(top,bottom,middle)'
		});
		(0, _defineProperty2.default)(MjHero, "defaultAttributes", {
		  mode: 'fixed-height',
		  height: '0px',
		  'background-url': null,
		  'background-position': 'center center',
		  padding: '0px',
		  'padding-bottom': null,
		  'padding-left': null,
		  'padding-right': null,
		  'padding-top': null,
		  'background-color': '#ffffff',
		  'vertical-align': 'top'
		});
		module.exports = exports$1.default; 
	} (lib$b, lib$b.exports));
	return lib$b.exports;
}

var lib$a = {exports: {}};

var hasRequiredLib$c;

function requireLib$c () {
	if (hasRequiredLib$c) return lib$a.exports;
	hasRequiredLib$c = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		let MjButton = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjButton() {
		    (0, _classCallCheck2.default)(this, MjButton);
		    return (0, _callSuper2.default)(this, MjButton, arguments);
		  }
		  (0, _inherits2.default)(MjButton, _BodyComponent);
		  return (0, _createClass2.default)(MjButton, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        table: {
		          'border-collapse': 'separate',
		          width: this.getAttribute('width'),
		          'line-height': '100%'
		        },
		        td: {
		          border: this.getAttribute('border'),
		          'border-bottom': this.getAttribute('border-bottom'),
		          'border-left': this.getAttribute('border-left'),
		          'border-radius': this.getAttribute('border-radius'),
		          'border-right': this.getAttribute('border-right'),
		          'border-top': this.getAttribute('border-top'),
		          cursor: 'auto',
		          'font-style': this.getAttribute('font-style'),
		          height: this.getAttribute('height'),
		          'mso-padding-alt': this.getAttribute('inner-padding'),
		          'text-align': this.getAttribute('text-align'),
		          background: this.getAttribute('background-color')
		        },
		        content: {
		          display: 'inline-block',
		          width: this.calculateAWidth(this.getAttribute('width')),
		          background: this.getAttribute('background-color'),
		          color: this.getAttribute('color'),
		          'font-family': this.getAttribute('font-family'),
		          'font-size': this.getAttribute('font-size'),
		          'font-style': this.getAttribute('font-style'),
		          'font-weight': this.getAttribute('font-weight'),
		          'line-height': this.getAttribute('line-height'),
		          'letter-spacing': this.getAttribute('letter-spacing'),
		          margin: '0',
		          'text-decoration': this.getAttribute('text-decoration'),
		          'text-transform': this.getAttribute('text-transform'),
		          padding: this.getAttribute('inner-padding'),
		          'mso-padding-alt': '0px',
		          'border-radius': this.getAttribute('border-radius')
		        }
		      };
		    }
		  }, {
		    key: "calculateAWidth",
		    value: function calculateAWidth(width) {
		      if (!width) return null;
		      const {
		        parsedWidth,
		        unit
		      } = (0, _widthParser.default)(width);

		      // impossible to handle percents because it depends on padding and text width
		      if (unit !== 'px') return null;
		      const {
		        borders
		      } = this.getBoxWidths();
		      const innerPaddings = this.getShorthandAttrValue('inner-padding', 'left') + this.getShorthandAttrValue('inner-padding', 'right');
		      return `${parsedWidth - innerPaddings - borders}px`;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const tag = this.getAttribute('href') ? 'a' : 'p';
		      return `
      <table
        ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table'
		      })}
      >
        <tbody>
          <tr>
            <td
              ${this.htmlAttributes({
		        align: 'center',
		        bgcolor: this.getAttribute('background-color') === 'none' ? undefined : this.getAttribute('background-color'),
		        role: 'presentation',
		        style: 'td',
		        valign: this.getAttribute('vertical-align')
		      })}
            >
              <${tag}
                ${this.htmlAttributes({
		        href: this.getAttribute('href'),
		        name: this.getAttribute('name'),
		        rel: this.getAttribute('rel'),
		        title: this.getAttribute('title'),
		        style: 'content',
		        target: tag === 'a' ? this.getAttribute('target') : undefined
		      })}
              >
                ${this.getContent()}
              </${tag}>
            </td>
          </tr>
        </tbody>
      </table>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjButton, "componentName", 'mj-button');
		(0, _defineProperty2.default)(MjButton, "endingTag", true);
		(0, _defineProperty2.default)(MjButton, "allowedAttributes", {
		  align: 'enum(left,center,right)',
		  'background-color': 'color',
		  'border-bottom': 'string',
		  'border-left': 'string',
		  'border-radius': 'string',
		  'border-right': 'string',
		  'border-top': 'string',
		  border: 'string',
		  color: 'color',
		  'container-background-color': 'color',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-style': 'string',
		  'font-weight': 'string',
		  height: 'unit(px,%)',
		  href: 'string',
		  name: 'string',
		  title: 'string',
		  'inner-padding': 'unit(px,%){1,4}',
		  'letter-spacing': 'unitWithNegative(px,em)',
		  'line-height': 'unit(px,%,)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  rel: 'string',
		  target: 'string',
		  'text-decoration': 'string',
		  'text-transform': 'string',
		  'vertical-align': 'enum(top,bottom,middle)',
		  'text-align': 'enum(left,right,center)',
		  width: 'unit(px,%)'
		});
		(0, _defineProperty2.default)(MjButton, "defaultAttributes", {
		  align: 'center',
		  'background-color': '#414141',
		  border: 'none',
		  'border-radius': '3px',
		  color: '#ffffff',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'font-weight': 'normal',
		  'inner-padding': '10px 25px',
		  'line-height': '120%',
		  padding: '10px 25px',
		  target: '_blank',
		  'text-decoration': 'none',
		  'text-transform': 'none',
		  'vertical-align': 'middle'
		});
		module.exports = exports$1.default; 
	} (lib$a, lib$a.exports));
	return lib$a.exports;
}

var lib$9 = {exports: {}};

var hasRequiredLib$b;

function requireLib$b () {
	if (hasRequiredLib$b) return lib$9.exports;
	hasRequiredLib$b = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		let MjColumn = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjColumn() {
		    (0, _classCallCheck2.default)(this, MjColumn);
		    return (0, _callSuper2.default)(this, MjColumn, arguments);
		  }
		  (0, _inherits2.default)(MjColumn, _BodyComponent);
		  return (0, _createClass2.default)(MjColumn, [{
		    key: "getChildContext",
		    value: function getChildContext() {
		      const {
		        containerWidth: parentWidth
		      } = this.context;
		      const {
		        nonRawSiblings
		      } = this.props;
		      const {
		        borders,
		        paddings
		      } = this.getBoxWidths();
		      const innerBorders = this.getShorthandBorderValue('left', 'inner-border') + this.getShorthandBorderValue('right', 'inner-border');
		      const allPaddings = paddings + borders + innerBorders;
		      let containerWidth = this.getAttribute('width') || `${parseFloat(parentWidth) / nonRawSiblings}px`;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(containerWidth, {
		        parseFloatToInt: false
		      });
		      if (unit === '%') {
		        containerWidth = `${parseFloat(parentWidth) * parsedWidth / 100 - allPaddings}px`;
		      } else {
		        containerWidth = `${parsedWidth - allPaddings}px`;
		      }
		      return {
		        ...this.context,
		        containerWidth
		      };
		    }
		  }, {
		    key: "getStyles",
		    value: function getStyles() {
		      const hasBorderRadius = this.hasBorderRadius();
		      const hasInnerBorderRadius = this.hasInnerBorderRadius();
		      const tableStyle = {
		        'background-color': this.getAttribute('background-color'),
		        border: this.getAttribute('border'),
		        'border-bottom': this.getAttribute('border-bottom'),
		        'border-left': this.getAttribute('border-left'),
		        'border-radius': this.getAttribute('border-radius'),
		        'border-right': this.getAttribute('border-right'),
		        'border-top': this.getAttribute('border-top'),
		        'vertical-align': this.getAttribute('vertical-align'),
		        ...(hasBorderRadius && {
		          'border-collapse': 'separate'
		        })
		      };
		      return {
		        div: {
		          'font-size': '0px',
		          'text-align': 'left',
		          direction: this.getAttribute('direction'),
		          display: 'inline-block',
		          'vertical-align': this.getAttribute('vertical-align'),
		          width: this.getMobileWidth()
		        },
		        table: {
		          ...(this.hasGutter() ? {
		            'background-color': this.getAttribute('inner-background-color'),
		            border: this.getAttribute('inner-border'),
		            'border-bottom': this.getAttribute('inner-border-bottom'),
		            'border-left': this.getAttribute('inner-border-left'),
		            'border-radius': this.getAttribute('inner-border-radius'),
		            'border-right': this.getAttribute('inner-border-right'),
		            'border-top': this.getAttribute('inner-border-top')
		          } : tableStyle),
		          ...(hasInnerBorderRadius && {
		            'border-collapse': 'separate'
		          })
		        },
		        tdOutlook: {
		          'vertical-align': this.getAttribute('vertical-align'),
		          width: this.getWidthAsPixel()
		        },
		        gutter: {
		          ...tableStyle,
		          padding: this.getAttribute('padding'),
		          'padding-top': this.getAttribute('padding-top'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'padding-left': this.getAttribute('padding-left')
		        }
		      };
		    }
		  }, {
		    key: "getMobileWidth",
		    value: function getMobileWidth() {
		      const {
		        containerWidth
		      } = this.context;
		      const {
		        nonRawSiblings
		      } = this.props;
		      const width = this.getAttribute('width');
		      const mobileWidth = this.getAttribute('mobileWidth');
		      if (mobileWidth !== 'mobileWidth') {
		        return '100%';
		      }
		      if (width === undefined) {
		        return `${parseInt(100 / nonRawSiblings, 10)}%`;
		      }
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(width, {
		        parseFloatToInt: false
		      });
		      switch (unit) {
		        case '%':
		          return width;
		        case 'px':
		        default:
		          return `${parsedWidth / parseInt(containerWidth, 10) * 100}%`;
		      }
		    }
		  }, {
		    key: "getWidthAsPixel",
		    value: function getWidthAsPixel() {
		      const {
		        containerWidth
		      } = this.context;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(this.getParsedWidth(true), {
		        parseFloatToInt: false
		      });
		      if (unit === '%') {
		        return `${parseFloat(containerWidth) * parsedWidth / 100}px`;
		      }
		      return `${parsedWidth}px`;
		    }
		  }, {
		    key: "getParsedWidth",
		    value: function getParsedWidth(toString) {
		      const {
		        nonRawSiblings
		      } = this.props;
		      const width = this.getAttribute('width') || `${100 / nonRawSiblings}%`;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(width, {
		        parseFloatToInt: false
		      });
		      if (toString) {
		        return `${parsedWidth}${unit}`;
		      }
		      return {
		        unit,
		        parsedWidth
		      };
		    }
		  }, {
		    key: "getColumnClass",
		    value: function getColumnClass() {
		      const {
		        addMediaQuery
		      } = this.context;
		      let className = '';
		      const {
		        parsedWidth,
		        unit
		      } = this.getParsedWidth();
		      const formattedClassNb = parsedWidth.toString().replace('.', '-');
		      switch (unit) {
		        case '%':
		          className = `mj-column-per-${formattedClassNb}`;
		          break;
		        case 'px':
		        default:
		          className = `mj-column-px-${formattedClassNb}`;
		          break;
		      }

		      // Add className to media queries
		      addMediaQuery(className, {
		        parsedWidth,
		        unit
		      });
		      return className;
		    }
		  }, {
		    key: "hasBorderRadius",
		    value: function hasBorderRadius() {
		      const borderRadius = this.getAttribute('border-radius');
		      return borderRadius !== '' && typeof borderRadius !== 'undefined';
		    }
		  }, {
		    key: "hasInnerBorderRadius",
		    value: function hasInnerBorderRadius() {
		      const innerBorderRadius = this.getAttribute('inner-border-radius');
		      return innerBorderRadius !== '' && typeof innerBorderRadius !== 'undefined';
		    }
		  }, {
		    key: "hasGutter",
		    value: function hasGutter() {
		      return ['padding', 'padding-bottom', 'padding-left', 'padding-right', 'padding-top'].some(attr => this.getAttribute(attr) != null);
		    }
		  }, {
		    key: "renderGutter",
		    value: function renderGutter() {
		      const hasBorderRadius = this.hasBorderRadius();
		      return `
      <table
        ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        width: '100%',
		        ...(hasBorderRadius && {
		          style: {
		            'border-collapse': 'separate'
		          }
		        })
		      })}
      >
        <tbody>
          <tr>
            <td ${this.htmlAttributes({
		        style: 'gutter'
		      })}>
              ${this.renderColumn()}
            </td>
          </tr>
        </tbody>
      </table>
    `;
		    }
		  }, {
		    key: "renderColumn",
		    value: function renderColumn() {
		      const {
		        children
		      } = this.props;
		      return `
      <table
        ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table',
		        width: '100%'
		      })}
      >
        <tbody>
          ${this.renderChildren(children, {
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
              <tr>
                <td
                  ${component.htmlAttributes({
		          align: component.getAttribute('align'),
		          class: component.getAttribute('css-class'),
		          style: {
		            background: component.getAttribute('container-background-color'),
		            'font-size': '0px',
		            padding: component.getAttribute('padding'),
		            'padding-top': component.getAttribute('padding-top'),
		            'padding-right': component.getAttribute('padding-right'),
		            'padding-bottom': component.getAttribute('padding-bottom'),
		            'padding-left': component.getAttribute('padding-left'),
		            'word-break': 'break-word'
		          }
		        })}
                >
                  ${component.render()}
                </td>
              </tr>
            `
		      })}
        </tbody>
      </table>
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      let classesName = `${this.getColumnClass()} mj-outlook-group-fix`;
		      if (this.getAttribute('css-class')) {
		        classesName += ` ${this.getAttribute('css-class')}`;
		      }
		      return `
      <div
        ${this.htmlAttributes({
		        class: classesName,
		        style: 'div'
		      })}
      >
        ${this.hasGutter() ? this.renderGutter() : this.renderColumn()}
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjColumn, "componentName", 'mj-column');
		(0, _defineProperty2.default)(MjColumn, "allowedAttributes", {
		  'background-color': 'color',
		  border: 'string',
		  'border-bottom': 'string',
		  'border-left': 'string',
		  'border-radius': 'unit(px,%){1,4}',
		  'border-right': 'string',
		  'border-top': 'string',
		  direction: 'enum(ltr,rtl)',
		  'inner-background-color': 'color',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  'inner-border': 'string',
		  'inner-border-bottom': 'string',
		  'inner-border-left': 'string',
		  'inner-border-radius': 'unit(px,%){1,4}',
		  'inner-border-right': 'string',
		  'inner-border-top': 'string',
		  padding: 'unit(px,%){1,4}',
		  'vertical-align': 'enum(top,bottom,middle)',
		  width: 'unit(px,%)'
		});
		(0, _defineProperty2.default)(MjColumn, "defaultAttributes", {
		  direction: 'ltr',
		  'vertical-align': 'top'
		});
		module.exports = exports$1.default; 
	} (lib$9, lib$9.exports));
	return lib$9.exports;
}

var lib$8 = {exports: {}};

var hasRequiredLib$a;

function requireLib$a () {
	if (hasRequiredLib$a) return lib$8.exports;
	hasRequiredLib$a = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		let MjDivider = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjDivider() {
		    (0, _classCallCheck2.default)(this, MjDivider);
		    return (0, _callSuper2.default)(this, MjDivider, arguments);
		  }
		  (0, _inherits2.default)(MjDivider, _BodyComponent);
		  return (0, _createClass2.default)(MjDivider, [{
		    key: "getStyles",
		    value: function getStyles() {
		      let computeAlign = '0px auto';
		      if (this.getAttribute('align') === 'left') {
		        computeAlign = '0px';
		      } else if (this.getAttribute('align') === 'right') {
		        computeAlign = '0px 0px 0px auto';
		      }
		      const p = {
		        'border-top': ['style', 'width', 'color'].map(attr => this.getAttribute(`border-${attr}`)).join(' '),
		        'font-size': '1px',
		        margin: computeAlign,
		        width: this.getAttribute('width')
		      };
		      return {
		        p,
		        outlook: {
		          ...p,
		          width: this.getOutlookWidth()
		        }
		      };
		    }
		  }, {
		    key: "getOutlookWidth",
		    value: function getOutlookWidth() {
		      const {
		        containerWidth
		      } = this.context;
		      const paddingSize = this.getShorthandAttrValue('padding', 'left') + this.getShorthandAttrValue('padding', 'right');
		      const width = this.getAttribute('width');
		      const {
		        parsedWidth,
		        unit
		      } = (0, _widthParser.default)(width);
		      switch (unit) {
		        case '%':
		          {
		            const effectiveWidth = parseInt(containerWidth, 10) - paddingSize;
		            const percentMultiplier = parseInt(parsedWidth, 10) / 100;
		            return `${effectiveWidth * percentMultiplier}px`;
		          }
		        case 'px':
		          return width;
		        default:
		          return `${parseInt(containerWidth, 10) - paddingSize}px`;
		      }
		    }
		  }, {
		    key: "renderAfter",
		    value: function renderAfter() {
		      return `
      <!--[if mso | IE]>
        <table
          ${this.htmlAttributes({
		        align: this.getAttribute('align'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        style: 'outlook',
		        role: 'presentation',
		        width: this.getOutlookWidth()
		      })}
        >
          <tr>
            <td style="height:0;line-height:0;">
              &nbsp;
            </td>
          </tr>
        </table>
      <![endif]-->
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      <p
        ${this.htmlAttributes({
		        style: 'p'
		      })}
      >
      </p>
      ${this.renderAfter()}
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjDivider, "componentName", 'mj-divider');
		(0, _defineProperty2.default)(MjDivider, "allowedAttributes", {
		  'border-color': 'color',
		  'border-style': 'string',
		  'border-width': 'unit(px)',
		  'container-background-color': 'color',
		  padding: 'unit(px,%){1,4}',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  width: 'unit(px,%)',
		  align: 'enum(left,center,right)'
		});
		(0, _defineProperty2.default)(MjDivider, "defaultAttributes", {
		  'border-color': '#000000',
		  'border-style': 'solid',
		  'border-width': '4px',
		  padding: '10px 25px',
		  width: '100%',
		  align: 'center'
		});
		module.exports = exports$1.default; 
	} (lib$8, lib$8.exports));
	return lib$8.exports;
}

var lib$7 = {exports: {}};

var hasRequiredLib$9;

function requireLib$9 () {
	if (hasRequiredLib$9) return lib$7.exports;
	hasRequiredLib$9 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		let MjGroup = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjGroup() {
		    (0, _classCallCheck2.default)(this, MjGroup);
		    return (0, _callSuper2.default)(this, MjGroup, arguments);
		  }
		  (0, _inherits2.default)(MjGroup, _BodyComponent);
		  return (0, _createClass2.default)(MjGroup, [{
		    key: "getChildContext",
		    value: function getChildContext() {
		      const {
		        containerWidth: parentWidth
		      } = this.context;
		      const {
		        nonRawSiblings,
		        children
		      } = this.props;
		      const paddingSize = this.getShorthandAttrValue('padding', 'left') + this.getShorthandAttrValue('padding', 'right');
		      let containerWidth = this.getAttribute('width') || `${parseFloat(parentWidth) / nonRawSiblings}px`;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(containerWidth, {
		        parseFloatToInt: false
		      });
		      if (unit === '%') {
		        containerWidth = `${parseFloat(parentWidth) * parsedWidth / 100 - paddingSize}px`;
		      } else {
		        containerWidth = `${parsedWidth - paddingSize}px`;
		      }
		      return {
		        ...this.context,
		        containerWidth,
		        nonRawSiblings: children.length
		      };
		    }
		  }, {
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        div: {
		          'font-size': '0',
		          'line-height': '0',
		          'text-align': 'left',
		          display: 'inline-block',
		          width: '100%',
		          direction: this.getAttribute('direction'),
		          'vertical-align': this.getAttribute('vertical-align'),
		          'background-color': this.getAttribute('background-color')
		        },
		        tdOutlook: {
		          'vertical-align': this.getAttribute('vertical-align'),
		          width: this.getWidthAsPixel()
		        }
		      };
		    }
		  }, {
		    key: "getParsedWidth",
		    value: function getParsedWidth(toString) {
		      const {
		        nonRawSiblings
		      } = this.props;
		      const width = this.getAttribute('width') || `${100 / nonRawSiblings}%`;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(width, {
		        parseFloatToInt: false
		      });
		      if (toString) {
		        return `${parsedWidth}${unit}`;
		      }
		      return {
		        unit,
		        parsedWidth
		      };
		    }
		  }, {
		    key: "getWidthAsPixel",
		    value: function getWidthAsPixel() {
		      const {
		        containerWidth
		      } = this.context;
		      const {
		        unit,
		        parsedWidth
		      } = (0, _widthParser.default)(this.getParsedWidth(true), {
		        parseFloatToInt: false
		      });
		      if (unit === '%') {
		        return `${parseFloat(containerWidth) * parsedWidth / 100}px`;
		      }
		      return `${parsedWidth}px`;
		    }
		  }, {
		    key: "getColumnClass",
		    value: function getColumnClass() {
		      const {
		        addMediaQuery
		      } = this.context;
		      let className = '';
		      const {
		        parsedWidth,
		        unit
		      } = this.getParsedWidth();
		      switch (unit) {
		        case '%':
		          className = `mj-column-per-${parseInt(parsedWidth, 10)}`;
		          break;
		        case 'px':
		        default:
		          className = `mj-column-px-${parseInt(parsedWidth, 10)}`;
		          break;
		      }

		      // Add className to media queries
		      addMediaQuery(className, {
		        parsedWidth,
		        unit
		      });
		      return className;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const {
		        children,
		        nonRawSiblings
		      } = this.props;
		      const {
		        containerWidth: groupWidth
		      } = this.getChildContext();
		      const {
		        containerWidth
		      } = this.context;
		      const getElementWidth = width => {
		        if (!width) {
		          return `${parseInt(containerWidth, 10) / parseInt(nonRawSiblings, 10)}px`;
		        }
		        const {
		          unit,
		          parsedWidth
		        } = (0, _widthParser.default)(width, {
		          parseFloatToInt: false
		        });
		        if (unit === '%') {
		          return `${100 * parsedWidth / groupWidth}px`;
		        }
		        return `${parsedWidth}${unit}`;
		      };
		      let classesName = `${this.getColumnClass()} mj-outlook-group-fix`;
		      if (this.getAttribute('css-class')) {
		        classesName += ` ${this.getAttribute('css-class')}`;
		      }
		      return `
      <div
        ${this.htmlAttributes({
		        class: classesName,
		        style: 'div'
		      })}
      >
        <!--[if mso | IE]>
        <table
          ${this.htmlAttributes({
		        bgcolor: this.getAttribute('background-color') === 'none' ? undefined : this.getAttribute('background-color'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation'
		      })}
        >
          <tr>
        <![endif]-->
          ${this.renderChildren(children, {
		        attributes: {
		          mobileWidth: 'mobileWidth'
		        },
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
              <!--[if mso | IE]>
              <td
                ${component.htmlAttributes({
		          style: {
		            align: component.getAttribute('align'),
		            'vertical-align': component.getAttribute('vertical-align'),
		            width: getElementWidth(component.getWidthAsPixel ? component.getWidthAsPixel() : component.getAttribute('width'))
		          }
		        })}
              >
              <![endif]-->
                ${component.render()}
              <!--[if mso | IE]>
              </td>
              <![endif]-->
          `
		      })}
        <!--[if mso | IE]>
          </tr>
          </table>
        <![endif]-->
      </div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjGroup, "componentName", 'mj-group');
		(0, _defineProperty2.default)(MjGroup, "allowedAttributes", {
		  'background-color': 'color',
		  direction: 'enum(ltr,rtl)',
		  'vertical-align': 'enum(top,bottom,middle)',
		  width: 'unit(px,%)'
		});
		(0, _defineProperty2.default)(MjGroup, "defaultAttributes", {
		  direction: 'ltr'
		});
		module.exports = exports$1.default; 
	} (lib$7, lib$7.exports));
	return lib$7.exports;
}

var lib$6 = {exports: {}};

var hasRequiredLib$8;

function requireLib$8 () {
	if (hasRequiredLib$8) return lib$6.exports;
	hasRequiredLib$8 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _min2 = _interopRequireDefault(requireMin());
		var _mjmlCore = requireLib$r();
		var _widthParser = _interopRequireDefault(requireWidthParser());
		let MjImage = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjImage(...args) {
		    var _this;
		    (0, _classCallCheck2.default)(this, MjImage);
		    _this = (0, _callSuper2.default)(this, MjImage, [...args]);
		    (0, _defineProperty2.default)(_this, "headStyle", breakpoint => `
    @media only screen and (max-width:${(0, _mjmlCore.makeLowerBreakpoint)(breakpoint)}) {
      table.mj-full-width-mobile { width: 100% !important; }
      td.mj-full-width-mobile { width: auto !important; }
    }
  `);
		    return _this;
		  }
		  (0, _inherits2.default)(MjImage, _BodyComponent);
		  return (0, _createClass2.default)(MjImage, [{
		    key: "getStyles",
		    value: function getStyles() {
		      const width = this.getContentWidth();
		      const fullWidth = this.getAttribute('full-width') === 'full-width';
		      const {
		        parsedWidth,
		        unit
		      } = (0, _widthParser.default)(width);
		      return {
		        img: {
		          border: this.getAttribute('border'),
		          'border-left': this.getAttribute('border-left'),
		          'border-right': this.getAttribute('border-right'),
		          'border-top': this.getAttribute('border-top'),
		          'border-bottom': this.getAttribute('border-bottom'),
		          'border-radius': this.getAttribute('border-radius'),
		          display: 'block',
		          outline: 'none',
		          'text-decoration': 'none',
		          height: this.getAttribute('height'),
		          'max-height': this.getAttribute('max-height'),
		          'min-width': fullWidth ? '100%' : null,
		          width: '100%',
		          'max-width': fullWidth ? '100%' : null,
		          'font-size': this.getAttribute('font-size')
		        },
		        td: {
		          width: fullWidth ? null : `${parsedWidth}${unit}`
		        },
		        table: {
		          'min-width': fullWidth ? '100%' : null,
		          'max-width': fullWidth ? '100%' : null,
		          width: fullWidth ? `${parsedWidth}${unit}` : null,
		          'border-collapse': 'collapse',
		          'border-spacing': '0px'
		        }
		      };
		    }
		  }, {
		    key: "getContentWidth",
		    value: function getContentWidth() {
		      const width = this.getAttribute('width') ? parseInt(this.getAttribute('width'), 10) : Infinity;
		      const {
		        box
		      } = this.getBoxWidths();
		      return (0, _min2.default)([box, width]);
		    }
		  }, {
		    key: "renderImage",
		    value: function renderImage() {
		      const height = this.getAttribute('height');
		      const img = `
      <img
        ${this.htmlAttributes({
		        alt: this.getAttribute('alt'),
		        src: this.getAttribute('src'),
		        srcset: this.getAttribute('srcset'),
		        sizes: this.getAttribute('sizes'),
		        style: 'img',
		        title: this.getAttribute('title'),
		        width: this.getContentWidth(),
		        usemap: this.getAttribute('usemap'),
		        ...(height ? {
		          height: height === 'auto' ? height : parseInt(height, 10)
		        } : {})
		      })}
      />
    `;
		      if (this.getAttribute('href')) {
		        return `
        <a
          ${this.htmlAttributes({
		          href: this.getAttribute('href'),
		          target: this.getAttribute('target'),
		          rel: this.getAttribute('rel'),
		          name: this.getAttribute('name'),
		          title: this.getAttribute('title')
		        })}
        >
          ${img}
        </a>
      `;
		      }
		      return img;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      <table
        ${this.htmlAttributes({
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table',
		        class: this.getAttribute('fluid-on-mobile') ? 'mj-full-width-mobile' : null
		      })}
      >
        <tbody>
          <tr>
            <td ${this.htmlAttributes({
		        style: 'td',
		        class: this.getAttribute('fluid-on-mobile') ? 'mj-full-width-mobile' : null
		      })}>
              ${this.renderImage()}
            </td>
          </tr>
        </tbody>
      </table>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjImage, "componentName", 'mj-image');
		(0, _defineProperty2.default)(MjImage, "allowedAttributes", {
		  alt: 'string',
		  href: 'string',
		  name: 'string',
		  src: 'string',
		  srcset: 'string',
		  sizes: 'string',
		  title: 'string',
		  rel: 'string',
		  align: 'enum(left,center,right)',
		  border: 'string',
		  'border-bottom': 'string',
		  'border-left': 'string',
		  'border-right': 'string',
		  'border-top': 'string',
		  'border-radius': 'unit(px,%){1,4}',
		  'container-background-color': 'color',
		  'fluid-on-mobile': 'boolean',
		  padding: 'unit(px,%){1,4}',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  target: 'string',
		  width: 'unit(px)',
		  height: 'unit(px,auto)',
		  'max-height': 'unit(px,%)',
		  'font-size': 'unit(px)',
		  usemap: 'string'
		});
		(0, _defineProperty2.default)(MjImage, "defaultAttributes", {
		  alt: '',
		  align: 'center',
		  border: '0',
		  height: 'auto',
		  padding: '10px 25px',
		  target: '_blank',
		  'font-size': '13px'
		});
		module.exports = exports$1.default; 
	} (lib$6, lib$6.exports));
	return lib$6.exports;
}

var lib$5 = {exports: {}};

var hasRequiredLib$7;

function requireLib$7 () {
	if (hasRequiredLib$7) return lib$5.exports;
	hasRequiredLib$7 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjRaw = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjRaw() {
		    (0, _classCallCheck2.default)(this, MjRaw);
		    return (0, _callSuper2.default)(this, MjRaw, arguments);
		  }
		  (0, _inherits2.default)(MjRaw, _BodyComponent);
		  return (0, _createClass2.default)(MjRaw, [{
		    key: "render",
		    value: function render() {
		      return this.getContent();
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjRaw, "componentName", 'mj-raw');
		(0, _defineProperty2.default)(MjRaw, "endingTag", true);
		(0, _defineProperty2.default)(MjRaw, "rawElement", true);
		(0, _defineProperty2.default)(MjRaw, "allowedAttributes", {
		  position: 'enum(file-start)'
		});
		module.exports = exports$1.default; 
	} (lib$5, lib$5.exports));
	return lib$5.exports;
}

var lib$4 = {exports: {}};

var hasRequiredLib$6;

function requireLib$6 () {
	if (hasRequiredLib$6) return lib$4.exports;
	hasRequiredLib$6 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _filter2 = _interopRequireDefault(requireFilter());
		var _join2 = _interopRequireDefault(requireJoin());
		var _identity2 = _interopRequireDefault(requireIdentity());
		var _flow2 = _interopRequireDefault(requireFlow());
		var _mjmlCore = requireLib$r();
		const makeBackgroundString = (0, _flow2.default)((0, _filter2.default)(_identity2.default), (0, _join2.default)(' '));
		let MjSection = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjSection() {
		    (0, _classCallCheck2.default)(this, MjSection);
		    return (0, _callSuper2.default)(this, MjSection, arguments);
		  }
		  (0, _inherits2.default)(MjSection, _BodyComponent);
		  return (0, _createClass2.default)(MjSection, [{
		    key: "getChildContext",
		    value: function getChildContext() {
		      const {
		        box
		      } = this.getBoxWidths();
		      return {
		        ...this.context,
		        containerWidth: `${box}px`,
		        gap: this.getAttribute('gap')
		      };
		    }
		  }, {
		    key: "getStyles",
		    value: function getStyles() {
		      const {
		        containerWidth
		      } = this.context;
		      const fullWidth = this.isFullWidth();
		      const hasBorderRadius = this.hasBorderRadius();
		      const isFirstSection = this.props.index === 0;
		      const background = this.getAttribute('background-url') ? {
		        background: this.getBackground(),
		        // background size, repeat and position has to be seperate since yahoo does not support shorthand background css property
		        'background-position': this.getBackgroundString(),
		        'background-repeat': this.getAttribute('background-repeat'),
		        'background-size': this.getAttribute('background-size')
		      } : {
		        background: this.getAttribute('background-color'),
		        'background-color': this.getAttribute('background-color')
		      };
		      return {
		        tableFullwidth: {
		          ...(fullWidth ? background : {}),
		          width: '100%'
		        },
		        table: {
		          ...(fullWidth ? {} : background),
		          width: '100%',
		          ...(hasBorderRadius && {
		            'border-collapse': 'separate'
		          })
		        },
		        td: {
		          border: this.getAttribute('border'),
		          'border-bottom': this.getAttribute('border-bottom'),
		          'border-left': this.getAttribute('border-left'),
		          'border-right': this.getAttribute('border-right'),
		          'border-top': this.getAttribute('border-top'),
		          'border-radius': this.getAttribute('border-radius'),
		          direction: this.getAttribute('direction'),
		          'font-size': '0px',
		          padding: this.getAttribute('padding'),
		          'padding-bottom': this.getAttribute('padding-bottom'),
		          'padding-left': this.getAttribute('padding-left'),
		          'padding-right': this.getAttribute('padding-right'),
		          'padding-top': this.getAttribute('padding-top'),
		          'text-align': this.getAttribute('text-align')
		        },
		        div: {
		          ...(fullWidth ? {} : background),
		          margin: '0px auto',
		          'max-width': containerWidth,
		          'border-radius': this.getAttribute('border-radius'),
		          ...(hasBorderRadius && {
		            overflow: 'hidden'
		          }),
		          'margin-top': !isFirstSection ? this.context.gap : undefined
		        },
		        innerDiv: {
		          'line-height': '0',
		          'font-size': '0'
		        }
		      };
		    }
		  }, {
		    key: "getBackground",
		    value: function getBackground() {
		      return makeBackgroundString([this.getAttribute('background-color'), ...(this.hasBackground() ? [`url('${this.getAttribute('background-url')}')`, this.getBackgroundString(), `/ ${this.getAttribute('background-size')}`, this.getAttribute('background-repeat')] : [])]);
		    }
		  }, {
		    key: "getBackgroundString",
		    value: function getBackgroundString() {
		      const {
		        posX,
		        posY
		      } = this.getBackgroundPosition();
		      return `${posX} ${posY}`;
		    }
		  }, {
		    key: "getBackgroundPosition",
		    value: function getBackgroundPosition() {
		      const {
		        x,
		        y
		      } = this.parseBackgroundPosition();
		      return {
		        posX: this.getAttribute('background-position-x') || x,
		        posY: this.getAttribute('background-position-y') || y
		      };
		    }
		  }, {
		    key: "parseBackgroundPosition",
		    value: function parseBackgroundPosition() {
		      const posSplit = this.getAttribute('background-position').split(' ');
		      if (posSplit.length === 1) {
		        const val = posSplit[0];
		        // here we must determine if x or y was provided ; other will be center
		        if (['top', 'bottom'].includes(val)) {
		          return {
		            x: 'center',
		            y: val
		          };
		        }
		        return {
		          x: val,
		          y: 'center'
		        };
		      }
		      if (posSplit.length === 2) {
		        // x and y can be put in any order in background-position so we need to determine that based on values
		        const val1 = posSplit[0];
		        const val2 = posSplit[1];
		        if (['top', 'bottom'].includes(val1) || val1 === 'center' && ['left', 'right'].includes(val2)) {
		          return {
		            x: val2,
		            y: val1
		          };
		        }
		        return {
		          x: val1,
		          y: val2
		        };
		      }

		      // more than 2 values is not supported, let's treat as default value
		      return {
		        x: 'center',
		        y: 'top'
		      };
		    }
		  }, {
		    key: "hasBackground",
		    value: function hasBackground() {
		      return this.getAttribute('background-url') != null;
		    }
		  }, {
		    key: "isFullWidth",
		    value: function isFullWidth() {
		      return this.getAttribute('full-width') === 'full-width';
		    }
		  }, {
		    key: "hasBorderRadius",
		    value: function hasBorderRadius() {
		      const borderRadius = this.getAttribute('border-radius');
		      return borderRadius !== '' && typeof borderRadius !== 'undefined';
		    }
		  }, {
		    key: "hasGap",
		    value: function hasGap() {
		      const {
		        gap
		      } = this.context;
		      return gap != null && gap !== '';
		    }
		  }, {
		    key: "renderBefore",
		    value: function renderBefore() {
		      const {
		        containerWidth
		      } = this.context;
		      const bgcolorAttr = this.getAttribute('background-color') ? {
		        bgcolor: this.getAttribute('background-color')
		      } : {};
		      const isFirstSection = this.props.index === 0;
		      const hasGap = this.hasGap();
		      return `
      <!--[if mso | IE]>
      <table
        ${this.htmlAttributes({
		        align: 'center',
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        class: (0, _mjmlCore.suffixCssClasses)(this.getAttribute('css-class'), 'outlook'),
		        role: 'presentation',
		        style: {
		          width: `${containerWidth}`,
		          'padding-top': !isFirstSection ? this.context.gap : undefined
		        },
		        width: parseInt(containerWidth, 10),
		        ...(!hasGap && {
		          ...bgcolorAttr
		        })
		      })}
      >
        <tr>
          <td style="line-height:0px;font-size:0px;mso-line-height-rule:exactly;">
      <![endif]-->
    `;
		    }

		    // eslint-disable-next-line class-methods-use-this
		  }, {
		    key: "renderAfter",
		    value: function renderAfter() {
		      return `
      <!--[if mso | IE]>
          </td>
        </tr>
      </table>
      <![endif]-->
    `;
		    }
		  }, {
		    key: "renderWrappedChildren",
		    value: function renderWrappedChildren() {
		      const {
		        children
		      } = this.props;
		      return `
      <!--[if mso | IE]>
        <tr>
      <![endif]-->
      ${this.renderChildren(children, {
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
          <!--[if mso | IE]>
            <td
              ${component.htmlAttributes({
		          align: component.getAttribute('align'),
		          class: (0, _mjmlCore.suffixCssClasses)(component.getAttribute('css-class'), 'outlook'),
		          style: 'tdOutlook'
		        })}
            >
          <![endif]-->
            ${component.render()}
          <!--[if mso | IE]>
            </td>
          <![endif]-->
    `
		      })}

      <!--[if mso | IE]>
        </tr>
      <![endif]-->
    `;
		    }
		  }, {
		    key: "renderWithBackground",
		    value: function renderWithBackground(content) {
		      const fullWidth = this.isFullWidth();
		      const {
		        containerWidth
		      } = this.context;
		      const isPercentage = str => /^\d+(\.\d+)?%$/.test(str);
		      let vSizeAttributes = {};
		      let {
		        posX: bgPosX,
		        posY: bgPosY
		      } = this.getBackgroundPosition();
		      switch (bgPosX) {
		        case 'left':
		          bgPosX = '0%';
		          break;
		        case 'center':
		          bgPosX = '50%';
		          break;
		        case 'right':
		          bgPosX = '100%';
		          break;
		        default:
		          if (!isPercentage(bgPosX)) {
		            bgPosX = '50%';
		          }
		          break;
		      }
		      switch (bgPosY) {
		        case 'top':
		          bgPosY = '0%';
		          break;
		        case 'center':
		          bgPosY = '50%';
		          break;
		        case 'bottom':
		          bgPosY = '100%';
		          break;
		        default:
		          if (!isPercentage(bgPosY)) {
		            bgPosY = '0%';
		          }
		          break;
		      }

		      // this logic is different when using repeat or no-repeat
		      let [[vOriginX, vPosX], [vOriginY, vPosY]] = ['x', 'y'].map(coordinate => {
		        const isX = coordinate === 'x';
		        const bgRepeat = this.getAttribute('background-repeat') === 'repeat';
		        let pos = isX ? bgPosX : bgPosY;
		        let origin = isX ? bgPosX : bgPosY;
		        if (isPercentage(pos)) {
		          // Should be percentage at this point
		          const percentageValue = pos.match(/^(\d+(\.\d+)?)%$/)[1];
		          const decimal = parseInt(percentageValue, 10) / 100;
		          if (bgRepeat) {
		            pos = decimal;
		            origin = decimal;
		          } else {
		            pos = (-50 + decimal * 100) / 100;
		            origin = (-50 + decimal * 100) / 100;
		          }
		        } else if (bgRepeat) {
		          // top (y) or center (x)
		          origin = isX ? '0.5' : '0';
		          pos = isX ? '0.5' : '0';
		        } else {
		          origin = isX ? '0' : '-0.5';
		          pos = isX ? '0' : '-0.5';
		        }
		        return [origin, pos];
		      }, this);

		      // If background size is either cover or contain, we tell VML to keep the aspect
		      // and fill the entire element.
		      if (this.getAttribute('background-size') === 'cover' || this.getAttribute('background-size') === 'contain') {
		        vSizeAttributes = {
		          size: '1,1',
		          aspect: this.getAttribute('background-size') === 'cover' ? 'atleast' : 'atmost'
		        };
		      } else if (this.getAttribute('background-size') !== 'auto') {
		        const bgSplit = this.getAttribute('background-size').split(' ');
		        if (bgSplit.length === 1) {
		          vSizeAttributes = {
		            size: this.getAttribute('background-size'),
		            aspect: 'atmost' // reproduces height auto
		          };
		        } else {
		          vSizeAttributes = {
		            size: bgSplit.join(',')
		          };
		        }
		      }
		      let vmlType = this.getAttribute('background-repeat') === 'no-repeat' ? 'frame' : 'tile';
		      if (this.getAttribute('background-size') === 'auto') {
		        vmlType = 'tile' // if no size provided, keep old behavior because outlook can't use original image size with "frame"
		        ;
		        [[vOriginX, vPosX], [vOriginY, vPosY]] = [[0.5, 0.5], [0, 0]]; // also ensure that images are still cropped the same way
		      }
		      return `
      <!--[if mso | IE]>
        <v:rect ${this.htmlAttributes({
		        style: fullWidth ? {
		          'mso-width-percent': '1000'
		        } : {
		          width: containerWidth
		        },
		        'xmlns:v': 'urn:schemas-microsoft-com:vml',
		        fill: 'true',
		        stroke: 'false'
		      })}>
        <v:fill ${this.htmlAttributes({
		        origin: `${vOriginX}, ${vOriginY}`,
		        position: `${vPosX}, ${vPosY}`,
		        src: this.getAttribute('background-url'),
		        color: this.getAttribute('background-color'),
		        type: vmlType,
		        ...vSizeAttributes
		      })} />
        <v:textbox style="mso-fit-shape-to-text:true" inset="0,0,0,0">
      <![endif]-->
          ${content}
        <!--[if mso | IE]>
        </v:textbox>
      </v:rect>
    <![endif]-->
    `;
		    }
		  }, {
		    key: "renderSection",
		    value: function renderSection() {
		      const hasBackground = this.hasBackground();
		      return `
      <div ${this.htmlAttributes({
		        class: this.isFullWidth() ? null : this.getAttribute('css-class'),
		        style: 'div'
		      })}>
        ${hasBackground ? `<div ${this.htmlAttributes({
		        style: 'innerDiv'
		      })}>` : ''}
        <table
          ${this.htmlAttributes({
		        align: 'center',
		        background: this.isFullWidth() ? null : this.getAttribute('background-url'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'table'
		      })}
        >
          <tbody>
            <tr>
              <td
                ${this.htmlAttributes({
		        style: 'td'
		      })}
              >
                <!--[if mso | IE]>
                  <table role="presentation" border="0" cellpadding="0" cellspacing="0">
                <![endif]-->
                  ${this.renderWrappedChildren()}
                <!--[if mso | IE]>
                  </table>
                <![endif]-->
              </td>
            </tr>
          </tbody>
        </table>
        ${hasBackground ? '</div>' : ''}
      </div>
    `;
		    }
		  }, {
		    key: "renderFullWidth",
		    value: function renderFullWidth() {
		      const content = this.hasBackground() ? this.renderWithBackground(`
        ${this.renderBefore()}
        ${this.renderSection()}
        ${this.renderAfter()}
      `) : `
        ${this.renderBefore()}
        ${this.renderSection()}
        ${this.renderAfter()}
      `;
		      return `
      <table
        ${this.htmlAttributes({
		        align: 'center',
		        class: this.getAttribute('css-class'),
		        background: this.getAttribute('background-url'),
		        border: '0',
		        cellpadding: '0',
		        cellspacing: '0',
		        role: 'presentation',
		        style: 'tableFullwidth'
		      })}
      >
        <tbody>
          <tr>
            <td>
              ${content}
            </td>
          </tr>
        </tbody>
      </table>
    `;
		    }
		  }, {
		    key: "renderSimple",
		    value: function renderSimple() {
		      const section = this.renderSection();
		      return `
      ${this.renderBefore()}
      ${this.hasBackground() ? this.renderWithBackground(section) : section}
      ${this.renderAfter()}
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return this.isFullWidth() ? this.renderFullWidth() : this.renderSimple();
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjSection, "componentName", 'mj-section');
		(0, _defineProperty2.default)(MjSection, "allowedAttributes", {
		  'background-color': 'color',
		  'background-url': 'string',
		  'background-repeat': 'enum(repeat,no-repeat)',
		  'background-size': 'string',
		  'background-position': 'string',
		  'background-position-x': 'string',
		  'background-position-y': 'string',
		  border: 'string',
		  'border-bottom': 'string',
		  'border-left': 'string',
		  'border-radius': 'string',
		  'border-right': 'string',
		  'border-top': 'string',
		  direction: 'enum(ltr,rtl)',
		  'full-width': 'enum(full-width,false,)',
		  padding: 'unit(px,%){1,4}',
		  'padding-top': 'unit(px,%)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'text-align': 'enum(left,center,right)',
		  'text-padding': 'unit(px,%){1,4}'
		});
		(0, _defineProperty2.default)(MjSection, "defaultAttributes", {
		  'background-repeat': 'repeat',
		  'background-size': 'auto',
		  'background-position': 'top center',
		  direction: 'ltr',
		  padding: '20px 0',
		  'text-align': 'center',
		  'text-padding': '4px 4px 4px 0'
		});
		module.exports = exports$1.default; 
	} (lib$4, lib$4.exports));
	return lib$4.exports;
}

var lib$3 = {exports: {}};

var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$3.exports;
	hasRequiredLib$5 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		let MjSpacer = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjSpacer() {
		    (0, _classCallCheck2.default)(this, MjSpacer);
		    return (0, _callSuper2.default)(this, MjSpacer, arguments);
		  }
		  (0, _inherits2.default)(MjSpacer, _BodyComponent);
		  return (0, _createClass2.default)(MjSpacer, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        div: {
		          height: this.getAttribute('height'),
		          'line-height': this.getAttribute('height')
		        }
		      };
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      return `
      <div
        ${this.htmlAttributes({
		        style: 'div'
		      })}
      >&#8202;</div>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjSpacer, "componentName", 'mj-spacer');
		(0, _defineProperty2.default)(MjSpacer, "allowedAttributes", {
		  border: 'string',
		  'border-bottom': 'string',
		  'border-left': 'string',
		  'border-right': 'string',
		  'border-top': 'string',
		  'container-background-color': 'color',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  height: 'unit(px,%)'
		});
		(0, _defineProperty2.default)(MjSpacer, "defaultAttributes", {
		  height: '20px'
		});
		module.exports = exports$1.default; 
	} (lib$3, lib$3.exports));
	return lib$3.exports;
}

var lib$2 = {exports: {}};

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$2.exports;
	hasRequiredLib$4 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlCore = requireLib$r();
		var _conditionalTag = _interopRequireDefault(requireConditionalTag());
		let MjText = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjText() {
		    (0, _classCallCheck2.default)(this, MjText);
		    return (0, _callSuper2.default)(this, MjText, arguments);
		  }
		  (0, _inherits2.default)(MjText, _BodyComponent);
		  return (0, _createClass2.default)(MjText, [{
		    key: "getStyles",
		    value: function getStyles() {
		      return {
		        text: {
		          'font-family': this.getAttribute('font-family'),
		          'font-size': this.getAttribute('font-size'),
		          'font-style': this.getAttribute('font-style'),
		          'font-weight': this.getAttribute('font-weight'),
		          'letter-spacing': this.getAttribute('letter-spacing'),
		          'line-height': this.getAttribute('line-height'),
		          'text-align': this.getAttribute('align'),
		          'text-decoration': this.getAttribute('text-decoration'),
		          'text-transform': this.getAttribute('text-transform'),
		          color: this.getAttribute('color'),
		          height: this.getAttribute('height')
		        }
		      };
		    }
		  }, {
		    key: "renderContent",
		    value: function renderContent() {
		      return `
      <div
        ${this.htmlAttributes({
		        style: 'text'
		      })}
      >${this.getContent()}</div>
    `;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const height = this.getAttribute('height');
		      return height ? `
        ${(0, _conditionalTag.default)(`
          <table role="presentation" border="0" cellpadding="0" cellspacing="0"><tr><td height="${height}" style="vertical-align:top;height:${height};">
        `)}
        ${this.renderContent()}
        ${(0, _conditionalTag.default)(`
          </td></tr></table>
        `)}
      ` : this.renderContent();
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjText, "componentName", 'mj-text');
		(0, _defineProperty2.default)(MjText, "endingTag", true);
		(0, _defineProperty2.default)(MjText, "allowedAttributes", {
		  align: 'enum(left,right,center,justify)',
		  'background-color': 'color',
		  color: 'color',
		  'container-background-color': 'color',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-style': 'string',
		  'font-weight': 'string',
		  height: 'unit(px,%)',
		  'letter-spacing': 'unitWithNegative(px,em)',
		  'line-height': 'unit(px,%,)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  'text-decoration': 'string',
		  'text-transform': 'string',
		  'vertical-align': 'enum(top,bottom,middle)'
		});
		(0, _defineProperty2.default)(MjText, "defaultAttributes", {
		  align: 'left',
		  color: '#000000',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'line-height': '1',
		  padding: '10px 25px'
		});
		module.exports = exports$1.default; 
	} (lib$2, lib$2.exports));
	return lib$2.exports;
}

var lib$1 = {exports: {}};

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$1.exports;
	hasRequiredLib$3 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _reduce2 = _interopRequireDefault(requireReduce());
		var _widthParser = _interopRequireDefault(requireWidthParser());
		var _mjmlCore = requireLib$r();
		let MjTable = exports$1.default = /*#__PURE__*/function (_BodyComponent) {
		  function MjTable() {
		    (0, _classCallCheck2.default)(this, MjTable);
		    return (0, _callSuper2.default)(this, MjTable, arguments);
		  }
		  (0, _inherits2.default)(MjTable, _BodyComponent);
		  return (0, _createClass2.default)(MjTable, [{
		    key: "getStyles",
		    value: function getStyles() {
		      const hasCellspacing = this.hasCellspacing();
		      return {
		        table: {
		          color: this.getAttribute('color'),
		          'font-family': this.getAttribute('font-family'),
		          'font-size': this.getAttribute('font-size'),
		          'line-height': this.getAttribute('line-height'),
		          'table-layout': this.getAttribute('table-layout'),
		          width: this.getAttribute('width'),
		          border: this.getAttribute('border'),
		          ...(hasCellspacing && {
		            'border-collapse': 'separate'
		          })
		        }
		      };
		    }
		  }, {
		    key: "getWidth",
		    value: function getWidth() {
		      const width = this.getAttribute('width');
		      if (width === 'auto') {
		        return width;
		      }
		      const {
		        parsedWidth,
		        unit
		      } = (0, _widthParser.default)(width);
		      return unit === '%' ? width : parsedWidth;
		    }
		  }, {
		    key: "hasCellspacing",
		    value: function hasCellspacing() {
		      const cellspacing = this.getAttribute('cellspacing');
		      const numericValue = parseFloat(String(cellspacing).replace(/[^\d.]/g, ''));
		      return !Number.isNaN(numericValue) && numericValue > 0;
		    }
		  }, {
		    key: "render",
		    value: function render() {
		      const tableAttributes = (0, _reduce2.default)(['cellpadding', 'cellspacing', 'role'], (acc, v) => ({
		        ...acc,
		        [v]: this.getAttribute(v)
		      }), {});
		      return `
      <table
        ${this.htmlAttributes({
		        ...tableAttributes,
		        width: this.getWidth(),
		        border: '0',
		        style: 'table'
		      })}
      >
        ${this.getContent()}
      </table>
    `;
		    }
		  }]);
		}(_mjmlCore.BodyComponent);
		(0, _defineProperty2.default)(MjTable, "componentName", 'mj-table');
		(0, _defineProperty2.default)(MjTable, "endingTag", true);
		(0, _defineProperty2.default)(MjTable, "allowedAttributes", {
		  align: 'enum(left,right,center)',
		  border: 'string',
		  cellpadding: 'integer',
		  cellspacing: 'integer',
		  'container-background-color': 'color',
		  color: 'color',
		  'font-family': 'string',
		  'font-size': 'unit(px)',
		  'font-weight': 'string',
		  'line-height': 'unit(px,%,)',
		  'padding-bottom': 'unit(px,%)',
		  'padding-left': 'unit(px,%)',
		  'padding-right': 'unit(px,%)',
		  'padding-top': 'unit(px,%)',
		  padding: 'unit(px,%){1,4}',
		  role: 'enum(none,presentation)',
		  'table-layout': 'enum(auto,fixed,initial,inherit)',
		  'vertical-align': 'enum(top,bottom,middle)',
		  width: 'unit(px,%,auto)'
		});
		(0, _defineProperty2.default)(MjTable, "defaultAttributes", {
		  align: 'left',
		  border: 'none',
		  cellpadding: '0',
		  cellspacing: '0',
		  color: '#000000',
		  'font-family': 'Ubuntu, Helvetica, Arial, sans-serif',
		  'font-size': '13px',
		  'line-height': '22px',
		  padding: '10px 25px',
		  'table-layout': 'auto',
		  width: '100%'
		});
		module.exports = exports$1.default; 
	} (lib$1, lib$1.exports));
	return lib$1.exports;
}

var lib = {exports: {}};

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib.exports;
	hasRequiredLib$2 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
		var _createClass2 = _interopRequireDefault(requireCreateClass());
		var _callSuper2 = _interopRequireDefault(requireCallSuper());
		var _inherits2 = _interopRequireDefault(requireInherits());
		var _defineProperty2 = _interopRequireDefault(requireDefineProperty());
		var _mjmlSection = _interopRequireDefault(requireLib$6());
		var _mjmlCore = requireLib$r();
		let MjWrapper = exports$1.default = /*#__PURE__*/function (_MjSection) {
		  function MjWrapper() {
		    (0, _classCallCheck2.default)(this, MjWrapper);
		    return (0, _callSuper2.default)(this, MjWrapper, arguments);
		  }
		  (0, _inherits2.default)(MjWrapper, _MjSection);
		  return (0, _createClass2.default)(MjWrapper, [{
		    key: "renderWrappedChildren",
		    value: function renderWrappedChildren() {
		      const {
		        children
		      } = this.props;
		      const {
		        containerWidth
		      } = this.context;
		      return `
      ${this.renderChildren(children, {
		        renderer: component => component.constructor.isRawElement() ? component.render() : `
          <!--[if mso | IE]>
            <tr>
              <td
                ${component.htmlAttributes({
		          align: component.getAttribute('align'),
		          class: (0, _mjmlCore.suffixCssClasses)(component.getAttribute('css-class'), 'outlook'),
		          width: containerWidth
		        })}
              >
          <![endif]-->
            ${component.render()}
          <!--[if mso | IE]>
              </td>
            </tr>
          <![endif]-->
        `
		      })}
    `;
		    }
		  }]);
		}(_mjmlSection.default);
		(0, _defineProperty2.default)(MjWrapper, "componentName", 'mj-wrapper');
		(0, _defineProperty2.default)(MjWrapper, "allowedAttributes", {
		  ..._mjmlSection.default.allowedAttributes,
		  gap: 'unit(px)'
		});
		module.exports = exports$1.default; 
	} (lib, lib.exports));
	return lib.exports;
}

var dependencies = {exports: {}};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies.exports;
	hasRequiredDependencies = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		exports$1.default = {
		  mjml: ['mj-body', 'mj-head', 'mj-raw'],
		  'mj-accordion': ['mj-accordion-element', 'mj-raw'],
		  'mj-accordion-element': ['mj-accordion-title', 'mj-accordion-text', 'mj-raw'],
		  'mj-accordion-title': [],
		  'mj-accordion-text': [],
		  'mj-attributes': [/^.*^/],
		  'mj-body': ['mj-raw', 'mj-section', 'mj-wrapper', 'mj-hero'],
		  'mj-button': [],
		  'mj-carousel': ['mj-carousel-image'],
		  'mj-carousel-image': [],
		  'mj-column': ['mj-accordion', 'mj-button', 'mj-carousel', 'mj-divider', 'mj-image', 'mj-raw', 'mj-social', 'mj-spacer', 'mj-table', 'mj-text', 'mj-navbar'],
		  'mj-html-attribute': [],
		  'mj-html-attributes': ['mj-selector'],
		  'mj-divider': [],
		  'mj-group': ['mj-column', 'mj-raw'],
		  'mj-head': ['mj-attributes', 'mj-breakpoint', 'mj-html-attributes', 'mj-font', 'mj-preview', 'mj-style', 'mj-title', 'mj-raw'],
		  'mj-hero': ['mj-accordion', 'mj-button', 'mj-carousel', 'mj-divider', 'mj-image', 'mj-social', 'mj-spacer', 'mj-table', 'mj-text', 'mj-navbar', 'mj-raw'],
		  'mj-image': [],
		  'mj-navbar': ['mj-navbar-link', 'mj-raw'],
		  'mj-raw': [],
		  'mj-section': ['mj-column', 'mj-group', 'mj-raw'],
		  'mj-selector': ['mj-html-attribute'],
		  'mj-social': ['mj-social-element', 'mj-raw'],
		  'mj-social-element': [],
		  'mj-spacer': [],
		  'mj-table': [],
		  'mj-text': [],
		  'mj-wrapper': ['mj-hero', 'mj-raw', 'mj-section']
		};
		module.exports = exports$1.default; 
	} (dependencies, dependencies.exports));
	return dependencies.exports;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$p.exports;
	hasRequiredLib$1 = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _mjmlSocial = requireLib$q();
		var _mjmlNavbar = requireLib$p();
		var _mjmlCarousel = requireLib$o();
		var _mjmlAccordion = requireLib$n();
		var _mjmlBody = _interopRequireDefault(requireLib$m());
		var _mjmlHead = _interopRequireDefault(requireLib$l());
		var _mjmlHeadAttributes = _interopRequireDefault(requireLib$k());
		var _mjmlHeadBreakpoint = _interopRequireDefault(requireLib$j());
		var _mjmlHeadHtmlAttributes = _interopRequireDefault(requireLib$i());
		var _mjmlHeadFont = _interopRequireDefault(requireLib$h());
		var _mjmlHeadPreview = _interopRequireDefault(requireLib$g());
		var _mjmlHeadStyle = _interopRequireDefault(requireLib$f());
		var _mjmlHeadTitle = _interopRequireDefault(requireLib$e());
		var _mjmlHero = _interopRequireDefault(requireLib$d());
		var _mjmlButton = _interopRequireDefault(requireLib$c());
		var _mjmlColumn = _interopRequireDefault(requireLib$b());
		var _mjmlDivider = _interopRequireDefault(requireLib$a());
		var _mjmlGroup = _interopRequireDefault(requireLib$9());
		var _mjmlImage = _interopRequireDefault(requireLib$8());
		var _mjmlRaw = _interopRequireDefault(requireLib$7());
		var _mjmlSection = _interopRequireDefault(requireLib$6());
		var _mjmlSpacer = _interopRequireDefault(requireLib$5());
		var _mjmlText = _interopRequireDefault(requireLib$4());
		var _mjmlTable = _interopRequireDefault(requireLib$3());
		var _mjmlWrapper = _interopRequireDefault(requireLib$2());
		var _dependencies = _interopRequireDefault(requireDependencies());
		const components = [_mjmlBody.default, _mjmlHead.default, _mjmlHeadAttributes.default, _mjmlHeadBreakpoint.default, _mjmlHeadHtmlAttributes.default, _mjmlHeadFont.default, _mjmlHeadPreview.default, _mjmlHeadStyle.default, _mjmlHeadTitle.default, _mjmlHero.default, _mjmlButton.default, _mjmlColumn.default, _mjmlDivider.default, _mjmlGroup.default, _mjmlImage.default, _mjmlRaw.default, _mjmlSection.default, _mjmlSpacer.default, _mjmlText.default, _mjmlTable.default, _mjmlWrapper.default, _mjmlSocial.Social, _mjmlSocial.SocialElement, _mjmlNavbar.Navbar, _mjmlNavbar.NavbarLink, _mjmlAccordion.Accordion, _mjmlAccordion.AccordionElement, _mjmlAccordion.AccordionText, _mjmlAccordion.AccordionTitle, _mjmlCarousel.Carousel, _mjmlCarousel.CarouselImage];
		const presetCore = {
		  components,
		  dependencies: _dependencies.default
		};
		exports$1.default = presetCore;
		module.exports = exports$1.default; 
	} (lib$p, lib$p.exports));
	return lib$p.exports;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$z.exports;
	hasRequiredLib = 1;
	(function (module, exports$1) {

		var _interopRequireDefault = requireInteropRequireDefault().default;
		var _interopRequireWildcard = requireInteropRequireWildcard().default;
		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _mjmlCore = _interopRequireWildcard(requireLib$r());
		var _mjmlValidator = requireLib$s();
		var _mjmlPresetCore = _interopRequireDefault(requireLib$1());
		(0, _mjmlCore.assignComponents)(_mjmlCore.components, _mjmlPresetCore.default.components);
		(0, _mjmlValidator.assignDependencies)(_mjmlValidator.dependencies, _mjmlPresetCore.default.dependencies);
		exports$1.default = _mjmlCore.default;
		module.exports = exports$1.default; 
	} (lib$z, lib$z.exports));
	return lib$z.exports;
}

var libExports = requireLib();
const mjml2html = /*@__PURE__*/getDefaultExportFromCjs(libExports);

function simpleRender(templateStr, vars) {
  if (!templateStr) return templateStr;
  let s = templateStr;
  Object.keys(vars).forEach((k) => {
    const regex = new RegExp(`{{${k}}}`, "g");
    s = s.replace(regex, String(vars[k] ?? ""));
  });
  s = s.replace(/\{\{#if logoUrl\}\}[\s\S]*?\{\{\/if\}\}/g, "");
  return s;
}
function renderMjmlTemplate(key, vars = {}) {
  const mjmlPath = require$$0$3.join(process.cwd(), "src", "lib", "emailTemplates", "mjml", `${key}.mjml`);
  if (!require$$0$4.existsSync(mjmlPath)) return null;
  const raw = require$$0$4.readFileSync(mjmlPath, "utf8");
  const rendered = simpleRender(raw, vars);
  const { html, errors } = mjml2html(rendered, { validationLevel: "soft" });
  if (errors && errors.length) console.warn("MJML render warnings:", errors);
  return html;
}

export { renderMjmlTemplate, simpleRender };
