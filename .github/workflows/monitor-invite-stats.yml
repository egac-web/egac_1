name: Monitor invite stats

on:
  schedule:
    - cron: '*/15 * * * *' # every 15 minutes
  workflow_dispatch: {}

# Allow this workflow to create issues
permissions:
  issues: write
  contents: read

# Docs: see `docs/ops/ci-secrets.md` for quick reference on repository secrets and troubleshooting
# Quick link (repo-level): https://github.com/<owner>/<repo>/settings/secrets/actions

jobs:
  check-invites:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Check invite stats (node)
        env:
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          PAGES_SITE_URL: ${{ secrets.PAGES_SITE_URL }}
        run: |
          set -euo pipefail
          # Ensure the essential secret is present and give a clear error if not
          if [ -z "${CRON_SECRET}" ]; then
            echo "ERROR: CRON_SECRET not set in repository secrets" >&2
            exit 2
          fi
          # Run the Node check script but don't fail the job immediately so we can open or update an issue
          node scripts/check_invite_stats.mjs > stats.out 2>&1 || true
          cat stats.out
          # Extract the counts JSON printed by the script, fallback to zeros if missing
          COUNTS_JSON=$(grep '^Invite counts:' stats.out | sed -E 's/^Invite counts:[[:space:]]*//' || echo '{"pending":0,"failed":0,"sent":0}')
          FAILED=$(jq -r '.failed // 0' <<< "$COUNTS_JSON")
          echo "FAILED=$FAILED" >> $GITHUB_ENV

      - name: Open GitHub issue if failures detected
        if: env.FAILED != '0'
        uses: actions/github-script@v6
        env:
          MONITORING_MENTION: ${{ secrets.MONITORING_MENTION }}
        with:
          script: |
            const failed = parseInt(process.env.FAILED || '0', 10);
            const mention = (process.env.MONITORING_MENTION || '').trim();
            const label = 'monitoring';
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Ensure the monitoring label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: label });
            } catch (e) {
              await github.rest.issues.createLabel({ owner, repo, name: label, color: 'ff0000', description: 'Auto-created monitoring alerts' });
            }

            // Look for an existing open issue for this alert
            const issues = await github.rest.issues.listForRepo({ owner, repo, labels: label, state: 'open', per_page: 100 });
            const existing = issues.data.find(i => i.title.includes('Invite retry failures') || i.title.includes('Invite retries failing'));

            const mentionLine = mention ? `${mention} ` : '';
            const time = new Date().toISOString();

            if (existing) {
              await github.rest.issues.createComment({ owner, repo, issue_number: existing.number, body: `${mentionLine}Detected ${failed} failed invites at ${time}. See workflow run: ${runUrl}` });
            } else {
              const title = `Automated: Invite retry failures (${failed} failed)`;
              const body = `${mentionLine}Automated alert: ${failed} invite send failures detected.\n\n- Site: ${process.env.PAGES_SITE_URL}\n- Time: ${time}\n- Workflow run: ${runUrl}\n\nPlease investigate failed invites and the retry job.`;
              await github.rest.issues.create({ owner, repo, title, body, labels: [label] });
            }

      - name: Fail if failures detected
        if: env.FAILED != '0'
        run: |
          echo "Found $FAILED failed invites â€” failing the job to signal an incident."
          exit 1
